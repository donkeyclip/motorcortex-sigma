'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Helper = require('../_coreUtils/Helper');
var helper = new Helper();
var conf = require('../configuration/generalConf');

var Channel = function () {
    function Channel(props) {
        _classCallCheck(this, Channel);

        this.runTimeInfo = props.runTimeInfo;
        this.context = props.context;
        this.onInitialise();
        // this.type = "plain";
    }

    _createClass(Channel, [{
        key: 'onInitialise',
        value: function onInitialise() {
            ;
        }
    }, {
        key: '_resize',
        value: function _resize() {
            helper.log('Please overwite the _resize method of the Channel');
        }

        /**
         * @param {array} incidents - A collection of Incidents in the form:
         * {
         *  millisecond
         *  incident
         *  id
         * }
         * @returns either:
         *   {
         *       result:true,
         *       execute: // an array of functions that when executed it will add the Incidents on the Channels
         *   }
         *   or
         *   {
         *       result: false,
         *       errors
         *   }
        */

    }, {
        key: 'addIncidents',
        value: function addIncidents(incidents) {
            // first check the Incidents addition directly using the checkAddition method of the class
            var result = this.checkAddition(incidents);

            if (result.result === false) {
                return {
                    result: false,
                    errors: result.errors
                };
            } else {
                return {
                    result: true,
                    execute: result.execute
                };
            }
        }

        /**
         * It initially checks if the edit is allowed and if it is it retuns an array of executable functions
         * that apply the change
         * @param {array} incidents - the list of the incidents to edit in an array format [object, object, ...]
         * @param {int} millisecondsDelta - the milliseconds delta to apply to the incidents
         * @returns {object} -
         * either:
         {
            result: true,
            execute: // array of functions to be executed in order to apply the edit
         }
         or
         {
             result: false,
             errors: // an array including all the errors / conflicts found on edit
         }
        */

    }, {
        key: 'editIncidents',
        value: function editIncidents(incidents, millisecondsDelta, instantiatedChannels) {
            // first check the Incidents addition directly using the checkAddition method of the class
            var result = this.checkEdit(incidents, millisecondsDelta);
            if (result.result === false) {
                return {
                    result: false,
                    errors: result.errors
                };
            } else {
                return {
                    result: true,
                    execute: result.execute
                };
            }
        }

        /**
         * Method to remove incidents
         * @param {array} incidents - the ids of the incidents to remove in an array format
         * @param {object} props - if passed it supports the preventSlip key which if false the channel should not slip. This case is for 
            flashDOM of DOMAwareIncidents where we have elements deleted so slipping on their lanes is not valid nor necessaryi
         * @retuns {object} -
         * either:
         {
            result: true,
            execute: // array of functions to be executed in order to apply the edit
         }
         or
         {
             result: false,
             errors: // an array including all the errors / conflicts found on edit
         }
        */

    }, {
        key: 'removeIncidents',
        value: function removeIncidents(incidents) {
            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            // first check the Incidents addition directly using the checkAddition method of the class
            var result = this.checkDelete(incidents, props);
            if (result.result === false) {
                return {
                    result: false,
                    errors: result.errors
                };
            } else {
                return {
                    result: true,
                    execute: result.execute
                };
            }
        }

        /**
         * On this method the user defines the specific rules that apply on the plugin itself and on the Incidents of the plugin itself
         * The method should either return {result: true} or {result: false, errors:[{error-object}]}, where error-object has the structure:
         *  {
                incident: // reference to the Incident object that has bee discarded
                error: // text
            }
        * @param {array} incidents - a colleciton of all incidents to be added on the form:
        *
            {
                id
                millisecond
                incident
            }
        * @returns {object} -
        * either:
            {
                result:true,
                execute: // a function that when executed it will add the Incidents on the Channels
            }
            or
            {
                result: false,
                errors
            }
        */

    }, {
        key: 'checkAddition',
        value: function checkAddition(incidents) {
            return { result: true, execute: function execute() {} };
        }
    }, {
        key: 'checkEdit',
        value: function checkEdit(incidentsArray, millisecondsDelta) {
            return { result: true, execute: function execute() {} };
        }
    }, {
        key: 'checkDelete',
        value: function checkDelete(incidentIds) {
            return { result: true, execute: function execute() {} };
        }
    }, {
        key: 'checkResizedIncidents',
        value: function checkResizedIncidents(incidents) {
            return { result: true, execute: function execute() {} };
        }
    }, {
        key: 'goTo',
        value: function goTo(millisecond) {
            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            // first decide the millisecond we want to goTo
            if (millisecond === null || millisecond === undefined) {
                millisecond = this.runTimeInfo.currentMillisecond;
            }
            if (props.hasOwnProperty('relativeTo')) {
                millisecond += this.getIncidentMillisecond(props.relativeTo);
            }

            var startFrom = this.runTimeInfo.currentMillisecond;
            if (props.hasOwnProperty('previousStop')) {
                startFrom = props.previousStop;
            }

            this.moveTo(startFrom, millisecond);
        }
    }, {
        key: 'moveTo',
        value: function moveTo(from, to) {
            ;
        }
    }, {
        key: 'exportState',
        value: function exportState(props) {
            return {
                class: this.constructor.name,
                Incident: this.constructor
            };
        }
    }], [{
        key: 'type',
        get: function get() {
            return "plain";
        }
    }]);

    return Channel;
}();

module.exports = Channel;