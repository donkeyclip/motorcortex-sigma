'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _cloneDeep = require('../../../lodash-custom-build/modularize/lodash.clonedeep/index');
var _filter = require('../../../lodash-custom-build/modularize/lodash.filter/index');
var _sortBy = require('../../../lodash-custom-build/modularize/lodash.sortby/index');
var _findIndex = require('../../../lodash-custom-build/modularize/lodash.findindex/index');
var _find = require('../../../lodash-custom-build/modularize/lodash.find/index');

var Helper = require('../../_coreUtils/Helper');
var helper = new Helper({ logLevel: 4 });

var Collection = require('./helpers/Collection');
var SandboxLanes = require('./helpers/SandboxLanes');
var SandboxCollection = require('./helpers/SandboxCollection');

var LanesHandler = function () {
    function LanesHandler() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, LanesHandler);

        /*
         * Keeps the lanes of the Channel in the form:
         * {
         *  <motorcortex-id>_<attribute>: [
         *      {
         *          millisecond: the millisecond of the channel this Animation (that affects the selector/attribute pair) runs
         *          incident: Animation (the animation object that holds the affecting animation
         *      }
         *  ]
         * }
         /** @type {{}}
         */
        this.lanes = new Collection({});
        if (props.lanes) {
            this.lanes = props.lanes;
        }

        this.comboAttributes = {};
        if (props.comboAttributes != null) {
            this.comboAttributes = props.comboAttributes;
        }

        /*
        Keeps an indexing of the lanes each Animation belongs to. The form is the following:
        belongingLaneKeysByAnimationId: {
            <animation_id>: [laneKey1, laneKey2, ...],
            <animation_id>: [laneKey2, laneKey3, ...],
            ...
        }
         */
        this.belongingLaneKeysByAnimationId = new Collection({});
        if (props.belongingLaneKeysByAnimationId) {
            this.belongingLaneKeysByAnimationId = props.belongingLaneKeysByAnimationId;
        }
    }

    /**
     * This method resizes all the lanes of the Lanes Handler by the durationFraction provided.
     * No checks are performed. 
     * This method is been invoked in cases where a full Clip gets resized, so no conflict checks need to
     * run.
     * @param {float} durationFration: the fraction between the new duration and the current
    */


    _createClass(LanesHandler, [{
        key: '_resize',
        value: function _resize(durationFraction) {
            var keys = this.lanes._keys();

            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var theLane = this.lanes._get(key);
                for (var _i = 0; _i < theLane.length; _i++) {
                    theLane[_i].millisecond = theLane[_i].millisecond * durationFraction;
                }
            }
        }

        /**
         * it creates a new LanesHandler that acts as a sanbox for testing changes
        */

    }, {
        key: 'createTestLanesSanbox',
        value: function createTestLanesSanbox() {
            var props = {
                lanes: new SandboxLanes(this.lanes._export()),
                belongingLaneKeysByAnimationId: new SandboxCollection(this.belongingLaneKeysByAnimationId._export()) //JSON.parse(JSON.stringify(this.belongingLaneKeysByAnimationId))
            };

            if (this.comboAttributes) {
                props.comboAttributes = this.comboAttributes;
            }

            return new LanesHandler(props);
        }
    }, {
        key: 'getLanesCopy',
        value: function getLanesCopy(lane) {
            var laneToReturn = [];
            for (var i = 0; i < lane.length; i++) {
                laneToReturn.push({
                    id: lane[i].id,
                    incident: lane[i].incident,
                    millisecond: lane[i].millisecond * 1
                });
            }
            return laneToReturn;
        }
    }, {
        key: 'getLaneElementsClone',
        value: function getLaneElementsClone(laneElement) {
            // return _cloneDeep(laneElement);
            return {
                id: laneElement.id,
                millisecond: laneElement.millisecond * 1,
                incident: {
                    duration: laneElement.incident.duration * 1,
                    id: laneElement.incident.id
                }
                // return JSON.parse(JSON.stringify(laneElement));
            };
        }
    }, {
        key: 'applySandboxChanges',
        value: function applySandboxChanges(SanboxObject) {
            this.lanes = new Collection(SanboxObject.lanes._export());

            this.belongingLaneKeysByAnimationId = new Collection(SanboxObject.belongingLaneKeysByAnimationId._export());
        }
    }, {
        key: 'getLane',
        value: function getLane(mcid, attr) {
            return this.lanes._get(helper.getLaneKey(mcid, attr));
        }

        /**
         * Checks whether the incident has animatedAttrs or not. 
        **/

    }, {
        key: '_incidentHasAnimatedAttrs',
        value: function _incidentHasAnimatedAttrs(incident) {
            if (incident.attrs.hasOwnProperty('animatedAttrs')) {
                return true;
            }
            return false;
        }

        /**
         * return true if lane exists or false otherwise
         * @param {String} mcid
         * @param {String} attr
         * @param {boolean} ifNotCreateIt - if is set to true and the lane doesn't exist it creates it but still returning false
        */

    }, {
        key: 'laneExists',
        value: function laneExists(mcid, attr) {
            var ifNotCreateIt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

            var laneKey = helper.getLaneKey(mcid, attr);
            if (!this.lanes._hasOwnProperty(laneKey)) {
                if (ifNotCreateIt) {
                    this.lanes._set(laneKey, []);
                }
                return false;
            } else {
                return true;
            }
        }
    }, {
        key: 'animationIDExists',
        value: function animationIDExists(mcid, attr, animationID) {
            if (this.belongingLaneKeysByAnimationId._hasOwnProperty(animationID)) {
                if (this.belongingLaneKeysByAnimationId._get(animationID).indexOf(helper.getLaneKey(mcid, attr)) >= 0) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        }

        /**
         * @param {Object} newAnim - an object of the form of a lane item (with keys "millisecond" and "incident"
         * @param {string} mcid
         * @param {String} attr
         * @param {array} excludeIdsFromCheck - optional. If exists it excludes all the ids of this array from check. This
         *  parameter has been added for the edit checks where an animation might overlap another animation that participates on
         *  the move, something that should not happen as the edited animations pre-existed without conflicts and the move of all
         *  of them together guarantees that there is going to be no conflict between them even after the edit
         * @param {int} testDuration - optional. This parameter is used when the channel needs to addcheck overlaps after duration
         *  edits, so the testDuration is passed (we don't want to polute the original animation object as it refers to the real one)
         * @retuns {array} - a list of all overlapping animations of the lane
        */

    }, {
        key: 'getOverlappingAnims',
        value: function getOverlappingAnims(newAnim, mcid, attr) {
            var excludeIdsFromCheck = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
            var testDuration = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

            var overlappingAnims = _filter(this.lanes._get(helper.getLaneKey(mcid, attr)), function (existingAnim) {
                var durationToUseOnChecks = newAnim.incident.duration;
                if (testDuration != null) {
                    durationToUseOnChecks = testDuration;
                }

                return existingAnim.incident.id != newAnim.incident.id && excludeIdsFromCheck.indexOf(existingAnim.incident.id) < 0 && (
                // existing anim starts within the new anim's extend
                existingAnim.millisecond >= newAnim.millisecond && existingAnim.millisecond < durationToUseOnChecks + newAnim.millisecond ||
                // or ends within the new anim's extend
                existingAnim.millisecond + existingAnim.incident.duration > newAnim.millisecond && existingAnim.millisecond + existingAnim.incident.duration <= durationToUseOnChecks + newAnim.millisecond
                // or it starts before and ends after the new anim's extend
                || existingAnim.millisecond < newAnim.millisecond && existingAnim.millisecond + existingAnim.incident.duration > durationToUseOnChecks + newAnim.millisecond);
            });

            return overlappingAnims;
        }

        /**
         * it justs adds the lane item to the lane and adjusts the initial values of the Anims in sequence
         * No checks are performed, just execution.
         * @param {String} mcid
         * @param {String} attr
         * @param {int} millisecond
         * @param {Object} incident
        */

    }, {
        key: 'addElementToLane',
        value: function addElementToLane(mcid, attr, millisecond, incident) {

            var laneKey = helper.getLaneKey(mcid, attr);

            var laneElement = {
                millisecond: millisecond,
                incident: incident,
                id: incident.id
            };

            this.laneExists(mcid, attr, true);
            var theLane = this.lanes._get(laneKey);

            theLane.push(laneElement);
            theLane = _sortBy(theLane, ['millisecond']);

            // indexing stuff
            if (!this.belongingLaneKeysByAnimationId._hasOwnProperty(incident.id)) {
                this.belongingLaneKeysByAnimationId._set(incident.id, []);
            }
            this.belongingLaneKeysByAnimationId._get(incident.id).push(laneKey);
            // indexing
            var newAnimsIndex = _findIndex(theLane, function (item) {
                return item.incident.id === incident.id;
            });

            /* if the incident has no animated attributes we don't need to work on start and final values */
            if (!this._incidentHasAnimatedAttrs(incident)) {
                return { onSuccessAction: function onSuccessAction() {} };
            }

            // helper.log(newAnimsIndex);
            // step 1: set the intial values of the new Animation
            if (newAnimsIndex === 0) {
                // if the newly entered animation is the first of the lane
                if (theLane.length > 1) {
                    // and it has other animations too
                    if (theLane[1].incident.hasInitialValue(attr)) {
                        // if the initial value of the following animation
                        // which used to be first is already calculated "steal" it
                        incident.setInitialValue(attr, theLane[1].incident.getInitialValue(attr));
                    }
                } else {
                    // else take it directly from the dom
                    incident.setInitialValue(attr, incident.getScratchValue(mcid, attr));
                }
            } else {
                incident.setInitialValue(attr, theLane[newAnimsIndex - 1].incident.attrs.animatedAttrs[attr]);
            }

            /* if the attribute of the lane is a compo attribute */
            if (this.comboAttributes.hasOwnProperty(attr)) {
                var incidentInitialValues = incident.getInitialValue(attr);
                for (var key in incidentInitialValues) {
                    if (!incident.attrs.animatedAttrs[attr].hasOwnProperty(key)) {
                        incident.attrs.animatedAttrs[attr][key] = incidentInitialValues[key];
                    }
                }
            }

            var onSuccessAction = function onSuccessAction() {};
            // step 2: set the inital values of the following Animation (if any)
            if (newAnimsIndex + 1 < theLane.length) {
                onSuccessAction = function onSuccessAction() {
                    theLane[newAnimsIndex + 1].incident.setInitialValue(attr, incident.attrs.animatedAttrs[attr]);
                    if (theLane[newAnimsIndex + 1].incident.gotContext) {
                        theLane[newAnimsIndex + 1].incident.onGetContext();
                    }
                };
            }

            onSuccessAction();
        }

        /**
         * it justs updates the lane
         * No checks are performed, just execution
         * @param {array} affectedAnimationsIds
         * @param {String} attr
         * @param {int} millisecondDelta
        */

    }, {
        key: 'updateLane',
        value: function updateLane(affectedAnimationsIds, millisecondsDelta) {
            var _this = this;

            // first we group the affected animations by lanes
            var affectedLanes = {};
            var that = this;
            for (var i = 0; i < affectedAnimationsIds.length; i++) {
                var belongingLanes = this.belongingLaneKeysByAnimationId._get(affectedAnimationsIds[i]);
                for (var j = 0; j < belongingLanes.length; j++) {
                    var laneKey = belongingLanes[j];
                    if (!affectedLanes.hasOwnProperty(laneKey)) {
                        affectedLanes[laneKey] = {
                            animations: [],
                            lane: that.lanes._get(laneKey),
                            laneData: helper.getMCIDandAttrOutOfLaneKey(belongingLanes[j])
                        };
                    }
                    affectedLanes[laneKey].animations.push(affectedAnimationsIds[i]);
                }
            }

            // for each of the affected lanes
            for (var _laneKey in affectedLanes) {
                var affectedLane = affectedLanes[_laneKey];
                var lane = affectedLane.lane;
                var laneData = affectedLane.laneData;
                var laneBeforeEdit = _sortBy(this.getLanesCopy(lane), ['millisecond']);

                // edit lane items millisecond
                for (var k = 0; k < lane.length; k++) {
                    if (affectedLane.animations.indexOf(lane[k].incident.id) >= 0) {
                        lane[k].millisecond += millisecondsDelta;
                    }
                } // end for searching for the animations within the lane

                var sortedLane = _sortBy(lane, ['millisecond']);
                this.lanes._set(_laneKey, sortedLane);
                lane = sortedLane;
                // console.log(this);

                var _loop = function _loop(_i2) {
                    var animationToCheck = affectedLane.animations[_i2];
                    var animationIndexBeforeEdit = _findIndex(laneBeforeEdit, function (item) {
                        return item.incident.id === animationToCheck;
                    });
                    var animationIndexAfterEdit = _findIndex(lane, function (item) {
                        return item.incident.id === animationToCheck;
                    });
                    var animation = lane[animationIndexAfterEdit].incident;

                    /**
                     * if the first animation doesn't have animated attributes that means no one on this channel has. Brake
                     * and exit the loop that handles start and end values
                    */
                    if (!_this._incidentHasAnimatedAttrs(animation)) {
                        return 'break';
                    }

                    if (animationIndexBeforeEdit !== animationIndexAfterEdit || animationIndexAfterEdit > 1) {
                        if (animationIndexBeforeEdit + 1 < lane.length) {
                            // if the animation was not the last animation on the lane before the edit
                            // we should take care of the initial values of the animation's previous successor
                            if (animationIndexBeforeEdit === 0) {
                                // if the edited animation was the first one before the edit
                                // if it has initial values, pass them to its previous successor as its new initial values
                                if (animation.hasInitialValue(laneData.attribute) !== false) {
                                    // get the initial value of the edited animation and set it as initial value of the new 0 index
                                    laneBeforeEdit[1].incident.setInitialValue(laneData.attribute, animation.getInitialValue(laneData.mcid, laneData.attribute));
                                } else {
                                    // otherwise calculate the initial value on the fly, out of the dom and set it to the new 0
                                    laneBeforeEdit[1].incident.setInitialValue(laneData.attribute, laneBeforeEdit[1].incident.getScratchValue(laneData.mcid, laneData.attribute));
                                }
                            } else {
                                // else if the edited animation was not the first one before the edit
                                // meaning its previous successor is not the first one on the lane after the edit
                                // just grab the target value of the new previous animation of the animation's previous successor and set it as initial value
                                laneBeforeEdit[animationIndexBeforeEdit + 1].incident.setInitialValue(laneData.attribute, laneBeforeEdit[animationIndexBeforeEdit - 1].incident.attrs.animatedAttrs[laneData.attribute]);
                            }
                        }

                        // for the edited animation itself now:
                        if (animationIndexAfterEdit === 0) {
                            // is it the first one (after edit)?
                            // does the previously zero index animation has initial value?
                            if (laneBeforeEdit[0].incident.hasInitialValue(laneData.attribute)) {
                                // get the initial values of the previously 0 indexed animation of the lane
                                animation.setInitialValue(laneData.attribute, laneBeforeEdit[0].incident.getInitialValue(laneData.mcid, laneData.attribute));
                            } else {
                                // otherwise calculate the initial value on the fly, our of the dom
                                animation.setInitialValue(laneData.mcid, laneData.attribute, animation.getScratchValue(laneData.mcid, laneData.attribute));
                            }
                        } else {
                            // else if it is not the first one after edit
                            // just grab the target value of the previous animation on the updated lane and set it as its initial value
                            animation.setInitialValue(laneData.attribute, lane[animationIndexAfterEdit - 1].incident.attrs.animatedAttrs[laneData.attribute]);
                        }

                        // for its new next animation (if it has one)
                        if (animationIndexAfterEdit + 1 < lane.length) {
                            // set its initial value to equal the target value of the edited animation
                            lane[animationIndexAfterEdit + 1].incident.setInitialValue(laneData.attribute, animation.attrs.animatedAttrs[laneData.attribute]);
                        }
                    }
                };

                for (var _i2 = 0; _i2 < affectedLane.animations.length; _i2++) {
                    var _ret = _loop(_i2);

                    if (_ret === 'break') break;
                }
            } // end for each of the belonging lanes of the animation
        }

        /**
         * removes the list of animations as provided
         * @param {array} removedAnimations - an array with the removed animations' ids
        */

    }, {
        key: 'deleteAnimations',
        value: function deleteAnimations(removedAnimations, currentMillisecond) {
            var affectedLanes = {};

            for (var i = 0; i < removedAnimations.length; i++) {
                var id = removedAnimations[i];
                // for each lane the affected Animation appears in
                var belongingLanes = this.belongingLaneKeysByAnimationId._get(id);
                for (var j = 0; j < belongingLanes.length; j++) {
                    var lane = this.lanes._get(belongingLanes[j]);

                    var _animationIndexBeforeEdit = -1;
                    for (var k = 0; k < lane.length; k++) {
                        if (lane[k].incident.id === id) {
                            _animationIndexBeforeEdit = k;
                            break;
                        }
                    }

                    // helper.log(animationIndexBeforeEdit);
                    var animationToDelete = Object.assign({}, lane[_animationIndexBeforeEdit]);
                    var animationObjectToDelete = animationToDelete.incident;
                    var laneData = helper.getMCIDandAttrOutOfLaneKey(belongingLanes[j]);

                    // gets the lane without the removed animation
                    var newLane = [];
                    for (var _k = 0; _k < lane.length; _k++) {
                        if (lane[_k].incident.id != id) {
                            newLane.push(lane[_k]);
                        }
                    }
                    this.lanes._set(belongingLanes[j], newLane);
                    lane = this.lanes._get(belongingLanes[j]);

                    if (lane.length === 0) {
                        this.lanes._delete(belongingLanes[j]);
                        if (affectedLanes.hasOwnProperty(belongingLanes[j])) {
                            delete affectedLanes[belongingLanes[j]];
                        }
                    } else {
                        if (this._incidentHasAnimatedAttrs(animationToDelete.incident)) {
                            affectedLanes[belongingLanes[j]] = helper.getMCIDandAttrOutOfLaneKey(belongingLanes[j]);
                            if (_animationIndexBeforeEdit < lane.length && animationToDelete.incident.getInitialValue(laneData.mcid, laneData.attribute) !== false) {
                                lane[_animationIndexBeforeEdit].incident.setInitialValue(laneData.attribute, animationToDelete.incident.getInitialValue(laneData.mcid, laneData.attribute));
                            }
                        }
                    }
                }
                this.belongingLaneKeysByAnimationId._delete(removedAnimations[i]);
            }
            return affectedLanes;
        }

        /**
         * This method handles edits on the final value of a specific attribute of a specific animation object
         * @param {string} animationId - the id of the Animation object that has been edited
         * @param {string} attr - the name of the attribute that has been edited
         * @param {string} value - the new value of the edited attribute
        */

    }, {
        key: 'updateAttributeOnLanes',
        value: function updateAttributeOnLanes(animationId, attr, value) {
            var belongingLanes = this.belongingLaneKeysByAnimationId._get(animationId);
            var affectedLanes = [];
            for (var i = 0; i < belongingLanes.length; i++) {
                var lane = this.lanes._get(belongingLanes[i]);
                var laneData = helper.getMCIDandAttrOutOfLaneKey(belongingLanes[i]);

                // get the index of the animation on the lane
                var animationIndex = -1;
                for (var k = 0; k < lane.length; k++) {
                    if (lane[k].incident.id === animationId) {
                        animationIndex = k;
                        break;
                    }
                }

                // if the animation is not the last one on the lane
                if (lane.length - 1 != animationIndex) {
                    lane[animationIndex + 1].incident.setInitialValue(laneData.mcid, laneData.attribute, value);
                }

                affectedLanes.push(laneData);
            }

            return affectedLanes;
        }
    }]);

    return LanesHandler;
}();

module.exports = LanesHandler;