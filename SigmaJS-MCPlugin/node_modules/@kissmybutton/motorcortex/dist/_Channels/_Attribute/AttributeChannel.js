'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Channel = require('../Channel');
var Helper = require('../../_coreUtils/Helper');
var helper = new Helper();
var conf = require('../../configuration/generalConf');

var _filter = require('../../../lodash-custom-build/modularize/lodash.filter/index');
var _sortBy = require('../../../lodash-custom-build/modularize/lodash.sortby/index');

var lanesHandler = require('./LanesHandler');

var AttributeChannel = function (_Channel) {
    _inherits(AttributeChannel, _Channel);

    function AttributeChannel(props) {
        _classCallCheck(this, AttributeChannel);

        /*
        comboAttributes are attributes of type object, holding a number of other attributes.
        E.g. CSS "transform" attribute is a combo that holds a number of other attributes such as:
        translateX, translateY, etc. The lanes handler keeps just one lane for the combo attrs 
        in an object format keeping the value of each attribute at any given point.
        Combo attributes are passed on the constructor of the Channel in the format:
        props.comboAttributes: {
            transition: ['translateX', 'translateY', ...],
            <something_else>: ['<attrName1>', '<attrName2>', ...]
        }
        */
        var _this = _possibleConstructorReturn(this, (AttributeChannel.__proto__ || Object.getPrototypeOf(AttributeChannel)).call(this, props));

        _this.comboAttributes = {};

        /**
         * For incidents that do not have animatedAttrs there should be only one lane per element. 
         * The attributes Channel will use a default (fake), fixed attribute for this cases so it always ends
         * up with just one lane per element: <element_id>_<this.fixedAttributeName>
        */
        _this.fixedAttributeName = "_";

        if (props.comboAttributes != null) {
            _this.comboAttributes = props.comboAttributes;
        }

        _this.LanesHandler = new lanesHandler({ comboAttributes: _this.comboAttributes });
        // this.type = "attributes";
        return _this;
    }

    _createClass(AttributeChannel, [{
        key: 'setComboAttributes',
        value: function setComboAttributes(comboAttributes) {
            this.comboAttributes = comboAttributes;
            this.LanesHandler = new lanesHandler({ comboAttributes: this.comboAttributes });
        }
    }, {
        key: '_resize',
        value: function _resize(durationFraction) {
            this.LanesHandler._resize(durationFraction);
        }

        /**
         * Checks whether the incident has animatedAttrs or not. 
        **/

    }, {
        key: '_incidentHasAnimatedAttrs',
        value: function _incidentHasAnimatedAttrs(incident) {
            if (incident.attrs.hasOwnProperty('animatedAttrs')) {
                return true;
            }
            return false;
        }

        /* *******************************************************
         DECISION METHODS
         ********************************************************/

        /**
         * All of the incidents coming to this method are element-attribute incidents meaning that they only
         * target just one element and also they include just a single attribute on the incident.attrs.animatedAttrs
         * object
         *
         * @param {array} incidents - A collection of Incidents in the form:
         * {
         *  millisecond
         *  incident
         *  id
         * }
         * @param {string} type - can be either "all-or-nothing" (default) or "keep-passing". If type = "all-or-nothing"
         *  the addition passes only if all incidents pass. If type = "keep-passing" the method will still return true
         *  but will also include an errors array on its return and also will only include the success callbacks on 
         *  the execute key of its return
         * @returns either:
         *   {
         *       result:true,
         *       execute: // an array of functions that when executed it will add the Incidents on the Channels
         *   }
         *   or
         *   {
         *       result: false,
         *       errors
         *   }
        */

    }, {
        key: 'checkAddition',
        value: function checkAddition(incidents) {
            var _this2 = this;

            var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "all-or-nothing";

            var LanesHandlerSandbox = this.LanesHandler.createTestLanesSanbox();
            /* an array where we keep all affected lanes so we can slip on them at the end. 
            The format for each affected lane we keep is:
            {
                mcid: mcid,
                attribute: attribute
            }
            */
            var affectedLanes = [];

            // while the LanesHandlerSanbox adds lane items it makes decisions of which permanent changes should be made to
            // the permanent and pre-existing objects it handles, such as changes on the initial values of existing animations.
            // Because of the fact the LanesSandboxHandler is only there for testing we don't want to execute these changes
            // during checks but still we need to know them on success. For this, the onSuccessActions array holds all executable
            // functions retured by various LanesHandlerSanbox functions so it can execute them on success.
            var onSuccessActions = [];

            var conflicts = [];

            var _loop = function _loop(i) {
                var incidentConflicts = false; // a boolean that keeps the information whether the incident conflicts or not
                var laneItem = incidents[i];
                var incident = laneItem.incident;

                var mcid = _this2.context.getMCID(incident.element);

                // console.log("the incident",incident)
                var attribute = _this2.fixedAttributeName;
                if (_this2._incidentHasAnimatedAttrs(incident)) {
                    attribute = Object.keys(incident.attrs.animatedAttrs)[0];
                }

                LanesHandlerSandbox.laneExists(mcid, attribute); // create the lane if it doesn't exist already

                affectedLanes.push({
                    mcid: mcid,
                    attribute: attribute
                });

                if (LanesHandlerSandbox.animationIDExists(mcid, attribute, incident.id)) {
                    incidentConflicts = true;
                    conflicts.push({
                        type: 'duplicate Animation id',
                        meta: {
                            id: incident.id
                        }
                    });
                }

                // **** if the lane did exist before the new addition check for conflicts
                var overlappingAnims = LanesHandlerSandbox.getOverlappingAnims(laneItem, mcid, attribute);

                // helper.log(overlappingAnim)
                if (overlappingAnims.length > 0) {
                    incidentConflicts = true;
                    conflicts.push({
                        type: 'unauthorised, overlapping incidents on the same element',
                        meta: {
                            element_mcid: mcid,
                            attribute: attribute,
                            incident: laneItem,
                            overlappingAnims: overlappingAnims
                        }
                    });
                }

                if (!incidentConflicts) {
                    onSuccessActions.push(function () {
                        LanesHandlerSandbox.addElementToLane(mcid, attribute, laneItem.millisecond, incident);
                        incident._onGetContextOnce();
                    });
                }
            };

            for (var i = 0; i < incidents.length; i++) {
                _loop(i);
            } // end for each incident

            // if we have conflicts and the type = "all-or-nothing"
            if (conflicts.length > 0 && type === "all-or-nothing") {
                return {
                    result: false,
                    errors: conflicts
                };
            } else {
                // as soon as we want all passing additions to get applied the Lanes Handler will create a callback that will be passed to the result.
                // This callback will apply all passing additions.

                // success message
                var that = this;
                var exec = function exec() {
                    for (var i = 0; i < onSuccessActions.length; i++) {
                        onSuccessActions[i]();
                    }
                    that.LanesHandler.applySandboxChanges(LanesHandlerSandbox);

                    // TODO how exactly are we handling slipping?
                    for (var _i = 0; _i < affectedLanes.length; _i++) {
                        var affectedLane = affectedLanes[_i];
                        that.slipIntoLaneForwards(that.LanesHandler.getLane(affectedLane.mcid, affectedLane.attribute), affectedLane, 0, that.runTimeInfo.currentMillisecond);
                    }
                };

                return {
                    result: true,
                    errors: conflicts,
                    execute: exec
                };
            }
        }

        /**
        * It initially checks if the edit is allowed and if it is it retuns an array of executable functions
        * that apply the change
        * @param {array} incidents - the list of the lane items to edit in an array format [object, object, ...]
        * @param {int} millisecondsDelta - the milliseconds delta to apply to the incidents
        * @returns {object} -
        * either:
        {
           result: true,
           execute: // array of functions to be executed in order to apply the edit
        }
        or
        {
            result: false,
            errors: // an array including all the errors / conflicts found on edit
        }
        */

    }, {
        key: 'checkEdit',
        value: function checkEdit(incidents, millisecondsDelta) {

            var affectedIncidentIds = [];
            for (var i = 0; i < incidents.length; i++) {
                affectedIncidentIds.push(incidents[i].id);
            }

            var LanesHandlerSandbox = this.LanesHandler.createTestLanesSanbox();

            var conflicts = [];
            var affectedLanes = [];

            // for each of the affectedAnimations
            for (var _i2 = 0; _i2 < incidents.length; _i2++) {
                var _incident = incidents[_i2].incident;
                var incidentId = _incident.id;
                var _mcid = this.context.getMCID(_incident.element);
                var _attribute = this.fixedAttributeName;
                if (this._incidentHasAnimatedAttrs(_incident)) {
                    _attribute = Object.keys(_incident.attrs.animatedAttrs)[0];
                }
                var lane = LanesHandlerSandbox.getLane(_mcid, _attribute);
                var laneAttrs = {
                    mcid: _mcid,
                    attribute: _attribute

                    // check for conflicts and edit lane items millisecond
                };for (var k = 0; k < lane.length; k++) {
                    if (lane[k].incident.id === incidentId) {
                        affectedLanes.push(laneAttrs);
                        var affectedAnim = lane[k];
                        var testLaneElement = LanesHandlerSandbox.getLaneElementsClone(affectedAnim);
                        testLaneElement.millisecond += millisecondsDelta;
                        var _overlappingAnims = LanesHandlerSandbox.getOverlappingAnims(testLaneElement, _mcid, _attribute, affectedIncidentIds);

                        if (_overlappingAnims.length > 0) {
                            conflicts.push({
                                type: 'anauthorised, overlapping animations on the same element',
                                meta: {
                                    element_mcid: _mcid,
                                    attribute: _attribute,
                                    newAnimation: testLaneElement,
                                    overlappingAnims: _overlappingAnims
                                }
                            });
                        }

                        break;
                    } // end of if we found the specific animation on the lane's sequence
                } // end of each lane's item

            } // end for each affected animation's id

            if (conflicts.length > 0) {
                return {
                    result: false,
                    errors: conflicts
                };
            } else {
                var that = this;
                var exec = function exec() {
                    // as soon as there are no conflicts the Lanes Handler applies the changes before sending over the
                    // success message
                    that.LanesHandler.updateLane(affectedIncidentIds, millisecondsDelta);

                    for (var _i3 = 0; _i3 < affectedLanes.length; _i3++) {
                        var affectedLane = affectedLanes[_i3];
                        var theActualLane = that.LanesHandler.getLane(affectedLane.mcid, affectedLane.attribute);
                        that.slipIntoLaneForwards(theActualLane, affectedLane, 0, that.runTimeInfo.currentMillisecond);
                    }
                };
                return {
                    result: true,
                    execute: exec
                };
            }
        }

        /**
         * @param {array} affectedAnimations - [{id, start, end, startDelta}]
         * @param {boolean} fullChannelResize - if set to true then the full html channel is resizing. This is a special case as in
         *  that case no checks should be actually perfomed nor the projected candidate should be applied directly
        **/

    }, {
        key: 'checkResizedIncidents',
        value: function checkResizedIncidents(affectedAnimations) {
            var fullChannelResize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

            var excludeIdsFromCheck = [];
            for (var i = 0; i < affectedAnimations.length; i++) {
                excludeIdsFromCheck.push(affectedAnimations[i].id);
            }

            var LanesHandlerSandbox = this.LanesHandler.createTestLanesSanbox();

            var conflicts = [];
            var affectedLanes = [];

            // for each of the affectedAnimations
            for (var _i4 = 0; _i4 < affectedAnimations.length; _i4++) {
                var belongingLanes = LanesHandlerSandbox.belongingLaneKeysByAnimationId._get(affectedAnimations[_i4].id);
                var testDuration = affectedAnimations[_i4].end - affectedAnimations[_i4].start;

                // for each lane the affected Animation appears in
                for (var j in belongingLanes) {
                    var lane = LanesHandlerSandbox.lanes._get(belongingLanes[j]);
                    var laneData = helper.getMCIDandAttrOutOfLaneKey(belongingLanes[j]);

                    // check for conflicts and edit lane items millisecond
                    for (var k = 0; k < lane.length; k++) {
                        if (lane[k].incident.id === affectedAnimations[_i4].id) {
                            affectedLanes.push(laneData);
                            if (fullChannelResize === false) {
                                var affectedAnim = lane[k];
                                var testLaneElement = LanesHandlerSandbox.getLaneElementsClone(affectedAnim);
                                testLaneElement.millisecond += affectedAnimations[_i4].startDelta;
                                var _overlappingAnims2 = LanesHandlerSandbox.getOverlappingAnims(testLaneElement, laneData.mcid, laneData.attribute, excludeIdsFromCheck, testDuration);

                                if (_overlappingAnims2.length > 0) {
                                    conflicts.push({
                                        type: 'anauthorised overlapping animations on the same element',
                                        meta: {
                                            element_mcid: laneData.mcid,
                                            attribute: laneData.attribute,
                                            newAnimation: testLaneElement,
                                            overlappingAnims: _overlappingAnims2
                                        }
                                    });
                                }
                            }

                            break;
                        } // end of if we found the specific animation on the lane's sequence
                    } // end of each lane's item

                } // end of each belonging lane
            } // end for each affected animation's id

            if (conflicts.length > 0) {
                return {
                    result: false,
                    conflicts: conflicts
                };
            } else {
                // unlike the case of editing the start millisecond of a Scene / Incident on editing the duration of a Scene
                // or an Incident slipping to lanes should occur depends not only on the positioning of the Animations on
                // the lanes but also on their duration. Editing the duration occurs on the Scene that received the editDuration
                // command and thus at that point the HTMLChannel (and its LanesHaldler) is not ready to slip as the affected
                // Animations still have the old (un-edited) duration.
                // For this reason and only on the case of duration edit slip to lanes will take place not here and not now
                // but on the scope of the Scene that got the command, at the point it receives the success ({result:true}).
                // For this we will create a callback function which holds the slipping to lanes commands and pass it on the
                // "callback" key of the result object ({success:true, callback:function(){that slips into lanes}})
                var that = this;

                var exec = function exec() {
                    var slippingCommands = []; // an array that will hold all of the slipping commands in all of the affected lanes

                    // updateLanes (only this time animation by animation as the milliseconds delta is not standard for all)
                    // as soon as there are no conflicts the Lanes Handler applies the changes before sending over the
                    // success message
                    for (var _i5 = 0; _i5 < affectedAnimations.length; _i5++) {
                        that.LanesHandler.updateLane([affectedAnimations[_i5].id], affectedAnimations[_i5].startDelta);
                    }

                    var _loop2 = function _loop2(_i6) {
                        var affectedLane = affectedLanes[_i6];
                        var theActualLane = that.LanesHandler.getLane(affectedLane.mcid, affectedLane.attribute);
                        // put the slip command on the slippingCommands array
                        slippingCommands.push(function () {
                            that.slipIntoLaneForwards(theActualLane, affectedLane, 0, that.runTimeInfo.currentMillisecond);
                        });
                    };

                    for (var _i6 = 0; _i6 < affectedLanes.length; _i6++) {
                        _loop2(_i6);
                    }

                    for (var _i7 = 0; _i7 < slippingCommands.length; _i7++) {
                        slippingCommands[_i7]();
                    }
                };

                return {
                    execute: exec,
                    result: true
                };
            }
        }

        /**
         * 
        */

    }, {
        key: 'checkDelete',
        value: function checkDelete(removedAnimations) {
            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            var removedAnimationIds = [];
            for (var i = 0; i < removedAnimations.length; i++) {
                removedAnimationIds.push(removedAnimations[i].id);
            }

            // no slipping is needed as on deletion the Animations set their elements to their initial values
            var that = this;
            var exec = function exec() {
                var affectedLanes = that.LanesHandler.deleteAnimations(removedAnimationIds, that.runTimeInfo.currentMillisecond);
                for (var laneKey in affectedLanes) {
                    var _affectedLane = affectedLanes[laneKey];
                    var _theActualLane = that.LanesHandler.getLane(_affectedLane.mcid, _affectedLane.attribute);
                    if (props.preventSlip != true) {
                        that.slipIntoLaneForwards(_theActualLane, _affectedLane, 0, that.runTimeInfo.currentMillisecond);
                    }
                }
            };

            return {
                result: true,
                execute: exec
            };
        }

        /**
         * checks if a duration edit is feasible and doesn't cause conflicts
         * @param {int} duration - the new duration
         * @param {array} ids - (optional) if provided it only checks resizes on the given ids (not all incidents have been re)
        **/

    }, {
        key: 'checkDurationEdit',
        value: function checkDurationEdit(durationFraction) {
            var ids = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

            // using ProjectionsHanlder it will create the candidates and the projections to pass up to the parent
            // returned object keys: candidateOwnProjectedAnimations, affectedAnimations
            var projectedAnimations = this.projectionsHandler.systoleDiastoleProjections(durationFraction, ids);
            // once it gets the porojectedAnimations from its projections hanlder it will pass it up for check

            // if the ids array is provided that means the checkDurationEdit is been used by an Animation directly
            // belonging to the html channel, so it's not a full channel resize
            var check = this.checkResizedAnimations(projectedAnimations.affectedAnimations, ids.length === 0 ? true : false);

            return check;
        }

        /**
         * Method that is invoked by Animation objects when one of their attributes value is edited
         * The purpose of this method here on the HTMLChannel is to update the lanes accordingly and slip into the
         * corresponding lanes
         * @param {string} animationId - the id of the Animation object that has been edited
         * @param {string} attr - the name of the attribute that has been edited
         * @param {string} value - the new value of the edited attribute
        */

    }, {
        key: 'animationAttributeValueChange',
        value: function animationAttributeValueChange(animationId, attr, value) {
            var affectedLanes = this.LanesHandler.updateAttributeOnLanes(animationId, attr, value);
            for (var i = 0; i < affectedLanes.length; i++) {
                var _affectedLane2 = affectedLanes[i];
                var _theActualLane2 = this.LanesHandler.getLane(_affectedLane2.mcid, _affectedLane2.attribute);
                this.slipIntoLaneForwards(_theActualLane2, _affectedLane2, 0, this.runTimeInfo.currentMillisecond);
            }
        }

        /**
         * Slips to just one lane forwards
         * @param {array} lane - the lane to slip into
         * @param {object} laneData - an object with keys: attribute & mcid
         * @param {int} currentMillisecond - the millisecond the slip starts from
         * @param {int} millisecond - the target millisecond of the slip
         */

    }, {
        key: 'slipIntoLaneForwards',
        value: function slipIntoLaneForwards(lane, laneData, currentMillisecond, millisecond) {
            // helper.log(lane, currentMillisecond, millisecond);
            var participatingAnims = _filter(lane, function (laneItem) {
                return laneItem.millisecond + laneItem.incident.duration >= currentMillisecond && laneItem.millisecond + laneItem.incident.duration <= millisecond || // it ends after currentMillisecond and before target millisecond
                laneItem.incident.duration + laneItem.millisecond >= millisecond && laneItem.millisecond <= millisecond; // or it ends after the target millisecond but also starts before it
            });

            if (participatingAnims.length == 0) {
                return true;
            }

            participatingAnims = _sortBy(participatingAnims, [function (laneItem) {
                return laneItem.millisecond;
            }]);

            // now we have all participatingAnims of the slip action in chronological order
            // our first job is to create a variable that will hold the last known value of the lane
            var lastValue = null;
            for (var i = 0; i < participatingAnims.length; i++) {
                var participatingAnim = participatingAnims[i].incident;
                var startMillisecond = participatingAnims[i].millisecond;

                // if the animation has no start values go ahead and calculated them now
                if (!participatingAnim.hasInitialValue(laneData.attribute) && lastValue === null) {
                    // helper.log('setting initial value: ', laneData.mcid, laneData.attribute, 'calculated');
                    participatingAnim.setInitialValue(laneData.mcid, laneData.attribute);
                } else if (!participatingAnim.hasInitialValue(laneData.attribute) && lastValue != null) {
                    // helper.log('setting initial value: ', laneData.mcid, laneData.attribute, lastValue);
                    participatingAnim.setInitialValue(laneData.mcid, laneData.attribute, lastValue);
                }

                // if the animation ends before the target millisecond
                // helper.log('participatingAnim.duration + startMillisecond', participatingAnim.duration + startMillisecond, millisecond);\

                if (participatingAnim.duration + startMillisecond <= millisecond) {
                    // helper.log('ends before target')
                    if (participatingAnim.attrs.hasOwnProperty('animatedAttrs')) {
                        lastValue = participatingAnim.attrs.animatedAttrs[laneData.attribute];
                    }
                    if (i === participatingAnims.length - 1) {
                        participatingAnim.progress(1, participatingAnim.duration);
                    }
                } else {
                    // slip for the specific element and the specific attribute. Set the Animation as paused or playing a
                    // and store this info somewhere
                    var percentageComplete = (millisecond - startMillisecond) / participatingAnim.duration;
                    participatingAnim.progress(percentageComplete, millisecond - startMillisecond);
                }
            }
        }

        /**
         * Slips to just one lane backwards
         * @param {array} lane - the lane to slip into
         * @param {object} laneData - an object with keys: attribute & mcid
         * @param {int} currentMillisecond - the millisecond the slip starts from
         * @parama {int} millisecond - the target millisecond of the slip
         */

    }, {
        key: 'slipToLaneBackwards',
        value: function slipToLaneBackwards(lane, laneData, currentMillisecond, millisecond) {
            // we take all Animations that are either currently running or
            // they end after the destination point
            // helper.log('<------');
            var participatingAnims = _filter(lane, function (laneItem) {
                var laneItemEnd = laneItem.incident.duration + laneItem.millisecond;
                return laneItemEnd <= millisecond && laneItemEnd >= currentMillisecond || // they end in the hot area
                laneItem.millisecond >= currentMillisecond && laneItem.millisecond <= millisecond || // they start in the hot area
                laneItem.millisecond < currentMillisecond && laneItemEnd > millisecond; // they overlap the hot area
            });

            if (participatingAnims.length == 0) {
                return true;
            }

            participatingAnims = _sortBy(participatingAnims, [function (laneItem) {
                return laneItem.millisecond;
            }]);

            var lastValue = null;
            for (var i = participatingAnims.length - 1; i >= 0; i--) {
                var participatingAnim = participatingAnims[i].incident;
                var startMillisecond = participatingAnims[i].millisecond;
                if (startMillisecond >= millisecond) {
                    participatingAnim.progress(0, 0);
                } else {
                    var percentageComplete = (millisecond - startMillisecond) / participatingAnim.duration;

                    participatingAnim.progress(percentageComplete, millisecond - startMillisecond);
                }
            }
        }

        /**
         @param {int} from - the millisecond to start from
         @param {int} to - the millisecond to go to
         */

    }, {
        key: 'moveTo',
        value: function moveTo(from, to) {
            // step 1: iterate through all lanes
            var laneKeys = this.lanes._keys();
            for (var i = 0; i < laneKeys.length; i++) {
                var laneid = laneKeys[i];
                var lane = this.lanes._get(laneid);
                var laneData = helper.getMCIDandAttrOutOfLaneKey(laneid);
                if (from < to) {
                    // helper.log(laneid);
                    this.slipIntoLaneForwards(lane, laneData, from, to);
                } else if (from >= to) {
                    this.slipToLaneBackwards(lane, laneData, from, to);
                }
            }
        }
    }, {
        key: 'lanes',
        get: function get() {
            return this.LanesHandler.lanes;
        }
    }], [{
        key: 'type',
        get: function get() {
            return "attributes";
        }
    }]);

    return AttributeChannel;
}(Channel);

module.exports = AttributeChannel;