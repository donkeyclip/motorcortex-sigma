'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Channel = require('./_Channels/Channel');
var Group = require('./_BaseClasses/Group');
var Incident = require('./_BaseClasses/Incident');
var TimedIncident = require('./_BaseClasses/TimedIncident');
var Helper = require('./_coreUtils/Helper');var helper = new Helper();
var AttributeChannel = require('./_Channels/_Attribute/AttributeChannel');
var ClipFromDefinition = require('./corePlugins/SelfContainedIncidents/ClipFromDefinition');
var SelfContainedChannel = require('./corePlugins/SelfContainedIncidents/SCIChannel');
var pipeMessages = require('./configuration/pipesConf');

var conf = require('./configuration/generalConf');
var Timer = require('./utils/Timer');

var checkPlugin = function checkPlugin(main) {
    if (main.hasOwnProperty('default')) {
        main = main.default;
    }

    var plugin_name = main.npm_name;
    var check = true;

    if (!main.hasOwnProperty('incidents')) {
        helper.error('Error on plugin ' + plugin_name + '. A plugin must expose at least one Incident.\n        Exposed plugin Incidents should be defined on the "incidents" key of the main.js file.');
        check = false;
    }

    if (!helper.isArray(main.incidents)) {
        helper.error('Error on plugin ' + plugin_name + '. thePlugin exposed Incidents are defined on the "incidents" key of the main.js file in array format.\n        Please refer to the documentation');
        check = false;
    } else {
        for (var i = 0; i < main.incidents.length; i++) {
            var exposedIncidentDefinition = main.incidents[i];
            if (_typeof(exposedIncidentDefinition.exportable) === "object") {
                if (exposedIncidentDefinition.exportable.hasOwnProperty('default')) {
                    exposedIncidentDefinition.exportable = exposedIncidentDefinition.exportable.default;
                }
            }
            if (!(exposedIncidentDefinition.exportable.prototype instanceof Incident)) {
                helper.error('Error on plugin ' + plugin_name + '. Exportable Incidents by any plugin must extend one of the base classes provided by MotorCortex.\n                ' + exposedIncidentDefinition.exportable.constructor.name + ' doesn\'t.\n                Please refer to documentation');
                check = false;
            }

            if (!exposedIncidentDefinition.hasOwnProperty('name')) {
                helper.error('Error on plugin ' + plugin_name + '. Exportable Incidents by any plugin must have the "name" key which defines the name of the exported Incident.\n                Please refer to documentation');
                check = false;
            }

            if (!exposedIncidentDefinition.hasOwnProperty('propTypes')) {
                helper.log('Warning on plugin ' + plugin_name + '.\n                It\'s always good for plugins to define the supported propTypes of their exposed Incidents\' supported properties.\n                ' + exposedIncidentDefinition.exportable.constructor.name + ' doesn\'t.\n                Please refer to documentation', 'warning');
            }
        }
    }

    if (!main.hasOwnProperty('channel')) {
        helper.error('Error on plugin ' + plugin_name + '. A plugin must always define its Channel on the "channel" key of the main.js file.\n        It\'s missing. Please refer to documentation');
        check = false;
    } else {
        if (_typeof(main.channel) === "object") {
            if (main.channel.hasOwnProperty('default')) {
                main.channel = main.channel.default;
            }
        }
    }

    return check;
};

// plugin_name is the unique name of the plugin
function loadPlugin(plugin) {
    if (plugin.hasOwnProperty('default')) {
        plugin = plugin.default;
    }

    if (!plugin.hasOwnProperty('npm_name')) {
        plugin.npm_name = 'plugin_' + new Date().getTime();
    }

    if (!plugin.hasOwnProperty('channel')) {
        plugin.channel = Channel;
    }
    if (!checkPlugin(plugin)) {
        return false;
    } else {
        // thePlugin is the plugin object which will hold on its keys
        // the names of the exposed Incidents of its. The keys of this object
        // are going to be identical with the names of the classes exposed
        var thePlugin = {};

        if (plugin.hasOwnProperty('clip')) {
            if (_typeof(plugin.clip) === "object") {
                if (plugin.clip.hasOwnProperty('default')) {
                    plugin.clip = plugin.clip.default;
                }
            }
            Object.defineProperty(thePlugin, 'Clip', {
                get: function get() {
                    var WrapperClass = function WrapperClass(attrs, props) {
                        _classCallCheck(this, WrapperClass);

                        var instantiatedIncident = new plugin.clip(attrs, props);
                        instantiatedIncident.plugin_channel_class = SelfContainedChannel;
                        // instantiatedIncident.mc_plugin_npm_name = '@kissmybutton/self-contained-incidents';

                        return instantiatedIncident;
                    };

                    return WrapperClass;
                }
            });
            // thePlugin.Clip = plugin.clip;
        }

        // for each of the exposed Incidents

        var _loop = function _loop(i) {
            var incidentClass = plugin.incidents[i].exportable;

            // TODO hanlde the different css style isolation versions through the cssIsolation parameter of the containerParams of the incident

            // dynamically assign getters on the Incident's name key of the thePlugin object
            Object.defineProperty(thePlugin, plugin.incidents[i].name, {
                get: function get() {
                    // the getter will construct a wrapper class which on the constructor will instantiate an object of the
                    // exposed class, set to it the plugin name and channel class parameters and return
                    // it from the constructor
                    var WrapperClass = function WrapperClass(attrs, props) {
                        _classCallCheck(this, WrapperClass);

                        var instantiatedIncident = new incidentClass(attrs, props);

                        instantiatedIncident.mc_plugin_npm_name = plugin.npm_name;
                        if (plugin.incidents[i].bypassChannel !== true) {
                            // if the exportable incident has the flag bypassChannel the incident will be treated as motorcortex incident
                            instantiatedIncident.plugin_channel_class = plugin.channel;
                        } else {
                            instantiatedIncident.bypassChannel = true;
                        }

                        if (plugin.channel.type === "attributes" && (!props.hasOwnProperty('selector') || props.selector === null || props.selector === undefined) && plugin.incidents[i].bypassChannel !== true) {
                            helper.error('You tried to instantiate an Incident of plugin ' + plugin.npm_name + ' without passing props.selector. This plugin uses the AttributeChannel and thus all of its incidents must \n                                    be initialised with a valid props.selector.');
                            return false;
                        }

                        // it's a good idea to both validate the props here before returning the new object
                        // also is a good idea to create a Proxy for the instantiated Incident to prevent setting:
                        // id, plugin_channel_class, mc_plugin_npm_name

                        return instantiatedIncident;
                    };

                    ;

                    return WrapperClass;
                }
            });
        };

        for (var i = 0; i < plugin.incidents.length; i++) {
            _loop(i);
        }
        return thePlugin;
    }
}

var ProgrammaticIncidentPluginDefinition = require('./corePlugins/ProgrammaticIncidents/main.js');
var ProgrammaticIncidentPlugin = loadPlugin(ProgrammaticIncidentPluginDefinition);

var SelfContainedIncidentsPluginDefinition = require('./corePlugins/SelfContainedIncidents/main.js');
var SelfContainedIncidentsPlugin = loadPlugin(SelfContainedIncidentsPluginDefinition);
var ExtendableClip = require('./corePlugins/SelfContainedIncidents/ExtendableClip');

var TimeCapsule = require('./_coreUtils/TimeCapsule');

module.exports = {
    Channel: Channel,
    Group: Group,
    Clip: SelfContainedIncidentsPlugin.Clip,
    ClipFromDefinition: ClipFromDefinition,
    Incident: Incident,
    ProgrammaticIncident: ProgrammaticIncidentPlugin.ProgrammaticIncident,
    DummyIncident: ProgrammaticIncidentPlugin.DummyIncident,
    TimedIncident: TimedIncident,

    _channels: {
        'motor-cortex-js': Channel,
        '@kissmybutton/programmatic-incidents': ProgrammaticIncidentPluginDefinition.channel,
        '@kissmybutton/self-contained-incidents': SelfContainedIncidentsPluginDefinition.channel
    },

    // channels
    AttributeChannel: AttributeChannel,

    TimeCapsule: TimeCapsule,

    conf: conf,
    Timer: Timer,

    ExtendableClip: ExtendableClip,

    Helper: Helper,

    loadPlugin: loadPlugin,

    _GAIN_CHANGE: pipeMessages._GAIN_CHANGE
};