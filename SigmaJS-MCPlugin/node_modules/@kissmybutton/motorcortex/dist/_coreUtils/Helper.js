'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/** @classdesc Helper maintains a number of helpful functions in a single point  */
var conf = require('../configuration/generalConf');

var Helper = function () {
    function Helper(configuration) {
        _classCallCheck(this, Helper);

        var logLevel = 2;
        if (configuration) {
            if (configuration.hasOwnProperty('logLevel')) {
                logLevel = configuration.logLevel;
            }
        }

        this.lanesMCIDattrsSeperator = '___';

        for (var i = 0; i < conf.logTypes.length; i++) {
            var logType = conf.logTypes[i];
            if (logLevel >= logType.level) this[logType.key] = window.console.log.bind(window.console, "MotorCortex - %c%s", logType.style);else this[logType.key] = function () {};
        }

        if (logLevel >= 3) this.log = window.console.log.bind(window.console, "MotorCortex - ");else this.log = function () {};
    }

    _createClass(Helper, [{
        key: 'renderTemplate',
        value: function renderTemplate(templateString, templateVars) {
            return new Function("return `" + templateString + "`;").call(templateVars);
        }

        /**
         * @returns {string} in the form "1bc45f78-ab23-jl59"
         */

    }, {
        key: 'getAnId',
        value: function getAnId() {
            var underscore = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

            var specialChar = '-';
            if (underscore) {
                specialChar = '_';
            }
            function s4() {
                return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
            }
            return s4() + s4() + specialChar + s4() + specialChar + s4();
        }
    }, {
        key: 'getLaneKey',
        value: function getLaneKey(mcid, attribute) {
            return mcid + this.lanesMCIDattrsSeperator + attribute;
        }
    }, {
        key: 'getMCIDandAttrOutOfLaneKey',
        value: function getMCIDandAttrOutOfLaneKey(laneKey) {
            var laneArray = laneKey.split(this.lanesMCIDattrsSeperator);
            return {
                mcid: laneArray[0],
                attribute: laneArray[1]
            };
        }
    }, {
        key: 'getElementByMCID',
        value: function getElementByMCID(context, mcid) {
            return context.document.querySelectorAll('[' + conf.elements_data_attribute_name + '="' + mcid + '"]')[0];
        }
    }, {
        key: 'getMCIDOfElement',
        value: function getMCIDOfElement(element) {
            return element.getAttribute(conf.elements_data_attribute_name);
        }

        /**
        subdivision might be rounding the number to its:
        - units (subdivision = 1)
        - tenths (subdivision = 10)
        - hundreds (subdivision = 100)
        - thousands (subdivision = 1000)
         @param {string} int
         @param {subdivision} int
         @returns {int} the rounded number
        */

    }, {
        key: 'roundNumberTo',
        value: function roundNumberTo(number, subdivision) {
            return Math.round(number / subdivision) * subdivision;
        }
    }, {
        key: 'isInteger',
        value: function isInteger(number) {
            if (number === parseInt(number, 10)) {
                return true;
            } else {
                return false;
            }
        }
    }, {
        key: 'isString',
        value: function isString(test) {
            if (typeof test === 'string' || test instanceof String) {
                return true;
            } else {
                return false;
            }
        }
    }, {
        key: 'isObject',
        value: function isObject(test) {
            return (typeof test === 'undefined' ? 'undefined' : _typeof(test)) === "object";
        }
    }, {
        key: 'isArray',
        value: function isArray(test) {
            return Array.isArray(test);
        }
    }, {
        key: 'isFunction',
        value: function isFunction(functionToCheck) {
            return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
        }
    }, {
        key: 'addClass',
        value: function addClass(el, className) {
            if (el.classList) el.classList.add(className);else el.className += ' ' + className;
        }
    }, {
        key: 'removeClass',
        value: function removeClass(el, className) {
            if (el.classList) el.classList.remove(className);else el.className = el.className.replace(new RegExp('(^|\\b)' + className.split(' ').join('|') + '(\\b|$)', 'gi'), ' ');
        }
    }, {
        key: 'addStyle',
        value: function addStyle(el, style) {
            for (var key in style) {
                el.style[key] = style[key];
            }
        }

        /**
         * systole / diastole of the projections
         * @param {float} fraction - the duration fraction of the parent Scene
         * @returns {array} - collection of objects with keys: {id, start, end, startDelta}
        **/

    }, {
        key: 'systoleDiastoleProjections',
        value: function systoleDiastoleProjections(projections, durationFraction, adjustMillisecond) {
            var alteredProjections = [];

            for (var i = 0; i < projections.length; i++) {
                var projectedIncident = projections[i];

                if (durationFraction != 1) {
                    alteredProjections.push({
                        id: projectedIncident.incident.id,
                        start: projectedIncident.millisecond * durationFraction + adjustMillisecond,
                        end: projectedIncident.millisecond * durationFraction + projectedIncident.incident.duration * durationFraction + adjustMillisecond,
                        startDelta: projectedIncident.millisecond * durationFraction - projectedIncident.millisecond
                    });
                }
            }

            return alteredProjections;
        }
    }]);

    return Helper;
}();

module.exports = Helper;