'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Helper = require('../_coreUtils/Helper');
var helper = new Helper();
var conf = require('../configuration/generalConf');
var Draggabilly = require('draggabilly');
var TimeCapsule = require('../_coreUtils/TimeCapsule');
var timeCapsule = new TimeCapsule();
var journey = null;

/**
 * @classdesc
 * Timer's purpose is to provide an interface through which any TimedIncident (such as a Scene or a Clip)
 * can both privide info regarding their timing state but also provide an interface for interacting /
 * altering the timing of it
 */

var Timer = function () {
    function Timer(props) {
        _classCallCheck(this, Timer);

        this.id = props.id || helper.getAnId();
        this.cursor = document.getElementById('time-cursor');
        this.leftSlot = document.getElementsByClassName('left-slot')[0];
        this.rightSlot = document.getElementsByClassName('right-slot')[0];
        this.playButton = document.getElementById('play-pause');
        this.Incident = props.Incident;
        this.subscribeToTimer();
        this.subscribeToEvents();
        this.afterRender();
        this.previousTimestamp = 0;
        this.previousIncidentState = 'idle';
        this.width = props.width;
        this.cursorWidth = props.cursorWidth || 10;
    }

    _createClass(Timer, [{
        key: 'millisecondChange',
        value: function millisecondChange(millisecond, state) {
            // helper.log(millisecond);
            this.cursor.style.left = 'calc(' + millisecond * 100 / this.Incident.duration + '% - ' + this.cursorWidth + 'px)';
            this.leftSlot.innerHTML = millisecond;
            this.rightSlot.innerHTML = this.Incident.duration - millisecond;
        }
    }, {
        key: 'eventBroadcast',
        value: function eventBroadcast(eventName, meta) {
            if (eventName === 'state-change') {
                if (meta.newState === 'waiting') {
                    this.playButton.innerHTML = 'Resume';
                } else if (meta.newState === 'playing') {
                    this.playButton.innerHTML = 'Pause';
                } else if (meta.newState === 'completed') {
                    this.leftSlot.innerHTML = this.Incident.duration;
                    this.rightSlot.innerHTML = 0;
                    this.playButton.innerHTML = "completed";
                    helper.log(this.Incident);
                } else if (meta.newState === 'transitional') {
                    this.playButton.innerHTML = "transitioning";
                } else if (meta.newState === 'idle') {
                    this.playButton.innerHTML = "Play";
                }
            } else if (eventName === 'attribute-rejection') {
                helper.log('Attributes', meta.attributes, 'have been rejected from animation with id ' + meta.animationID);
            } else if (eventName === 'animation-rejection') {
                helper.log('Animation ' + meta.animationID + ' has been rejected as all attributes of it overlap on specific elements because of existing animations');
            } else if (eventName === 'duration-change') {
                this.millisecondChange(this.Incident.runTimeInfo.currentMillisecond, this.Incident.state);
            }
        }
    }, {
        key: 'subscribeToEvents',
        value: function subscribeToEvents() {
            // helper.error('Timer is subscirbing to the clips events');
            this.Incident.subscribeToEvents(this.id, this.eventBroadcast.bind(this));
        }
    }, {
        key: 'subscribeToTimer',
        value: function subscribeToTimer() {
            // helper.log('Timer is subscirbing to the clips timer', 'notice');
            this.Incident.subscribe(this.id, this.millisecondChange.bind(this));
        }
    }, {
        key: 'handleDragStart',
        value: function handleDragStart(event, pointer) {
            // helper.log('drag is starting', 'warning')
            journey = timeCapsule.startJourney(this.Incident);
        }
    }, {
        key: 'handleDrag',
        value: function handleDrag(event, pointer, position) {
            var millisecond = Math.round(this.Incident.duration * position.x / this.width);
            if (millisecond < 0) {
                millisecond = 0;
            }
            this.leftSlot.innerHTML = millisecond;
            this.rightSlot.innerHTML = this.Incident.duration - millisecond;

            journey.station(millisecond);
        }
    }, {
        key: 'handleDragEnd',
        value: function handleDragEnd(event, pointer) {
            //  Velocity.defaults.speed=1;
            // this.previousTimestamp is the target millisecond of the drag

            journey.destination();

            helper.log(this.Incident.exportState());
        }
    }, {
        key: 'afterRender',
        value: function afterRender() {
            var that = this;

            this.playButton.onclick = function (e) {
                if (that.Incident.state === 'playing') {
                    that.Incident.wait();
                } else if (that.Incident.state === 'waiting') {
                    that.Incident.resume();
                } else if (that.Incident.state === 'idle') {
                    that.Incident.play();
                }
            };

            var elem = document.querySelector('#time-cursor');
            var draggie = new Draggabilly(elem, {
                axis: 'x',
                containment: '.bar'
            });

            draggie.on('dragStart', this.handleDragStart.bind(this));
            draggie.on('dragMove', function (event, pointer) {
                that.handleDrag(event, pointer, draggie.position);
            });
            draggie.on('dragEnd', this.handleDragEnd.bind(this));
        }
    }, {
        key: 'render',
        value: function render(container) {}
    }]);

    return Timer;
}();

module.exports = Timer;