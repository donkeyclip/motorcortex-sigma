'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
iframe[seamless]{
    background-color: transparent;
    border: 0px none transparent;
    padding: 0px;
    overflow: hidden;
}

might need more work for IE. See here: https://stackoverflow.com/a/29209248
*/

var Helper = require('../../../_coreUtils/Helper');
var helper = new Helper();
var conf = require('../../../configuration/generalConf');

var WebComponentContextHandler = function () {
    /**
     * @param {object} props - an object that should contain all of the following keys:
     * - html (the html template to render)
     * - css (the css template of the isolated tree)
     * - initParams (optional / the initialisation parameteres that will be passed both on the css and the html templates in order to render)
     * - host (an Element object that will host the isolated tree)
     * - containerParams (an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc)
    */
    function WebComponentContextHandler() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, WebComponentContextHandler);

        if (!helper.isObject(props)) {
            helper.error('ContextHandler expects an object on its constructor. ' + (typeof props === 'undefined' ? 'undefined' : _typeof(props)) + ' passed');
            return false;
        }

        if (!props.hasOwnProperty('html')) {
            helper.error('ContextHandler expects the html key on its constructor properties which is missing');
            return false;
        }

        if (!props.hasOwnProperty('css')) {
            helper.error('ContextHandler expects the css key on its constructor properties which is missing');
            return false;
        }

        var initParams = props.initParams;
        if (!props.hasOwnProperty('initParams')) {
            helper.info('ContextHandler got null initParams');
            initParams = {};
        }

        if (!props.hasOwnProperty('host')) {
            helper.error('ContextHandler expects the host key on its constructor properties which is missing');
            return false;
        }

        this.isDOM = true;

        var ownerDocument = props.host.ownerDocument;

        var shadow = props.host.attachShadow({ mode: 'closed' });
        var wrapper = document.createElement('div');
        if (props.hasOwnProperty('containerParams')) {
            if (props.containerParams.hasOwnProperty('width')) {
                wrapper.style.width = props.containerParams.width;
            }
            if (props.containerParams.hasOwnProperty('height')) {
                wrapper.style.height = props.containerParams.height;
            }
        }
        wrapper.innerHTML = helper.renderTemplate(props.html + '<slot></slot>', { params: props.initParams });
        shadow.appendChild(wrapper);

        var styleTag = document.createElement('style');
        styleTag.type = 'text/css';
        if (styleTag.styleSheet) {
            styleTag.styleSheet.cssText = helper.renderTemplate(props.css, { params: props.initParams });
        } else {
            styleTag.appendChild(document.createTextNode(props.css));
        }
        shadow.appendChild(styleTag);

        if (props.hasOwnProperty('fonts')) {
            for (var i = 0; i < props.fonts.length; i++) {
                var theFont = props.fonts[i];
                if (theFont.type === "google-font") {
                    var fontTag = document.createElement('link');
                    fontTag.setAttribute('rel', 'stylesheet');
                    fontTag.setAttribute('src', theFont.src);
                    shadow.appendChild(fontTag);
                }
            }
        }

        wrapper.style.overflow = "hidden";

        this.rootElement = wrapper;

        this.context = {
            document: document,
            window: window,
            clipContainer: this.rootElement,
            rootElement: wrapper,
            unmount: function unmount() {
                props.host.removeChild(shadow);
            },
            getElements: this.getElements.bind(this),
            getMCID: this.getMCID.bind(this),
            setMCID: this.setMCID.bind(this),
            getElementSelectorByMCID: this.getElementSelectorByMCID.bind(this),
            getElementByMCID: this.getElementByMCID.bind(this)
        };

        this.elementsByMCID = {};
    }

    _createClass(WebComponentContextHandler, [{
        key: 'getElementByMCID',
        value: function getElementByMCID(mcid) {
            if (this.elementsByMCID.hasOwnProperty(mcid)) {
                return this.elementsByMCID[mcid];
            } else {
                var element = this.context.rootElement.querySelector(this.getElementSelectorByMCID(mcid));
                this.elementsByMCID[mcid] = element;
                return element;
            }
        }
    }, {
        key: 'getElements',
        value: function getElements(selector) {
            return Array.from(this.context.rootElement.querySelectorAll(selector));
        }
    }, {
        key: 'getMCID',
        value: function getMCID(element) {
            return element.getAttribute(conf.elements_data_attribute_name);
        }
    }, {
        key: 'setMCID',
        value: function setMCID(element, mcid) {
            element.setAttribute(conf.elements_data_attribute_name, mcid);
        }
    }, {
        key: 'getElementSelectorByMCID',
        value: function getElementSelectorByMCID(mcid) {
            return '[' + conf.elements_data_attribute_name + '="' + mcid + '"]';
        }
    }]);

    return WebComponentContextHandler;
}();

module.exports = WebComponentContextHandler;