'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Helper = require('../../_coreUtils/Helper');
var helper = new Helper();
var Group = require('../../_BaseClasses/Group');
var conf = require('../../configuration/generalConf');
var pipeMessages = require('../../configuration/pipesConf');
var ClipChannel = require('./SCIChannel');
var selfContainedIncidentsNpmName = '@kissmybutton/self-contained-incidents';

var ExtendableClip = function (_Group) {
    _inherits(ExtendableClip, _Group);

    /**
     * @param {object} props - an object that should contain all of the following keys:
     * - html (the html template to render)
     * - css (the css template of the isolated tree)
     * - initParams (optional / the initialisation parameteres that will be passed both on the css and the html templates in order to render)
     * - host (an Element object that will host the isolated tree)
     * - containerParams (an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc)
     * - type (optional, defaults to "iframe") the type of the Clip. It can be one of the:
     *  - iframe 
     *  - plain
    */
    function ExtendableClip() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var oldProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        _classCallCheck(this, ExtendableClip);

        var attrsToPass = void 0,
            propsToUse = void 0;

        /*
        backwards compatibility. If the user doesn't pass a second argument on the constructor then this is 
        the new way of initialising a Group (only props).
        */
        if (oldProps === null) {
            attrsToPass = {};
            propsToUse = props;
        } else {
            // else, in case the user has passed two arguments then both should be used
            attrsToPass = props;
            propsToUse = oldProps;
        }

        if (!helper.isObject(propsToUse)) {
            var _ret;

            helper.error('Self Contained Incident expects an object on its second argument on the constructor. ' + (typeof propsToUse === 'undefined' ? 'undefined' : _typeof(propsToUse)) + ' passed');
            return _ret = false, _possibleConstructorReturn(_this, _ret);
        }

        var _this = _possibleConstructorReturn(this, (ExtendableClip.__proto__ || Object.getPrototypeOf(ExtendableClip)).call(this, attrsToPass, propsToUse));

        _this.mc_plugin_npm_name = "@kissmybutton/self-contained-incidents";
        _this.plugin_channel_class = ClipChannel;

        _this.isTheClip = true;

        _this.volume = 1;

        _this.editingStatus = 'editing'; // either normal or editing

        _this.blockingWaitings = {};

        _this.onClipInitialise();
        return _this;
    }

    _createClass(ExtendableClip, [{
        key: 'onClipInitialise',
        value: function onClipInitialise() {
            // called when group gets initialised
        }
    }, {
        key: '_getChannel',
        value: function _getChannel(channelId) {
            if (!this.instantiatedChannels.hasOwnProperty(channelId)) {
                return null;
            } else {
                return this.instantiatedChannels[channelId];
            }
        }
    }, {
        key: 'lastWish',
        value: function lastWish() {
            this.ownContext.unmount();
        }
    }, {
        key: 'startEditing',
        value: function startEditing() {
            this.editingStatus = "editing";
        }
    }, {
        key: 'doneEditing',
        value: function doneEditing() {
            this.stop();
            this.setCurrentMillisecond(this.runTimeInfo.currentMillisecond);
            this.recalcState(this.runTimeInfo.currentMillisecond);
            this.restore();
            this.editingStatus = "editing";
        }

        /**************************************************************************
         * methods inheritied from Group
        **************************************************************************/
        // *******************************************************
        // INCIDENTS MANAGEMENT METHODS
        // POLYMORPHISM APPLIED. IF THE GROUP HAS NO PARENT IT ACTS AS A SCENE. IF THE GROUP HAS PARENT IT ACTS AS
        // A "TRANSPARENT GROUP"

        /**
         * The checkAddition method serves exactly what its name implies. To check if the addition of an Incident
         * is valid and accepted, according to the rules defined on the channels.
         * The method boobles up until it reaches the Clip by carrying adjusting the millisecond.
         * The method takes as input the management type. On error / conflict:
         *  - on type === 'all-or-nothing' completely discard addition of all incidents
         *  - on type === 'keep-passing' it will only add the passing incidents no matter if some other incidents of the addition failed
         * @param {object} incident - the incident to add
         * @param {int} millisecond - the millisecond to add the Incident to
         * @param {string} type - as explained above
         * The method returns either:
            {
                result:true,
                execute: // an array of functions that when executed it will add the Incidents on the Channels
            }
            or
            {
                result: false,
                errors
            }
        */

    }, {
        key: 'checkAddition',
        value: function checkAddition(incident, millisecond) {
            var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "all-or-nothing";

            if (incident.props.autoGeneratedID === false) {
                var existingIncidentWithTheSameId = this.getIncidentById(incident.id);
                if (existingIncidentWithTheSameId != null) {
                    return { result: false, errors: [{ reason: 'Already existing Incident with id ' + incident.id, incident: existingIncidentWithTheSameId }] };
                }
            }

            // get all incidents separated by plugin
            var incidentsById = incident.getIncidentsByChannel(millisecond);

            // prepare the return payload
            var toReturnResult = true;
            var toReturnErrors = [];
            var toReturnExecutables = [];

            // for each key of the incidentsById object perform the check
            for (var key in incidentsById) {
                // if the clip had no channel instantiated for the specific key (plugin id) yet create it
                if (!this.instantiatedChannels.hasOwnProperty(key)) {
                    // intstantiate the channel of the plugin by using the reference to the class definition stored on
                    // the very first incident of the array
                    this.instantiatedChannels[key] = new incidentsById[key][0].incident.plugin_channel_class({
                        runTimeInfo: this.runTimeInfo,
                        context: this.context
                    });
                }

                // perform the check
                var pluginResult = this.instantiatedChannels[key].addIncidents(incidentsById[key], type);
                toReturnResult = toReturnResult && pluginResult.result;
                if (pluginResult.result === false) {
                    toReturnErrors = toReturnErrors.concat(pluginResult.errors);
                } else {
                    toReturnExecutables.push(pluginResult.execute);
                }
            } // enf of iteration on the incidentsById keys

            var toReturnExecute = function toReturnExecute() {
                for (var i = 0; i < toReturnExecutables.length; i++) {
                    toReturnExecutables[i]();
                }
            };

            var additionResult = {
                result: toReturnResult,
                errors: toReturnErrors,
                execute: toReturnExecute
            };
            return additionResult;
        }

        /**
         * The checkEdit method serves exactly what its name implies. To check if the edit of an Incident (edit of Incident's position given in milliseconds delta)
         * is valid and accepted, according to the rules defined on the channels.
         * The method boobles up until it reaches the Clip.
         * @param {object} incident - the incident to edit
         * @param {int} millisecondsDelta - the milliseconds delta of the Incident's start time
         The method should return either:
            {
                result:true,
                execute: // an array of functions that when executed it will edit the Incidents on the Channels
            }
            or
            {
                result: false,
                errors
            }
        */

    }, {
        key: 'checkEdit',
        value: function checkEdit(incident, millisecondsDelta) {
            // get all incidents separated by plugin
            var incidentsById = incident.getIncidentsByChannel();

            // prepare the return payload
            var toReturnResult = true;
            var toReturnErrors = [];
            var toReturnExecutables = [];

            // for each key of the incidentsById object perform the check
            for (var key in incidentsById) {
                // perform the check
                var pluginResult = this.instantiatedChannels[key].editIncidents(incidentsById[key], millisecondsDelta);
                toReturnResult = toReturnResult && pluginResult.result;
                if (pluginResult.result === false) {
                    toReturnErrors = toReturnErrors.concat(pluginResult.errors);
                } else {
                    toReturnExecutables.push(pluginResult.execute);
                }
            } // enf of iteration on the incidentsById keys

            var toReturnExecute = function toReturnExecute() {
                for (var i = 0; i < toReturnExecutables.length; i++) {
                    toReturnExecutables[i]();
                }
            };

            var editResult = {
                result: toReturnResult,
                errors: toReturnErrors,
                execute: toReturnExecute
            };
            return editResult;
        }

        /**
         * The checkDelete method serves exactly what its name implies. To check if the deletion of an Incident
         * is valid and accepted, according to the rules defined on the channels.
         * The method boobles up until it reaches the Clip.
         * @param {object} incident - the incident to edit
         * @param {object} props - if passed it supports the preventSlip key which if false the channel should not slip. This case is for 
            flashDOM of DOMAwareIncidents where we have elements deleted so slipping on their lanes is not valid nor necessary
          The result might be either:
            {
                result:true,
                execute: // an array of functions that when executed it will remove the Incident on the Channels
            }
            or
            {
                result: false,
                errors
            }
        */

    }, {
        key: 'checkDelete',
        value: function checkDelete(incidentId) {
            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            var incident = this.getIncidentById(incidentId);
            // get all incidents separated by plugin
            var incidentsById = incident.getIncidentsByChannel();

            // prepare the return payload
            var toReturnResult = true;
            var toReturnErrors = [];
            var toReturnExecutables = [];

            // for each key of the incidentsById object perform the check
            for (var key in incidentsById) {
                // perform the check
                var pluginResult = this.instantiatedChannels[key].removeIncidents(incidentsById[key], props);
                toReturnResult = toReturnResult && pluginResult.result;
                if (pluginResult.result === false) {
                    toReturnErrors = toReturnErrors.concat(pluginResult.errors);
                } else {
                    toReturnExecutables.push(pluginResult.execute);
                }
            } // enf of iteration on the incidentsById keys

            var toReturnExecute = function toReturnExecute() {
                for (var i = 0; i < toReturnExecutables.length; i++) {
                    toReturnExecutables[i]();
                }
            };

            var editResult = {
                result: toReturnResult,
                errors: toReturnErrors,
                execute: toReturnExecute
            };
            return editResult;
        }

        /**
         * checks if a duration edit is feasible and doesn't cause conflicts
         * @param {int} duration - the new duration
        **/

    }, {
        key: 'checkResizedIncident',
        value: function checkResizedIncident(durationFraction, incident) {
            var adjustMillisecond = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

            // IF THE GROUP HAS NO PARENTS (IS A CLIP)
            if (incident.id != this.id) {
                // get all incidents separated by plugin
                var incidentsById = incident.getIncidentsByChannel();

                // prepare the return payload
                var toReturnResult = true;
                var toReturnErrors = [];
                var toReturnExecutables = [];
                // for each key of the incidentsById object perform the check

                for (var key in incidentsById) {
                    // perform the check
                    var adjustedIncidents = helper.systoleDiastoleProjections(incidentsById[key], durationFraction, adjustMillisecond);
                    var pluginResult = this.instantiatedChannels[key].checkResizedIncidents(adjustedIncidents);
                    toReturnResult = toReturnResult && pluginResult.result;
                    if (pluginResult.result === false) {
                        toReturnErrors = toReturnErrors.concat(pluginResult.errors);
                    } else {
                        toReturnExecutables.push(pluginResult.execute);
                    }
                } // enf of iteration on the incidentsById keys

                var toReturnExecute = function toReturnExecute() {
                    for (var i = 0; i < toReturnExecutables.length; i++) {
                        toReturnExecutables[i]();
                    }
                };

                var editResult = {
                    result: toReturnResult,
                    errors: toReturnErrors,
                    execute: toReturnExecute
                };
                return editResult;
            } else {
                return { result: true, execute: function execute() {} };
                // the resizing of the internal Channels occurs on the systolDiastole method of the Groups when they identify that the Groups is actually a Clip
            }
        }

        /**
         * Starting from itself and going all the way down to each and every leaf of its tree it systols/diastoles the
         * Incidents
         * @param {float} durationFraction the fraction of the new duration to the existing duration
        **/

    }, {
        key: 'systolDiastole',
        value: function systolDiastole(durationFraction) {
            _get(ExtendableClip.prototype.__proto__ || Object.getPrototypeOf(ExtendableClip.prototype), 'systolDiastole', this).call(this, durationFraction);

            for (var key in this.instantiatedChannels) {
                this.instantiatedChannels[key]._resize(durationFraction);
            }
        }
    }, {
        key: 'getIncidentsByChannel',


        /**
         * Returns an object with keys the keys of all the plugins Incidents of which appear in the
         * tree of the Group. All Incidents are projected to the Group's timeline.
         * The array includes the Group's projection too
        */
        value: function getIncidentsByChannel() {
            var adjustMillisecond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

            var incidentsByPlugin = {};
            incidentsByPlugin[selfContainedIncidentsNpmName] = [{
                millisecond: adjustMillisecond,
                incident: this,
                id: this.id
            }];

            return incidentsByPlugin;
        }

        /**
         * goTo method should always be handled by the Clip. No other Group nor Incident can handle goTo alone.
         * Thus, if the Group is not the Clip it passes the command up. If the Group is the Clip then it handles goTo
         * by passing the command to its Channels.
        **/

    }, {
        key: 'goTo',
        value: function goTo(millisecond) {
            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            // first decide the millisecond we want to goTo
            if (millisecond === null || millisecond === undefined) {
                millisecond = this.runTimeInfo.currentMillisecond;
            }
            if (props.hasOwnProperty('relativeTo')) {
                millisecond += this.getIncidentMillisecond(props.relativeTo);
            }

            if (millisecond > this.duration) {
                millisecond = this.duration;
            } else if (millisecond < 0) {
                millisecond = 0;
            }

            for (var key in this.instantiatedChannels) {
                this.instantiatedChannels[key].goTo(millisecond, props);
            }
            return true;
        }

        /**************************************************************************
        **************************************************************************/

    }, {
        key: 'handlePipeMessage',
        value: function handlePipeMessage(name, params) {
            var waitingID = params.blockingWaitingID;
            switch (name) {
                case pipeMessages._BLOCKING_WAITING:
                    if (this.blockingWaitings.hasOwnProperty(waitingID)) {
                        helper.error('Blocking waiting with id=' + waitingID + ' already exists. Blocking waiting is going to be discarded');
                        return;
                    }
                    helper.notice('adding blocking waiting with id: ' + waitingID);
                    this.blockingWaitings[waitingID] = params;
                    this.block();
                    break;
                case pipeMessages._UNBLOCK_WAITING:
                    if (!this.blockingWaitings.hasOwnProperty(waitingID)) {
                        helper.error('Blocking waiting with id=' + waitingID + ' does not exist and thus unblocking can not be performed');
                        return;
                    }
                    delete this.blockingWaitings[waitingID];

                    helper.notice('removing blocking waiting with id: ' + waitingID);
                    // If after the unblocking there are no other blocking waitings:
                    if (Object.keys(this.blockingWaitings).length === 0) {
                        // if the Clip is on blocked state play
                        this.unblock();
                    }
                    break;
                case pipeMessages._CLIP_EDITING_STATUS:
                    return this.editingStatus;
            }
        }
    }, {
        key: 'setVolume',
        value: function setVolume(newVal) {
            this.volume = parseFloat(newVal);
            this.putMessageOnPipe(pipeMessages._GAIN_CHANGE, { gain: newVal }, false, "down");
        }
    }, {
        key: 'onArm',
        value: function onArm() {
            this.blockingWaitings = {};
        }
    }, {
        key: '_onGetContextOnce',
        value: function _onGetContextOnce() {
            return; // Clips do not get context from noone
        }
    }, {
        key: 'exportState',
        value: function exportState() {
            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            var state = _get(ExtendableClip.prototype.__proto__ || Object.getPrototypeOf(ExtendableClip.prototype), 'exportState', this).call(this, props);

            if (props.hasOwnProperty('exportChannels')) {
                if (props.exportChannels === true) {
                    var channelsToExport = [];
                    for (var channel in this.instantiatedChannels) {
                        var _state = this.instantiatedChannels[channel].exportState(props);
                        _state.mc_plugin_npm_name = channel;
                        channelsToExport.push(_state);
                    }

                    state.channels = channelsToExport;
                }
            }

            return state;
        }
    }, {
        key: 'isHeadlessClip',
        get: function get() {
            return false;
        }
    }, {
        key: 'context',
        get: function get() {
            return this.ownContext;
        }
    }]);

    return ExtendableClip;
}(Group);

module.exports = ExtendableClip;