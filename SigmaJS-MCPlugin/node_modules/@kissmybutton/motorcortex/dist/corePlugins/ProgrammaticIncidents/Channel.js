'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Helper = require('../../_coreUtils/Helper');
var helper = new Helper();
var conf = require('../../configuration/generalConf');
var Channel = require('../../_Channels/Channel');
var _sortBy = require('../../../lodash-custom-build/modularize/lodash.sortby/index.js');
var _filter = require('../../../lodash-custom-build/modularize/lodash.filter/index.js');

var PIChannel = function (_Channel) {
    _inherits(PIChannel, _Channel);

    function PIChannel() {
        _classCallCheck(this, PIChannel);

        return _possibleConstructorReturn(this, (PIChannel.__proto__ || Object.getPrototypeOf(PIChannel)).apply(this, arguments));
    }

    _createClass(PIChannel, [{
        key: 'onInitialise',

        /*
        this.incidents is a collection of {incident, id, millisecond} objects always kept in order
            from lower to higher millisecond
        this.incidetnsById is an index of the incidents kept by id (this.incidents[incident-id] = Incident)
        */
        value: function onInitialise() {
            this.incidents = [];
            this.incidentsById = {};
        }
    }, {
        key: 'slipToLaneForwards',
        value: function slipToLaneForwards(currentMillisecond, millisecond) {
            var participatinIncidents = _filter(this.incidents, function (laneItem) {
                return laneItem.millisecond > currentMillisecond && laneItem.millisecond <= millisecond;
            });
            // helper.log(`participating incidents: `, participatinIncidents);

            for (var i = 0; i < participatinIncidents.length; i++) {
                participatinIncidents[i].incident.command.forwards();
            }

            // this.runTimeInfo.currentMillisecond = millisecond;
        }
    }, {
        key: 'slipToLaneBackwards',
        value: function slipToLaneBackwards(currentMillisecond, millisecond) {
            // helper.log(`participating incidents: `, participatinIncidents);
            var participatinIncidents = _filter(this.incidents, function (laneItem) {
                return laneItem.millisecond > millisecond && laneItem.millisecond <= currentMillisecond;
            });

            for (var i = participatinIncidents.length - 1; i >= 0; i--) {
                participatinIncidents[i].incident.command.backwards();
            }

            // this.runTimeInfo.currentMillisecond = millisecond;
        }

        /**
         * On this method the user defines the specific rules that apply on the plugin itself and on the Incidents of the plugin itself
         * The method should either return {result: true} or {result: false, errors:[{error-object}]}, where error-object has the structure:
         *  {
                incident: // reference to the Incident object that has bee discarded
                error: // text
            }
        * @param {array} incidents - a colleciton of all incidents to be added on the form:
        *
            {
                id
                millisecond
                incident
            }
        * @returns {object} -
        * either:
            {
                result:true,
                execute: // a function that when executed it will add the Incidents on the Channels
            }
            or
            {
                result: false,
                errors
            }
        */

    }, {
        key: 'checkAddition',
        value: function checkAddition(incidents) {
            var errors = [];
            var candidateIncidentsById = {};

            for (var i = 0; i < incidents.length; i++) {
                candidateIncidentsById[incidents[i].id] = incidents[i].incident;
                if (this.incidentsById.hasOwnProperty(incidents[i].id)) {
                    helper.error('Incident with the id ' + incidents[i].id + ' already exists. Addition is rejected.');
                    errors.push({
                        type: 'Already existing id',
                        meta: {
                            id: incidents[i].id
                        }
                    });
                }
            }

            if (errors.length > 0) {
                return {
                    result: false,
                    errors: errors
                };
            }

            var that = this;
            var exec = function exec() {
                that.incidentsById = Object.assign(that.incidentsById, candidateIncidentsById);
                that.incidents = that.incidents.concat(incidents);
                that.incidents = _sortBy(that.incidents, [function (laneItem) {
                    return laneItem.millisecond;
                }]);
                that.slipToLaneForwards(0, that.runTimeInfo.currentMillisecond);
            };

            return { result: true, execute: exec };
        }

        /**
        @param {array} incidentsArray - A collection of the Incidetns to get edited in the form:
        {
            id
            millisecond
            incident
        }
        @param {int} millisecondsDelta- the delta of the star point of the provided incidents
        */

    }, {
        key: 'checkEdit',
        value: function checkEdit(incidentsArray, millisecondsDelta) {
            var that = this;
            var exec = function exec() {
                for (var i = 0; i < incidentsArray.length; i++) {
                    for (var j = 0; j < that.incidents.length; j++) {
                        if (that.incidents[j].id === incidentsArray[i].id) {
                            that.incidents[j].millisecond += millisecondsDelta;
                            break;
                        }
                    }
                }

                that.incidents = _sortBy(that.incidents, [function (laneItem) {
                    return laneItem.millisecond;
                }]);

                that.slipToLaneForwards(0, that.runTimeInfo.currentMillisecond);
            };

            return { result: true, execute: exec };
        }
    }, {
        key: 'checkDelete',
        value: function checkDelete(incidentsArray) {
            var that = this;
            var incidentIds = [];
            for (var i = 0; i < incidentsArray.length; i++) {
                incidentIds.push(incidentsArray[i].id);
            }

            var exec = function exec() {
                var newIncidents = _filter(that.incidents, function (incident) {
                    return incidentIds.indexOf(incident.id) === -1;
                });

                that.incidents = newIncidents;
                for (var _i = 0; _i < incidentIds.length; _i++) {
                    delete that.incidentsById[incidentIds[_i]];
                }

                that.slipToLaneForwards(0, that.runTimeInfo.currentMillisecond);
            };

            return { result: true, execute: exec };
        }

        /**
        * @param {array} incidents - [{id, start, end, startDelta}]
        */

    }, {
        key: 'checkResizedIncidents',
        value: function checkResizedIncidents(incidents) {
            var that = this;
            var exec = function exec() {
                for (var i = 0; i < incidents.length; i++) {
                    for (var j = 0; j < that.incidents.length; j++) {
                        if (that.incidents[j].id === incidents[i].id) {
                            that.incidents[j].millisecond += incidents[i].startDelta;
                            break;
                        }
                    }
                }

                that.incidents = _sortBy(that.incidents, [function (laneItem) {
                    return laneItem.millisecond;
                }]);

                that.slipToLaneForwards(0, that.runTimeInfo.currentMillisecond);
            };

            return { result: true, execute: exec };
        }

        /**
         @param {int} from - the millisecond to start from
         @param {int} to - the millisecond to go to
         */

    }, {
        key: 'moveTo',
        value: function moveTo(from, to) {
            if (from < to) {
                // helper.log(`slipping to lane frowards from ${from} to ${to}`);
                this.slipToLaneForwards(from, to);
            } else if (from >= to) {
                // helper.log(`slipping to lane backwards from ${from} to ${to}`);
                this.slipToLaneBackwards(from, to);
            }
        }
    }]);

    return PIChannel;
}(Channel);

module.exports = PIChannel;