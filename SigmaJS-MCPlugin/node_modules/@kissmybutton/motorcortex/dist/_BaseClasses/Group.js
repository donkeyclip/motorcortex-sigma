'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TimedIncident = require('./TimedIncident');
var Helper = require('../_coreUtils/Helper');
var helper = new Helper();
var conf = require('../configuration/generalConf');
var pipeMessges = require('../configuration/pipesConf');
var checkTransition = require('../configuration/allowedStateChanges').checkTransition;
var _CONST = require('../configuration/_CONST');

/** @classdesc
 * A Scene is a TimeIncident that can have other Incidents (any kind of) on its timeline and its state mainly derives
 * from the state of its incidents rather than itself.
 */

var Group = function (_TimedIncident) {
    _inherits(Group, _TimedIncident);

    function Group() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var oldProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        _classCallCheck(this, Group);

        var attrsToPass = void 0,
            propsToPass = void 0;

        /*
        backwards compatibility. If the user doesn't pass a second argument on the constructor then this is 
        the new way of initialising a Group (only props).
        */
        if (oldProps === null) {
            attrsToPass = {};
            propsToPass = props;
        } else {
            // else, in case the user has passed two arguments then both should be used
            attrsToPass = props;
            propsToPass = oldProps;
        }

        var _this = _possibleConstructorReturn(this, (Group.__proto__ || Object.getPrototypeOf(Group)).call(this, attrsToPass, propsToPass));

        _this.hasIncidents = true;
        _this.isChannel = false;

        /**
          keyframes are special points on the Scene's time where Incidents should be executed
          The keys of the keyframes array are the millisecond on which the keyframes should get executed:
          e.g.:
          keyframes = {
                sec_2000: {
                    incident_id: IncidentObject,
                    incident_id: IncidentObject,
                    ...
                },
                ...
          }
          */
        _this.keyframes = {};

        /**
          An object holding the mapping incidentid / keyframekey, from which we can get the keyframe id as defined on
          the this.keyframes object where the incident belongs to
          e.g.:
          incidentsKeyframeKeys = {
                incidentid: sec_2000,
                ...
          }
           */
        _this.incidentsKeyframeKeys = {};

        /**
          The array holds the Incidents of the Scene on the format:
          {
                id // the id of the Incident object
                incident // the incident object
                millisecond // the millisecond the incident should be executed
          }
           */
        _this.incidents = [];

        /*
        an object / associative array holding all Incidents in the form:
        <incident_id>: Incident object
         */
        _this.incidentsById = {};

        _this.calculatedDuration = 0;

        /**
         * The cnannels attribute holds a list of all intantiated Channels of the Incidents belonging to the clip
         * this attribute is only valuable when the Group becomes the Clip
         * The format of the attribute is:
         *  key-value pairs in the manner:
         * <mc_plugin_npm_name>: Channel object
        */
        _this.instantiatedChannels = {};

        _this.isTheClip = false;

        _this.onGroupInitialise();
        return _this;
    }

    _createClass(Group, [{
        key: 'onGroupInitialise',
        value: function onGroupInitialise() {
            // called when group gets initialised
        }
    }, {
        key: '_getChannel',


        /*
        returns the initialised channel by the Clip the Incident belongs to
        */
        value: function _getChannel(mc_plugin_npm_name) {
            if (this.checkParentScene()) {
                return this.parentSceneObject._getChannel(mc_plugin_npm_name);
            } else {
                return null;
            }
        }

        /*
        removes all emtpy groups that belong to the group as incident
        */

    }, {
        key: 'removeEmtpyGroups',
        value: function removeEmtpyGroups() {
            var incidentsToRemove = [];
            for (var i = 0; i < this.incidents.length; i++) {
                if (this.incidents[i].incident.hasIncidents && this.incidents[i].incident.incidents.length === 0) {
                    incidentsToRemove.push(this.incidents[i].id);
                }
            }
            for (var _i = 0; _i < incidentsToRemove.length; _i++) {
                this.removeIncident(incidentsToRemove[_i]);
            }
        }

        /*
        return the direct parent of a specific Incident
        */

    }, {
        key: '_getDirectParent',
        value: function _getDirectParent(incidentId) {
            if (this.incidentsById.hasOwnProperty(incidentId)) {
                return this;
            } else {
                for (var i = 0; i < this.incidents.length; i++) {
                    if (this.incidents[i].incident.hasIncidents) {
                        var directParent = this.incidents[i].incident._getDirectParent(incidentId);
                        if (directParent != null) {
                            return directParent;
                        }
                    }
                }
            }

            return null;
        }

        /**
         * Returns all of its Incidents (not groups) in a collection of the form:
         * {
                id,
                millisecond
                incident
            }
        */

    }, {
        key: 'getIncidentsByChannel',


        /**
         * Returns an object that has the key of the npm plugin name the Channel of which manages the specific Incident
         * With the same logic all Incidents that belong to this Group as categorised by plugin / channel on the same object
        */
        value: function getIncidentsByChannel() {
            var adjustMillisecond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

            // initially it only puts itself onthe incidentsByPlugin array, exactly as the plain Incidents do
            var incidentsByPlugin = {};
            var keyToUse = this.mc_plugin_npm_name;
            if (this.bypassChannel === true) {
                keyToUse = 'motor-cortex-js';
            }
            incidentsByPlugin[keyToUse] = [{
                millisecond: adjustMillisecond,
                incident: this,
                id: this.id
            }];

            // proceed to gather the contained incidents as well
            for (var i = 0; i < this.incidents.length; i++) {
                var incidentsToAdd = this.incidents[i].incident.getIncidentsByChannel(adjustMillisecond + this.incidents[i].millisecond);
                for (var key in incidentsToAdd) {
                    if (incidentsByPlugin.hasOwnProperty(key)) {
                        incidentsByPlugin[key] = incidentsByPlugin[key].concat(incidentsToAdd[key]);
                    } else {
                        incidentsByPlugin[key] = incidentsToAdd[key];
                    }
                }
            }
            return incidentsByPlugin;
        }
    }, {
        key: 'checkStateTransition',
        value: function checkStateTransition(targetState) {
            if (checkTransition(this.runTimeInfo.state, targetState, this.direction)) {
                return true;
            }

            return false;
        }

        /**
         * This method returns the Incidents of each Incident in array format holding the incidents in the structure:
            {
                id,
                millisecond
                incident
            }
            Depending on who asks for the incidents, it might pass the adjustMillisecond argument. This argument is
            used in case a parent Group wants to receive the Incidents of its child but by passing a correction millisecond
            that represents the millisecond the Incident starts on its parent's timeline.
            @param {int} adjustMillisecond
        */

    }, {
        key: 'getProjectedIncidents',
        value: function getProjectedIncidents() {
            var adjustMillisecond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

            var projectedIncidents = [];
            for (var i = 0; i < this.incidents.length; i++) {
                var incidentsToAdd = this.incidents[i].incident.getProjectedIncidents(adjustMillisecond + this.incidents[i].millisecond);
                projectedIncidents = projectedIncidents.concat(incidentsToAdd);
            }
            return projectedIncidents;
        }

        // ******** METHODS TO CALCULATE OVERALL DURATION OF SCENE
        // *******************************************************

        /**
         * called when an Incident of the Scene gets affected by an edit or a deletion. The command targets the
         * root of the scenes tree where a recalc state and a set current millisecond should take place
         */

    }, {
        key: 'getDurationAfterIncidentAffected',
        value: function getDurationAfterIncidentAffected() {
            var durationBeforeChange = this.duration * 1;
            var currentMillisecondBeforeChange = this.runTimeInfo.currentMillisecond * 1;
            var stateBeforeChage = this.state + '';

            var newDuration = 0;
            for (var i = 0; i < this.incidents.length; i++) {
                var incident = this.incidents[i];
                if (incident.incident.duration + incident.millisecond > newDuration) {
                    newDuration = incident.incident.duration + incident.millisecond;
                }
            }
            this.duration = newDuration;
            // helper.log('duration changed on incident: ' + this.id + '. New duration: ' + newDuration);
            if (this.duration != durationBeforeChange) {
                this.broadcastEvent('duration-change', { newDuration: newDuration });
            }

            if (this.checkParentScene()) {
                this.parentSceneObject.getDurationAfterIncidentAffected();
            } else {
                // return ;
                if (this.putMessageOnPipe(pipeMessges._CLIP_EDITING_STATUS, {}, true, "up", { type: 'rootClip' }) === "normal") {
                    this.stop();
                    this.setCurrentMillisecond(currentMillisecondBeforeChange);
                    this.recalcState(currentMillisecondBeforeChange);
                    this.restore();
                }
            }
        }

        /**
         * called when an Incident gets added on the Scene
         * @param {int} startMillisecond
         * @param {int} incidentDuration
         */

    }, {
        key: 'getDurationAfterIncidentAdded',
        value: function getDurationAfterIncidentAdded(startMillisecond, incidentDuration) {
            var durationBeforeChange = this.duration * 1;
            var currentMillisecondBeforeChange = this.runTimeInfo.currentMillisecond * 1;
            // const stateBeforeRecal = this.state + "";

            if (startMillisecond + incidentDuration > this.calculatedDuration) {
                this.calculatedDuration = startMillisecond + incidentDuration;
            }

            if (this.duration != durationBeforeChange) {
                this.broadcastEvent('duration-change', { newDuration: this.duration });
            }

            if (this.checkParentScene()) {
                this.parentSceneObject.getDurationAfterIncidentAffected();
            } else {
                // return ;
                if (this.putMessageOnPipe(pipeMessges._CLIP_EDITING_STATUS, {}, true, "up", { type: 'rootClip' }) === "normal") {
                    this.stop();
                    this.setCurrentMillisecond(currentMillisecondBeforeChange);
                    this.recalcState(currentMillisecondBeforeChange);
                    this.restore();
                }
            }
        }

        // ******** INCIDENT METHODS IMPLEMENTATION **************
        // *******************************************************

    }, {
        key: 'play',
        value: function play() {
            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            if (this.isHeadlessClip) {
                return false;
            }
            _get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'play', this).call(this, props);
        }

        /** timer blocking */

    }, {
        key: 'wait',
        value: function wait() {
            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            if (_get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'wait', this).call(this, props)) {
                for (var i = 0; i < this.incidents.length; i++) {
                    if (props.callerId === this.incidents[i].id) continue;
                    this.incidents[i].incident.block(props);
                }
                return true;
            }
            return false;
        }

        /** timer blocking */

    }, {
        key: 'block',
        value: function block(props) {
            if (_get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'block', this).call(this, props)) {
                for (var i = 0; i < this.incidents.length; i++) {
                    this.incidents[i].incident.block();
                }
                return true;
            }
            return false;
        }

        /** timer unblocking */

    }, {
        key: 'resume',
        value: function resume(props) {
            if (_get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'resume', this).call(this, props)) {
                for (var i = 0; i < this.incidents.length; i++) {
                    this.incidents[i].incident.resume();
                }
                return true;
            }
            return false;
        }
    }, {
        key: 'reset',
        value: function reset(props) {
            if (_get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'reset', this).call(this, props)) {
                for (var i = 0; i < this.incidents.length; i++) {
                    this.incidents[i].incident.reset();
                }
            }
            return false;
        }
    }, {
        key: 'stop',
        value: function stop(props) {
            if (_get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'stop', this).call(this, props)) {
                for (var i = 0; i < this.incidents.length; i++) {
                    this.incidents[i].incident.stop();
                }
                return true;
            }
            return false;
        }

        /**
         * The parameter it takes is relative to the beginning of the Incident itself and it might be negative
         * Negative targetMillisecond means the target millisecond is N milliseconds BEFORE the start of the Incident
         * @param {int} targetMillisecondDeltaFromStart - the delta of the target millisecond compared to the Incident start
        */

    }, {
        key: 'recalcState',
        value: function recalcState(targetMillisecondDeltaFromStart) {
            _get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'recalcState', this).call(this, targetMillisecondDeltaFromStart);
            for (var i = 0; i < this.incidents.length; i++) {
                var incident = this.incidents[i].incident;
                var startMillisecond = this.incidents[i].millisecond;
                incident.recalcState(targetMillisecondDeltaFromStart - startMillisecond);
            }
        }
    }, {
        key: 'lastWish',
        value: function lastWish() {
            for (var i = 0; i < this.incidents.length; i++) {
                this.incidents[i].incident.lastWish();
            }
            this.stop();
        }

        // *******************************************************
        // SCENE SPECIFIC FUNCTIONS / HELPER FUNCTIONS

    }, {
        key: 'reverse',
        value: function reverse(_reverse) {
            this.reversed = _reverse;
        }
    }, {
        key: 'getIncidentMillisecond',
        value: function getIncidentMillisecond(incidentId) {
            return conf.getMillisecondFromKeyframeKey(this.incidentsKeyframeKeys[incidentId]);
        }
    }, {
        key: 'exportState',
        value: function exportState() {
            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            var incidents = [];

            for (var i = 0; i < this.incidents.length; i++) {
                if (this.incidents[i].incident.autoGenerated === true && props.unprocessed === true) {
                    continue;
                }
                var incident = {};
                incident.millisecond = this.incidents[i].millisecond;
                incident.incident = this.incidents[i].incident.exportState(props);
                incident.id = this.incidents[i].id;
                incidents.push(incident);
            }

            var state = _get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'exportState', this).call(this, props);
            state.incidents = incidents;

            return state;
        }
    }, {
        key: 'setCurrentMillisecond',
        value: function setCurrentMillisecond(millisecond) {
            // helper.log(`setting currentUser of ${this.id} to ${millisecond}`);
            this.runTimeInfo.currentMillisecond = millisecond;

            for (var i = 0; i < this.incidents.length; i++) {
                var childIncident = this.incidents[i];

                // if the child incident starts before the millisecond and has not ended yet
                if (childIncident.millisecond < millisecond && childIncident.incident.duration + childIncident.millisecond > millisecond) {
                    childIncident.incident.setCurrentMillisecond(millisecond - childIncident.millisecond);
                } else {
                    childIncident.incident.setCurrentMillisecond(0);
                }
            }
        }

        /**
         * Returns the Incident by ID no matter if the Incident balongs directly to the Scene of to a child Scene
         * @param {string} id - the id of the Incident to get
        */

    }, {
        key: 'getIncidentById',
        value: function getIncidentById(id) {
            if (this.incidentsById.hasOwnProperty(id)) {
                return this.incidentsById[id];
            } else {
                for (var i = 0; i < this.incidents.length; i++) {
                    if (this.incidents[i].incident.hasIncidents) {
                        var incident = this.incidents[i].incident.getIncidentById(id);
                        if (incident != null) {
                            return incident;
                        }
                    }
                }
            }

            return null;
        }

        // *******************************************************
        // INCIDENTS MANAGEMENT METHODS
        // POLYMORPHISM APPLIED. IF THE GROUP HAS NO PARENT IT ACTS AS A SCENE. IF THE GROUP HAS PARENT IT ACTS AS
        // A "TRANSPARENT GROUP"

        /**
         * The checkAddition method serves exactly what its name implies. To check if the addition of an Incident
         * is valid and accepted, according to the rules defined on the channels.
         * The method boobles up until it reaches the Clip by carrying adjusting the millisecond.
         * The method takes as input the management type. On error / conflict:
         *  - on type === 'all-or-nothing' completely discard addition of all incidents
         *  - on type === 'keep-passing' it will only add the passing incidents no matter if some other incidents of the addition failed
         * @param {object} incident - the incident to add
         * @param {int} millisecond - the millisecond to add the Incident to
         * @param {string} type - as explained above
         * The method returns either:
            {
                result:true,
                execute: // an array of functions that when executed it will add the Incidents on the Channels
            }
            or
            {
                result: false,
                errors
            }
        */

    }, {
        key: 'checkAddition',
        value: function checkAddition(incident, millisecond) {
            var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "all-or-nothing";

            if (this.isHeadlessClip) {
                return { result: true, execute: function execute() {} };
            } else {
                // IF THE GROUP HAS NO PARENT (ACT AS THE CLIP)
                return this.parentSceneObject.checkAddition(incident, millisecond + this.parentSceneObject.getIncidentMillisecond(this.id), type);
            }
        }

        /**
         * The checkEdit method serves exactly what its name implies. To check if the edit of an Incident (edit of Incident's position given in milliseconds delta)
         * is valid and accepted, according to the rules defined on the channels.
         * The method boobles up until it reaches the Clip.
         * @param {object} incident - the incident to edit
         * @param {int} millisecondsDelta - the milliseconds delta of the Incident's start time
         The method should return either:
            {
                result:true,
                execute: // an array of functions that when executed it will edit the Incidents on the Channels
            }
            or
            {
                result: false,
                errors
            }
        */

    }, {
        key: 'checkEdit',
        value: function checkEdit(incident, millisecondsDelta) {
            if (this.isHeadlessClip) {
                return { result: true, execute: function execute() {} };
            } else {
                // IF THE GROUP HAS NO PARENT (ACT AS THE CLIP)
                return this.parentSceneObject.checkEdit(incident, millisecondsDelta);
            }
        }

        /**
         * The checkDelete method serves exactly what its name implies. To check if the deletion of an Incident
         * is valid and accepted, according to the rules defined on the channels.
         * The method boobles up until it reaches the Clip.
         * @param {object} incident - the incident to edit
         * @param {object} props - if passed it supports the preventSlip key which if false the channel should not slip. This case is for 
            flashDOM of DOMAwareIncidents where we have elements deleted so slipping on their lanes is not valid nor necessary
          The result might be either:
            {
                result:true,
                execute: // an array of functions that when executed it will remove the Incident on the Channels
            }
            or
            {
                result: false,
                errors
            }
        */

    }, {
        key: 'checkDelete',
        value: function checkDelete(incidentId) {
            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            if (this.isHeadlessClip) {
                return { result: true, execute: function execute() {} };
            } else {
                // IF THE GROUP HAS NO PARENT (ACT AS THE CLIP)
                return this.parentSceneObject.checkDelete(incidentId, props);
            }
        }

        /**
         * It's called always by a child to Scene that wants to expand to the left to its parent.
         * Expanding a Scene to the left means it tries to add extra (initially unsued) space (in milliseconds) before its
         * current starting point.
         * In order for this action to be allowed the Scene's context should allow such an expansion. This means:
         *  - that if the Scene has no parents this expansion is not legal
         *  - that if the root Scene of the Scene's parents tree needs to expand on the left in order to apply the expansion
         *      then the expansion is not acceptable
         * @param {int} howManyMilliseconds - the milliseconds to expand the Scene to the left
         * @param {string} sceneId - the child scene id that wants to gain extra space to the left
         * @returns {object} - the result is an object with two keys:
         *  - the first key is the "result" which might either be true or false
         *  - the second key is the "undo" which is a function that can undo the (approved) expansion
        */

    }, {
        key: 'expandSceneToTheLeft',
        value: function expandSceneToTheLeft(howManyMilliseconds, sceneId) {
            var _this2 = this;

            // First we identify the expansion within the context of the parent (this) Scene
            var currentStartMillisecondOfTheChildScene = this.getIncidentMillisecond(sceneId);
            var newStartMillisecondOfTheChildScene = howManyMilliseconds - currentStartMillisecondOfTheChildScene;

            // Check if the expansion is allowed
            // if the millisecons to expand are zero or less (meaning the current Scene is actually not affected by the expansion)
            if (newStartMillisecondOfTheChildScene <= 0) {
                var rootScene = this;
                var changeResult = this.changeIncidentsStartMillisecond(-newStartMillisecondOfTheChildScene, sceneId);
                var undo = function undo() {
                    _this2.changeIncidentsStartMillisecond(changeResult.oldMillisecond, sceneId);
                };
                return {
                    result: true,
                    undo: undo,
                    rootScene: rootScene
                };
            }

            // if it reaches to that point that means the expansion afects the left borders of this (parent) Scene as well
            // If it doesn't have a parent scene that means the expansion is illegal
            if (!this.checkParentScene()) {
                return {
                    result: false
                };
            }

            // if it has a parent scene and the this Scene needs to expand to the left as well then this Scene
            // assigns the obligation to evaluate the expansion to its parent
            var parentDecision = this.parentSceneObject.expandSceneToTheLeft(newStartMillisecondOfTheChildScene, this.id);
            // if the parent approves the expansion
            if (parentDecision.result === true) {
                // TODO apply the expansion itself and bundle its undo along with the undo coming from the parent
                this.expandStartPoint(-newStartMillisecondOfTheChildScene);
                var overallUndo = function overallUndo() {
                    parentDecision.undo();
                    _this2.expandStartPoint(newStartMillisecondOfTheChildScene);
                };
                return {
                    result: true,
                    undo: overallUndo,
                    rootScene: parentDecision.rootScene
                };
            } else {
                // otherwise
                return {
                    result: false
                };
            }
        }

        /**
         * expands or collapses the Scene's start millisecond by the given milliseconds
         * e.g. expandStartPoint(200) will expand the Scene by 200 milliseconds to the left keeping all
         *      of its incidents to the exact same place they were before on the overall timeline
         * e.g. expandStartPoint(-200) will collapse the Scene, moving its start point by 200 milliseconds
         *      to the right, again without affecting at all its Incidents' start point on the overall timeline
         * @param {int} byMilliseconds - the number of milliseconds to expand (positive number) or collapse (minus number) number of milliseconds
        */

    }, {
        key: 'expandStartPoint',
        value: function expandStartPoint(byMilliseconds) {
            for (var i = 0; i < this.incidents.length; i++) {
                var incident = this.incidents[i];
                this.changeIncidentsStartMillisecond(incident.millisecond + byMilliseconds, incident.id);
            }
        }

        /**
         * it alters the start millisecond of any already existing Incident of the Scene
         * @param {int} newmillisecond - the new millisecond to place the Incident
         * @param {string} incidentId - the incident id
         * @returns {function} - the undo function of the change
        */

    }, {
        key: 'changeIncidentsStartMillisecond',
        value: function changeIncidentsStartMillisecond(newmillisecond, id) {
            var keyframe_sec_key = this.incidentsKeyframeKeys[id];
            //OPTIMIZE delete is slow on v8 engine we should check if we can achieve the same result by setting the value of the key to undefined
            delete this.keyframes[keyframe_sec_key][id];

            if (Object.keys(this.keyframes[keyframe_sec_key]).length === 0) {
                delete this.keyframes[keyframe_sec_key];
            }

            delete this.listeners[id]; // delete the listener that currently manages the Incident's execution


            var oldMillisecond = void 0; // the previous millisecond of the edited incident before the edit
            for (var i = 0; i < this.incidents.length; i++) {
                if (this.incidents[i].id === id) {
                    oldMillisecond = this.incidents[i].millisecond * 1; // *1 to avoid reference, keep value
                    this.incidents[i].millisecond = newmillisecond;
                    break;
                }
            }

            var incident = this.incidentsById[id];
            var new_keyframe_sec_key = conf.keyframe_sec_key + newmillisecond;
            if (!this.keyframes.hasOwnProperty(new_keyframe_sec_key)) {
                this.keyframes[new_keyframe_sec_key] = {};
            }
            this.keyframes[new_keyframe_sec_key][incident.id] = incident;
            this.incidentsKeyframeKeys[incident.id] = new_keyframe_sec_key;

            // subscribe Incident start on the listeners
            var funct = function funct(sceneMillisecond, previousTimeStamp, sceneState) {
                if (sceneMillisecond >= newmillisecond && sceneMillisecond <= newmillisecond + incident.duration) {
                    incident.play({ startFrom: sceneMillisecond - newmillisecond, previousTimeStamp: previousTimeStamp });
                }
            };

            this.subscribe(incident.id, funct);

            return {
                oldMillisecond: oldMillisecond,
                incident: incident
            };
        }

        /**
         * Plain groups
            Can have on their timeline:
            - Another plain group
            - An incident with no selector
            - A dom group (this method should actually turn any incident with selector to one)
            Can’t have on their timeline:
            - An attribute group
         */

    }, {
        key: '_prepareInicdentForAddition',
        value: function _prepareInicdentForAddition(incident) {
            if (!incident.props.hasOwnProperty('selector') && !incident.hasIncidents) {
                // if the incident is not a group and it has no selector proceed normally
                return incident;
            } else if (incident.groupType === "plain") {
                // if the Incident is a plain group proceed normally
                return incident;
            } else if (incident.groupType === "attribute") {
                helper.error("Plain groups can not accept attribute groups on their timeline");
                return null;
            }

            // We need to turn the Incident to a DOMAwareIncident
            // before adding it to the group
            var DOMAwareIncident = require('../_responsiveness/DOMAwareIncident');
            var theDOMAwareIncident = new DOMAwareIncident(incident);
            return theDOMAwareIncident;
        }
    }, {
        key: 'flashDOM',
        value: function flashDOM() {
            var result = {
                failedAdditions: []
            };
            for (var i = 0; i < this.incidents.length; i++) {
                var flashResult = this.incidents[i].incident.flashDOM();
                result.failedAdditions = result.failedAdditions.concat(flashResult.failedAdditions);
            }
            return result;
        }
    }, {
        key: 'addPassiveIncident',
        value: function addPassiveIncident(incident, millisecond, sceneId) {
            var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "all-or-nothing";

            return this.addIncident(incident, millisecond, sceneId, type, true);
        }

        /**
        Any Scene can receive the addIncdent command either for adding an Incident on its own Incidents list or in order
        to pass deeper the command to the parent Scene of the Incident (sceneId).
        No matter which Scene took the command, all parent Scenes get informed
         addIncident takes 3 arguments:
        @param {Incident} incident - the Incident object to get added
        @param {int} millisecond - the millisecond to which we want the Incident to get added, starting from the zero point of the
            target Scene. It can't be negative. Millisecond can also take the string value "end" which means the new Incident should be added at the end of the Group
        @param {string} sceneId - the sceneId to which we want to put the new Incident. It is optional and if it is not specified the
            target Scene is the current one
        @param {string} type - one of "all-or-nothing" / "keep-passing"
        @param {boolean} autoGenerated - if set to true, it means the Incident was auto generated by another incident and it should not export itself on exportState with unprocessed = true
         */

    }, {
        key: 'addIncident',
        value: function addIncident(incident, millisecond, sceneId) {
            var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "all-or-nothing";
            var autoGenerated = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

            if (millisecond < 0) {
                return {
                    result: false,
                    conflicts: [{
                        type: 'minus millisecond violation'
                    }]
                };
            }

            if (millisecond === _CONST.atTheEndOfTheGroup.value) {
                millisecond = this.duration;
            }

            var originalMillisecond = millisecond * 1; // a backup variable holding the original millisecond passed as
            // this might change during potential left expansion manipulation

            if (!sceneId || sceneId === this.id) {
                var that = this;
                incident = this._prepareInicdentForAddition(incident);
                if (autoGenerated === true) {
                    incident.autoGenerated = true;
                }

                // when adding headless Clips to a group that has context (either because it's the clip itself or because
                // it belongs to a clip that has context) we need to run flash the newly entered group's dom so it creates
                // its elementIncidents
                var flashIncidentsDOMAfterEnter = false;

                if (incident.hasIncidents && incident.isHeadlessClip && this.context != null) {
                    flashIncidentsDOMAfterEnter = true;
                }

                incident.setParentScene(that);

                // check if the Incident is eligible for addition
                var additionCheck = this.checkAddition(incident, millisecond, type);
                if (additionCheck.result === false) {
                    return additionCheck;
                }
                additionCheck.execute();

                // indexing start
                this.incidents.push({
                    id: incident.id,
                    incident: incident,
                    millisecond: millisecond
                });
                this.incidentsById[incident.id] = incident;
                var keyframe_sec_key = conf.keyframe_sec_key + millisecond;
                if (!this.keyframes.hasOwnProperty(keyframe_sec_key)) {
                    this.keyframes[keyframe_sec_key] = {};
                }
                this.keyframes[keyframe_sec_key][incident.id] = incident;
                this.incidentsKeyframeKeys[incident.id] = keyframe_sec_key;
                // indexing end

                incident.executionSpeed = this.speed;

                // subscribe Incident start on the listeners
                // currentMillisecond: the millisecond the Group is on
                // millisecond: the millisecond we set our Incident to get executed on the Group's timeline
                var funct = function funct(currentMillisecond, previousTimeStamp, sceneState) {
                    if (incident.speed > 0) {
                        if (currentMillisecond >= millisecond && currentMillisecond <= millisecond + incident.duration || incident.state === 'idle' && currentMillisecond > millisecond) {
                            // helper.log('greater');
                            incident.play({ startFrom: currentMillisecond - millisecond, previousTimeStamp: previousTimeStamp });
                        }
                    } else {
                        if (currentMillisecond >= millisecond && currentMillisecond <= millisecond + incident.duration || incident.state === 'completed' && currentMillisecond < millisecond) {
                            // helper.log('greater');
                            incident.play({ startFrom: currentMillisecond - millisecond, previousTimeStamp: previousTimeStamp });
                        }
                    }
                };

                this.subscribe(incident.id, funct);
                this.getDurationAfterIncidentAdded(millisecond, incident.duration);

                if (flashIncidentsDOMAfterEnter) {
                    var result = incident.flashDOM();
                    if (result.failedAdditions.length > 0 && type === "all-or-nothing") {
                        this.removeIncident(incident.id);
                        incident.parentSceneObject = null;
                        return {
                            result: false,
                            conflicts: result.failedAdditions
                        };
                    } else {
                        // if flashing incident's DOM passes let the Incident know that
                        // it now has context
                        incident._onGetContextOnce();
                        this.onAddIncident(incident, millisecond);
                        this.recalcState(this.runTimeInfo.currentMillisecond);
                        if (result.failedAdditions.length > 0 && type === 'keep-passing') {
                            incident.removeEmtpyGroups();
                        }
                        helper.notice('incident added');

                        return {
                            result: true,
                            meta: {
                                conflicts: result.failedAdditions
                            }
                        };
                    }
                } else {
                    if (this.context != null) {
                        incident._onGetContextOnce();
                    }
                    this.onAddIncident(incident, millisecond);
                    helper.notice('incident added');
                    return {
                        result: true,
                        meta: {
                            incidentId: incident.id
                        }
                    };
                }
            } else {
                for (var i = 0; i < this.incidents.length; i++) {
                    if (this.incidents[i].incident.hasIncidents) {
                        if (this.incidents[i].incident.addIncident(incident, millisecond - this.incidents[i].millisecond, sceneId).result === true) {
                            return {
                                result: true,
                                meta: {
                                    incidentId: incident.id
                                }
                            };
                        }
                    }
                } // if it reaches the end of the loop without having returned true
                return { result: false };
            }
        }

        /**
        Any Scene can receive the editIncident command in order to set a new starting point for one of its own Incidents or to
        pass the command deeper down to its children Scenes so the parent of it can take care of it.
        The Incident object and id remain the same after the edit.
        No matter which Scene takes the command, all Parents get infomed about the edit.
         It takes two params:
         @param {string} id - the id of the incident to be edited
         @param {int} newmillisecond - the new position of the Incident compared to the target Scene start (and not to the Scene it belongs)
         */

    }, {
        key: 'editIncident',
        value: function editIncident(id, newmillisecond) {
            var expansionValidation = null;
            var originalMillisecond = newmillisecond * 1;

            if (!helper.isString(id)) {
                helper.error('editIncident method of Group expects as its first argument the id of the Incident to edit in string format. ' + (typeof id === 'undefined' ? 'undefined' : _typeof(id)) + ' passed');
                return {
                    result: false,
                    conflicts: [{
                        type: 'wrong parameter type'
                    }]
                };
            }

            if (this.incidentsById[id]) {
                var existingMillisecond = this.getIncidentMillisecond(id);
                var millisecondDelta = newmillisecond - existingMillisecond;
                // first check for minus expansion
                if (newmillisecond < 0) {
                    // if the Scene doesn't have a parent then it is the root and thus it can't expand to the left
                    if (!this.checkParentScene()) {
                        return {
                            result: false,
                            conflicts: [{
                                type: 'minus millisecond violation'
                            }]
                        };
                    }

                    expansionValidation = this.parentSceneObject.expandSceneToTheLeft(-newmillisecond, this.id);
                    if (expansionValidation.result === false) {
                        return {
                            result: false,
                            conflicts: [{
                                type: 'minus millisecond violation'
                            }]
                        };
                    } else {
                        newmillisecond = 0;
                    }
                } // end of if millisecond < 0

                // if the edit is allowed (thus we come to that point) and the originalMillisecond is lower than 0
                if (originalMillisecond < 0) {
                    this.expandStartPoint(-originalMillisecond);
                }

                this.incidentsById[id].stop();

                var editCheck = this.checkEdit(this.incidentsById[id], millisecondDelta);
                if (editCheck.result === false) {
                    helper.error(editCheck);
                    if (expansionValidation !== null) {
                        expansionValidation.undo();
                        this.expandStartPoint(originalMillisecond);
                    }
                    return editCheck;
                }

                editCheck.execute();

                var editIncidentStartResult = this.changeIncidentsStartMillisecond(newmillisecond, id);

                this.getDurationAfterIncidentAffected();

                this.onEditIncident(this.incidentsById[id], editIncidentStartResult.oldMillisecond, newmillisecond);

                return { result: true };
            } else {
                for (var i = 0; i < this.incidents.length; i++) {
                    if (this.incidents[i].incident.hasIncidents) {
                        var result = this.incidents[i].incident.editIncident(id, newmillisecond - this.incidents[i].millisecond);
                        if (result.result === true) {
                            return { result: true };
                        } else if (result.hasOwnProperty('errors')) {
                            // if the result.result is false but it contains no errors that means the Incident we're looking for just not belong to 
                            // to the Group we are iterating in. Though if result.result==false && result.hasOwnProperty('errors') that means the 
                            // Incident has been found but editing it results to errors.
                            return result;
                        }
                    }
                } // if it reaches the end of the loop without having returned true
                return { result: false };
            }
        }

        /**
        Any Scene can receive the removeIncident command either for removing one of its own Incidents or for passing the command
        deeper down to its Scenes tree and have the Incident deleted no matter to which child Scene it belongs
        No matter which Scene took the command, all parent Scenes get informed
         It takes just one argument:
        @param {string} id - the id of the Incident to be deleted
        @param {object} props - if passed it supports the preventSlip key which if false the channel should not slip. This case is for 
            flashDOM of DOMAwareIncidents where we have elements deleted so slipping on their lanes is not valid nor necessary
         */

    }, {
        key: 'removeIncident',
        value: function removeIncident(id) {
            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            if (this.incidentsById[id]) {
                var deleteCheck = this.checkDelete(id, props);
                if (deleteCheck.result === false) {
                    helper.error(deleteCheck);
                    return deleteCheck;
                }

                deleteCheck.execute();

                this.incidentsById[id].lastWish();
                this.incidentsById[id].parentSceneObject = null;

                var keyframe_sec_key = this.incidentsKeyframeKeys[id];
                //OPTIMIZE delete is slow on v8 engine we should check if we can achieve the same result by setting the value of the key to undefined
                delete this.incidentsKeyframeKeys[id];
                delete this.keyframes[keyframe_sec_key][id];
                delete this.incidentsById[id];
                if (Object.keys(this.keyframes[keyframe_sec_key]).length === 0) {
                    delete this.keyframes[keyframe_sec_key];
                }
                delete this.listeners[id]; // delete the listener that manages the Incident's execution

                var deletedIncident = void 0;
                for (var i = 0; i < this.incidents.length; i++) {
                    if (this.incidents[i].id === id) {
                        deletedIncident = this.incidents.splice(i, 1);
                        break;
                    }
                }

                this.getDurationAfterIncidentAffected();
                this.onRemoveIncident(deletedIncident[0]);

                return { result: true };
            } else {
                for (var _i2 = 0; _i2 < this.incidents.length; _i2++) {
                    if (this.incidents[_i2].incident.hasIncidents) {
                        if (this.incidents[_i2].incident.removeIncident(id).result === true) {
                            return { result: true };
                        }
                    }
                } // if it reaches the end of the loop without having returned true
                return { result: false };
            }
        }

        /**
         * This method which is provided only by Groups accepts an incidentId and a new duration and 
         * edits the duration of the corresponding incident accordingly
         * @param {string} incidentId - the id of the incident to resize
         * @param {int} newDuration - the new duration of the incident in milliseconds
        */

    }, {
        key: 'resizeIncident',
        value: function resizeIncident(incidentId, newDuration) {
            var existingIncident = this.getIncidentById(incidentId);
            if (existingIncident === null) {
                return { result: false, errors: [{ reason: 'The incident with id ' + incidentId + ' does not belong to the Group or any of its child Groups' }] };
            }
            return existingIncident.resize(newDuration);
        }

        /**
         * This method which is provided only by Groups accepts an incidentId and a new attrs object 
         * and edits the attributes of the corresponding incident accordingly
         * If the attribute editing ends up with conflicts the edit is discarded.
         * @param {string} incidentId - the id of the incident to resize
         * @param {int} attrs - the new attrs of the Incident
        */

    }, {
        key: 'editIncidentAttributes',
        value: function editIncidentAttributes(incidentId, attrs) {
            var directParent = this._getDirectParent(incidentId);
            if (directParent === null) {
                return {
                    result: false,
                    errors: ['The Incident with id ' + incidentId + ' does not belong to the Group or any of its child Groups']
                };
            }
            return directParent._editChildIncidentAttributes(incidentId, attrs);
        }

        /**
         * By this method a Group tries to edit the attributes of one of its children. The process goes as follows:
         * 1. The Group gets an export of the Incident's state
         * 2. The Group deletes the Incident
         * 3. The Group tries to create a new Incident with the same id as the old one and with type="all-or-nothing"
         * 4.a. If the new Incident gets added ok process finishes
         * 4.b. If the new Incident doesn't get added because of conflicts the previous Incident gets back in
         * @param {string} incidentId - the id of the Incident to edit its attrs
         * @param {object} attrs - the new attributes of the Incident
        */

    }, {
        key: '_editChildIncidentAttributes',
        value: function _editChildIncidentAttributes(incidentId, attrs) {
            var incidentToEdit = this.getIncidentById(incidentId);
            var existingIncidentDefinition = incidentToEdit.exportState();
            var millisecond = this.getIncidentMillisecond(incidentId);
            this.removeIncident(incidentId);
            var newIncidentProps = Object.assign({}, existingIncidentDefinition.props);
            var newIncident = new existingIncidentDefinition.Incident(attrs, newIncidentProps);
            var result = this.addIncident(newIncident, millisecond);
            if (result.result === false) {
                var myOldIncident = new existingIncidentDefinition.Incident(existingIncidentDefinition.attrs, newIncidentProps);
                this.addIncident(myOldIncident, millisecond);
                return result;
            } else {
                return {
                    result: true
                };
            }
        }

        /**
         * Starting from itself and going all the way down to each and every leaf of its tree it systols/diastoles the
         * Incidents
         * @param {float} durationFraction the fraction of the new duration to the existing duration
        **/

    }, {
        key: 'systolDiastole',
        value: function systolDiastole(durationFraction) {
            this.calculatedDuration = durationFraction * this.duration;
            for (var i = 0; i < this.incidents.length; i++) {
                this.changeIncidentsStartMillisecond(this.incidents[i].millisecond * durationFraction, this.incidents[i].incident.id);
                this.incidents[i].incident.systolDiastole(durationFraction);
            }
        }

        // THE "EARS" OF THE SCENE TO ITS CHILD INCIDENTS
        /**
              NEW STATE CALCULATION RULES:
              If a Scene has at least one clipBlockingWaiting (meaning the full Clip is halted at the moment) the Scene’s state will be “clipBlockingWaiting” unless it is the Clip so its state will be “waiting”.
              If a Scene has all children on the completed state, the Scene has the completed state as well.
              If a Scene has at least one of its children on one of the following states:
                    waiting     it has started playing and has been halted internally
                    playing     it has started playing
                    idle            it has not been executed yet
              the Scene is on playing state
               */

    }, {
        key: 'incidentStateChange',
        value: function incidentStateChange(id, oldState, newState, props) {
            if (newState === 'clipBlockingWaiting' || newState === 'sceneBlockingWaiting') {
                var propsToPass = props;
                propsToPass.callerId = id;
                if (newState === 'sceneBlockingWaiting') {
                    // stop propagation as this should only affect the Scene and not its parents
                    props.waitingStateName = 'waiting';
                }
                this.wait(propsToPass);
            } else if (newState === 'completed' && this.speed > 0) {
                // helper.log('Incident ' + id + ' got into completed state');
                // helper.log('Incident ' + this.id + ' takes care of it');
                var allCompleted = true;
                // helper.log('going to iterate on all Incidents');
                for (var i = 0; i < this.incidents.length; i++) {
                    // helper.log(
                    //     this.incidents[i].incident.id + '.state = ' + this.incidents[i].incident.state
                    // );
                    if (this.incidents[i].incident.state != 'completed') {
                        allCompleted = false;
                        break;
                    }
                }
                if (allCompleted) {
                    this.complete();
                }
            } else if (newState === 'idle' && this.speed < 0) {
                // helper.log('Incident ' + id + ' got into completed state');
                // helper.log('Incident ' + this.id + ' takes care of it');
                var _allCompleted = true;
                // helper.log('going to iterate on all Incidents');
                for (var _i3 = 0; _i3 < this.incidents.length; _i3++) {
                    // helper.log(
                    //     this.incidents[i].incident.id + '.state = ' + this.incidents[i].incident.state
                    // );
                    if (this.incidents[_i3].incident.state != 'idle') {
                        _allCompleted = false;
                        break;
                    }
                }
                if (_allCompleted) {
                    this.complete();
                }
            } else {
                // in case the child was either on sceneBlockingWaiting or clipBlockingWaiting and now is changing
                this.resume();
            }
        }

        /**
         * it checks if a block with the provided props exists on its blockingWaitings array
         * if it exists it removes it.
         * If the remaining blocking waitings are equal to 0 it returns true otherwise it returns false
        */

    }, {
        key: 'removeBlock',
        value: function removeBlock(props) {
            var newBlockingWaitings = [];
            var found = false;
            for (var i = 0; i < this.blockingWaitings.length; i++) {
                var bWaiting = this.blockingWaitings[i];
                if (bWaiting.id === props.id) {
                    found = true;
                    continue;
                }
                newBlockingWaitings.push(this.blockingWaitings[i]);
            }

            this.blockingWaitings = newBlockingWaitings;
            return found;
        }

        /**
         * goTo method should always be handled by the Clip. No other Group nor Incident can handle goTo alone.
         * Thus, if the Group is not the Clip it passes the command up. If the Group is the Clip then it handles goTo
         * by passing the command to its Channels.
        **/

    }, {
        key: 'goTo',
        value: function goTo(millisecond) {
            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            // first decide the millisecond we want to goTo
            if (millisecond === null || millisecond === undefined) {
                millisecond = this.runTimeInfo.currentMillisecond;
            }
            if (props.hasOwnProperty('relativeTo')) {
                millisecond += this.getIncidentMillisecond(props.relativeTo);
            }

            if (millisecond > this.duration) {
                millisecond = this.duration;
            } else if (millisecond < 0) {
                millisecond = 0;
            }

            if (this.isHeadlessClip) {
                return false;
            } else {
                props.relativeTo = this.id;
                if (this.parentSceneObject.goTo(millisecond, props)) {
                    return true;
                }
            }
        }

        /**
         * when the Group is on test mode (this.isOnTestMode = true) the emulateStep method
         * becomes functional.
         * The method takes as input the millisecondsDelta from the previous timestamp and triggers
         * the step function passing in a baked timestamp so the Incident behaves exactly as if the requestAnimationFrame run
         * passing a timestamp that has exactly millisecondsDelta difference from the previous one
         * @param {int} millisecondsDelta - the milliseconds difference between the previous timestamp and the new one
        */

    }, {
        key: 'emulateStep',
        value: function emulateStep(millisecondsDelta) {
            if (!this.isOnTestMode) {
                helper.error('emulateStep method can only be used on test mode');
            } else {
                this.step(this.runTimeInfo.previousTimeStamp + millisecondsDelta);
                for (var i = 0; i < this.incidents.length; i++) {
                    var childIncident = this.incidents[i];

                    if (childIncident.incident.state === "playing") {
                        childIncident.incident.emulateStep(Math.abs((this.runTimeInfo.currentMillisecond - childIncident.millisecond - childIncident.incident.runTimeInfo.currentMillisecond) / this.speed));
                    }
                }
            }
        }

        // *******************************************************
        // STEP FUNCTION

    }, {
        key: 'step',
        value: function step(timestamp) {
            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

            var that = this;

            // start from is the number of milliseconds elapsed from the actual starting point of the Incident caused mainly
            // by CPU performance. (each requestAnimationFrame cirlce doesn't happen every one millisecond
            // so an Incident that was supposed to start on millisecond 100 of a Group might get fired 10 milliseconds later than
            // its actual starting point, so tth startFrom will be 10)
            if (props != null) {
                var startFrom = props.startFrom;
                if (!props.hasOwnProperty('startFrom')) {
                    if (this.direction === "forwards") {
                        startFrom = 0;
                    } else {
                        startFrom = this.duration;
                    }
                }

                if (this.speed > 0) {
                    this.runTimeInfo.previousTimeStamp = timestamp - startFrom / this.speed;
                } else {
                    this.runTimeInfo.previousTimeStamp = timestamp - (this.duration - startFrom) / Math.abs(this.speed);
                }
            }

            var informListeners = function informListeners(progress) {
                for (var key in that.listeners) {
                    var listner = that.listeners[key];
                    if (Math.abs(progress.milliseconds + listner.cavaDelta - that.runTimeInfo.currentMillisecond) > listner.threshold) {
                        listner.funct(progress.milliseconds, timestamp, helper.roundNumberTo(listner.roundTo));
                        listner.cavaDelta = 0;
                    } else {
                        listner.cavaDelta += Math.abs(progress.milliseconds - that.runTimeInfo.currentMillisecond);
                    }
                }
            };

            // helper.log('got into step on ' + this.id);
            if (this.runTimeInfo.state !== 'playing') {
                return;
            }

            // progressStep is the progress made from previousTimeStamp both in milliseconds and in fraction [0 to 1]
            var progress = {
                milliseconds: Math.round(this.runTimeInfo.currentMillisecond + (timestamp - this.runTimeInfo.previousTimeStamp) * this.speed),
                fraction: (this.runTimeInfo.currentMillisecond + (timestamp - this.runTimeInfo.previousTimeStamp) * this.speed) / this.duration
            };
            // helper.notice(`calculation properties of progress for ${this.id}`);
            // helper.log(`this.runTimeInfo.currentMillisecond: ${this.runTimeInfo.currentMillisecond}, timestamp: ${timestamp}, this.runTimeInfo.previousTimeStamp: ${this.runTimeInfo.previousTimeStamp}`)

            // helper.log(this.id, progress);

            if (progress.fraction < 0) {
                this.onProgress(0, 0);
                informListeners({ fraction: 0, milliseconds: 0 });
                this._dontTellMamaStateChange('idle');
                this.broadcastEvent('state-change', { oldState: "playing", newState: "idle" });
                this.resetState();
                return;
            }

            this.onProgress(progress.fraction, progress.milliseconds);

            // helper.log(this.id);
            // helper.log(this.runTimeInfo.currentMillisecond);
            // helper.log(this.id + ' progress: ', progress);
            // handle listeners
            informListeners(progress);

            this.runTimeInfo.currentMillisecond = progress.milliseconds;
            this.runTimeInfo.previousTimeStamp = timestamp;

            // helper.log(this.runTimeInfo.currentMillisecond);

            // helper.log('this.runtimeInfo.state on ' + this.id + ' = ' + this.runTimeInfo.state);
            this.requestAnimaFrame(that.step.bind(that));
        }

        /**
         * The Scene receives this command from its chilren and the purpose of it is to help the caller
         * identify the milliseconds delta of its start compared to the root Scene of it.
         * In a multi-level situation with Scenes within scenes the Scene that receives this command might not own
         * the Incident that triggered this thread directly. That's why we use the extraDelta helping parameter that
         * actually delivers level by level the delta of the triggering Incident within the tree
         * @param {string} incidentId = the id of the child incident of the scene that trigerred the method
         * @param {int} extraDelta - the extra delta to add to the result
        **/

    }, {
        key: 'getRootCurrentMillisecondDeltaFromIncidentsStart',
        value: function getRootCurrentMillisecondDeltaFromIncidentsStart(incidentId) {
            var extraDelta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

            // first step find the start millisecond of the incident
            var incidentMillisecond = this.getIncidentMillisecond(incidentId);
            if (!this.checkParentScene()) {
                return this.runTimeInfo.currentMillisecond - incidentMillisecond - extraDelta;
            } else {
                return this.parentSceneObject.getRootCurrentMillisecondDeltaFromIncidentsStart(this.id, incidentMillisecond + extraDelta);
            }
        }

        /*
        CALLBACKS AFTER SUCCESSFUL ADDING / EDITING / DELETING AN INCIDENT
         */

    }, {
        key: 'onAddIncident',
        value: function onAddIncident(incident, millisecond) {}
    }, {
        key: 'onEditIncident',
        value: function onEditIncident(incident, oldMillisecond, newMillisecond) {}
    }, {
        key: 'onRemoveIncident',
        value: function onRemoveIncident(incident) {}

        // on Groups there is no need to prevent re-invoking the onGetContext method

    }, {
        key: '_onGetContextOnce',
        value: function _onGetContextOnce() {
            this.onGetContext();
            for (var i = 0; i < this.incidents.length; i++) {
                this.incidents[i].incident._onGetContextOnce();
            }
        }
    }, {
        key: 'duration',
        get: function get() {
            return this.calculatedDuration;
        },
        set: function set(duration) {
            this.calculatedDuration = duration;
        }
    }, {
        key: 'groupType',
        get: function get() {
            return "plain";
        }
    }, {
        key: 'projectedIncidents',
        get: function get() {
            return this.getProjectedIncidents();
        }
    }, {
        key: 'executionSpeed',
        set: function set(speed) {
            helper.notice(this.id + ' is setting its execution speed to: ' + speed + ' while on millisecond: ' + this.runTimeInfo.currentMillisecond);
            if (speed === 0) {
                helper.error("Speed can't be 0");
                return false;
            }

            this.speed = speed;
            this.onSpeedChange(speed);
            for (var i = 0; i < this.incidents.length; i++) {
                this.incidents[i].incident.executionSpeed = speed;
            }
        }
    }]);

    return Group;
}(TimedIncident);

module.exports = Group;