'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Helper = require('../_coreUtils/Helper');
var checkTransition = require('../configuration/allowedStateChanges').checkTransition;
var helper = new Helper();
var Channel = require('../_Channels/Channel');
var pipeMessges = require('../configuration/pipesConf');
var generalConf = require('../configuration/generalConf');

/** @classdesc
 * Incidents are all events that should happen on a specific time on the timeline. An incident can have parametric
      execution behaviour based on the times it has been executed and (might be) on other parameters.

      The state an Incident can have is one of the following:
                 idle
                 playing
                 waiting
                 sceneBlockingWaiting
                 clipBlockingWaiting
                 blocked    // in the case the Incident is blocked / paused by a waiting
                 completed

      Each Incident has the obligation to inform the Scene about its state changes.
      For this Incident provides the method “setParentScene” which takes just one argument a Timer object.
      Timer provides the method “incidentStateChange” which lets the Incidents change their state by
      providing their id and their new state.
 * */

var Incident = function () {
    /**
     It takes just one argument, "props". Props pass data useful only for the following:
     An incident can be set to be either inexhaustible (meaning it can be executed again and again infinite times -- default)
     or finite meaning it can only be executed a limited (specific) number of times. This info can be found on the maxLifeCycles
     Of course the incident can be reset to its initial condition at any time through the "reset" method it provides.
      As a luxuriousness, and along WITH the maxLifeCycles parameter, the Incident also provides the executionPattern parameter
     through which the programmer / user can define a more complex behaviour of the Incident execution depending on the number times
     the incident has alrady be executed ( is the 1st time, the 2nd time, the 3rd time etc) and any custom parameter it
     holds. The execution times are held on the "executionTimes" attribute of the class.
      props:
     {
        id: if passed that's the id of the Incident. If not we create a new one
        plugin_channel_class - if passed gets set to it
        mc_plugin_npm_name - if passed gets set to it
        
     }
        @param {object} props */
    function Incident() {
        var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        _classCallCheck(this, Incident);

        this.attrs = attrs;
        this.props = props;

        // auto-generated id. This parameter indicates whether the id of the Incident was given by the user or 
        // it was auto-generated by MC. Auto-generated ids do not get checked for duplicates on checkAddition 
        // process, for the shake of performance
        this.autoGeneratedID = false;
        if (!props.hasOwnProperty('id') && props.autogeneratedID != true) {
            this.autoGeneratedID = true;
        }
        this.id = props.id || helper.getAnId();

        // this parameter is initialised to false. Once the onGetContext method gets invoked this parameter
        // is set to true so we prevent multiple executions of the onGetContext method
        this.gotContext = false;

        /*
        these are the default values that define channeling for the default Incidents. These values get ovewriden through
        the loadPlugin method of MC with the values found on the main.js file of the plugin
        */
        this.plugin_channel_class = Channel;
        this.mc_plugin_npm_name = "motor-cortex-js";
        if (props.hasOwnProperty('plugin_channel_class')) {
            this.plugin_channel_class = props.plugin_channel_class;
        }
        if (props.hasOwnProperty('mc_plugin_npm_name')) {
            this.mc_plugin_npm_name = props.mc_plugin_npm_name;
        }

        /* 
        The following two properties ("statusBeforeHalt" and "stateBeforeStop") which have stupidly 
        used "status" in the one case and "state" in the other
        act as the memory of the Incident in the case of a stop or
        a halting command (wait or block), storing the state of it just before any of the two get 
        executed. 
        These properties can be used in various ways in the program
        and they do not target specific functionality.
        */
        // the status of the Incident before it got halted by either the block or the wait command
        this.statusBeforeHalt = 'idle';
        // holds the state of the Incident before the stop command
        this.stateBeforeStop = 'idle';

        this.timesExecuted = 0;
        this.parentSceneObject = null;

        this.runTimeInfo = {
            state: 'idle' // one of "idle", "playing", "waiting"
        };

        this.bitIncident = true;
        this.hasIncidents = false;

        /* an array holding all  */
        this.eventsSubscriptions = {};

        /*
        Right now many keys of the Incident (such as "props", "attrs", etc) are already been used by the Incident 
        class. The final users of the library (the plugin developers) might want to keep special / specific data
        on their Incidents and:
        a) they might don't know which keys are already taken and which are not
        b) might use an already used key and ruin the functionality
        c) so they feel unsafe keeping data and it's not safe for the lib too
        For this reason we have a blank object reserved for them, the "customParams", in order for them to 
        put anything they want and we encourage them to use the built-in methods:
        setParam
        getParam
        setParams
        for this job
        */
        this.customParams = {};

        this.speed = 1;

        /*
        initialValues is an object holding the autmatically computed initial values of the animatedAttrs 
        (if any). The initialValues are calculated by the AttributesChannel (only Incidents belonging to 
        an AttributesChannel have initialValues).
        The keys set of this object is identical to the object attrs.animatedAttrs 
        The only thing the generic AttributesChannel can't calculate is the initial value of an animated attr
        of a specific element when there are no other Incidents entered on its lanes yet. These values are
        the "scratchValues" and they are strongly dependend on the nature of the lib. E.g. for a CSS animation
        what we are looking for can be found on the computedStyle.
        */
        this.initialValues = {};

        /*
        The user has the ability to explicitely define the initial values for any of the animatedAttrs. The user
        can do that by providing the initialValues object on the attrs of the constructor.
        */
        this.userDefinedInitialValues = {};
        if (attrs != null && attrs != undefined) {
            if (attrs.hasOwnProperty('initialValues')) {
                this.userDefinedInitialValues = attrs.initialValues;
            }
        }

        /*
        blockingWaitings is an array, a collection, of blocing waitings that have the Scene as target.
        The logic is simple:
        - if the scene receives a "sceneBlockingWaiting" then it is the target and it adopts it
        - if the scene receives a "channelBlockingWaiting" then if it is a channel it adopts it otherwise it tries to
            pass it further up until it finds a channel
        - if the scene receives a "clipBlockingWaiting" if it is the Clip it adopts it otherwise it tries to pass it
            further up until it reaches the clip
        Each object on this array represents a blocking waiting triggered by a child of the Scene
            and which targets the Scene itself.
        Each child signs the blocking waiting by assigning its own id to it. Each child can only assign just one
            blocking waiting at a time.
        The structure of each blocking waiting appearing on this array is the following:
        {
            id: the-signature-of-the-triggering-incident,
            type: any of the sceneBlockingWaiting / channelBlockingWaiting / ClipBlockingWaiting,
            nature: any of the scheduled / dynamic / system-problem
        }
        */
        this.blockingWaitings = [];

        /**
        * @member {boolean} - if testingMode is set to true the requestAnimationFrame method is not going
        * to get executed automatically but instead the emaulateStep method will start functioning allowing
        * developers to pass the milliseconds difference from the previous timestamp manually
        **/
        this.testMode = false;
        if (props.hasOwnProperty('testMode')) {
            this.testMode = props.testMode;
        }

        if (props.hasOwnProperty('initialValues')) {
            this.initialValues = props.initialValues;
        }

        /**
         * @member {boolean} - if autoGenerated is set to true, it means that this Incident has been auto-generated by its parent on initialisation.
         * This happens when plugins export Incidents that on initialisation they automatically create other incidents and automatically put them 
         * on specific points on their timeline. 
         * In such cases we don't want these Incidents to be exported on getState with unprocessed = true and this because they will be re-generated
         * automatically on the clip's reconstruction process based on the exported json. 
        */
        this.autoGenerated = false;

        this.onInitialise(attrs, props);
    }

    _createClass(Incident, [{
        key: 'getScratchValue',


        /**
        This method shoudl be overwritten by the Incidents of the plugins. The method accepts
        as arguments the mcid (an element) and the attribue (one of the animatedAttrs, if any)
        and return the initial value of them as the library calculates / defines them. The 
        returned value represents the very initial value of the element's attribute before
        any Incident that alters it gets added.
        @param {string} mcid
        @param {string} attribute
        @returns {mixed} - the initial value of the element's attribute just when the HTML & CSS
        of the Clip gets rendered
        */
        value: function getScratchValue(mcid, attribute) {
            return 0;
        }
    }, {
        key: 'getElementAttribute',
        value: function getElementAttribute(attr) {
            return this.element.getAttribute(attr);
        }
    }, {
        key: 'getElementByMCID',
        value: function getElementByMCID(mcid) {
            if (this.context === null) {
                return null;
            }

            return this.context.getElementByMCID(mcid);
        }
    }, {
        key: 'flashDOM',
        value: function flashDOM() {
            return {
                failedAdditions: []
            };
        }
    }, {
        key: 'turnIncidentToMC',
        value: function turnIncidentToMC() {
            this.plugin_channel_class = Channel;
            this.mc_plugin_npm_name = "motor-cortex-js";
        }
    }, {
        key: 'resetState',
        value: function resetState() {}
    }, {
        key: 'getIncidentsByChannel',


        /**
         * Returns an object that has the key of the npm plugin name the Channel of which manages the specific Incident
        */
        value: function getIncidentsByChannel() {
            var adjustMillisecond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

            var incidentsByPlugin = {};
            var keyToUse = this.mc_plugin_npm_name;
            if (this.bypassChannel === true) {
                keyToUse = 'motor-cortex-js';
            }
            incidentsByPlugin[keyToUse] = [{
                millisecond: adjustMillisecond,
                incident: this,
                id: this.id
            }];
            return incidentsByPlugin;
        }
    }, {
        key: 'setParam',
        value: function setParam(param, value) {
            this.customParams[param] = value;
        }
    }, {
        key: 'getParam',
        value: function getParam(param) {
            return this.customParams[param];
        }
    }, {
        key: 'setParams',
        value: function setParams() {
            var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            this.customParams = params;
        }

        /** *************************************************
        HELPER FUNCTIONS
        checks if the parent Scene object has been defined */

    }, {
        key: 'checkParentScene',
        value: function checkParentScene() {
            if (this.parentSceneObject === null) {
                return false;
            } else {
                return true;
            }
        }
    }, {
        key: 'checkStateTransition',
        value: function checkStateTransition(targetState) {
            // we prevent play (and thus any other transition) in cases the Incident has no parent
            // group. The method changes on Group
            if (this.checkParentScene()) {
                if (checkTransition(this.runTimeInfo.state, targetState, this.direction)) {
                    return true;
                }
            }
            return false;
        }
    }, {
        key: '_hasUserDefinedInitialValue',
        value: function _hasUserDefinedInitialValue(attr) {
            return this.userDefinedInitialValues.hasOwnProperty(attr);
        }
    }, {
        key: '_getUserDefinedInitialValue',
        value: function _getUserDefinedInitialValue(attr) {
            return this.userDefinedInitialValues[attr];
        }
    }, {
        key: 'setInitialValue',
        value: function setInitialValue(attr, value) {
            if (this._hasUserDefinedInitialValue(attr)) {
                helper.notice('Incident with id ' + this.id + ' has initial value defined for ' + attr + ' and no change is allowed on it');
                return;
            }
            this.initialValues[attr] = value;
        }
    }, {
        key: 'hasInitialValue',
        value: function hasInitialValue(attr) {
            return this._hasUserDefinedInitialValue(attr) || this.initialValues.hasOwnProperty(attr);
        }
    }, {
        key: 'getInitialValue',
        value: function getInitialValue(attr) {
            if (this._hasUserDefinedInitialValue(attr)) {
                return this._getUserDefinedInitialValue(attr);
            }
            return this.initialValues[attr];
        }
    }, {
        key: 'setParentScene',
        value: function setParentScene(parentSceneObject) {
            this.parentSceneObject = parentSceneObject;
        }

        /* *************************************************
        STATE CHANGING FUNCTION
        method from which we can set the state of the Incident.
        this method should never be invoked directly from code outside the core definition of Incident. All state changes
        should occur through the corresponding built-in functions (play, wait, etc) */

    }, {
        key: '_setState',
        value: function _setState(state) {
            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            var oldState = this.runTimeInfo.state;
            this.runTimeInfo.state = state;

            if (this.checkParentScene() && state === 'completed' && this.speed > 0) {
                this.parentSceneObject.incidentStateChange(this.id, oldState, state, props);
            } else if (this.checkParentScene() && state === 'idle' && this.speed < 0) {
                this.parentSceneObject.incidentStateChange(this.id, oldState, state, props);
            }

            var newState = state;
            if ((state === 'waiting' || state === 'blocked') && props.waitingStateName != 'waiting') {
                newState = props.waitingStateName;
            }
            this.broadcastEvent('state-change', { oldState: oldState, newState: newState });
        }
    }, {
        key: 'setCurrentMillisecond',
        value: function setCurrentMillisecond(millisecond) {
            this.runTimeInfo.currentMillisecond = millisecond;
        }

        /**
         * sets the state of the Incident silently without broadcasting the event nor informing the parent Incident
         */

    }, {
        key: '_dontTellMamaStateChange',
        value: function _dontTellMamaStateChange(state) {
            if (this.checkStateTransition(state)) {
                // helper.log('setting state of ' + this.id + ' to ' + state);
                var oldState = this.runTimeInfo.state;
                this.runTimeInfo.state = state;
                this.broadcastEvent('state-change', { oldState: oldState, newState: state });
            }
        }

        /** *************************************************
        EXECUTION FUNCTIONS
        sets state to "playing" */

    }, {
        key: 'play',
        value: function play() {
            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            if (!this.onBeforePlay(props)) {
                return false;
            }
            if (!this.checkStateTransition('playing')) {
                return false;
            }

            this.timesExecuted += 1;
            this.onPlay(props);
            this._setState('playing');

            if (this.bitIncident) {
                this.complete();
            }
            return true;
        }

        /**
         wait method can be invoked by the object itself or by its parent Scene. No children are allowd to call the wait
         method.
          the nature of a waiting might be:
             - scheduled    *                               default
             - dynamic
             - system-error
          the waitingStateName of a waiting can be:
             - waiting *                                    default
             - sceneBlockingWaiting
             - clipBlockingWaiting
          An Incident can only exit waiting mode through the resume method
          */

    }, {
        key: 'wait',
        value: function wait(props) {
            if (!props.waitingStateName) {
                props = { nature: 'scheduled', waitingStateName: 'waiting' };
            }

            if (!this.checkStateTransition('waiting')) {
                return false;
            }

            this.statusBeforeHalt = this.runTimeInfo.state;
            this._setState('waiting', props);
            this.onWait(props);
            return true;
        }
    }, {
        key: 'unblock',
        value: function unblock() {
            if (this.statusBeforeHalt === 'playing') {
                this.resume();
            }
        }

        /**
         block and unblock methods can only be invoked by a parent of the Incident. No children (in the case of a Scene) nor
         the Incident itself can block or unblock itself.
          */

    }, {
        key: 'block',
        value: function block() {
            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            if (!this.checkStateTransition('blocked')) {
                return false;
            }

            this.statusBeforeHalt = this.runTimeInfo.state;
            this._setState('blocked', props);
            this.onBlock(props);
            return true;
        }
    }, {
        key: 'resume',
        value: function resume() {
            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            if (!this.onBeforeResume(props)) {
                return false;
            }
            if (!this.checkStateTransition(this.statusBeforeHalt)) {
                return false;
            }

            this.onResume(props);
            this._setState(this.statusBeforeHalt);

            return true;
        }
    }, {
        key: 'reset',
        value: function reset() {
            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            // this.stop();
            if (!this.checkStateTransition('idle')) {
                return false;
            }

            this.blockingWaitings = [];

            this.timesExecuted = 0;
            this._setState('idle');
            this.onReset(props);
            return true;
        }
    }, {
        key: 'complete',
        value: function complete() {
            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            if (this.speed > 0) {
                if (!this.checkStateTransition('completed')) {
                    return false;
                }
            } else {
                if (!this.checkStateTransition('idle')) {
                    return false;
                }
            }

            this.onBeforeComplete(props);

            if (this.speed > 0) {
                this._setState('completed');
            } else {
                this._setState('idle');
            }

            if (this.speed > 0) {
                this.runTimeInfo.currentMillisecond = this.duration;
            } else {
                this.runTimeInfo.currentMillisecond = 0;
            }

            return true;
        }
    }, {
        key: 'stop',
        value: function stop() {
            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            if (!this.checkStateTransition('transitional')) {
                return false;
            }

            this.blockingWaitings = [];

            this.stateBeforeStop = this.state + "";
            this._setState('transitional');
            this.onStop(props);
            return true;
        }

        /**
         * Restores the execution of the Incident after a stop
        **/

    }, {
        key: 'restore',
        value: function restore() {
            if ((this.state === 'waiting' || this.state === 'blocked') && this.stateBeforeStop === 'playing') {
                this.resume();
            }
        }
    }, {
        key: 'arm',
        value: function arm() {
            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            if (!this.checkStateTransition('waiting')) {
                return false;
            }

            this.blockingWaitings = [];

            this._dontTellMamaStateChange('waiting');
            this.onArm(props);
            return true;
        }

        /**
         * There are various events happening on the scope of an Incident. Any class extending Incident might have / define its own
         * events.
         *
         * The "broadcastEvent" method of the Incident allows the Incident (of any type, even on classes extending it) broadcast
         * events on any of the interested parties that have subscribed to it.
         *
         * The "subscribeToEvents" method allows any third party subscribe and listen to events' broadcasts by any Incident
         *
         * @param {string} id - the unique id of the event listener
         * @param {function} fnct - a function to get executed whenever an event gets broadcasted by the specific Incident. The
         *  fnct will be executed on all events' broadcasts and it will receive the event object as argument. The event object is
         *  of format:
         *  {
                name: the name of the event,
                meta: an object holding all the meta-info of the event
            }
         }
        */

    }, {
        key: 'subscribeToEvents',
        value: function subscribeToEvents(id, fnct) {
            this.eventsSubscriptions[id] = fnct;
        }

        /**
         * unsubscribes any subscribed listener to the Incident's events broadcasting
         * @param {string} id
         */

    }, {
        key: 'unsubscribeFromEvents',
        value: function unsubscribeFromEvents(id) {
            if (this.eventsSubscriptions[id]) {
                delete this.eventsSubscriptions[id];
            }
        }

        /**
         * broadcasts any event
         * @param {string} eventName
         * @param {object} meta
         */

    }, {
        key: 'broadcastEvent',
        value: function broadcastEvent(eventName, meta) {
            for (var key in this.eventsSubscriptions) {
                this.eventsSubscriptions[key](eventName, meta);
            }
        }

        /**
         * This method's (which should be called whenever a slip ends) purpose is to calculate and set
         * the right state of the Incident based on the target millisecond.
         * The parameter it takes is relative to the beginning of the Incident itself and it might be negative
         * Negative targetMillisecond means the target millisecond is N milliseconds BEFORE the start of the Incident
         * @param {int} targetMillisecondDeltaFromStart - the delta of the target millisecond compared to the Incident start
         */

    }, {
        key: 'recalcState',
        value: function recalcState(targetMillisecondDeltaFromStart) {
            if (targetMillisecondDeltaFromStart >= 0) {
                // if it ends before the target millisecond
                this._dontTellMamaStateChange('completed');
            } else {
                // if it has been completed on targetMillisecond
                this._dontTellMamaStateChange('idle');
            }
        }
    }, {
        key: 'resize',
        value: function resize(duration) {
            this.systolDiastole(duration / this.duration);
            return { result: true };
        }
    }, {
        key: 'systolDiastole',
        value: function systolDiastole(durationFraction) {
            return true;
        }
    }, {
        key: 'exportState',
        value: function exportState() {
            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            var toExport = {
                id: this.id,
                duration: this.duration,
                class: this.constructor.name,
                mc_plugin_npm_name: this.mc_plugin_npm_name,
                customParams: this.customParams,
                attrs: Object.assign({}, this.attrs),
                props: Object.assign({ id: this.id, autogeneratedID: true }, this.props)
            };

            var exportType = 'live';
            if (props.hasOwnProperty('type')) {
                if (props.type === "json") {
                    toExport.initialValues = this.initialValues;
                    exportType = 'json';
                }
            }

            if (exportType === 'live') {
                toExport.plugin_channel_class = this.plugin_channel_class;
                toExport.state = this.state;
                toExport.Incident = this.constructor;
            }

            return toExport;
        }

        // *************************************************
        /* PIPES SYSTEM
            The Pipes system is a vertical interconnection system that runs out the full Incidents tree and connects all of them.
            Through Pipes any Incident can communicate anything to all of its children or parents.
            
            In order to initialise a pipe message the user should use the putMessageOnPipe method. This method is exposed by all
                Incidents, of all types, and it is first been processed by the receiver Incident and then passed further down to
                its children (if any).
            This method takes exactly 5 arguments:
            - name (the name of the command). This should be unique among the full MC ecosystem including native message names & 
                plugins' message names. In order to avoid conflicts is good to use the convention: <plugin_npm_name>.<message_name>
            - parameters (an object holding the parameters of the command)
            - selfExecute (true/false) - If true the Incident will try to process the pipe command before further passing further up or down
            - direction (default "down") - defines the direction of the pipe command. It can be either "down" so it passes it down to 
                its children or "up" so it passes it up to its parents
            - target. The target defines / describes the receivers of the pipe message. This might be:
                - null (default) - targets all incidents
                - type: "group" - targets only groups (including clips)
                - type: "clip" - targets only clips
                - type: "rootClip" - targets only the root clip of the tree
                - id: "<id>" - targets a specific incident with specific id
                - plugin: "<plugin_npm_name>" - targets only Incidents of a specific plugin
            
            Handling pipe messages:
            The putMessageOnPipe method decides whether it should be processed or
            not by the Incident depending on the target. This method is the _processPipeMessage. If the Incident should process the 
            pipe message the _processPipeMessage method calls the "handlePipeMessage" method passing the name and the parameters.
            The "handlePipeMessage" is a built in method as well and the developers should just overwrite it so they handle the 
            various pipes messages based on their names.
            
            Pipe messages targeting the clip return a result.
        */

    }, {
        key: 'putMessageOnPipe',
        value: function putMessageOnPipe(name, params, selfExecute, direction) {
            var target = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

            if (selfExecute) {
                if (target === null) {
                    this.handlePipeMessage(name, params);
                } else {
                    if (target.hasOwnProperty('type')) {
                        if (target.type === 'group' && this.hasIncidents) {
                            this.handlePipeMessage(name, params);
                        } else if (target.type === 'clip' && this.isTheClip) {
                            this.handlePipeMessage(name, params);
                        } else if (target.type === "rootClip" && this.isTheClip && !this.checkParentScene()) {
                            return this.handlePipeMessage(name, params);
                        }
                    } else if (target.hasOwnProperty('id')) {
                        if (this.id === target.id) {
                            this.handlePipeMessage(name, params);
                            return;
                        }
                    } else if (target.hasOwnProperty('plugin')) {
                        if (this.mc_plugin_npm_name === target.plugin) {
                            this.handlePipeMessage(name, params);
                        }
                    }
                }
            }

            if (direction === "down" && this.hasIncidents) {
                for (var i = 0; i < this.incidents.length; i++) {
                    this.incidents[i].incident.putMessageOnPipe(name, params, true, direction, target);
                }
            } else if (direction === "up" && this.checkParentScene()) {
                this.parentSceneObject.putMessageOnPipe(name, params, true, direction, target);
            }
        }
    }, {
        key: 'handlePipeMessage',
        value: function handlePipeMessage(name, params) {}
        // Plugins developers can overwrite this method so they can handle pipe messages per name


        // *************************************************
        /* BLOCKING WAITINGS
        The triggerBlockingWatiing method that can be used by any Incident at any time. The Incident can trigger a blocking waiting. 
        The "blocking waitings" block the root Clip's execution (puts it to blocked state). 
        Any blocking waiting has an id (it must be unique) and it can be unblocked by any Incident at any time through the triggerUnblock
        method which takes an id and removes the corresponding blocking waiting. 
        */

    }, {
        key: 'triggerBlockingWatiing',
        value: function triggerBlockingWatiing(id) {
            var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            params.blockingWaitingID = id;
            this.putMessageOnPipe(pipeMessges._BLOCKING_WAITING, params, true, "up", { type: 'rootClip' });
        }
    }, {
        key: 'triggerUnblock',
        value: function triggerUnblock(id) {
            var params = {
                blockingWaitingID: id
            };
            this.putMessageOnPipe(pipeMessges._UNBLOCK_WAITING, params, true, "up", { type: 'rootClip' });
        }

        // *************************************************
        // ACTUAL BAHAVIOUR FUNCTIONS THAT SHOULD BE IMPLEMENTED BY ALL CLASSES EXTENDING INCIDENT
        // this is a chance to block play of an incident by returning false

    }, {
        key: 'onBeforePlay',
        value: function onBeforePlay() {
            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            return true;
        }
    }, {
        key: 'onPlay',
        value: function onPlay(props) {
            helper.info('Overwritte the "onPlay" method with the code you want to get executed', 'info');
        }
    }, {
        key: 'onResume',
        value: function onResume(props) {
            helper.info('Overwritte the "onResume" method with the code you want to get executed', 'info');
        }
    }, {
        key: 'onBeforeResume',
        value: function onBeforeResume() {
            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            return true;
        }

        /**
         * Helper function that normalises the millisecond to pass to the Incidents on goTo
         * If millisecond < 0 it makes it 0
         * If millisecond > duration of the Incident it makes it equals to the duration
         * @param {int} millisecond - the millisecond to normalise. It represents the distance of the time to go to from
         *  the start of the Incident
         * @returns {int} - the normalised millisecond
        **/

    }, {
        key: 'normaliseGoToTarget',
        value: function normaliseGoToTarget(millisecond) {
            if (millisecond < 0) {
                millisecond = 0;
            } else if (millisecond > this.duration) {
                millisecond = this.duration;
            }

            return millisecond;
        }

        /**
         * goTo on the Incident level implements the logic of passing the authority of execution to its parent
         * (if there is any)
         * Incidents that implement their own goTo logic should overwrite the goTo method otherwise the goTo
         * will be passed up until either it reaches a context owner or a tree root
         * @param {int} millisecond - (optional) the millisecond where we want to goTo. If not provided we use the current millisecond of the Incident
         * @returns {boolean} - if the context owner of the Incident actually executes the goTo command the
         *  method returns true otherwise it returns false
        **/

    }, {
        key: 'goTo',
        value: function goTo(millisedond) {
            // if the incident has a parent scene
            if (this.checkParentScene()) {
                if (this.parentSceneObject.goTo(millisedond, { relativeTo: this.id })) {
                    return true;
                }
            }
            return false;
        }

        /**
         * Returns the milliseconds delta between the Incident's start point and its root Scene's current millisecond.
         * If the result is negative it means the root scene's current millisecond is prior to the Incident's start point
         * @returns {int}
        **/

    }, {
        key: 'getRootCurrentMillisecondDeltaFromStart',
        value: function getRootCurrentMillisecondDeltaFromStart() {
            if (this.checkParentScene()) {
                return this.parentSceneObject.getRootCurrentMillisecondDeltaFromIncidentsStart(this.id);
            } else {
                return this.runTimeInfo.currentMillisecond;
            }
        }
    }, {
        key: 'beOn',
        value: function beOn(millisecond) {
            var goTo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

            var previousState = this.state + "";
            this.stop();
            if (goTo) {
                this.goTo(millisecond);
            }
            this.setCurrentMillisecond(millisecond);
            this.recalcState(millisecond);
            var newState = this.state + "";
            return {
                previousState: previousState,
                newState: newState
            };
        }
    }, {
        key: '_onGetContextOnce',
        value: function _onGetContextOnce() {
            if (!this.gotContext) {
                this.onGetContext();
                this.gotContext = true;
            }
        }
    }, {
        key: 'onGetContext',
        value: function onGetContext() {
            helper.info('Overwritte the "onGetContext" method with the code you want to get executed', 'info');
        }
    }, {
        key: 'onStop',
        value: function onStop(props) {
            helper.info('Overwritte the "onBeforeStop" method with the code you want to get executed', 'info');
        }
    }, {
        key: 'onReset',
        value: function onReset(props) {
            helper.info('Overwritte the "onReset" method with the code you want to get executed', 'info');
        }
    }, {
        key: 'onBeforeComplete',
        value: function onBeforeComplete(props) {
            helper.info('Overwritte the "onBeforeEnd" method with the code you want to get executed', 'info');
        }
    }, {
        key: 'onBlock',
        value: function onBlock(props) {
            helper.info('Overwritte the "onBlock" method with the code you want to get executed', 'info');
        }
    }, {
        key: 'onUnblock',
        value: function onUnblock(props) {
            helper.info('Overwritte the "onUnblock" method with the code you want to get executed', 'info');
        }
    }, {
        key: 'onWait',
        value: function onWait(props) {
            helper.info('Overwritte the "onWait" method with the code you want to get executed', 'info');
        }
    }, {
        key: 'onArm',
        value: function onArm(props) {
            helper.info('Overwritte the "onArm" method with the code you want to get executed', 'info');
        }
    }, {
        key: 'lastWish',
        value: function lastWish() {
            this.stop();
        }
    }, {
        key: 'onInitialise',
        value: function onInitialise(attrs, props) {
            helper.info('Overwritte the "onInialise" method with the code you want to get executed', 'info');
        }
    }, {
        key: 'onSpeedChange',
        value: function onSpeedChange(speed) {
            helper.info('Overwritte the "onSpeedChange" method with the code you want to get executed', 'info');
        }
    }, {
        key: 'isOnTestMode',
        get: function get() {
            if (this.checkParentScene()) {
                return this.parentSceneObject.isOnTestMode;
            } else {
                return this.testMode;
            }
        }
    }, {
        key: 'selector',
        get: function get() {
            return this.props.selector;
        }

        /* shortcuts for attrs.attrs and attrs.animatedAttrs */

    }, {
        key: 'animAttributes',
        get: function get() {
            return this.attrs.animatedAttrs;
        }
    }, {
        key: 'confAttributes',
        get: function get() {
            return this.attrs.attrs;
        }
    }, {
        key: 'isHeadlessClip',
        get: function get() {
            return !this.checkParentScene();
        }
    }, {
        key: 'context',
        get: function get() {
            if (this.checkParentScene()) {
                return this.parentSceneObject.context;
            } else {
                return null;
            }
        }
    }, {
        key: 'element',
        get: function get() {
            if (this.contex === null) {
                return [];
            }
            if (this.context.getElementByMCID) {
                return this.context.getElementByMCID(this.props.mcid);
            }
            return this.context.getElements(this.selector)[0];
        }

        /*
        returns the initialised channel by the Clip the Incident belongs to
        */

    }, {
        key: 'channel',
        get: function get() {
            if (this.checkParentScene()) {
                return this.parentSceneObject._getChannel(this.mc_plugin_npm_name);
            } else {
                return null;
            }
        }
    }, {
        key: 'elements',
        get: function get() {
            if (this.contex === null) {
                return [];
            }
            return this.context.getElements(this.selector);
        }
    }, {
        key: 'executionSpeed',
        set: function set(speed) {
            this.speed = parseFloat(speed);
            this.onSpeedChange(speed);
            // this.beOn(this.runTimeInfo.currentMillisecond);
        }

        /**
         * gets the Incident's duration. This method should be overwriten accordingly by all Incidents
         */

    }, {
        key: 'duration',
        get: function get() {
            return 0;
        },
        set: function set(duration) {
            ;
        }
    }, {
        key: 'state',
        get: function get() {
            return this.runTimeInfo.state;
        }
    }, {
        key: 'direction',
        get: function get() {
            return this.speed > 0 ? "forwards" : "backwards";
        }
    }]);

    return Incident;
}();

module.exports = Incident;