'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Incident = require('./Incident');
var Helper = require('../_coreUtils//Helper');
var helper = new Helper();
var isTimePausingState = require('../configuration/allowedStateChanges').isTimePausingState;

/** @classdesc
 * A TimedIncident is an incident that lasts some time. It has duration and a timer of its own. It can take all the states.
 *
 */

var TimedIncident = function (_Incident) {
    _inherits(TimedIncident, _Incident);

    function TimedIncident() {
        var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        _classCallCheck(this, TimedIncident);

        /**
         * @member {object} - repeat
         * - times: the repeatFactor property defines the times an Incident should be executed repeatedly.
         * For Bit Inicdents this is not acceptable as Bit Incidents have 0 duration and thus positioning them on a chain
         * the one after the other doesn't make sense.
         * This property has practical value on TimedIncidents.
         * In any case the default value of this member is 1 and it can only accept unsigned integer values
         * - delay: the left gap in milliseconds
         * - gap: the right gap in milliseconds
        */
        var _this = _possibleConstructorReturn(this, (TimedIncident.__proto__ || Object.getPrototypeOf(TimedIncident)).call(this, attrs, props));

        _this.repeat = {
            times: 1,
            delay: 0,
            hiatus: 0
        };
        _this.repetationDuration = _this.props.duration;
        if (props.hasOwnProperty('repeat')) {
            if (props.repeat.hasOwnProperty('times')) {
                _this.repeat.times = props.repeat.times;
            }
            if (props.repeat.hasOwnProperty('delay')) {
                _this.repeat.delay = props.repeat.delay;
                _this.repetationDuration += props.repeat.delay;
            }
            if (props.repeat.hasOwnProperty('hiatus')) {
                _this.repeat.hiatus = props.repeat.hiatus;
                _this.repetationDuration += props.repeat.hiatus;
            }
        }

        _this.resetState();

        /**
          @member {object} - listeners are functions to be executed on time change of the Timed Incident. It has the following format:
           listeners: {
            listener_id: {
                     funct : the function to be executed
                     threshold : the threshold of delta
                     roundTo : round millisecond
                 },
                 listener_id: {
                     funct : the function to be executed
                     threshold : the threshold of delta
                     roundTo : round millisecond
                 },
                 ...
           }
           */
        _this.listeners = {};

        _this.bitIncident = false;
        return _this;
    }

    _createClass(TimedIncident, [{
        key: 'requestAnimaFrame',
        value: function requestAnimaFrame(fn) {
            /* if the Incident is on test mode we want to prevent requestAnimationFrame as execution
                during testing is controlled through emulateStep method */
            if (this.isOnTestMode) {
                return function () {};
            }

            try {
                return this.context.window.requestAnimationFrame(fn);
            } catch (e) {
                helper.error('Your browser does not support requestAnimationFrame');
                return function (fn) {};
            }
        }

        /**
         * when the Incident is on test mode (this.isOnTestMode = true) the emulateStep method
         * becomes functional.
         * The method takes as input the millisecondsDelta from the previous timestamp and triggers
         * the step function passing in a baked timestamp so the Incident behaves exactly as if the requestAnimationFrame run
         * passing a timestamp that has exactly millisecondsDelta difference from the previous one
         * @param {int} millisecondsDelta - the milliseconds difference between the previous timestamp and the new one
        */

    }, {
        key: 'emulateStep',
        value: function emulateStep(millisecondsDelta) {
            if (!this.isOnTestMode) {
                helper.error('emulateStep method can only be used on test mode');
            } else {
                this.step(this.runTimeInfo.previousTimeStamp + millisecondsDelta);
            }
        }

        /**
         * All TimedIncidents must implement the get duration method
        **/

    }, {
        key: 'checkResizedIncident',


        /**
         * checks if a duration edit is feasible and doesn't cause conflicts
         * @param {int} duration - the new duration
        **/
        value: function checkResizedIncident(durationFraction, incident) {
            var adjustMillisecond = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

            if (this.isHeadlessClip) {
                return { result: true, execute: function execute() {} };
            } else {
                // IF THE GROUP HAS NO PARENT (ACT AS THE CLIP)
                return this.parentSceneObject.checkResizedIncident(durationFraction, incident, adjustMillisecond + this.parentSceneObject.getIncidentMillisecond(this.id));
            }
        }

        /**
         * Edits the total duration of the Incident, as this is calculated based on the sum of delay, duration and hiatus
         * @param {int} duration - the new duration in milliseconds
        **/

    }, {
        key: 'resize',
        value: function resize(duration) {
            // console.trace();
            // don't waste cpu resources if the new duration equals the current value
            if (duration === this.duration) {
                return { result: true };
            } else if (duration <= 0) {
                helper.error('resizeIncident method of Scene only accepts integers > 0 as the new duration of the Scene. ' + duration + ' provided.');
                return {
                    result: false
                };
            }
            // stop the execution
            this.stop();

            var editCheck = this.checkResizedIncident(duration / this.duration, this);

            if (editCheck.result === false) {
                helper.error(editCheck);
                return editCheck;
            }

            this.systolDiastole(duration / this.duration);
            editCheck.execute();

            if (this.checkParentScene()) {
                this.parentSceneObject.getDurationAfterIncidentAffected();
            }
            this.broadcastEvent('duration-change', { newDuration: this.duration });
            return { result: true };
        }

        /**
         * This method edits the duration params. As "duration params" we define:
         * - the props.duration
         * - the props.repeat (with all of its keys: times, delay, hiatus)
         * @param {object} params - An object that accepts at least one of the following keys:
         * - duration
         * - times
         * - delay
         * - hiatus
        */

    }, {
        key: 'editDurationParams',
        value: function editDurationParams(params) {
            // stop the execution
            this.stop();

            // calculate the new values for props.duration and props.repeat
            var newPropsDuration = this.props.duration;
            if (params.hasOwnProperty('duration')) {
                newPropsDuration = params.duration;
            }
            var newRepeat = JSON.parse(JSON.stringify(this.repeat));
            if (params.hasOwnProperty('times')) {
                newRepeat.times = params.times;
            }
            if (params.hasOwnProperty('delay')) {
                newRepeat.delay = params.delay;
            }
            if (params.hasOwnProperty('hiatus')) {
                newRepeat.hiatus = params.hiatus;
            }

            // calculate the new total duration
            var newTotalDuration = newRepeat.times * (newPropsDuration + newRepeat.delay + newRepeat.hiatus);

            // check the edit
            var editCheck = {
                result: true,
                execute: function execute() {}
            };
            if (newTotalDuration != this.duration) {
                editCheck = this.checkResizedIncident(newTotalDuration / this.duration, this);
            }

            if (editCheck.result === false) {
                helper.error(editCheck);
                return editCheck;
            }

            // update the Incident's values
            this.props.duration = newPropsDuration;
            this.repeat = newRepeat;

            editCheck.execute();

            if (this.checkParentScene() && newTotalDuration != this.duration) {
                this.parentSceneObject.getDurationAfterIncidentAffected();
                this.broadcastEvent('duration-change', { newDuration: this.duration });
            }

            return { result: true };
        }
    }, {
        key: 'systolDiastole',
        value: function systolDiastole(durationFraction) {
            this.duration = this.duration * durationFraction;
        }
    }, {
        key: 'resetState',
        value: function resetState() {
            _get(TimedIncident.prototype.__proto__ || Object.getPrototypeOf(TimedIncident.prototype), 'resetState', this).call(this);
            // the current millisecond having as 0 the start of the animation
            if (this.state === 'idle') this.runTimeInfo.currentMillisecond = 0; // the current millisecond of the incident as it's calculated based on the speed of the Incident
            else if (this.state === 'completed') this.runTimeInfo.currentMillisecond = this.duration;
            // in other words the millisecond that the Incident is on the UI
            this.runTimeInfo.start = null; // the millisecond started as provided by requestAnimationFrame
            this.runTimeInfo.previousTimeStamp = null; // the timestamp of the previous circle as provided by requestAnimationFrame
            this.runTimeInfo.pauseMoment = null; // the pause moment as provided by new Date().getTime()
            this.runTimeInfo.pauseMillisecond = 0; // the pauseMillisecond is the current millisecond at the pause moment
            for (var key in this.listeners) {
                this.listeners[key].cavaDelta = 0;
            }
        }

        /**
         * This method calculates the previousTimeStamp based on the target UI millisecond we want to go to and
         * the speed of the Incident.
         * E.g. if targetUIMillisecond = 2000 and speed =2 then we will take the timestamp from requestAnimationFrame (ra_stamp) and
         * set the previousMillisecond to ra_stamp-1000
         * @param {int} currentMIllisecond - the millisecond to which we want our Inicdent to be on
        */

    }, {
        key: 'programmaticSetPreviousTimeStamp',
        value: function programmaticSetPreviousTimeStamp(targetUIMillisecond) {
            var _this2 = this;

            var that = this;

            if (this.isOnTestMode) {
                that.runTimeInfo.previousTimeStamp = 0;
            }

            this.requestAnimaFrame(function (timestamp) {
                that.runTimeInfo.previousTimeStamp = timestamp - targetUIMillisecond / _this2.speed;
            });
        }

        // ******** INCIDENT METHODS IMPLEMENTATION **************
        // *******************************************************

    }, {
        key: 'play',
        value: function play() {
            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            if (!this.onBeforePlay(props)) {
                return false;
            }
            if (!this.checkStateTransition('playing')) {
                return false;
            }

            var that = this;
            this._setState('playing');
            this.onPlay(props);

            if (!this.isOnTestMode) {
                this.requestAnimaFrame(function (timestamp) {
                    that.step(timestamp, props);
                }.bind(that));
            } else {
                this.runTimeInfo.previousTimeStamp = 0;
                this.emulateStep(props.startFrom);
            }
        }
    }, {
        key: 'complete',
        value: function complete() {
            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            _get(TimedIncident.prototype.__proto__ || Object.getPrototypeOf(TimedIncident.prototype), 'complete', this).call(this);
            this.resetState();
        }

        // timer blocking

    }, {
        key: 'wait',
        value: function wait(props, waitCallerId) {
            var previousState = this.runTimeInfo.state;
            if (_get(TimedIncident.prototype.__proto__ || Object.getPrototypeOf(TimedIncident.prototype), 'wait', this).call(this, props, waitCallerId)) {
                if (!isTimePausingState(previousState)) {
                    this.runTimeInfo.pauseMillisecond = this.runTimeInfo.currentMillisecond * 1;
                    this.runTimeInfo.pauseMoment = new Date().getTime();
                }
                return true;
            }
            return false;
        }

        // timer blocking

    }, {
        key: 'block',
        value: function block(props) {
            var previousState = this.runTimeInfo.state;
            if (_get(TimedIncident.prototype.__proto__ || Object.getPrototypeOf(TimedIncident.prototype), 'block', this).call(this, props)) {
                if (!isTimePausingState(previousState)) {
                    this.runTimeInfo.pauseMillisecond = this.runTimeInfo.currentMillisecond * 1;
                    this.runTimeInfo.pauseMoment = new Date().getTime();
                }
                return true;
            }
            return false;
        }

        // timer unblocking

    }, {
        key: 'resume',
        value: function resume(props) {
            if (_get(TimedIncident.prototype.__proto__ || Object.getPrototypeOf(TimedIncident.prototype), 'resume', this).call(this, props)) {
                var delta = new Date().getTime() - this.runTimeInfo.pauseMoment;
                this.runTimeInfo.previousTimeStamp += delta;
                this.requestAnimaFrame(this.step.bind(this));
                return true;
            }
            return false;
        }
    }, {
        key: 'reset',
        value: function reset(props) {
            if (_get(TimedIncident.prototype.__proto__ || Object.getPrototypeOf(TimedIncident.prototype), 'reset', this).call(this, props)) {
                this.resetState();
            }

            return false;
        }
    }, {
        key: 'stop',
        value: function stop(props) {
            if (_get(TimedIncident.prototype.__proto__ || Object.getPrototypeOf(TimedIncident.prototype), 'stop', this).call(this, props)) {
                return true;
            }
            return false;
        }
    }, {
        key: 'arm',
        value: function arm(props) {
            if (_get(TimedIncident.prototype.__proto__ || Object.getPrototypeOf(TimedIncident.prototype), 'arm', this).call(this, props)) {
                // sets the pause moment to the current time...
                this.runTimeInfo.pauseMoment = new Date().getTime();
                var that = this;

                this.programmaticSetPreviousTimeStamp(0);
                this.runTimeInfo.currentMillisecond = props.targetMillisecondDeltaFromStart;
                this.runTimeInfo.pauseMillisecond = this.runTimeInfo.currentMillisecond * 1;
                return true;
            }
            return false;
        }

        // *******************************************************
        // STEP FUNCTION
        // Step method is identical for Groups and thus we use the "hasIncidents" flag to check whether the Incident is a Group or a TimeIncident

    }, {
        key: 'step',
        value: function step(timestamp) {
            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

            var that = this;

            // start from is the number of milliseconds elapsed from the actual starting point of the Incident caused mainly
            // by CPU performance. (each requestAnimationFrame cirlce doesn't happen every one millisecond
            // so an Incident that was supposed to start on millisecond 100 of a Group might get fired 10 milliseconds later than
            // its actual starting point, so tth startFrom will be 10)
            if (props != null) {
                var startFrom = props.startFrom;
                if (!props.hasOwnProperty('startFrom')) {
                    if (this.direction === "forwards") {
                        startFrom = 0;
                    } else {
                        startFrom = this.duration;
                    }
                }

                if (this.speed > 0) {
                    this.runTimeInfo.previousTimeStamp = timestamp - startFrom / this.speed;
                } else {
                    this.runTimeInfo.previousTimeStamp = timestamp - (this.duration - startFrom) / Math.abs(this.speed);
                }
            }

            var informListeners = function informListeners(progress) {
                for (var key in that.listeners) {
                    var listner = that.listeners[key];
                    if (Math.abs(progress.milliseconds + listner.cavaDelta - that.runTimeInfo.currentMillisecond) > listner.threshold) {
                        listner.funct(progress.milliseconds, timestamp, helper.roundNumberTo(listner.roundTo));
                        listner.cavaDelta = 0;
                    } else {
                        listner.cavaDelta += Math.abs(progress.milliseconds - that.runTimeInfo.currentMillisecond);
                    }
                }
            };

            // helper.log('got into step on ' + this.id);
            if (this.runTimeInfo.state !== 'playing') {
                return;
            }

            // progressStep is the progress made from previousTimeStamp both in milliseconds and in fraction [0 to 1]
            var overall_progress = {
                milliseconds: Math.round(this.runTimeInfo.currentMillisecond + (timestamp - this.runTimeInfo.previousTimeStamp) * this.speed),
                fraction: (this.runTimeInfo.currentMillisecond + (timestamp - this.runTimeInfo.previousTimeStamp) * this.speed) / this.duration
            };
            // the repeatation_progress is the progress made for just the running Incident
            var timeInRepatation = overall_progress.milliseconds % this.repetationDuration - this.repeat.delay;
            if (timeInRepatation < 0) {
                // that means the current millisecond is on the delay
                timeInRepatation = 0;
            } else if (timeInRepatation > this.props.duration) {
                // that means the current millisecond is on the hiatus
                timeInRepatation = this.props.duration;
            }
            var repeatation_progress = {
                milliseconds: timeInRepatation,
                fraction: timeInRepatation / this.props.duration
                // helper.notice(`calculation properties of progress for ${this.id}`);
                // helper.log(`this.runTimeInfo.currentMillisecond: ${this.runTimeInfo.currentMillisecond}, timestamp: ${timestamp}, this.runTimeInfo.previousTimeStamp: ${this.runTimeInfo.previousTimeStamp}`)

                // helper.log(this.id, progress);

            };if (overall_progress.fraction >= 1) {
                this.onProgress(1, this.props.duration);
                informListeners({ fraction: 1, milliseconds: this.duration });
                this.complete();
                return;
            } else if (overall_progress.fraction < 0) {
                this.onProgress(0, 0);
                informListeners({ fraction: 0, milliseconds: 0 });
                this._dontTellMamaStateChange('idle');
                this.broadcastEvent('state-change', { oldState: "playing", newState: "idle" });
                this.resetState();
                return;
            }

            this.onProgress(repeatation_progress.fraction, repeatation_progress.milliseconds);

            // helper.log(this.id);
            // helper.log(this.runTimeInfo.currentMillisecond);
            // helper.log(this.id + ' progress: ', progress);
            // handle listeners
            informListeners(repeatation_progress);

            this.runTimeInfo.currentMillisecond = overall_progress.milliseconds;
            this.runTimeInfo.previousTimeStamp = timestamp;

            // helper.log(this.runTimeInfo.currentMillisecond);

            // helper.log('this.runtimeInfo.state on ' + this.id + ' = ' + this.runTimeInfo.state);
            this.requestAnimaFrame(that.step.bind(that));
        }

        // ***** PUB SUB ***********
        // *************************

        /** Scene is responsible for knowing the time of it at any given moment. Also it acts as the single pipeline
          that transfers play, wait, resume, goto requests from to its Incidents.
          Scene is responsible for distributing the time information to any interested party
           In order for any Class / module to be aware about the time of any Scene it should subscribe to its dispatch functions
          By subscribing a module can get notified about changes on the Scene's time
           subscribe method subscribes a function to the time change dispatcher. As Scene uses requestAnimationFrame for its timing
          each cyrcle / step gets the current time and subtracts the previous time so it know how many milliseconds has elapsed
          since last step. Subscribers can set to get informed about time changes only if the delta is greater than a given
          number (e.g. greater than 300ms). That property is passed as the second argument "threshold".
          Finally if any of the subscribers want the Scene to provide back a rounded number of the milliseconds. Options:
            - 1 (round it on its actual units
           - 10 (round it on tenths)
           - 100 (round it on hundreds)
           - 1000 (round it on thousands)
           the first argument provides an id to the listener for future reference (deletion etc)
          the second argument is a function that takes two arguments: millisecond, state (current millisecond of the Scene
          and the state of it  */

    }, {
        key: 'subscribe',
        value: function subscribe(id, funct, threshold, roundTo) {
            if (!threshold) {
                threshold = 0;
            }
            if (!roundTo) {
                roundTo = 1; // round second to its units, meaning leave it as it is
            }
            this.listeners[id] = {
                funct: funct,
                threshold: threshold,
                roundTo: roundTo,
                cavaDelta: 0
            };
        }

        /**
         * This method's (which should be called whenever a slip ends) purpose is to calculate and set
         * the right state of the Incident based on the target millisecond.
         * The parameter it takes is relative to the beginning of the Incident itself and it might be negative
         * Negative targetMillisecond means the target millisecond is N milliseconds BEFORE the start of the Incident
         * @param {int} targetMillisecondDeltaFromStart - the delta of the target millisecond compared to the Incident start
         */

    }, {
        key: 'recalcState',
        value: function recalcState() {
            var targetMillisecondDeltaFromStart = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

            if (targetMillisecondDeltaFromStart === null) {
                targetMillisecondDeltaFromStart = this.runTimeInfo.currentMillisecond;
            }
            // helper.log('recalculating state for Incident: ' + this.id, targetMillisecondDeltaFromStart);
            if (targetMillisecondDeltaFromStart >= this.duration) {
                // if it ends before the targetMillisecond
                // helper.log('completes');
                this.statusBeforeHalt = "completed";
                this.runTimeInfo.currentMillisecond = this.duration;
                this._dontTellMamaStateChange('completed');
            } else if (targetMillisecondDeltaFromStart <= this.duration && targetMillisecondDeltaFromStart > 0) {
                // if the targetMillisecond is in the middle of it
                if (this.state === 'playing') {
                    return;
                }
                this.statusBeforeHalt = "playing";
                this.arm({ targetMillisecondDeltaFromStart: targetMillisecondDeltaFromStart });
            } else if (targetMillisecondDeltaFromStart <= 0) {
                // if it has been completed on targetMillisecond
                // helper.log('resets to idle');
                this.statusBeforeHalt = "idle";
                this.runTimeInfo.currentMillisecond = 0;
                this._dontTellMamaStateChange('idle');
                this.resetState();
            }
        }

        /**
         * Method called on progress of the timed incident.
         * @param {float} fraction - a number from 0 to 1 representing the fraction of duration covered
         * @param {int} milliseconds - the number of milliseconds passed from start of the incident
        */

    }, {
        key: 'onProgress',
        value: function onProgress(fraction, milliseconds) {}

        /**
         * This method is the all external parties should call when they want to force the Incident to progress
         * on a specific fraction & millisecond
         * @param {float} fraction - a number from 0 to 1 representing the fraction of duration covered
         * @param {int} milliseconds - the number of milliseconds passed from start of the incident
        */

    }, {
        key: 'progress',
        value: function progress(fraction, millisecond) {
            if (fraction >= 1) {
                this.onProgress(1, this.props.duration);
                return;
            }
            // the repeatation_progress is the progress made for just the running Incident
            // the repeatation_progress is the progress made for just the running Incident
            var timeInRepatation = millisecond % this.repetationDuration - this.repeat.delay;
            if (timeInRepatation < 0) {
                // that means the current millisecond is on the delay
                timeInRepatation = 0;
            } else if (timeInRepatation > this.props.duration) {
                // that means the current millisecond is on the hiatus
                timeInRepatation = this.props.duration;
            }

            var repeatation_progress = {
                milliseconds: timeInRepatation,
                fraction: timeInRepatation / this.props.duration
            };
            this.onProgress(repeatation_progress.fraction, repeatation_progress.milliseconds);
        }
    }, {
        key: 'beOn',
        value: function beOn(millisecond) {
            var beOnResult = _get(TimedIncident.prototype.__proto__ || Object.getPrototypeOf(TimedIncident.prototype), 'beOn', this).call(this, millisecond);
            if (beOnResult.previousState === "playing" && beOnResult.newState === "waiting") {
                this.resume();
                beOnResult.newState = "playing";
            }
            return beOnResult;
        }
    }, {
        key: 'duration',
        get: function get() {
            return this.repeat.times * (this.props.duration + this.repeat.delay + this.repeat.hiatus);
        }

        /**
         * All TimedIncidents must implement the duration setter method
        **/
        ,
        set: function set(duration) {
            var durationFraction = duration / this.duration;
            this.props.duration = this.props.duration * durationFraction;
            this.repeat.delay = this.repeat.delay * durationFraction;
            this.repeat.hiatus = this.repeat.hiatus * durationFraction;
        }
    }]);

    return TimedIncident;
}(Incident);

module.exports = TimedIncident;