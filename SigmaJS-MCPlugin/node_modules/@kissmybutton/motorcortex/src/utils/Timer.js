const Helper = require('../_coreUtils/Helper');
const helper = new Helper();
const conf = require('../configuration/generalConf');
const Draggabilly = require('draggabilly');
const TimeCapsule = require('../_coreUtils/TimeCapsule');
const timeCapsule = new TimeCapsule();
let journey = null;

/**
 * @classdesc
 * Timer's purpose is to provide an interface through which any TimedIncident (such as a Scene or a Clip)
 * can both privide info regarding their timing state but also provide an interface for interacting /
 * altering the timing of it
 */
class Timer {
    constructor(props) {
        this.id = props.id || helper.getAnId();
        this.cursor = document.getElementById('time-cursor');
        this.leftSlot = document.getElementsByClassName('left-slot')[0];
        this.rightSlot = document.getElementsByClassName('right-slot')[0];
        this.playButton = document.getElementById('play-pause');
        this.Incident = props.Incident;
        this.subscribeToTimer();
        this.subscribeToEvents();
        this.afterRender();
        this.previousTimestamp = 0;
        this.previousIncidentState = 'idle';
        this.width = props.width;
        this.cursorWidth = props.cursorWidth || 10;
    }

    millisecondChange(millisecond, state) {
        // helper.log(millisecond);
        this.cursor.style.left = `calc(${millisecond * 100 / this.Incident.duration}% - ${this.cursorWidth}px)`;
        this.leftSlot.innerHTML = millisecond;
        this.rightSlot.innerHTML = this.Incident.duration - millisecond;
    }

    eventBroadcast(eventName, meta) {
        if (eventName === 'state-change') {
            if (meta.newState === 'waiting') {
                this.playButton.innerHTML = 'Resume';
            } else if (meta.newState === 'playing') {
                this.playButton.innerHTML = 'Pause';
            } else if (meta.newState === 'completed') {
                this.leftSlot.innerHTML = this.Incident.duration;
                this.rightSlot.innerHTML = 0;
                this.playButton.innerHTML = "completed";
                helper.log(this.Incident);
            } else if(meta.newState === 'transitional'){
                this.playButton.innerHTML = "transitioning";
            } else if(meta.newState === 'idle'){
                this.playButton.innerHTML = "Play";
            }
        } else if(eventName === 'attribute-rejection'){
            helper.log('Attributes', meta.attributes, 'have been rejected from animation with id ' + meta.animationID);
        } else if(eventName === 'animation-rejection'){
            helper.log('Animation ' + meta.animationID + ' has been rejected as all attributes of it overlap on specific elements because of existing animations');
        } else if(eventName === 'duration-change'){
            this.millisecondChange(this.Incident.runTimeInfo.currentMillisecond, this.Incident.state);
        }
    }

    subscribeToEvents() {
        // helper.error('Timer is subscirbing to the clips events');
        this.Incident.subscribeToEvents(this.id, this.eventBroadcast.bind(this));
    }

    subscribeToTimer() {
        // helper.log('Timer is subscirbing to the clips timer', 'notice');
        this.Incident.subscribe(this.id, this.millisecondChange.bind(this));
    }

    handleDragStart(event, pointer) {
        // helper.log('drag is starting', 'warning')
        journey = timeCapsule.startJourney(this.Incident);
    }

    handleDrag(event, pointer, position) {
        let millisecond = Math.round(this.Incident.duration * position.x / this.width);
        if(millisecond < 0){
            millisecond = 0;
        }
        this.leftSlot.innerHTML = millisecond;
        this.rightSlot.innerHTML = this.Incident.duration - millisecond;
        
        journey.station(millisecond);
    }

    handleDragEnd(event, pointer) {
        //  Velocity.defaults.speed=1;
        // this.previousTimestamp is the target millisecond of the drag
        
        journey.destination();
        
        helper.log(this.Incident.exportState());
    }


    afterRender() {
        const that = this;

        this.playButton.onclick = e => {
            if (that.Incident.state === 'playing') {
                that.Incident.wait();
            } else if (that.Incident.state === 'waiting') {
                that.Incident.resume();
            } else if (that.Incident.state === 'idle') {
                that.Incident.play();
            }
        };

        const elem = document.querySelector('#time-cursor');
        const draggie = new Draggabilly(elem, {
            axis: 'x',
            containment: '.bar'
        });

        draggie.on('dragStart', this.handleDragStart.bind(this));
        draggie.on('dragMove', (event, pointer) => {
            that.handleDrag(event, pointer, draggie.position);
        });
        draggie.on('dragEnd', this.handleDragEnd.bind(this));
    }

    render(container) {}
}

module.exports = Timer;
