const Incident = require('./Incident');
const Helper = require('../_coreUtils//Helper');
const helper = new Helper();
const isTimePausingState = require('../configuration/allowedStateChanges').isTimePausingState;

/** @classdesc
 * A TimedIncident is an incident that lasts some time. It has duration and a timer of its own. It can take all the states.
 *
 */
class TimedIncident extends Incident {
    constructor(attrs={}, props = {}) {
        super(attrs, props);
        
        /**
         * @member {object} - repeat
         * - times: the repeatFactor property defines the times an Incident should be executed repeatedly.
         * For Bit Inicdents this is not acceptable as Bit Incidents have 0 duration and thus positioning them on a chain
         * the one after the other doesn't make sense.
         * This property has practical value on TimedIncidents.
         * In any case the default value of this member is 1 and it can only accept unsigned integer values
         * - delay: the left gap in milliseconds
         * - gap: the right gap in milliseconds
        */
        this.repeat = {
            times: 1,
            delay: 0,
            hiatus: 0
        }
        this.repetationDuration = this.props.duration;
        if(props.hasOwnProperty('repeat')) {
            if(props.repeat.hasOwnProperty('times')){
                this.repeat.times = props.repeat.times; 
            }
            if(props.repeat.hasOwnProperty('delay')){
                this.repeat.delay = props.repeat.delay; 
                this.repetationDuration += props.repeat.delay;
            }
            if(props.repeat.hasOwnProperty('hiatus')){
                this.repeat.hiatus = props.repeat.hiatus; 
                this.repetationDuration += props.repeat.hiatus;
            }
        }

        this.resetState();

        /**
          @member {object} - listeners are functions to be executed on time change of the Timed Incident. It has the following format:


         listeners: {
            listener_id: {
                     funct : the function to be executed
                     threshold : the threshold of delta
                     roundTo : round millisecond
                 },
                 listener_id: {
                     funct : the function to be executed
                     threshold : the threshold of delta
                     roundTo : round millisecond
                 },
                 ...
           }
           */
        this.listeners = {};

        this.bitIncident = false;
    }


    requestAnimaFrame(fn) {
        /* if the Incident is on test mode we want to prevent requestAnimationFrame as execution
            during testing is controlled through emulateStep method */
        if(this.isOnTestMode){
            return ()=>{};
        }

        try {
            return this.context.window.requestAnimationFrame(fn);
        } catch(e){
            helper.error('Your browser does not support requestAnimationFrame');
            return (fn)=>{};
        }
    }

    /**
     * when the Incident is on test mode (this.isOnTestMode = true) the emulateStep method
     * becomes functional.
     * The method takes as input the millisecondsDelta from the previous timestamp and triggers
     * the step function passing in a baked timestamp so the Incident behaves exactly as if the requestAnimationFrame run
     * passing a timestamp that has exactly millisecondsDelta difference from the previous one
     * @param {int} millisecondsDelta - the milliseconds difference between the previous timestamp and the new one
    */
    emulateStep(millisecondsDelta){
        if(!this.isOnTestMode){
            helper.error('emulateStep method can only be used on test mode');
        } else {
            this.step(this.runTimeInfo.previousTimeStamp + millisecondsDelta);
        }
    }

    /**
     * All TimedIncidents must implement the get duration method
    **/
    get duration() {
        return this.repeat.times * (this.props.duration + this.repeat.delay + this.repeat.hiatus);
    }  

    /**
     * All TimedIncidents must implement the duration setter method
    **/
    set duration(duration){
        const durationFraction = duration / this.duration;
        this.props.duration = this.props.duration*durationFraction;
        this.repeat.delay = this.repeat.delay * durationFraction;
        this.repeat.hiatus = this.repeat.hiatus * durationFraction;
    }


    /**
     * checks if a duration edit is feasible and doesn't cause conflicts
     * @param {int} duration - the new duration
    **/
    checkResizedIncident(durationFraction, incident, adjustMillisecond=0){
        if(this.isHeadlessClip){
            return {result: true, execute: function(){}};
        } else { // IF THE GROUP HAS NO PARENT (ACT AS THE CLIP)
            return this.parentSceneObject.checkResizedIncident(durationFraction, incident, adjustMillisecond + this.parentSceneObject.getIncidentMillisecond(this.id));
        }
    }


    /**
     * Edits the total duration of the Incident, as this is calculated based on the sum of delay, duration and hiatus
     * @param {int} duration - the new duration in milliseconds
    **/
    resize(duration){
        // console.trace();
         // don't waste cpu resources if the new duration equals the current value
        if(duration === this.duration){
            return {result: true};
        } else if(duration <= 0){
            helper.error('resizeIncident method of Scene only accepts integers > 0 as the new duration of the Scene. ' + duration + ' provided.');
            return {
                result: false,
            }
        }
        // stop the execution
        this.stop();

        const editCheck = this.checkResizedIncident(duration/this.duration, this);

        if(editCheck.result === false){
            helper.error(editCheck);
            return editCheck;
        }

        this.systolDiastole(duration/this.duration);
        editCheck.execute();

        if(this.checkParentScene()){
            this.parentSceneObject.getDurationAfterIncidentAffected();
        }
        this.broadcastEvent('duration-change', { newDuration: this.duration });
        return {result: true};
    }
    
    /**
     * This method edits the duration params. As "duration params" we define:
     * - the props.duration
     * - the props.repeat (with all of its keys: times, delay, hiatus)
     * @param {object} params - An object that accepts at least one of the following keys:
     * - duration
     * - times
     * - delay
     * - hiatus
    */
    editDurationParams(params) {
        // stop the execution
        this.stop();
        
        // calculate the new values for props.duration and props.repeat
        let newPropsDuration = this.props.duration;
        if(params. hasOwnProperty('duration')) {
            newPropsDuration = params.duration;
        }
        let newRepeat = JSON.parse(JSON.stringify(this.repeat));
        if(params.hasOwnProperty('times')) {
            newRepeat.times = params.times;
        }
        if(params.hasOwnProperty('delay')) {
            newRepeat.delay = params.delay;
        }
        if(params.hasOwnProperty('hiatus')) {
            newRepeat.hiatus = params.hiatus;
        }
        
        // calculate the new total duration
        const newTotalDuration = newRepeat.times * (newPropsDuration + newRepeat.delay + newRepeat.hiatus);
        
        // check the edit
        let editCheck = {
            result: true,
            execute: function(){}
        };
        if(newTotalDuration != this.duration){
            editCheck = this.checkResizedIncident(newTotalDuration/this.duration, this);
        }
        
        if(editCheck.result === false){
            helper.error(editCheck);
            return editCheck;
        }

        // update the Incident's values
        this.props.duration = newPropsDuration;
        this.repeat = newRepeat;
        
        editCheck.execute();

        if(this.checkParentScene() && newTotalDuration != this.duration){
            this.parentSceneObject.getDurationAfterIncidentAffected();
            this.broadcastEvent('duration-change', { newDuration: this.duration });
        }
        
        return {result: true};
    }


    systolDiastole(durationFraction){
        this.duration = this.duration*durationFraction;
    }


    resetState(){
        super.resetState();
        // the current millisecond having as 0 the start of the animation
        if(this.state === 'idle')
            this.runTimeInfo.currentMillisecond = 0; // the current millisecond of the incident as it's calculated based on the speed of the Incident
        else if(this.state === 'completed')
            this.runTimeInfo.currentMillisecond = this.duration;
                                                    // in other words the millisecond that the Incident is on the UI
        this.runTimeInfo.start = null; // the millisecond started as provided by requestAnimationFrame
        this.runTimeInfo.previousTimeStamp = null; // the timestamp of the previous circle as provided by requestAnimationFrame
        this.runTimeInfo.pauseMoment = null; // the pause moment as provided by new Date().getTime()
        this.runTimeInfo.pauseMillisecond = 0; // the pauseMillisecond is the current millisecond at the pause moment
        for(let key in this.listeners){
            this.listeners[key].cavaDelta = 0;
        }
    }

    /**
     * This method calculates the previousTimeStamp based on the target UI millisecond we want to go to and
     * the speed of the Incident.
     * E.g. if targetUIMillisecond = 2000 and speed =2 then we will take the timestamp from requestAnimationFrame (ra_stamp) and
     * set the previousMillisecond to ra_stamp-1000
     * @param {int} currentMIllisecond - the millisecond to which we want our Inicdent to be on
    */
    programmaticSetPreviousTimeStamp(targetUIMillisecond){
        const that = this;

        if(this.isOnTestMode){
            that.runTimeInfo.previousTimeStamp = 0;
        }

        this.requestAnimaFrame(timestamp => {
            that.runTimeInfo.previousTimeStamp = timestamp - targetUIMillisecond/this.speed;
        });
    }

    // ******** INCIDENT METHODS IMPLEMENTATION **************
    // *******************************************************
    play(props={}) {
        if(!this.onBeforePlay(props)){
            return false;
        }
        if (!this.checkStateTransition('playing')) {
            return false;
        }

        const that = this;
        this._setState('playing');
        this.onPlay(props);

        if(!this.isOnTestMode){
            this.requestAnimaFrame(function(timestamp){
                that.step(timestamp, props);
            }.bind(that));
        } else {
            this.runTimeInfo.previousTimeStamp = 0;
            this.emulateStep(props.startFrom);
        }
    }

    complete(props = {}) {
        super.complete();
        this.resetState();
    }

    // timer blocking
    wait(props, waitCallerId) {
        const previousState = this.runTimeInfo.state;
        if (super.wait(props, waitCallerId)) {
            if (!isTimePausingState(previousState)) {
                this.runTimeInfo.pauseMillisecond = this.runTimeInfo.currentMillisecond*1;
                this.runTimeInfo.pauseMoment = new Date().getTime();
            }
            return true;
        }
        return false;
    }

    // timer blocking
    block(props) {
        const previousState = this.runTimeInfo.state;
        if (super.block(props)) {
            if (!isTimePausingState(previousState)) {
                this.runTimeInfo.pauseMillisecond = this.runTimeInfo.currentMillisecond*1;
                this.runTimeInfo.pauseMoment = new Date().getTime();
            }
            return true;
        }
        return false;
    }

    // timer unblocking
    resume(props) {
        if (super.resume(props)) {
            const delta = new Date().getTime() - this.runTimeInfo.pauseMoment;
            this.runTimeInfo.previousTimeStamp += delta;
            this.requestAnimaFrame(this.step.bind(this));
            return true;
        }
        return false;
    }

    reset(props) {
        if (super.reset(props)) {
            this.resetState();
        }

        return false;
    }

    stop(props) {
        if (super.stop(props)) {
            return true;
        }
        return false;
    }

    arm(props) {
        if (super.arm(props)) {
            // sets the pause moment to the current time...
            this.runTimeInfo.pauseMoment = new Date().getTime();
            const that = this;


            this.programmaticSetPreviousTimeStamp(0);
            this.runTimeInfo.currentMillisecond =  props.targetMillisecondDeltaFromStart;
            this.runTimeInfo.pauseMillisecond = this.runTimeInfo.currentMillisecond*1;
            return true;
        }
        return false;
    }

    // *******************************************************
    // STEP FUNCTION
    // Step method is identical for Groups and thus we use the "hasIncidents" flag to check whether the Incident is a Group or a TimeIncident
    step(timestamp, props=null) {
        const that = this;

        // start from is the number of milliseconds elapsed from the actual starting point of the Incident caused mainly
        // by CPU performance. (each requestAnimationFrame cirlce doesn't happen every one millisecond
        // so an Incident that was supposed to start on millisecond 100 of a Group might get fired 10 milliseconds later than
        // its actual starting point, so tth startFrom will be 10)
        if(props != null){
            let startFrom = props.startFrom;
            if(!props.hasOwnProperty('startFrom')){
                if(this.direction === "forwards"){
                   startFrom = 0;
                } else {
                    startFrom = this.duration;
                }
            }

            if(this.speed > 0){
               this.runTimeInfo.previousTimeStamp = timestamp - startFrom/this.speed;
            } else {
                this.runTimeInfo.previousTimeStamp = timestamp - (this.duration - startFrom)/Math.abs(this.speed);
            }
        }

        const informListeners = (progress)=>{
            for (const key in that.listeners) {
                const listner = that.listeners[key];
                if (Math.abs(progress.milliseconds + listner.cavaDelta - that.runTimeInfo.currentMillisecond) > listner.threshold) {
                    listner.funct(progress.milliseconds, timestamp, helper.roundNumberTo(listner.roundTo));
                    listner.cavaDelta = 0;
                } else {
                    listner.cavaDelta += Math.abs(progress.milliseconds - that.runTimeInfo.currentMillisecond);
                }
            }
        }

        // helper.log('got into step on ' + this.id);
        if (this.runTimeInfo.state !== 'playing') {
            return;
        }

        // progressStep is the progress made from previousTimeStamp both in milliseconds and in fraction [0 to 1]
        const overall_progress = {
            milliseconds: Math.round(this.runTimeInfo.currentMillisecond + (timestamp - this.runTimeInfo.previousTimeStamp)*this.speed),
            fraction: (this.runTimeInfo.currentMillisecond + (timestamp - this.runTimeInfo.previousTimeStamp)*this.speed)/this.duration
        };
        // the repeatation_progress is the progress made for just the running Incident
        let timeInRepatation = (overall_progress.milliseconds % this.repetationDuration) - this.repeat.delay;
        if(timeInRepatation < 0) { // that means the current millisecond is on the delay
            timeInRepatation = 0;
        } else if(timeInRepatation > this.props.duration) { // that means the current millisecond is on the hiatus
            timeInRepatation = this.props.duration;
        }
        const repeatation_progress = {
            milliseconds: timeInRepatation,
            fraction: timeInRepatation / this.props.duration
        }
        // helper.notice(`calculation properties of progress for ${this.id}`);
        // helper.log(`this.runTimeInfo.currentMillisecond: ${this.runTimeInfo.currentMillisecond}, timestamp: ${timestamp}, this.runTimeInfo.previousTimeStamp: ${this.runTimeInfo.previousTimeStamp}`)

        // helper.log(this.id, progress);

        if(overall_progress.fraction >= 1){ 
            this.onProgress(1, this.props.duration);
            informListeners({fraction:1, milliseconds:this.duration});
            this.complete();
            return ;
        } else if(overall_progress.fraction < 0){
            this.onProgress(0, 0);
            informListeners({fraction:0, milliseconds:0});
            this._dontTellMamaStateChange('idle');
            this.broadcastEvent('state-change', { oldState: "playing", newState: "idle" });
            this.resetState();
            return ;
        }

        this.onProgress(repeatation_progress.fraction, repeatation_progress.milliseconds);

        // helper.log(this.id);
        // helper.log(this.runTimeInfo.currentMillisecond);
        // helper.log(this.id + ' progress: ', progress);
        // handle listeners
        informListeners(repeatation_progress);

        this.runTimeInfo.currentMillisecond = overall_progress.milliseconds;
        this.runTimeInfo.previousTimeStamp = timestamp;

        // helper.log(this.runTimeInfo.currentMillisecond);

        // helper.log('this.runtimeInfo.state on ' + this.id + ' = ' + this.runTimeInfo.state);
        this.requestAnimaFrame(that.step.bind(that));
    }

    // ***** PUB SUB ***********
    // *************************

    /** Scene is responsible for knowing the time of it at any given moment. Also it acts as the single pipeline
      that transfers play, wait, resume, goto requests from to its Incidents.
      Scene is responsible for distributing the time information to any interested party

      In order for any Class / module to be aware about the time of any Scene it should subscribe to its dispatch functions
      By subscribing a module can get notified about changes on the Scene's time

      subscribe method subscribes a function to the time change dispatcher. As Scene uses requestAnimationFrame for its timing
      each cyrcle / step gets the current time and subtracts the previous time so it know how many milliseconds has elapsed
      since last step. Subscribers can set to get informed about time changes only if the delta is greater than a given
      number (e.g. greater than 300ms). That property is passed as the second argument "threshold".
      Finally if any of the subscribers want the Scene to provide back a rounded number of the milliseconds. Options:
        - 1 (round it on its actual units
       - 10 (round it on tenths)
       - 100 (round it on hundreds)
       - 1000 (round it on thousands)

      the first argument provides an id to the listener for future reference (deletion etc)
      the second argument is a function that takes two arguments: millisecond, state (current millisecond of the Scene
      and the state of it  */
    subscribe(id, funct, threshold, roundTo) {
        if (!threshold) {
            threshold = 0;
        }
        if (!roundTo) {
            roundTo = 1; // round second to its units, meaning leave it as it is
        }
        this.listeners[id] = {
            funct: funct,
            threshold: threshold,
            roundTo: roundTo,
            cavaDelta: 0
        };
    }


    /**
     * This method's (which should be called whenever a slip ends) purpose is to calculate and set
     * the right state of the Incident based on the target millisecond.
     * The parameter it takes is relative to the beginning of the Incident itself and it might be negative
     * Negative targetMillisecond means the target millisecond is N milliseconds BEFORE the start of the Incident
     * @param {int} targetMillisecondDeltaFromStart - the delta of the target millisecond compared to the Incident start
     */
    recalcState(targetMillisecondDeltaFromStart=null) {
        if(targetMillisecondDeltaFromStart === null){
            targetMillisecondDeltaFromStart = this.runTimeInfo.currentMillisecond;
        }
        // helper.log('recalculating state for Incident: ' + this.id, targetMillisecondDeltaFromStart);
        if (targetMillisecondDeltaFromStart >= this.duration) {
            // if it ends before the targetMillisecond
            // helper.log('completes');
            this.statusBeforeHalt = "completed";
            this.runTimeInfo.currentMillisecond = this.duration;
            this._dontTellMamaStateChange('completed');
        } else if (
            targetMillisecondDeltaFromStart <= this.duration &&
            targetMillisecondDeltaFromStart > 0
        ) {
            // if the targetMillisecond is in the middle of it
            if(this.state === 'playing'){
                return ;
            }
            this.statusBeforeHalt = "playing";
            this.arm({ targetMillisecondDeltaFromStart: targetMillisecondDeltaFromStart });
        } else if (targetMillisecondDeltaFromStart <= 0) {
            // if it has been completed on targetMillisecond
            // helper.log('resets to idle');
            this.statusBeforeHalt = "idle";
            this.runTimeInfo.currentMillisecond = 0;
            this._dontTellMamaStateChange('idle');
            this.resetState();
        }
    }

    /**
     * Method called on progress of the timed incident.
     * @param {float} fraction - a number from 0 to 1 representing the fraction of duration covered
     * @param {int} milliseconds - the number of milliseconds passed from start of the incident
    */
    onProgress(fraction, milliseconds){

    }
    
    /**
     * This method is the all external parties should call when they want to force the Incident to progress
     * on a specific fraction & millisecond
     * @param {float} fraction - a number from 0 to 1 representing the fraction of duration covered
     * @param {int} milliseconds - the number of milliseconds passed from start of the incident
    */
    progress(fraction, millisecond) {
        if(fraction >= 1){
            this.onProgress(1, this.props.duration);
            return ;
        }
        // the repeatation_progress is the progress made for just the running Incident
        // the repeatation_progress is the progress made for just the running Incident
        let timeInRepatation = (millisecond % this.repetationDuration) - this.repeat.delay;
        if(timeInRepatation < 0) { // that means the current millisecond is on the delay
            timeInRepatation = 0;
        } else if(timeInRepatation > this.props.duration) { // that means the current millisecond is on the hiatus
            timeInRepatation = this.props.duration;
        }

        const repeatation_progress = {
            milliseconds: timeInRepatation,
            fraction: timeInRepatation / this.props.duration
        }
        this.onProgress(repeatation_progress.fraction, repeatation_progress.milliseconds);
    }

    beOn(millisecond){
        const beOnResult = super.beOn(millisecond);
        if(beOnResult.previousState ===  "playing" && beOnResult.newState === "waiting"){
            this.resume();
            beOnResult.newState = "playing";
        }
        return beOnResult;
    }

}

module.exports = TimedIncident;
