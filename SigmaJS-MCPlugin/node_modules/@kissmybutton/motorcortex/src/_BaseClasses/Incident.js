const Helper = require('../_coreUtils/Helper');
const checkTransition = require('../configuration/allowedStateChanges').checkTransition;
const helper = new Helper();
const Channel = require('../_Channels/Channel');
const pipeMessges = require('../configuration/pipesConf');
const generalConf = require('../configuration/generalConf');

/** @classdesc
 * Incidents are all events that should happen on a specific time on the timeline. An incident can have parametric
      execution behaviour based on the times it has been executed and (might be) on other parameters.

      The state an Incident can have is one of the following:
                 idle
                 playing
                 waiting
                 sceneBlockingWaiting
                 clipBlockingWaiting
                 blocked    // in the case the Incident is blocked / paused by a waiting
                 completed

      Each Incident has the obligation to inform the Scene about its state changes.
      For this Incident provides the method “setParentScene” which takes just one argument a Timer object.
      Timer provides the method “incidentStateChange” which lets the Incidents change their state by
      providing their id and their new state.
 * */
class Incident {
    /**
     It takes just one argument, "props". Props pass data useful only for the following:
     An incident can be set to be either inexhaustible (meaning it can be executed again and again infinite times -- default)
     or finite meaning it can only be executed a limited (specific) number of times. This info can be found on the maxLifeCycles
     Of course the incident can be reset to its initial condition at any time through the "reset" method it provides.

     As a luxuriousness, and along WITH the maxLifeCycles parameter, the Incident also provides the executionPattern parameter
     through which the programmer / user can define a more complex behaviour of the Incident execution depending on the number times
     the incident has alrady be executed ( is the 1st time, the 2nd time, the 3rd time etc) and any custom parameter it
     holds. The execution times are held on the "executionTimes" attribute of the class.

     props:
     {
        id: if passed that's the id of the Incident. If not we create a new one
        plugin_channel_class - if passed gets set to it
        mc_plugin_npm_name - if passed gets set to it
        
     }


      @param {object} props */
    constructor(attrs={}, props = {}) {
        this.attrs = attrs;
        this.props = props;
        
        // auto-generated id. This parameter indicates whether the id of the Incident was given by the user or 
        // it was auto-generated by MC. Auto-generated ids do not get checked for duplicates on checkAddition 
        // process, for the shake of performance
        this.autoGeneratedID = false;
        if(!props.hasOwnProperty('id') && props.autogeneratedID != true){
           this.autoGeneratedID = true; 
        }
        this.id = props.id || helper.getAnId();
        
        // this parameter is initialised to false. Once the onGetContext method gets invoked this parameter
        // is set to true so we prevent multiple executions of the onGetContext method
        this.gotContext = false;

        /*
        these are the default values that define channeling for the default Incidents. These values get ovewriden through
        the loadPlugin method of MC with the values found on the main.js file of the plugin
        */
        this.plugin_channel_class = Channel;
        this.mc_plugin_npm_name = "motor-cortex-js";
        if(props.hasOwnProperty('plugin_channel_class')){
            this.plugin_channel_class = props.plugin_channel_class;
        }
        if(props.hasOwnProperty('mc_plugin_npm_name')){
            this.mc_plugin_npm_name = props.mc_plugin_npm_name;
        }

        /* 
        The following two properties ("statusBeforeHalt" and "stateBeforeStop") which have stupidly 
        used "status" in the one case and "state" in the other
        act as the memory of the Incident in the case of a stop or
        a halting command (wait or block), storing the state of it just before any of the two get 
        executed. 
        These properties can be used in various ways in the program
        and they do not target specific functionality.
        */
        // the status of the Incident before it got halted by either the block or the wait command
        this.statusBeforeHalt = 'idle'; 
        // holds the state of the Incident before the stop command
        this.stateBeforeStop = 'idle';
        
        this.timesExecuted = 0;
        this.parentSceneObject = null;

        this.runTimeInfo = {
            state: 'idle' // one of "idle", "playing", "waiting"
        };

        this.bitIncident = true;
        this.hasIncidents = false;

        /* an array holding all  */
        this.eventsSubscriptions = {};

        /*
        Right now many keys of the Incident (such as "props", "attrs", etc) are already been used by the Incident 
        class. The final users of the library (the plugin developers) might want to keep special / specific data
        on their Incidents and:
        a) they might don't know which keys are already taken and which are not
        b) might use an already used key and ruin the functionality
        c) so they feel unsafe keeping data and it's not safe for the lib too
        For this reason we have a blank object reserved for them, the "customParams", in order for them to 
        put anything they want and we encourage them to use the built-in methods:
        setParam
        getParam
        setParams
        for this job
        */
        this.customParams = {};

        this.speed = 1;

        /*
        initialValues is an object holding the autmatically computed initial values of the animatedAttrs 
        (if any). The initialValues are calculated by the AttributesChannel (only Incidents belonging to 
        an AttributesChannel have initialValues).
        The keys set of this object is identical to the object attrs.animatedAttrs 
        The only thing the generic AttributesChannel can't calculate is the initial value of an animated attr
        of a specific element when there are no other Incidents entered on its lanes yet. These values are
        the "scratchValues" and they are strongly dependend on the nature of the lib. E.g. for a CSS animation
        what we are looking for can be found on the computedStyle.
        */
        this.initialValues = {};
        
        /*
        The user has the ability to explicitely define the initial values for any of the animatedAttrs. The user
        can do that by providing the initialValues object on the attrs of the constructor.
        */
        this.userDefinedInitialValues = {};
        if(attrs != null && attrs != undefined){
            if(attrs.hasOwnProperty('initialValues')){
                this.userDefinedInitialValues = attrs.initialValues;
            }
        }
        

        /*
        blockingWaitings is an array, a collection, of blocing waitings that have the Scene as target.
        The logic is simple:
        - if the scene receives a "sceneBlockingWaiting" then it is the target and it adopts it
        - if the scene receives a "channelBlockingWaiting" then if it is a channel it adopts it otherwise it tries to
            pass it further up until it finds a channel
        - if the scene receives a "clipBlockingWaiting" if it is the Clip it adopts it otherwise it tries to pass it
            further up until it reaches the clip
        Each object on this array represents a blocking waiting triggered by a child of the Scene
            and which targets the Scene itself.
        Each child signs the blocking waiting by assigning its own id to it. Each child can only assign just one
            blocking waiting at a time.
        The structure of each blocking waiting appearing on this array is the following:
        {
            id: the-signature-of-the-triggering-incident,
            type: any of the sceneBlockingWaiting / channelBlockingWaiting / ClipBlockingWaiting,
            nature: any of the scheduled / dynamic / system-problem
        }
        */
        this.blockingWaitings = [];

        /**
        * @member {boolean} - if testingMode is set to true the requestAnimationFrame method is not going
        * to get executed automatically but instead the emaulateStep method will start functioning allowing
        * developers to pass the milliseconds difference from the previous timestamp manually
        **/
        this.testMode = false;
        if(props.hasOwnProperty('testMode')){
            this.testMode = props.testMode;
        }

        if(props.hasOwnProperty('initialValues')){
            this.initialValues = props.initialValues;
        }
        
        /**
         * @member {boolean} - if autoGenerated is set to true, it means that this Incident has been auto-generated by its parent on initialisation.
         * This happens when plugins export Incidents that on initialisation they automatically create other incidents and automatically put them 
         * on specific points on their timeline. 
         * In such cases we don't want these Incidents to be exported on getState with unprocessed = true and this because they will be re-generated
         * automatically on the clip's reconstruction process based on the exported json. 
        */
        this.autoGenerated = false;

        this.onInitialise(attrs, props);
    }

    get isOnTestMode(){
        if(this.checkParentScene()){
            return this.parentSceneObject.isOnTestMode;
        } else {
            return this.testMode;
        }
    }

    get selector(){
        return this.props.selector;
    }
    
    /* shortcuts for attrs.attrs and attrs.animatedAttrs */
    get animAttributes(){
        return this.attrs.animatedAttrs;
    }
    
    get confAttributes(){
        return this.attrs.attrs;
    }
    
    get isHeadlessClip(){
        return !this.checkParentScene();
    }
    
    get context(){
        if(this.isHeadlessClip){
            return null;
        } else {
            return this.parentSceneObject.context;
        }
    }

    /**
    This method shoudl be overwritten by the Incidents of the plugins. The method accepts
    as arguments the mcid (an element) and the attribue (one of the animatedAttrs, if any)
    and return the initial value of them as the library calculates / defines them. The 
    returned value represents the very initial value of the element's attribute before
    any Incident that alters it gets added.
    @param {string} mcid
    @param {string} attribute
    @returns {mixed} - the initial value of the element's attribute just when the HTML & CSS
    of the Clip gets rendered
    */
    getScratchValue(mcid, attribute){
        return 0;
    }

    get element(){
        if(this.contex === null){
            return [];
        }
        if(this.context.getElementByMCID){
            return this.context.getElementByMCID(this.props.mcid);
        }
        return this.context.getElements(this.selector)[0];
    }
    
    /*
    returns the initialised channel by the Clip the Incident belongs to
    */
    get channel(){
        if(this.checkParentScene()){
            return this.parentSceneObject._getChannel(this.mc_plugin_npm_name);
        } else {
            return null;
        }
    }
    
    getElementAttribute(attr){
        return this.element.getAttribute(attr);
    }

    get elements() {
        if(this.contex === null){
            return [];
        }
        return this.context.getElements(this.selector);
    }
    
    getElementByMCID(mcid){
        if(this.context === null){
            return null;
        }
        
        return this.context.getElementByMCID(mcid);
    }
    
    
    flashDOM(){
        return {
            failedAdditions: []
        }
    }

    turnIncidentToMC(){
        this.plugin_channel_class = Channel;
        this.mc_plugin_npm_name = "motor-cortex-js";
    }

    resetState(){

    }

    set executionSpeed(speed){
        this.speed = parseFloat(speed);
        this.onSpeedChange(speed);
        // this.beOn(this.runTimeInfo.currentMillisecond);
    }

    /**
     * gets the Incident's duration. This method should be overwriten accordingly by all Incidents
     */

    get duration() {
        return 0;
    }
    
    set duration(duration){
        ;
    }

    get state() {
        return this.runTimeInfo.state;
    }

    get context(){
        if(this.checkParentScene()){
            return this.parentSceneObject.context;
        } else {
            return null;
        }
    }
    

    get direction(){
        return this.speed>0?"forwards":"backwards";
    }


    /**
     * Returns an object that has the key of the npm plugin name the Channel of which manages the specific Incident
    */
    getIncidentsByChannel(adjustMillisecond=0){
        let incidentsByPlugin = {};
        let keyToUse = this.mc_plugin_npm_name;
        if(this.bypassChannel === true){
            keyToUse = 'motor-cortex-js';
        }
        incidentsByPlugin[keyToUse] = [
            {
                millisecond: adjustMillisecond,
                incident: this,
                id: this.id
            }
        ];
        return incidentsByPlugin;
    }

    setParam(param, value){
        this.customParams[param] = value;
    }

    getParam(param){
        return this.customParams[param];
    }

    setParams(params={}){
        this.customParams = params;
    }

    /** *************************************************
    HELPER FUNCTIONS
    checks if the parent Scene object has been defined */
    checkParentScene() {
        if (this.parentSceneObject === null) {
            return false;
        } else {
            return true;
        }
    }

    checkStateTransition(targetState) {
        // we prevent play (and thus any other transition) in cases the Incident has no parent
        // group. The method changes on Group
        if (this.checkParentScene()) {
            if (checkTransition(this.runTimeInfo.state, targetState, this.direction)) {
                return true;
            }
        }
        return false;
    }

    _hasUserDefinedInitialValue(attr){
        return this.userDefinedInitialValues.hasOwnProperty( attr );
    }
    
    _getUserDefinedInitialValue(attr){
        return this.userDefinedInitialValues[attr];
    }

    setInitialValue( attr, value ) {
        if(this._hasUserDefinedInitialValue(attr)){
            helper.notice(`Incident with id ${this.id} has initial value defined for ${attr} and no change is allowed on it`);
            return ;
        }
        this.initialValues[attr] = value;
    }

    hasInitialValue( attr ) {
        return this._hasUserDefinedInitialValue(attr) || this.initialValues.hasOwnProperty( attr );
    }

    getInitialValue( attr ) {
        if(this._hasUserDefinedInitialValue(attr)){
            return this._getUserDefinedInitialValue(attr);
        }
        return this.initialValues[attr];
    }

    setParentScene(parentSceneObject) {
        this.parentSceneObject = parentSceneObject;
    }


    /* *************************************************
    STATE CHANGING FUNCTION
    method from which we can set the state of the Incident.
    this method should never be invoked directly from code outside the core definition of Incident. All state changes
    should occur through the corresponding built-in functions (play, wait, etc) */
    _setState(state, props = {}) {
        const oldState = this.runTimeInfo.state;
        this.runTimeInfo.state = state;

        if (this.checkParentScene() && state === 'completed' && this.speed > 0) {
            this.parentSceneObject.incidentStateChange(this.id, oldState, state, props);
        } else if (this.checkParentScene() && state === 'idle' && this.speed < 0) {
            this.parentSceneObject.incidentStateChange(this.id, oldState, state, props);
        }

        let newState = state;
        if((state === 'waiting' || state === 'blocked') && props.waitingStateName != 'waiting'){
            newState = props.waitingStateName;
        }
        this.broadcastEvent('state-change', { oldState: oldState, newState: newState });
    }


    setCurrentMillisecond(millisecond){
        this.runTimeInfo.currentMillisecond = millisecond;
    }

    /**
     * sets the state of the Incident silently without broadcasting the event nor informing the parent Incident
     */

    _dontTellMamaStateChange(state) {
        if (this.checkStateTransition(state)) {
            // helper.log('setting state of ' + this.id + ' to ' + state);
            const oldState = this.runTimeInfo.state;
            this.runTimeInfo.state = state;
            this.broadcastEvent('state-change', { oldState: oldState, newState: state });
        }
    }

    /** *************************************************
    EXECUTION FUNCTIONS
    sets state to "playing" */
    play(props = {}) {
        if(!this.onBeforePlay(props)){
            return false;
        }
        if (!this.checkStateTransition('playing')) {
            return false;
        }
        
        this.timesExecuted += 1;
        this.onPlay(props);
        this._setState('playing');

        if (this.bitIncident) {
            this.complete();
        }
        return true;
    }

    /**
     wait method can be invoked by the object itself or by its parent Scene. No children are allowd to call the wait
     method.

     the nature of a waiting might be:
         - scheduled    *                               default
         - dynamic
         - system-error

     the waitingStateName of a waiting can be:
         - waiting *                                    default
         - sceneBlockingWaiting
         - clipBlockingWaiting

     An Incident can only exit waiting mode through the resume method
      */
    wait(props) {
        if (!props.waitingStateName) {
            props = { nature: 'scheduled', waitingStateName: 'waiting' };
        }

        if (!this.checkStateTransition('waiting')) {
            return false;
        }

        this.statusBeforeHalt = this.runTimeInfo.state;
        this._setState('waiting', props);
        this.onWait(props);
        return true;
    }

    unblock(){
        if(this.statusBeforeHalt === 'playing'){
            this.resume();
        }
    }

    /**
     block and unblock methods can only be invoked by a parent of the Incident. No children (in the case of a Scene) nor
     the Incident itself can block or unblock itself.
      */
    block(props = {}) {
        if (!this.checkStateTransition('blocked')) {
            return false;
        }

        this.statusBeforeHalt = this.runTimeInfo.state;
        this._setState('blocked', props);
        this.onBlock(props);
        return true;
    }

    resume(props = {}) {
        if(!this.onBeforeResume(props)){
            return false;
        }
        if (
            !this.checkStateTransition(this.statusBeforeHalt)
        ) {
            return false;
        }

        this.onResume(props);
        this._setState(this.statusBeforeHalt);

        return true;
    }

    reset(props = {}) {
        // this.stop();
        if (!this.checkStateTransition('idle')) {
            return false;
        }

        this.blockingWaitings = [];

        this.timesExecuted = 0;
        this._setState('idle');
        this.onReset(props);
        return true;
    }

    complete(props = {}) {
        if(this.speed > 0){
            if (!this.checkStateTransition('completed')) {
                return false;
            }
        } else {
            if (!this.checkStateTransition('idle')) {
                return false;
            }
        }

        this.onBeforeComplete(props);

        if(this.speed > 0){
            this._setState('completed');
        } else {
            this._setState('idle');
        }

        if(this.speed > 0){
            this.runTimeInfo.currentMillisecond = this.duration;
        } else {
            this.runTimeInfo.currentMillisecond = 0;
        }

        return true;
    }

    stop(props = {}) {
        if (!this.checkStateTransition('transitional')) {
            return false;
        }

        this.blockingWaitings = [];

        this.stateBeforeStop = this.state + "";
        this._setState('transitional');
        this.onStop(props);
        return true;
    }

    /**
     * Restores the execution of the Incident after a stop
    **/
    restore(){
        if((this.state === 'waiting' || this.state === 'blocked') && this.stateBeforeStop === 'playing'){
            this.resume();
        }
    }

    arm(props = {}) {
        if (!this.checkStateTransition('waiting')) {
            return false;
        }

        this.blockingWaitings = [];

        this._dontTellMamaStateChange('waiting');
        this.onArm(props);
        return true;
    }

    /**
     * There are various events happening on the scope of an Incident. Any class extending Incident might have / define its own
     * events.
     *
     * The "broadcastEvent" method of the Incident allows the Incident (of any type, even on classes extending it) broadcast
     * events on any of the interested parties that have subscribed to it.
     *
     * The "subscribeToEvents" method allows any third party subscribe and listen to events' broadcasts by any Incident
     *
     * @param {string} id - the unique id of the event listener
     * @param {function} fnct - a function to get executed whenever an event gets broadcasted by the specific Incident. The
     *  fnct will be executed on all events' broadcasts and it will receive the event object as argument. The event object is
     *  of format:
     *  {
            name: the name of the event,
            meta: an object holding all the meta-info of the event
        }
     }
    */
    subscribeToEvents(id, fnct) {
        this.eventsSubscriptions[id] = fnct;
    }

    /**
     * unsubscribes any subscribed listener to the Incident's events broadcasting
     * @param {string} id
     */
    unsubscribeFromEvents(id) {
        if (this.eventsSubscriptions[id]) {
            delete this.eventsSubscriptions[id];
        }
    }

    /**
     * broadcasts any event
     * @param {string} eventName
     * @param {object} meta
     */
    broadcastEvent(eventName, meta) {
        for (const key in this.eventsSubscriptions) {
            this.eventsSubscriptions[key](eventName, meta);
        }
    }

    /**
     * This method's (which should be called whenever a slip ends) purpose is to calculate and set
     * the right state of the Incident based on the target millisecond.
     * The parameter it takes is relative to the beginning of the Incident itself and it might be negative
     * Negative targetMillisecond means the target millisecond is N milliseconds BEFORE the start of the Incident
     * @param {int} targetMillisecondDeltaFromStart - the delta of the target millisecond compared to the Incident start
     */
    recalcState(targetMillisecondDeltaFromStart) {
        if (targetMillisecondDeltaFromStart >= 0) {
            // if it ends before the target millisecond
            this._dontTellMamaStateChange('completed');
        } else {
            // if it has been completed on targetMillisecond
            this._dontTellMamaStateChange('idle');
        }
    }
    
    resize(duration){
        this.systolDiastole(duration/this.duration);
        return {result: true};
    }


    systolDiastole(durationFraction){
        return true;
    }

    exportState(props={}){
        let toExport = {
            id: this.id,
            duration: this.duration,
            class: this.constructor.name,
            mc_plugin_npm_name: this.mc_plugin_npm_name,
            customParams: this.customParams,
            attrs: Object.assign({}, this.attrs),
            props: Object.assign({id: this.id, autogeneratedID: true}, this.props)
        }
        
        let exportType = 'live';
        if(props.hasOwnProperty('type')){
            if(props.type === "json"){
                toExport.initialValues = this.initialValues;
                exportType = 'json';
            }
        }
        
        if(exportType === 'live'){
            toExport.plugin_channel_class = this.plugin_channel_class;
            toExport.state = this.state;
            toExport.Incident = this.constructor;
        }
        
        return toExport;
    }
    
    // *************************************************
    /* PIPES SYSTEM
        The Pipes system is a vertical interconnection system that runs out the full Incidents tree and connects all of them.
        Through Pipes any Incident can communicate anything to all of its children or parents.
        
        In order to initialise a pipe message the user should use the putMessageOnPipe method. This method is exposed by all
            Incidents, of all types, and it is first been processed by the receiver Incident and then passed further down to
            its children (if any).
        This method takes exactly 5 arguments:
        - name (the name of the command). This should be unique among the full MC ecosystem including native message names & 
            plugins' message names. In order to avoid conflicts is good to use the convention: <plugin_npm_name>.<message_name>
        - parameters (an object holding the parameters of the command)
        - selfExecute (true/false) - If true the Incident will try to process the pipe command before further passing further up or down
        - direction (default "down") - defines the direction of the pipe command. It can be either "down" so it passes it down to 
            its children or "up" so it passes it up to its parents
        - target. The target defines / describes the receivers of the pipe message. This might be:
            - null (default) - targets all incidents
            - type: "group" - targets only groups (including clips)
            - type: "clip" - targets only clips
            - type: "rootClip" - targets only the root clip of the tree
            - id: "<id>" - targets a specific incident with specific id
            - plugin: "<plugin_npm_name>" - targets only Incidents of a specific plugin
        
        Handling pipe messages:
        The putMessageOnPipe method decides whether it should be processed or
        not by the Incident depending on the target. This method is the _processPipeMessage. If the Incident should process the 
        pipe message the _processPipeMessage method calls the "handlePipeMessage" method passing the name and the parameters.
        The "handlePipeMessage" is a built in method as well and the developers should just overwrite it so they handle the 
        various pipes messages based on their names.
        
        Pipe messages targeting the clip return a result.
    */
    putMessageOnPipe(name, params, selfExecute, direction, target=null){
        if(selfExecute){
            if(target===null){
                this.handlePipeMessage(name, params);
            } else {
                if(target.hasOwnProperty('type')){
                    if(target.type==='group' && this.hasIncidents){
                        this.handlePipeMessage(name, params);
                    } else if(target.type==='clip' && this.isTheClip){
                        this.handlePipeMessage(name, params);
                    } else if(target.type==="rootClip" && this.isTheClip && !this.checkParentScene()){
                        return this.handlePipeMessage(name, params);
                    }
                } else if(target.hasOwnProperty('id')){
                    if(this.id===target.id){
                        this.handlePipeMessage(name, params);
                        return ;
                    }
                } else if(target.hasOwnProperty('plugin')){
                    if(this.mc_plugin_npm_name===target.plugin){
                        this.handlePipeMessage(name, params);
                    }
                }
            }
        }

        if(direction==="down" && this.hasIncidents){
            for(let i=0; i<this.incidents.length; i++){
                this.incidents[i].incident.putMessageOnPipe(name, params, true, direction, target);
            }
        } else if(direction==="up" && this.checkParentScene()) {
            this.parentSceneObject.putMessageOnPipe(name, params, true, direction, target);
        }
    }
    
    handlePipeMessage(name, params){
        // Plugins developers can overwrite this method so they can handle pipe messages per name
    }
    
    // *************************************************
    /* BLOCKING WAITINGS
    The triggerBlockingWatiing method that can be used by any Incident at any time. The Incident can trigger a blocking waiting. 
    The "blocking waitings" block the root Clip's execution (puts it to blocked state). 
    Any blocking waiting has an id (it must be unique) and it can be unblocked by any Incident at any time through the triggerUnblock
    method which takes an id and removes the corresponding blocking waiting. 
    */
    triggerBlockingWatiing(id, params={}){
        params.blockingWaitingID = id;
        this.putMessageOnPipe(pipeMessges._BLOCKING_WAITING, params, true, "up", {type: 'rootClip'});
    }
    
    triggerUnblock(id){
        const params = {
            blockingWaitingID: id
        };
        this.putMessageOnPipe(pipeMessges._UNBLOCK_WAITING, params, true, "up", {type: 'rootClip'});
    }
    



    // *************************************************
    // ACTUAL BAHAVIOUR FUNCTIONS THAT SHOULD BE IMPLEMENTED BY ALL CLASSES EXTENDING INCIDENT
    // this is a chance to block play of an incident by returning false
    onBeforePlay(props={}){
        return true;
    }
    
    onPlay(props) {
        helper.info('Overwritte the "onPlay" method with the code you want to get executed', 'info');
    }

    onResume(props) {
        helper.info('Overwritte the "onResume" method with the code you want to get executed', 'info');
    }
    
    onBeforeResume(props={}){
        return true;
    }


    /**
     * Helper function that normalises the millisecond to pass to the Incidents on goTo
     * If millisecond < 0 it makes it 0
     * If millisecond > duration of the Incident it makes it equals to the duration
     * @param {int} millisecond - the millisecond to normalise. It represents the distance of the time to go to from
     *  the start of the Incident
     * @returns {int} - the normalised millisecond
    **/
    normaliseGoToTarget(millisecond){
        if(millisecond < 0){
            millisecond = 0;
        } else if(millisecond > this.duration){
            millisecond = this.duration;
        }

        return millisecond;
    }

    /**
     * goTo on the Incident level implements the logic of passing the authority of execution to its parent
     * (if there is any)
     * Incidents that implement their own goTo logic should overwrite the goTo method otherwise the goTo
     * will be passed up until either it reaches a context owner or a tree root
     * @param {int} millisecond - (optional) the millisecond where we want to goTo. If not provided we use the current millisecond of the Incident
     * @returns {boolean} - if the context owner of the Incident actually executes the goTo command the
     *  method returns true otherwise it returns false
    **/
    goTo(millisedond) {
        // if the incident has a parent scene
        if(this.checkParentScene()){
            if(this.parentSceneObject.goTo(millisedond, {relativeTo: this.id})){
                return true;
            }
        }
        return false;
    }

    /**
     * Returns the milliseconds delta between the Incident's start point and its root Scene's current millisecond.
     * If the result is negative it means the root scene's current millisecond is prior to the Incident's start point
     * @returns {int}
    **/
    getRootCurrentMillisecondDeltaFromStart(){
        if(this.checkParentScene()){
            return this.parentSceneObject.getRootCurrentMillisecondDeltaFromIncidentsStart(this.id);
        } else {
            return this.runTimeInfo.currentMillisecond;
        }
    }

    beOn(millisecond, goTo=true){
        const previousState = this.state + "";
        this.stop();
        if(goTo){
            this.goTo(millisecond);
        }
        this.setCurrentMillisecond(millisecond);
        this.recalcState(millisecond);
        const newState = this.state + "";
        return {
            previousState: previousState,
            newState: newState
        }
    }
    
    _onGetContextOnce(){
        if(!this.gotContext){
            this.onGetContext();
            this.gotContext = true;
        }
    }
    
    onGetContext(){
        helper.info('Overwritte the "onGetContext" method with the code you want to get executed', 'info')
    }

    onStop(props) {
        helper.info('Overwritte the "onBeforeStop" method with the code you want to get executed', 'info');
    }

    onReset(props) {
        helper.info('Overwritte the "onReset" method with the code you want to get executed', 'info');
    }

    onBeforeComplete(props) {
        helper.info('Overwritte the "onBeforeEnd" method with the code you want to get executed', 'info');
    }

    onBlock(props) {
        helper.info('Overwritte the "onBlock" method with the code you want to get executed', 'info');
    }

    onUnblock(props) {
        helper.info('Overwritte the "onUnblock" method with the code you want to get executed', 'info');
    }

    onWait(props) {
        helper.info('Overwritte the "onWait" method with the code you want to get executed', 'info');
    }

    onArm(props) {
        helper.info('Overwritte the "onArm" method with the code you want to get executed', 'info');
    }

    lastWish() {
        this.stop();
    }

    onInitialise(attrs, props){
        helper.info('Overwritte the "onInialise" method with the code you want to get executed', 'info');
    }
    
    onSpeedChange(speed){
        helper.info('Overwritte the "onSpeedChange" method with the code you want to get executed', 'info');
    }
}

module.exports = Incident;
