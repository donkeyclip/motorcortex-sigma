const Helper = require('../_coreUtils/Helper');
const helper = new Helper();

const allowedStateChanges = {
    // from which states an Incident can become one of the:

    idle: {
        forwards: ['transitional'], // only from transitional
        backwards: ['transitional', 'playing']
    },
    transitional: {
        forwards: [
            'idle',
            'playing',
            'waiting',
            'sceneBlockingWaiting',
            'clipBlockingWaiting',
            'completed',
            'blocked'
        ],
        backwards: [
            'idle',
            'playing',
            'waiting',
            'sceneBlockingWaiting',
            'clipBlockingWaiting',
            'completed',
            'blocked'
        ]
    },
    playing: {
        forwards: ['idle', 'waiting', 'sceneBlockingWaiting', 'clipBlockingWaiting', 'blocked'],
        backwards: ['completed', 'waiting', 'sceneBlockingWaiting', 'clipBlockingWaiting', 'blocked']
    },
    waiting: {
        forwards: ['playing', 'blocked', 'transitional'],
        backwards: ['playing', 'blocked', 'transitional']
    },
    sceneBlockingWaiting: {
        forwards: ['playing', 'waiting', 'blocked'],
        backwards: ['playing', 'waiting', 'blocked']
    },
    clipBlockingWaiting: {
        forwards: ['playing', 'waiting', 'blocked'],
        backwards: ['playing', 'waiting', 'blocked']
    },
    completed: {
        forwards: ['transitional', 'playing'],
        backwards: ['transitional']
    },
    blocked: {
        forwards: ['transitional', 'playing', 'waiting', 'sceneBlockingWaiting'],
        backwards: ['transitional', 'playing', 'waiting', 'sceneBlockingWaiting']
    }
};

const timePausingStates = [
    'blocked',
    'waiting',
    'sceneBlockingWaiting',
    'clipBlockingWaiting'
];

const checkTransition = (oldState, newState, direction) => {
    if (!allowedStateChanges.hasOwnProperty(oldState)) {
        helper.error(
            'The state ' + oldState + ' is not recognised as one of the supported Incident states'
        );
        return false;
    } else if (!allowedStateChanges.hasOwnProperty(newState)) {
        helper.error(
            'The state ' + newState + ' is not recognised as one of the supported Incident states'
        );
        return false;
    }

    if (allowedStateChanges[newState][direction].indexOf(oldState) >= 0) {
        return true;
    } else {
        // helper.error('The transition from ' + oldState + ' to ' + newState + ' is not allowed');
        return false;
    }
};

const isTimePausingState = state => {
    return timePausingStates.indexOf(state) >= 0;
};

module.exports = { checkTransition: checkTransition, isTimePausingState: isTimePausingState };
