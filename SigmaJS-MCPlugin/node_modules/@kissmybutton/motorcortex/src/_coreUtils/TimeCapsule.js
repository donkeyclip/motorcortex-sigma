const Helper = require('../_coreUtils/Helper');
const helper = new Helper();

class Journey{
    constructor(props){
        if(!props.hasOwnProperty('incident')){
            helper.error('Journey constructor expects an Incident on its properties on the key "incident"');
            return false;
        }
        
        this.memory = props.calpuleMemory;
        this.stations = [];
        
        this.incident = props.incident;
        this.startMillisecond = this.incident.runTimeInfo.currentMillisecond*1;
        this.startState = this.incident.state + "";
        this.incident.stop();
    }
    
    station(millisecond){
        let props = {};
        if(this.stations.length > 0){
            props.previousStop = this.stations[this.stations.length - 1];
        }
        this.stations.push(millisecond);
        // helper.log(`CAPSULE passes as previousStop: ${props.previousStop}`);
        // helper.log(this.stations);
        this.incident.goTo(millisecond, props);
    }
    
    destination(millisecond=null){
        if(millisecond != null){
            this.station(millisecond);
        } else {
            millisecond = this.stations[this.stations.length - 1];
        }
        this.incident.beOn(millisecond, false);
        if(this.startState === 'playing' || this.startState === 'blocked'){
            this.incident.resume();
        }
        this.memory.push(this.exportJourneyLog);
    }
    
    exportJourneyLog(){
        return {
            startMillisecond: this.startMillisecond,
            startState: this.startState,
            incident: this.incident.exportState(),
            stations: this.stations
        }
    }
}

class TimeCapsule {
    constructor(){
        this.memory = [];
    }
    
    startJourney(incident){
        if(!incident){
            helper.error('startJourney expects an Incident as an argument');
            return false;
        }
        
        return new Journey({incident: incident, calpuleMemory: this.memory});
    }
}

module.exports = TimeCapsule;