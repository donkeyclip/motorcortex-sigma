/** @classdesc Helper maintains a number of helpful functions in a single point  */
const conf = require('../configuration/generalConf');


class Helper {
    constructor(configuration) {
        let logLevel = 2;
        if(configuration){
            if(configuration.hasOwnProperty('logLevel')){
                logLevel = configuration.logLevel;
            }
        }
        
        this.lanesMCIDattrsSeperator = '___';

        for(let i=0; i<conf.logTypes.length; i++){
            const logType = conf.logTypes[i];
            if(logLevel >= logType.level)
                this[logType.key] = window.console.log.bind(window.console, "MotorCortex - %c%s", logType.style);
            else
                this[logType.key] = function(){}
        }

        if(logLevel >= 3)
            this.log = window.console.log.bind(window.console, "MotorCortex - ");
        else
            this.log = function(){}
    }
    
    renderTemplate(templateString, templateVars){
        return new Function("return `"+templateString +"`;").call(templateVars);
    }

    /**
     * @returns {string} in the form "1bc45f78-ab23-jl59"
     */
    getAnId(underscore = false) {
        let specialChar = '-';
        if (underscore) {
            specialChar = '_';
        }
        function s4() {
            return Math.floor((1 + Math.random()) * 0x10000)
                .toString(16)
                .substring(1);
        }
        return s4() + s4() + specialChar + s4() + specialChar + s4();
    }

    getLaneKey(mcid, attribute) {
        return mcid + this.lanesMCIDattrsSeperator + attribute;
    }

    getMCIDandAttrOutOfLaneKey(laneKey) {
        const laneArray = laneKey.split(this.lanesMCIDattrsSeperator);
        return {
            mcid: laneArray[0],
            attribute: laneArray[1]
        };
    }

    getElementByMCID(context, mcid) {
        return context.document.querySelectorAll(
            '[' + conf.elements_data_attribute_name + '="' + mcid + '"]'
        )[0];
    }

    getMCIDOfElement(element){
        return element.getAttribute(conf.elements_data_attribute_name);
    }

    /**
	 subdivision might be rounding the number to its:
	 	- units (subdivision = 1)
	 	- tenths (subdivision = 10)
	 	- hundreds (subdivision = 100)
	 	- thousands (subdivision = 1000)
     @param {string} int
     @param {subdivision} int
     @returns {int} the rounded number
	  */
    roundNumberTo(number, subdivision) {
        return Math.round(number / subdivision) * subdivision;
    }

    isInteger(number){
        if (number === parseInt(number, 10)){
            return true;
        } else {
            return false;
        }
    }

    isString(test){
        if (typeof test === 'string' || test instanceof String){
            return true;
        } else {
            return false;
        }
    }

    isObject(test){
        return typeof test === "object";
    }

    isArray(test){
        return Array.isArray(test);
    }

    isFunction(functionToCheck) {
        return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
    }

    addClass(el, className){
        if (el.classList)
            el.classList.add(className);
        else
            el.className += ' ' + className;
    }

    removeClass(el, className){
        if (el.classList)
            el.classList.remove(className);
        else
            el.className = el.className.replace(new RegExp('(^|\\b)' + className.split(' ').join('|') + '(\\b|$)', 'gi'), ' ');
    }

    addStyle(el, style){
        for(let key in style){
            el.style[key] = style[key];
        }
    }

    /**
     * systole / diastole of the projections
     * @param {float} fraction - the duration fraction of the parent Scene
     * @returns {array} - collection of objects with keys: {id, start, end, startDelta}
    **/
    systoleDiastoleProjections(projections, durationFraction, adjustMillisecond){
        let alteredProjections = [];

        for(let i=0; i<projections.length; i++){
            let projectedIncident = projections[i];

            if(durationFraction != 1){
                alteredProjections.push({
                    id: projectedIncident.incident.id,
                    start: projectedIncident.millisecond*durationFraction + adjustMillisecond,
                    end: projectedIncident.millisecond*durationFraction + projectedIncident.incident.duration*durationFraction + adjustMillisecond,
                    startDelta: projectedIncident.millisecond*durationFraction - projectedIncident.millisecond
                });
            }
        }

        return alteredProjections;
    }
    
}

module.exports = Helper;
