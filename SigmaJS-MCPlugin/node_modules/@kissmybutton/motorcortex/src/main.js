const Channel = require('./_Channels/Channel');
const Group = require('./_BaseClasses/Group');
const Incident = require('./_BaseClasses/Incident');
const TimedIncident = require('./_BaseClasses/TimedIncident');
const Helper = require('./_coreUtils/Helper');  const helper = new Helper();
const AttributeChannel = require('./_Channels/_Attribute/AttributeChannel');
const ClipFromDefinition = require('./corePlugins/SelfContainedIncidents/ClipFromDefinition');
const SelfContainedChannel = require('./corePlugins/SelfContainedIncidents/SCIChannel');
const pipeMessages = require('./configuration/pipesConf');

const conf = require('./configuration/generalConf');
const Timer = require('./utils/Timer');

const checkPlugin = function(main){
    if(main.hasOwnProperty('default')){
        main = main.default;
    }
    
    const plugin_name = main.npm_name;
    let check = true;
    
    if(!main.hasOwnProperty('incidents')){
        helper.error(`Error on plugin ${plugin_name}. A plugin must expose at least one Incident.
        Exposed plugin Incidents should be defined on the "incidents" key of the main.js file.`);
        check = false;
    }

    if(!helper.isArray(main.incidents)){
        helper.error(`Error on plugin ${plugin_name}. thePlugin exposed Incidents are defined on the "incidents" key of the main.js file in array format.
        Please refer to the documentation`);
        check = false;
    } else {
        for(let i=0; i<main.incidents.length; i++){
            const exposedIncidentDefinition = main.incidents[i];
            if(typeof exposedIncidentDefinition.exportable === "object"){
                if(exposedIncidentDefinition.exportable.hasOwnProperty('default')){
                    exposedIncidentDefinition.exportable = exposedIncidentDefinition.exportable.default;
                }
            }
            if(!(exposedIncidentDefinition.exportable.prototype instanceof Incident)){
                helper.error(`Error on plugin ${plugin_name}. Exportable Incidents by any plugin must extend one of the base classes provided by MotorCortex.
                ${exposedIncidentDefinition.exportable.constructor.name} doesn't.
                Please refer to documentation`);
                check = false;
            }
            
            if(!exposedIncidentDefinition.hasOwnProperty('name')){
                helper.error(`Error on plugin ${plugin_name}. Exportable Incidents by any plugin must have the "name" key which defines the name of the exported Incident.
                Please refer to documentation`);
                check = false;
            }

            if(!exposedIncidentDefinition.hasOwnProperty('propTypes')){
                helper.log(`Warning on plugin ${plugin_name}.
                It's always good for plugins to define the supported propTypes of their exposed Incidents' supported properties.
                ${exposedIncidentDefinition.exportable.constructor.name} doesn't.
                Please refer to documentation`, 'warning');
            }
        }
    }

    if(!main.hasOwnProperty('channel')){
        helper.error(`Error on plugin ${plugin_name}. A plugin must always define its Channel on the "channel" key of the main.js file.
        It's missing. Please refer to documentation`);
        check = false;
    } else {
        if(typeof main.channel === "object"){
            if(main.channel.hasOwnProperty('default')){
                main.channel = main.channel.default;
            }
        }
    }

    return check;
}

// plugin_name is the unique name of the plugin
function loadPlugin(plugin){
    if(plugin.hasOwnProperty('default')){
        plugin = plugin.default;
    }
    
    if(!plugin.hasOwnProperty('npm_name')){
        plugin.npm_name = `plugin_${new Date().getTime()}`;
    }

    if(!plugin.hasOwnProperty('channel')){
        plugin.channel = Channel;
    }
    if(!checkPlugin(plugin)){
        return false;
    } else {
        // thePlugin is the plugin object which will hold on its keys
        // the names of the exposed Incidents of its. The keys of this object
        // are going to be identical with the names of the classes exposed
        const thePlugin = {};
        
        if(plugin.hasOwnProperty('clip')){
            if(typeof plugin.clip === "object"){
                if(plugin.clip.hasOwnProperty('default')){
                    plugin.clip = plugin.clip.default;
                }
            }
            Object.defineProperty(thePlugin, 'Clip', {
                get(){
                    class WrapperClass {
                        constructor(attrs, props){
                            const instantiatedIncident = new plugin.clip(attrs, props);
                            instantiatedIncident.plugin_channel_class = SelfContainedChannel;
                            // instantiatedIncident.mc_plugin_npm_name = '@kissmybutton/self-contained-incidents';
                            
                            return instantiatedIncident;
                        }
                    }
                    return WrapperClass;   
                }
            });
            // thePlugin.Clip = plugin.clip;
        }

        // for each of the exposed Incidents
        for(let i=0; i<plugin.incidents.length; i++){
            const incidentClass = plugin.incidents[i].exportable;

            // TODO hanlde the different css style isolation versions through the cssIsolation parameter of the containerParams of the incident

            // dynamically assign getters on the Incident's name key of the thePlugin object
            Object.defineProperty(thePlugin, plugin.incidents[i].name, {
                get(){
                    // the getter will construct a wrapper class which on the constructor will instantiate an object of the
                    // exposed class, set to it the plugin name and channel class parameters and return
                    // it from the constructor
                    class WrapperClass {
                        constructor(attrs, props){
                            const instantiatedIncident = new incidentClass(attrs, props);
                            
                            instantiatedIncident.mc_plugin_npm_name = plugin.npm_name;
                            if(plugin.incidents[i].bypassChannel!==true){ // if the exportable incident has the flag bypassChannel the incident will be treated as motorcortex incident
                                instantiatedIncident.plugin_channel_class = plugin.channel;
                            } else {
                                instantiatedIncident.bypassChannel = true;
                            }
                            
                            if(plugin.channel.type === "attributes" && (!props.hasOwnProperty('selector') || props.selector===null || props.selector===undefined) && plugin.incidents[i].bypassChannel!==true){
                                helper.error(`You tried to instantiate an Incident of plugin ${plugin.npm_name} without passing props.selector. This plugin uses the AttributeChannel and thus all of its incidents must 
                                    be initialised with a valid props.selector.`);
                                return false;
                            }

                            // it's a good idea to both validate the props here before returning the new object
                            // also is a good idea to create a Proxy for the instantiated Incident to prevent setting:
                            // id, plugin_channel_class, mc_plugin_npm_name

                            return instantiatedIncident;
                        }
                    };

                    return WrapperClass;
                }
            })
        }
        return thePlugin;
    }

}


const ProgrammaticIncidentPluginDefinition = require('./corePlugins/ProgrammaticIncidents/main.js');
const ProgrammaticIncidentPlugin = loadPlugin(ProgrammaticIncidentPluginDefinition);

const SelfContainedIncidentsPluginDefinition = require('./corePlugins/SelfContainedIncidents/main.js');
const SelfContainedIncidentsPlugin = loadPlugin(SelfContainedIncidentsPluginDefinition);
const ExtendableClip = require('./corePlugins/SelfContainedIncidents/ExtendableClip');

const TimeCapsule = require('./_coreUtils/TimeCapsule');


module.exports = {
    Channel: Channel,
    Group: Group,
    Clip: SelfContainedIncidentsPlugin.Clip,
    ClipFromDefinition: ClipFromDefinition,
    Incident: Incident,
    ProgrammaticIncident: ProgrammaticIncidentPlugin.ProgrammaticIncident,
    DummyIncident: ProgrammaticIncidentPlugin.DummyIncident,
    TimedIncident: TimedIncident,
    
    _channels:{
        'motor-cortex-js': Channel,
        '@kissmybutton/programmatic-incidents': ProgrammaticIncidentPluginDefinition.channel,
        '@kissmybutton/self-contained-incidents': SelfContainedIncidentsPluginDefinition.channel
    },

    // channels
    AttributeChannel: AttributeChannel,
    
    TimeCapsule: TimeCapsule,

    conf: conf,
    Timer: Timer,
    
    ExtendableClip: ExtendableClip,

    Helper: Helper,

    loadPlugin: loadPlugin,
    
    _GAIN_CHANGE: pipeMessages._GAIN_CHANGE
}