/*
iframe[seamless]{
    background-color: transparent;
    border: 0px none transparent;
    padding: 0px;
    overflow: hidden;
}

might need more work for IE. See here: https://stackoverflow.com/a/29209248
*/

const Helper = require('../../../_coreUtils/Helper');
const helper = new Helper();
const conf = require('../../../configuration/generalConf');

class WebComponentContextHandler {
    /**
     * @param {object} props - an object that should contain all of the following keys:
     * - html (the html template to render)
     * - css (the css template of the isolated tree)
     * - initParams (optional / the initialisation parameteres that will be passed both on the css and the html templates in order to render)
     * - host (an Element object that will host the isolated tree)
     * - containerParams (an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc)
    */
    constructor(props={}) {
        if(!helper.isObject(props)){
            helper.error(`ContextHandler expects an object on its constructor. ${typeof props} passed`);
            return false;
        }

        if(!props.hasOwnProperty('html')){
            helper.error(`ContextHandler expects the html key on its constructor properties which is missing`);
            return false;
        }

        if(!props.hasOwnProperty('css')){
            helper.error(`ContextHandler expects the css key on its constructor properties which is missing`);
            return false;
        }

        let initParams = props.initParams;
        if(!props.hasOwnProperty('initParams')){
            helper.info(`ContextHandler got null initParams`);
            initParams = {};
        }

        if(!props.hasOwnProperty('host')){
            helper.error(`ContextHandler expects the host key on its constructor properties which is missing`);
            return false;
        }
        
        this.isDOM = true;

        const ownerDocument = props.host.ownerDocument;
        
        const shadow = props.host.attachShadow({mode: 'closed'});
        const wrapper = document.createElement('div');
        if(props.hasOwnProperty('containerParams')){
            if(props.containerParams.hasOwnProperty('width')){
                wrapper.style.width = props.containerParams.width;
            }
            if(props.containerParams.hasOwnProperty('height')){
                wrapper.style.height = props.containerParams.height;
            }
        }
        wrapper.innerHTML = helper.renderTemplate(props.html + '<slot></slot>', {params:props.initParams});
        shadow.appendChild(wrapper);
        
        const styleTag = document.createElement('style');
        styleTag.type = 'text/css';
        if (styleTag.styleSheet){
            styleTag.styleSheet.cssText = helper.renderTemplate(props.css, {params:props.initParams}) ;
        } else {
            styleTag.appendChild(document.createTextNode(props.css));
        }
        shadow.appendChild(styleTag);
        
        if(props.hasOwnProperty('fonts')){
            for(let i=0; i<props.fonts.length; i++){
                const theFont = props.fonts[i];
                if(theFont.type === "google-font"){
                    const fontTag = document.createElement('link');
                    fontTag.setAttribute('rel', 'stylesheet');
                    fontTag.setAttribute('src', theFont.src);
                    shadow.appendChild(fontTag);
                }
            }
        }
        
        wrapper.style.overflow = "hidden";
        
        this.rootElement = wrapper;
        
        this.context = {
            document: document,
            window: window,
            clipContainer: this.rootElement,
            rootElement: wrapper,
            unmount: function(){
                props.host.removeChild(shadow);
            },
            getElements: this.getElements.bind(this),
            getMCID: this.getMCID.bind(this),
            setMCID: this.setMCID.bind(this),
            getElementSelectorByMCID: this.getElementSelectorByMCID.bind(this),
            getElementByMCID: this.getElementByMCID.bind(this)
        };

        this.elementsByMCID = {};
    }
    
    getElementByMCID(mcid){
        if(this.elementsByMCID.hasOwnProperty(mcid)){
            return this.elementsByMCID[mcid];
        } else {
            const element = this.context.rootElement.querySelector(this.getElementSelectorByMCID(mcid));
            this.elementsByMCID[mcid] = element;
            return element;
        }
    }
    
    getElements(selector){
        return Array.from(this.context.rootElement.querySelectorAll(selector));
    }
    
    getMCID(element){
        return element.getAttribute(conf.elements_data_attribute_name);
    }
    
    setMCID(element, mcid){
        element.setAttribute(conf.elements_data_attribute_name, mcid);
    }
    
    getElementSelectorByMCID(mcid){
        return '[' + conf.elements_data_attribute_name + '="' + mcid + '"]';
    }

}

module.exports = WebComponentContextHandler;
