const Helper = require('../../_coreUtils/Helper');
const helper = new Helper();
const Group = require('../../_BaseClasses/Group');
const conf = require('../../configuration/generalConf');
const pipeMessages = require('../../configuration/pipesConf');
const ClipChannel = require('./SCIChannel');
const selfContainedIncidentsNpmName = '@kissmybutton/self-contained-incidents';

class ExtendableClip extends Group{
    /**
     * @param {object} props - an object that should contain all of the following keys:
     * - html (the html template to render)
     * - css (the css template of the isolated tree)
     * - initParams (optional / the initialisation parameteres that will be passed both on the css and the html templates in order to render)
     * - host (an Element object that will host the isolated tree)
     * - containerParams (an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc)
     * - type (optional, defaults to "iframe") the type of the Clip. It can be one of the:
     *  - iframe 
     *  - plain
    */
    constructor(props={}, oldProps=null){
        let attrsToPass, propsToUse;
        
        /*
        backwards compatibility. If the user doesn't pass a second argument on the constructor then this is 
        the new way of initialising a Group (only props).
        */
        if(oldProps === null){
            attrsToPass = {};
            propsToUse = props;
        } else { // else, in case the user has passed two arguments then both should be used
            attrsToPass = props;
            propsToUse = oldProps;
        }
        
        if(!helper.isObject(propsToUse)){
            helper.error(`Self Contained Incident expects an object on its second argument on the constructor. ${typeof propsToUse} passed`);
            return false;
        }
        
        super(attrsToPass, propsToUse);
        this.mc_plugin_npm_name = "@kissmybutton/self-contained-incidents";
        this.plugin_channel_class = ClipChannel;
        
        this.isTheClip = true;  
        
        this.volume = 1;
        
        this.editingStatus = 'editing'; // either normal or editing
        
        this.blockingWaitings = {};
        
        this.onClipInitialise();
    }
    
    onClipInitialise(){
        // called when group gets initialised
    }
    
    _getChannel(channelId){
        if(!this.instantiatedChannels.hasOwnProperty(channelId)){
            return null;
        } else {
            return this.instantiatedChannels[channelId];
        }
    }
    
    lastWish(){
        this.ownContext.unmount();
    }
    
    startEditing(){
        this.editingStatus = "editing";
    }
    
    doneEditing(){
        this.stop();
        this.setCurrentMillisecond(this.runTimeInfo.currentMillisecond);
        this.recalcState(this.runTimeInfo.currentMillisecond);
        this.restore();
        this.editingStatus = "editing";
    }
    
    /**************************************************************************
     * methods inheritied from Group
    **************************************************************************/
     // *******************************************************
    // INCIDENTS MANAGEMENT METHODS
    // POLYMORPHISM APPLIED. IF THE GROUP HAS NO PARENT IT ACTS AS A SCENE. IF THE GROUP HAS PARENT IT ACTS AS
    // A "TRANSPARENT GROUP"

    /**
     * The checkAddition method serves exactly what its name implies. To check if the addition of an Incident
     * is valid and accepted, according to the rules defined on the channels.
     * The method boobles up until it reaches the Clip by carrying adjusting the millisecond.
     * The method takes as input the management type. On error / conflict:
     *  - on type === 'all-or-nothing' completely discard addition of all incidents
     *  - on type === 'keep-passing' it will only add the passing incidents no matter if some other incidents of the addition failed
     * @param {object} incident - the incident to add
     * @param {int} millisecond - the millisecond to add the Incident to
     * @param {string} type - as explained above
     * The method returns either:
        {
            result:true,
            execute: // an array of functions that when executed it will add the Incidents on the Channels
        }
        or
        {
            result: false,
            errors
        }
    */
    checkAddition(incident, millisecond, type="all-or-nothing"){
        if(incident.props.autoGeneratedID === false){
            const existingIncidentWithTheSameId = this.getIncidentById(incident.id);
            if(existingIncidentWithTheSameId != null){
                return {result:false, errors:[{reason: 'Already existing Incident with id ' + incident.id, incident:existingIncidentWithTheSameId}]};
            }
        }
        
        // get all incidents separated by plugin
        const incidentsById = incident.getIncidentsByChannel(millisecond);

        // prepare the return payload
        let toReturnResult = true;
        let toReturnErrors = [];
        let toReturnExecutables = [];

        // for each key of the incidentsById object perform the check
        for(let key in incidentsById){
            // if the clip had no channel instantiated for the specific key (plugin id) yet create it
            if(!this.instantiatedChannels.hasOwnProperty(key)){
                // intstantiate the channel of the plugin by using the reference to the class definition stored on
                // the very first incident of the array
                this.instantiatedChannels[key] = new incidentsById[key][0].incident.plugin_channel_class(
                    {
                        runTimeInfo:this.runTimeInfo,
                        context: this.context
                    }
                );
            }

            // perform the check
            const pluginResult = this.instantiatedChannels[key].addIncidents(incidentsById[key], type);
            toReturnResult = toReturnResult && pluginResult.result;
            if(pluginResult.result === false){
                toReturnErrors = toReturnErrors.concat(pluginResult.errors);
            } else {
                toReturnExecutables.push(pluginResult.execute);
            }
        } // enf of iteration on the incidentsById keys

        const toReturnExecute = function(){
            for(let i=0; i<toReturnExecutables.length; i++){
                toReturnExecutables[i]();
            }
        }

        const additionResult = {
            result: toReturnResult,
            errors: toReturnErrors,
            execute: toReturnExecute
        }
        return additionResult;
    }

    /**
     * The checkEdit method serves exactly what its name implies. To check if the edit of an Incident (edit of Incident's position given in milliseconds delta)
     * is valid and accepted, according to the rules defined on the channels.
     * The method boobles up until it reaches the Clip.
     * @param {object} incident - the incident to edit
     * @param {int} millisecondsDelta - the milliseconds delta of the Incident's start time
     The method should return either:
        {
            result:true,
            execute: // an array of functions that when executed it will edit the Incidents on the Channels
        }
        or
        {
            result: false,
            errors
        }
    */
    checkEdit(incident, millisecondsDelta){
        // get all incidents separated by plugin
        const incidentsById = incident.getIncidentsByChannel();

        // prepare the return payload
        let toReturnResult = true;
        let toReturnErrors = [];
        let toReturnExecutables = [];

        // for each key of the incidentsById object perform the check
        for(let key in incidentsById){
            // perform the check
            const pluginResult = this.instantiatedChannels[key].editIncidents(incidentsById[key], millisecondsDelta);
            toReturnResult = toReturnResult && pluginResult.result;
            if(pluginResult.result === false){
                toReturnErrors = toReturnErrors.concat(pluginResult.errors);
            } else {
                toReturnExecutables.push(pluginResult.execute);
            }
        } // enf of iteration on the incidentsById keys

        const toReturnExecute = function(){
            for(let i=0; i<toReturnExecutables.length; i++){
                toReturnExecutables[i]();
            }
        }

        const editResult = {
            result: toReturnResult,
            errors: toReturnErrors,
            execute: toReturnExecute
        }
        return editResult;
    }


    /**
     * The checkDelete method serves exactly what its name implies. To check if the deletion of an Incident
     * is valid and accepted, according to the rules defined on the channels.
     * The method boobles up until it reaches the Clip.
     * @param {object} incident - the incident to edit
     * @param {object} props - if passed it supports the preventSlip key which if false the channel should not slip. This case is for 
        flashDOM of DOMAwareIncidents where we have elements deleted so slipping on their lanes is not valid nor necessary
      The result might be either:
        {
            result:true,
            execute: // an array of functions that when executed it will remove the Incident on the Channels
        }
        or
        {
            result: false,
            errors
        }
    */
    checkDelete(incidentId, props={}){
        const incident = this.getIncidentById(incidentId);
        // get all incidents separated by plugin
        const incidentsById = incident.getIncidentsByChannel();

        // prepare the return payload
        let toReturnResult = true;
        let toReturnErrors = [];
        let toReturnExecutables = [];

        // for each key of the incidentsById object perform the check
        for(let key in incidentsById){
            // perform the check
            const pluginResult = this.instantiatedChannels[key].removeIncidents(incidentsById[key], props);
            toReturnResult = toReturnResult && pluginResult.result;
            if(pluginResult.result === false){
                toReturnErrors = toReturnErrors.concat(pluginResult.errors);
            } else {
                toReturnExecutables.push(pluginResult.execute);
            }
        } // enf of iteration on the incidentsById keys

        const toReturnExecute = function(){
            for(let i=0; i<toReturnExecutables.length; i++){
                toReturnExecutables[i]();
            }
        }

        const editResult = {
            result: toReturnResult,
            errors: toReturnErrors,
            execute: toReturnExecute
        }
        return editResult;
    }
    
    /**
     * checks if a duration edit is feasible and doesn't cause conflicts
     * @param {int} duration - the new duration
    **/
    checkResizedIncident(durationFraction, incident, adjustMillisecond=0){
        // IF THE GROUP HAS NO PARENTS (IS A CLIP)
        if(incident.id != this.id){
            // get all incidents separated by plugin
            const incidentsById = incident.getIncidentsByChannel();

            // prepare the return payload
            let toReturnResult = true;
            let toReturnErrors = [];
            let toReturnExecutables = [];
            // for each key of the incidentsById object perform the check

            for(let key in incidentsById){
                // perform the check
                const adjustedIncidents = helper.systoleDiastoleProjections(incidentsById[key], durationFraction, adjustMillisecond);
                const pluginResult = this.instantiatedChannels[key].checkResizedIncidents(adjustedIncidents);
                toReturnResult = toReturnResult && pluginResult.result;
                if(pluginResult.result === false){
                    toReturnErrors = toReturnErrors.concat(pluginResult.errors);
                } else {
                    toReturnExecutables.push(pluginResult.execute);
                }
            } // enf of iteration on the incidentsById keys

            const toReturnExecute = function(){
                for(let i=0; i<toReturnExecutables.length; i++){
                    toReturnExecutables[i]();
                }
            }

            const editResult = {
                result: toReturnResult,
                errors: toReturnErrors,
                execute: toReturnExecute
            }
            return editResult;
        } else {
            return {result: true, execute: function(){}};
            // the resizing of the internal Channels occurs on the systolDiastole method of the Groups when they identify that the Groups is actually a Clip
        }
    }

    
    /**
     * Starting from itself and going all the way down to each and every leaf of its tree it systols/diastoles the
     * Incidents
     * @param {float} durationFraction the fraction of the new duration to the existing duration
    **/
    systolDiastole(durationFraction){
        super.systolDiastole(durationFraction);
        
        for(let key in this.instantiatedChannels){
            this.instantiatedChannels[key]._resize(durationFraction);
        }
    }
    
    get isHeadlessClip(){
        return false;
    }
    
    get context(){
        return this.ownContext;
    }
    
    
    /**
     * Returns an object with keys the keys of all the plugins Incidents of which appear in the
     * tree of the Group. All Incidents are projected to the Group's timeline.
     * The array includes the Group's projection too
    */
    getIncidentsByChannel(adjustMillisecond=0){
        let incidentsByPlugin = {};
        incidentsByPlugin[selfContainedIncidentsNpmName] = [ 
            {
                millisecond: adjustMillisecond,
                incident: this,
                id: this.id
            }
        ];

        return incidentsByPlugin;
    }
    
    /**
     * goTo method should always be handled by the Clip. No other Group nor Incident can handle goTo alone.
     * Thus, if the Group is not the Clip it passes the command up. If the Group is the Clip then it handles goTo
     * by passing the command to its Channels.
    **/
    goTo(millisecond, props={}) {
        // first decide the millisecond we want to goTo
        if(millisecond === null || millisecond === undefined){
            millisecond = this.runTimeInfo.currentMillisecond;
        }
        if(props.hasOwnProperty('relativeTo')){
            millisecond += this.getIncidentMillisecond(props.relativeTo);
        }

        if(millisecond > this.duration){
            millisecond = this.duration;
        } else if(millisecond < 0){
            millisecond = 0;
        }

        for(let key in this.instantiatedChannels){
            this.instantiatedChannels[key].goTo(millisecond, props);
        }
        return true;
    }
    
    /**************************************************************************
    **************************************************************************/
    
    handlePipeMessage(name, params){
        const waitingID = params.blockingWaitingID;
        switch(name){
            case pipeMessages._BLOCKING_WAITING:
                if(this.blockingWaitings.hasOwnProperty(waitingID)){
                    helper.error(`Blocking waiting with id=${waitingID} already exists. Blocking waiting is going to be discarded`);
                    return ;
                }
                helper.notice(`adding blocking waiting with id: ${waitingID}`);
                this.blockingWaitings[waitingID] = params;
                this.block();
                break;
            case pipeMessages._UNBLOCK_WAITING:
                if(!this.blockingWaitings.hasOwnProperty(waitingID)){
                    helper.error(`Blocking waiting with id=${waitingID} does not exist and thus unblocking can not be performed`);
                    return ;
                }
                delete this.blockingWaitings[waitingID];
                
                helper.notice(`removing blocking waiting with id: ${waitingID}`);
                // If after the unblocking there are no other blocking waitings:
                if(Object.keys(this.blockingWaitings).length === 0){
                    // if the Clip is on blocked state play
                    this.unblock();
                }
                break;
            case pipeMessages._CLIP_EDITING_STATUS:
                return this.editingStatus;
        }
    }
    
    setVolume(newVal){
        this.volume = parseFloat(newVal);
        this.putMessageOnPipe(pipeMessages._GAIN_CHANGE, {gain: newVal}, false, "down");
    }
    
    onArm(){
        this.blockingWaitings = {};
    }
    
    _onGetContextOnce(){
        return ; // Clips do not get context from noone
    }
    
    exportState(props={}){
        const state = super.exportState(props);
        
        if(props.hasOwnProperty('exportChannels')){
            if(props.exportChannels === true){
                let channelsToExport = [];
                for(let channel in this.instantiatedChannels){
                    let state = this.instantiatedChannels[channel].exportState(props);
                    state.mc_plugin_npm_name = channel;
                    channelsToExport.push(state);
                }
                
                state.channels = channelsToExport;
            }
        }
        
        return state;
    }
    
}

module.exports = ExtendableClip;