const Helper = require('../../_coreUtils/Helper');
const helper = new Helper();
const conf = require('../../configuration/generalConf');
const Channel = require('../../_Channels/Channel');
const _sortBy = require('../../../lodash-custom-build/modularize/lodash.sortby/index.js');
const _filter = require('../../../lodash-custom-build/modularize/lodash.filter/index.js');

class SCIChannel extends Channel {
    /*
    this.incidents is a collection of {incident, id, millisecond} objects always kept in order
        from lower to higher millisecond
    this.incidetnsById is an index of the incidents kept by id (this.incidents[incident-id] = Incident)
    */
    onInitialise(){
        this.incidents = [];
        this.incidentsById = {};
    }
    
    
    _resize(durationFraction){
        for(let i=0; i<this.incidents.length; i++){
            this.incidents[i].millisecond = this.incidents[i].millisecond*durationFraction;
        }
    }
    
    /**
     * On this method the user defines the specific rules that apply on the plugin itself and on the Incidents of the plugin itself
     * The method should either return {result: true} or {result: false, errors:[{error-object}]}, where error-object has the structure:
     *  {
            incident: // reference to the Incident object that has bee discarded
            error: // text
        }
    * @param {array} incidents - a colleciton of all incidents to be added on the form:
    * 
        {
            id
            millisecond
            incident
        }
    * @returns {object} - 
    * either:
        {
            result:true,
            execute: // a function that when executed it will add the Incidents on the Channels
        }
        or
        {
            result: false,
            errors
        }
    */
    checkAddition(incidents){
        let errors = [];
        let candidateIncidentsById = {};
        
        for(let i=0; i<incidents.length; i++){
            candidateIncidentsById[incidents[i].id]= incidents[i].incident;
            if(this.incidentsById.hasOwnProperty(incidents[i].id)){
                helper.error(`Incident with the id ${incidents[i].id} already exists. Addition is rejected.`);
                errors.push({
                    type: 'Already existing id',
                    meta: {
                        id: incidents[i].id
                    }
                });
            }
        }
        
        if(errors.length > 0){
            return {
                result: false,
                errors: errors
            }
        }
        
        const that = this;
        const exec = function(){
            that.incidentsById = Object.assign(that.incidentsById, candidateIncidentsById);
            that.incidents = that.incidents.concat(incidents);
            that.incidents = _sortBy(that.incidents, [
                laneItem => {
                    return laneItem.millisecond;
                }
            ]);
            for(let i=0; i<incidents.length; i++){
                incidents[i].incident.goTo(that.runTimeInfo.currentMillisecond - incidents[i].millisecond);
            }
        }
        
        return {result: true, execute: exec};
    }
    
    
    /**
    @param {array} incidentsArray - A collection of the Incidetns to get edited in the form:
    {
        id
        millisecond
        incident
    }
    @param {int} millisecondsDelta- the delta of the star point of the provided incidents
    */
    checkEdit(incidentsArray, millisecondsDelta){
        const that = this;
        const exec = function(){
            for(let i=0; i<incidentsArray.length; i++){
                for(let j=0; j<that.incidents.length; j++){
                    if(that.incidents[j].id === incidentsArray[i].id){
                        that.incidents[j].millisecond += millisecondsDelta;
                        that.incidents[i].incident.goTo(that.runTimeInfo.currentMillisecond - that.incidents[i].millisecond);
                        break;
                    }
                }
            }
            
            that.incidents = _sortBy(that.incidents, [
                laneItem => {
                    return laneItem.millisecond;
                }
            ]);
            
        }
        
        return {result: true, execute: exec};
    }
    
    checkDelete(incidentsArray){
        const that = this;
        let incidentIds = [];
        for(let i=0; i<incidentsArray.length; i++){
            incidentIds.push(incidentsArray[i].id);
        }
        
        const exec = function(){
            let newIncidents = _filter(that.incidents, incident => {
                return incidentIds.indexOf(incident.id) === -1;
            });
            
            that.incidents = newIncidents;
            for(let i=0; i<incidentIds.length; i++){
                delete that.incidentsById[incidentIds[i]];
            }
        }
        
        return {result: true, execute: exec}; 
    }
    
    /**
    * @param {array} incidents - [{id, start, end, startDelta}] 
    */
    checkResizedIncidents(incidents){
        const that = this;
        const exec = function(){
            for(let i=0; i<incidents.length; i++){
                for(let j=0; j<that.incidents.length; j++){
                    if(that.incidents[j].id === incidents[i].id){
                        that.incidents[j].millisecond += incidents[i].startDelta;
                        that.incidents[i].incident.goTo(that.runTimeInfo.currentMillisecond - that.incidents[i].millisecond);
                        break;
                    }
                }
            }
            
            that.incidents = _sortBy(that.incidents, [
                laneItem => {
                    return laneItem.millisecond;
                }
            ]);
        }
        
        return {result: true, execute: exec};
    }
    
    /**
     @param {int} from - the millisecond to start from
     @param {int} to - the millisecond to go to
     */
    moveTo(from, to) {
        for(let i=0; i<this.incidents.length; i++){
            this.incidents[i].incident.goTo(to - this.incidents[i].millisecond, {previousStop: from-this.incidents[i].millisecond});
        }
    }
    
    
}

module.exports = SCIChannel;