const Helper = require('../../_coreUtils/Helper');
const helper = new Helper();
const conf = require('../../configuration/generalConf');

// context handlers
const IframeContextHandler = require('./helpers/IframeContextHandler');
const PlainContextHandler = require('./helpers/PlainContextHandler');
const WebComponentContextHandler = require('./helpers/WebComponentContextHandler');

const ExtendableClip = require('./ExtendableClip');

class Clip extends ExtendableClip{
    /**
     * @param {object} props - an object that should contain all of the following keys:
     * - html (the html template to render)
     * - css (the css template of the isolated tree)
     * - initParams (optional / the initialisation parameteres that will be passed both on the css and the html templates in order to render)
     * - host (an Element object that will host the isolated tree)
     * - containerParams (an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc)
     * - type (optional, defaults to "closed") the type of the Clip. It can be one of the:
     *  - closed (if closed then if shadow dom is supported by the browser it renders a shadow dom component else it falls back to iframe) 
     *  - plain (if plain it just uses the existing content of the host)
     *  - iframe (if iframe then it renders as an iframe component)
    */
    constructor(props={}, oldProps=null){
        let attrsToPass, propsToUse;
        
        /*
        backwards compatibility. If the user doesn't pass a second argument on the constructor then this is 
        the new way of initialising a Group (only props).
        */
        if(oldProps === null){
            attrsToPass = {};
            propsToUse = props;
        } else { // else, in case the user has passed two arguments then both should be used
            attrsToPass = props;
            propsToUse = oldProps;
        }
        
        let clipType = conf.selfContainedContextHandler;
        if(propsToUse.hasOwnProperty("type")){
            clipType = propsToUse.type;
        }
        
        if(!propsToUse.hasOwnProperty('html') && (clipType === "iframe" || clipType === "openiframe")){
            helper.error(`Self Contained Incident expects the html key on its constructor properties which is missing`);
            return false;
        }
        
        if(!propsToUse.hasOwnProperty('css')  && clipType === "iframe"){
            helper.error(`Self Contained Incident expects the css key on its constructor properties which is missing`);
            return false;
        }
        
        if(!propsToUse.hasOwnProperty('host')){
            helper.error(`Self Contained Incident expects the host key on its constructor properties which is missing`);
            return false;
        } 
        
        let ContextHanlder = null;
        if(clipType === 'closed'){
            if(document.head.createShadowRoot || document.head.attachShadow) {
                ContextHanlder = WebComponentContextHandler;
            } else {
                ContextHanlder = IframeContextHandler;
            }
        } else if(clipType === "plain") {
            ContextHanlder = PlainContextHandler;   
        } else if(clipType === 'iframe'){
            ContextHanlder = IframeContextHandler;
        } else {
            helper.error(`Clip type ${clipType} is not supported`);
            return false;
        }
        
        const contextHanlder = new ContextHanlder(propsToUse);
        
        super(attrsToPass, propsToUse);
        this.ownContext = contextHanlder.context;
        this.iframe = contextHanlder.iframeElement;
        
        this.forceExportIncidents = true;
    }
    
    
    get rootElement(){
        return this.ownContext.clipContainer;
    }
    
    renderHTML(){
        
    }
    
    renderCSS(){
        
    }
    
    ready(){
        this.stop();
        this.setCurrentMillisecond(0);
        this.recalcState(0);
        this.restore();
    }
    
    
}

module.exports = Clip;