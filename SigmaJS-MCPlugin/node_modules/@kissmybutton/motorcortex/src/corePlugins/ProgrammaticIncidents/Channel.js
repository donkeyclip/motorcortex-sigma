const Helper = require('../../_coreUtils/Helper');
const helper = new Helper();
const conf = require('../../configuration/generalConf');
const Channel = require('../../_Channels/Channel');
const _sortBy = require('../../../lodash-custom-build/modularize/lodash.sortby/index.js');
const _filter = require('../../../lodash-custom-build/modularize/lodash.filter/index.js');

class PIChannel extends Channel {
    /*
    this.incidents is a collection of {incident, id, millisecond} objects always kept in order
        from lower to higher millisecond
    this.incidetnsById is an index of the incidents kept by id (this.incidents[incident-id] = Incident)
    */
    onInitialise(){
        this.incidents = [];
        this.incidentsById = {};
    }

    slipToLaneForwards(currentMillisecond, millisecond){
        let participatinIncidents = _filter(this.incidents, laneItem => {
            return (laneItem.millisecond > currentMillisecond && laneItem.millisecond <= millisecond);
        });
        // helper.log(`participating incidents: `, participatinIncidents);

        for(let i=0; i<participatinIncidents.length; i++){
            participatinIncidents[i].incident.command.forwards();
        }

        // this.runTimeInfo.currentMillisecond = millisecond;
    }

    slipToLaneBackwards(currentMillisecond, millisecond){
        // helper.log(`participating incidents: `, participatinIncidents);
        let participatinIncidents = _filter(this.incidents, laneItem => {
            return (laneItem.millisecond > millisecond && laneItem.millisecond <= currentMillisecond);
        });

        for(let i=participatinIncidents.length-1; i>=0; i--){
            participatinIncidents[i].incident.command.backwards();
        }

        // this.runTimeInfo.currentMillisecond = millisecond;
    }


    /**
     * On this method the user defines the specific rules that apply on the plugin itself and on the Incidents of the plugin itself
     * The method should either return {result: true} or {result: false, errors:[{error-object}]}, where error-object has the structure:
     *  {
            incident: // reference to the Incident object that has bee discarded
            error: // text
        }
    * @param {array} incidents - a colleciton of all incidents to be added on the form:
    *
        {
            id
            millisecond
            incident
        }
    * @returns {object} -
    * either:
        {
            result:true,
            execute: // a function that when executed it will add the Incidents on the Channels
        }
        or
        {
            result: false,
            errors
        }
    */
    checkAddition(incidents){
        let errors = [];
        let candidateIncidentsById = {};

        for(let i=0; i<incidents.length; i++){
            candidateIncidentsById[incidents[i].id]= incidents[i].incident;
            if(this.incidentsById.hasOwnProperty(incidents[i].id)){
                helper.error(`Incident with the id ${incidents[i].id} already exists. Addition is rejected.`);
                errors.push({
                    type: 'Already existing id',
                    meta: {
                        id: incidents[i].id
                    }
                });
            }
        }

        if(errors.length > 0){
            return {
                result: false,
                errors: errors
            }
        }

        const that = this;
        const exec = function(){
            that.incidentsById = Object.assign(that.incidentsById, candidateIncidentsById);
            that.incidents = that.incidents.concat(incidents);
            that.incidents = _sortBy(that.incidents, [
                laneItem => {
                    return laneItem.millisecond;
                }
            ]);
            that.slipToLaneForwards(0, that.runTimeInfo.currentMillisecond);
        }

        return {result: true, execute: exec};
    }


    /**
    @param {array} incidentsArray - A collection of the Incidetns to get edited in the form:
    {
        id
        millisecond
        incident
    }
    @param {int} millisecondsDelta- the delta of the star point of the provided incidents
    */
    checkEdit(incidentsArray, millisecondsDelta){
        const that = this;
        const exec = function(){
            for(let i=0; i<incidentsArray.length; i++){
                for(let j=0; j<that.incidents.length; j++){
                    if(that.incidents[j].id === incidentsArray[i].id){
                        that.incidents[j].millisecond += millisecondsDelta;
                        break;
                    }
                }
            }

            that.incidents = _sortBy(that.incidents, [
                laneItem => {
                    return laneItem.millisecond;
                }
            ]);

            that.slipToLaneForwards(0, that.runTimeInfo.currentMillisecond);
        }

        return {result: true, execute: exec};
    }

    checkDelete(incidentsArray){
        const that = this;
        let incidentIds = [];
        for(let i=0; i<incidentsArray.length; i++){
            incidentIds.push(incidentsArray[i].id);
        }

        const exec = function(){
            let newIncidents = _filter(that.incidents, incident => {
                return incidentIds.indexOf(incident.id) === -1;
            });

            that.incidents = newIncidents;
            for(let i=0; i<incidentIds.length; i++){
                delete that.incidentsById[incidentIds[i]];
            }

            that.slipToLaneForwards(0, that.runTimeInfo.currentMillisecond);
        }

        return {result: true, execute: exec};
    }

    /**
    * @param {array} incidents - [{id, start, end, startDelta}]
    */
    checkResizedIncidents(incidents){
        const that = this;
        const exec = function(){
            for(let i=0; i<incidents.length; i++){
                for(let j=0; j<that.incidents.length; j++){
                    if(that.incidents[j].id === incidents[i].id){
                        that.incidents[j].millisecond += incidents[i].startDelta;
                        break;
                    }
                }
            }

            that.incidents = _sortBy(that.incidents, [
                laneItem => {
                    return laneItem.millisecond;
                }
            ]);

            that.slipToLaneForwards(0, that.runTimeInfo.currentMillisecond);
        }

        return {result: true, execute: exec};
    }

    /**
     @param {int} from - the millisecond to start from
     @param {int} to - the millisecond to go to
     */
    moveTo(from, to) {
        if (from < to) {
            // helper.log(`slipping to lane frowards from ${from} to ${to}`);
            this.slipToLaneForwards(
                from,
                to
            );
        } else if (from >= to) {
            // helper.log(`slipping to lane backwards from ${from} to ${to}`);
            this.slipToLaneBackwards(
                from,
                to
            );
        }

    }


}

module.exports = PIChannel;
