const _cloneDeep = require('../../../lodash-custom-build/modularize/lodash.clonedeep/index');
const _filter = require('../../../lodash-custom-build/modularize/lodash.filter/index');
const _sortBy = require('../../../lodash-custom-build/modularize/lodash.sortby/index');
const _findIndex = require('../../../lodash-custom-build/modularize/lodash.findindex/index');
const _find = require('../../../lodash-custom-build/modularize/lodash.find/index');

const Helper = require('../../_coreUtils/Helper');
const helper = new Helper({logLevel: 4});

const Collection = require('./helpers/Collection');
const SandboxLanes = require('./helpers/SandboxLanes');
const SandboxCollection = require('./helpers/SandboxCollection');

class LanesHandler {
    constructor(props={}) {
        /*
         * Keeps the lanes of the Channel in the form:
         * {
         *  <motorcortex-id>_<attribute>: [
         *      {
         *          millisecond: the millisecond of the channel this Animation (that affects the selector/attribute pair) runs
         *          incident: Animation (the animation object that holds the affecting animation
         *      }
         *  ]
         * }
         /** @type {{}}
         */
        this.lanes = new Collection({});
        if(props.lanes){
            this.lanes = props.lanes;
        }
        
        this.comboAttributes = {};
        if(props.comboAttributes != null){
            this.comboAttributes = props.comboAttributes;
        }

        /*
        Keeps an indexing of the lanes each Animation belongs to. The form is the following:
        belongingLaneKeysByAnimationId: {
            <animation_id>: [laneKey1, laneKey2, ...],
            <animation_id>: [laneKey2, laneKey3, ...],
            ...
        }
         */
        this.belongingLaneKeysByAnimationId = new Collection({});
        if(props.belongingLaneKeysByAnimationId){
            this.belongingLaneKeysByAnimationId = props.belongingLaneKeysByAnimationId;
        }
    }

    /**
     * This method resizes all the lanes of the Lanes Handler by the durationFraction provided.
     * No checks are performed. 
     * This method is been invoked in cases where a full Clip gets resized, so no conflict checks need to
     * run.
     * @param {float} durationFration: the fraction between the new duration and the current
    */
    _resize(durationFraction){
        const keys = this.lanes._keys();
        
        for(let i=0; i<keys.length; i++){
            const key = keys[i];
            const theLane = this.lanes._get(key);
            for(let i=0; i<theLane.length; i++){
                theLane[i].millisecond = theLane[i].millisecond*durationFraction;
            }
        }
    }


    /**
     * it creates a new LanesHandler that acts as a sanbox for testing changes
    */
    createTestLanesSanbox(){
        const props = {
            lanes: new SandboxLanes(this.lanes._export()),
            belongingLaneKeysByAnimationId: new SandboxCollection(this.belongingLaneKeysByAnimationId._export()) //JSON.parse(JSON.stringify(this.belongingLaneKeysByAnimationId))
        }
        
        if(this.comboAttributes){
            props.comboAttributes = this.comboAttributes;
        }
        
        return new LanesHandler(props);
    }

    getLanesCopy(lane){
        let laneToReturn = [];
        for(let i=0; i<lane.length; i++){
            laneToReturn.push({
                id: lane[i].id,
                incident: lane[i].incident,
                millisecond: lane[i].millisecond*1
            });
        }
        return laneToReturn;
    }

    getLaneElementsClone(laneElement){
        // return _cloneDeep(laneElement);
        return {
            id: laneElement.id,
            millisecond: laneElement.millisecond*1,
            incident: {
                duration: laneElement.incident.duration*1,
                id: laneElement.incident.id
            }
        }
        // return JSON.parse(JSON.stringify(laneElement));
    }

    applySandboxChanges(SanboxObject){
        this.lanes = new Collection(SanboxObject.lanes._export());
        
        this.belongingLaneKeysByAnimationId = new Collection(SanboxObject.belongingLaneKeysByAnimationId._export());
    }


    getLane(mcid, attr){
        return this.lanes._get(helper.getLaneKey(mcid, attr));
    }
    
    /**
     * Checks whether the incident has animatedAttrs or not. 
    **/
    _incidentHasAnimatedAttrs(incident){
        if(incident.attrs.hasOwnProperty('animatedAttrs')){
            return true;
        }
        return false;
    }

    /**
     * return true if lane exists or false otherwise
     * @param {String} mcid
     * @param {String} attr
     * @param {boolean} ifNotCreateIt - if is set to true and the lane doesn't exist it creates it but still returning false
    */
    laneExists(mcid, attr, ifNotCreateIt=false){
        let laneKey = helper.getLaneKey(mcid, attr);
        if(!this.lanes._hasOwnProperty(laneKey)){
            if(ifNotCreateIt){
                this.lanes._set(laneKey, []);
            }
            return false;
        } else {
            return true;
        }
    }


    animationIDExists(mcid, attr, animationID){
        if(this.belongingLaneKeysByAnimationId._hasOwnProperty(animationID)){
            if(this.belongingLaneKeysByAnimationId._get(animationID).indexOf(helper.getLaneKey(mcid, attr)) >= 0){
                return true;
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * @param {Object} newAnim - an object of the form of a lane item (with keys "millisecond" and "incident"
     * @param {string} mcid
     * @param {String} attr
     * @param {array} excludeIdsFromCheck - optional. If exists it excludes all the ids of this array from check. This
     *  parameter has been added for the edit checks where an animation might overlap another animation that participates on
     *  the move, something that should not happen as the edited animations pre-existed without conflicts and the move of all
     *  of them together guarantees that there is going to be no conflict between them even after the edit
     * @param {int} testDuration - optional. This parameter is used when the channel needs to addcheck overlaps after duration
     *  edits, so the testDuration is passed (we don't want to polute the original animation object as it refers to the real one)
     * @retuns {array} - a list of all overlapping animations of the lane
    */
    getOverlappingAnims(newAnim, mcid, attr, excludeIdsFromCheck=[], testDuration=null){
        let overlappingAnims = _filter(this.lanes._get(helper.getLaneKey(mcid, attr)), function(existingAnim){
            let durationToUseOnChecks = newAnim.incident.duration;
            if(testDuration != null){
                durationToUseOnChecks = testDuration;
            }

            return (
                existingAnim.incident.id != newAnim.incident.id &&
                excludeIdsFromCheck.indexOf(existingAnim.incident.id) < 0 && (
                // existing anim starts within the new anim's extend
                (existingAnim.millisecond >= newAnim.millisecond
                    && existingAnim.millisecond < durationToUseOnChecks + newAnim.millisecond)
                // or ends within the new anim's extend
                || (existingAnim.millisecond + existingAnim.incident.duration > newAnim.millisecond
                    && existingAnim.millisecond + existingAnim.incident.duration <= durationToUseOnChecks + newAnim.millisecond)
                // or it starts before and ends after the new anim's extend
                || (existingAnim.millisecond < newAnim.millisecond
                    && existingAnim.millisecond + existingAnim.incident.duration > durationToUseOnChecks + newAnim.millisecond)
            ));
        });

        return overlappingAnims;
    }

    /**
     * it justs adds the lane item to the lane and adjusts the initial values of the Anims in sequence
     * No checks are performed, just execution.
     * @param {String} mcid
     * @param {String} attr
     * @param {int} millisecond
     * @param {Object} incident
    */
    addElementToLane(mcid, attr, millisecond, incident){

        const laneKey = helper.getLaneKey(mcid, attr);

        const laneElement = {
            millisecond: millisecond,
            incident: incident,
            id: incident.id
        };

        this.laneExists(mcid, attr, true);
        let theLane = this.lanes._get(laneKey);

        theLane.push(laneElement);
        theLane = _sortBy(theLane, ['millisecond']);

        // indexing stuff
        if(!this.belongingLaneKeysByAnimationId._hasOwnProperty(incident.id)){
            this.belongingLaneKeysByAnimationId._set(incident.id, []);
        }
        this.belongingLaneKeysByAnimationId._get(incident.id).push(
            laneKey
        );
        // indexing
        const newAnimsIndex = _findIndex(theLane, function(item){
            return item.incident.id === incident.id;
        });
        
        /* if the incident has no animated attributes we don't need to work on start and final values */
        if(!this._incidentHasAnimatedAttrs(incident)){
            return {onSuccessAction: function(){}}
        }

        // helper.log(newAnimsIndex);
        // step 1: set the intial values of the new Animation
        if(newAnimsIndex === 0) { // if the newly entered animation is the first of the lane
            if(theLane.length > 1){ // and it has other animations too
                if(theLane[1].incident.hasInitialValue(attr)){ // if the initial value of the following animation
                // which used to be first is already calculated "steal" it
                    incident.setInitialValue(attr, theLane[1].incident.getInitialValue(attr));
                }
            } else { // else take it directly from the dom
                incident.setInitialValue(attr, incident.getScratchValue(mcid, attr) );
            }
        } else {
            incident.setInitialValue( attr, theLane[newAnimsIndex - 1].incident.attrs.animatedAttrs[attr] );
        }
        
        /* if the attribute of the lane is a compo attribute */
        if(this.comboAttributes.hasOwnProperty(attr)){
            const incidentInitialValues = incident.getInitialValue(attr);
            for(let key in incidentInitialValues){
                if(!incident.attrs.animatedAttrs[attr].hasOwnProperty(key)){
                    incident.attrs.animatedAttrs[attr][key] = incidentInitialValues[key];   
                }
            }
        }

        let onSuccessAction = function(){};
        // step 2: set the inital values of the following Animation (if any)
        if(newAnimsIndex + 1 < theLane.length){
            onSuccessAction = function(){
                theLane[newAnimsIndex + 1].incident.setInitialValue( attr, incident.attrs.animatedAttrs[attr] );
                if(theLane[newAnimsIndex + 1].incident.gotContext){
                    theLane[newAnimsIndex + 1].incident.onGetContext();
                }
            }
        }

        onSuccessAction();

    }


    /**
     * it justs updates the lane
     * No checks are performed, just execution
     * @param {array} affectedAnimationsIds
     * @param {String} attr
     * @param {int} millisecondDelta
    */
    updateLane(affectedAnimationsIds, millisecondsDelta){
        // first we group the affected animations by lanes
        let affectedLanes = {};
        const that = this;
        for (let i = 0; i < affectedAnimationsIds.length; i++) {
            const belongingLanes = this.belongingLaneKeysByAnimationId._get(affectedAnimationsIds[i]);
            for(let j=0; j<belongingLanes.length; j++){
                const laneKey = belongingLanes[j];
                if(!affectedLanes.hasOwnProperty(laneKey)){
                    affectedLanes[laneKey] = {
                        animations: [],
                        lane: that.lanes._get(laneKey),
                        laneData: helper.getMCIDandAttrOutOfLaneKey(belongingLanes[j])
                    }
                }
                affectedLanes[laneKey].animations.push(affectedAnimationsIds[i]);
            }
        }

        // for each of the affected lanes
        for (let laneKey in affectedLanes) {
            let affectedLane = affectedLanes[laneKey];
            let lane = affectedLane.lane;
            const laneData = affectedLane.laneData;
            const laneBeforeEdit = _sortBy(this.getLanesCopy(lane), ['millisecond']);

            // edit lane items millisecond
            for (let k = 0; k < lane.length; k++) {
                if (affectedLane.animations.indexOf(lane[k].incident.id) >= 0) {
                    lane[k].millisecond += millisecondsDelta;
                }
            } // end for searching for the animations within the lane

            let sortedLane = _sortBy(lane, ['millisecond']);
            this.lanes._set(laneKey, sortedLane);
            lane = sortedLane;
            // console.log(this);

            for(let i=0; i<affectedLane.animations.length; i++){
                let animationToCheck = affectedLane.animations[i];
                const animationIndexBeforeEdit = _findIndex(laneBeforeEdit, function(item){
                   return item.incident.id === animationToCheck;
                });
                const animationIndexAfterEdit = _findIndex(lane, function(item){
                   return item.incident.id === animationToCheck;
                });
                const animation = lane[animationIndexAfterEdit].incident;
                
                /**
                 * if the first animation doesn't have animated attributes that means no one on this channel has. Brake
                 * and exit the loop that handles start and end values
                */
                if(!this._incidentHasAnimatedAttrs(animation)){
                    break;
                }

                if(animationIndexBeforeEdit !== animationIndexAfterEdit || animationIndexAfterEdit > 1){
                    if(animationIndexBeforeEdit + 1 < lane.length){ // if the animation was not the last animation on the lane before the edit
                        // we should take care of the initial values of the animation's previous successor
                        if(animationIndexBeforeEdit === 0){ // if the edited animation was the first one before the edit
                            // if it has initial values, pass them to its previous successor as its new initial values
                            if(animation.hasInitialValue(laneData.attribute) !== false){
                                // get the initial value of the edited animation and set it as initial value of the new 0 index
                                laneBeforeEdit[1].incident.setInitialValue(laneData.attribute, animation.getInitialValue(laneData.mcid, laneData.attribute));
                            } else { // otherwise calculate the initial value on the fly, out of the dom and set it to the new 0
                                laneBeforeEdit[1].incident.setInitialValue(laneData.attribute, laneBeforeEdit[1].incident.getScratchValue(laneData.mcid, laneData.attribute));
                            }
                        } else { // else if the edited animation was not the first one before the edit
                            // meaning its previous successor is not the first one on the lane after the edit
                            // just grab the target value of the new previous animation of the animation's previous successor and set it as initial value
                            laneBeforeEdit[animationIndexBeforeEdit + 1].incident.setInitialValue(laneData.attribute, laneBeforeEdit[animationIndexBeforeEdit-1].incident.attrs.animatedAttrs[laneData.attribute]);
                        }
                    }

                    // for the edited animation itself now:
                    if(animationIndexAfterEdit === 0){ // is it the first one (after edit)?
                        // does the previously zero index animation has initial value?
                        if(laneBeforeEdit[0].incident.hasInitialValue(laneData.attribute)){
                            // get the initial values of the previously 0 indexed animation of the lane
                            animation.setInitialValue(laneData.attribute, laneBeforeEdit[0].incident.getInitialValue(laneData.mcid, laneData.attribute));
                        } else { // otherwise calculate the initial value on the fly, our of the dom
                            animation.setInitialValue(laneData.mcid, laneData.attribute, animation.getScratchValue(laneData.mcid, laneData.attribute));
                        }
                    } else { // else if it is not the first one after edit
                        // just grab the target value of the previous animation on the updated lane and set it as its initial value
                        animation.setInitialValue(laneData.attribute, lane[animationIndexAfterEdit-1].incident.attrs.animatedAttrs[laneData.attribute]);
                    }

                    // for its new next animation (if it has one)
                    if(animationIndexAfterEdit + 1 < lane.length){
                        // set its initial value to equal the target value of the edited animation
                        lane[animationIndexAfterEdit + 1].incident.setInitialValue(laneData.attribute, animation.attrs.animatedAttrs[laneData.attribute]);
                    }
                }
            }

        } // end for each of the belonging lanes of the animation

    }

    /**
     * removes the list of animations as provided
     * @param {array} removedAnimations - an array with the removed animations' ids
    */
    deleteAnimations(removedAnimations, currentMillisecond){
        let affectedLanes = {};

        for (let i = 0; i < removedAnimations.length; i++) {
            const id = removedAnimations[i];
            // for each lane the affected Animation appears in
            const belongingLanes = this.belongingLaneKeysByAnimationId._get(id);
            for (let j = 0; j < belongingLanes.length; j++) {
                let lane = this.lanes._get(belongingLanes[j]);

                let animationIndexBeforeEdit = -1;
                for(let k=0; k<lane.length; k++){
                    if(lane[k].incident.id === id){
                        animationIndexBeforeEdit = k;
                        break;
                    }
                }

                // helper.log(animationIndexBeforeEdit);
                const animationToDelete = Object.assign({}, lane[animationIndexBeforeEdit]);
                const animationObjectToDelete = animationToDelete.incident;
                const laneData = helper.getMCIDandAttrOutOfLaneKey(belongingLanes[j]);

                // gets the lane without the removed animation
                let newLane = [];
                for(let k=0; k<lane.length; k++){
                    if(lane[k].incident.id != id){
                        newLane.push(lane[k]);
                    }
                }
                this.lanes._set(belongingLanes[j], newLane);
                lane = this.lanes._get(belongingLanes[j]);

                if (lane.length === 0) {
                    this.lanes._delete(belongingLanes[j]);
                    if(affectedLanes.hasOwnProperty(belongingLanes[j])){
                        delete affectedLanes[belongingLanes[j]];
                    }
                } else {
                    if(this._incidentHasAnimatedAttrs(animationToDelete.incident)){
                        affectedLanes[belongingLanes[j]] = helper.getMCIDandAttrOutOfLaneKey(belongingLanes[j]);
                        if(animationIndexBeforeEdit < lane.length && animationToDelete.incident.getInitialValue(laneData.mcid, laneData.attribute) !== false){
                            lane[animationIndexBeforeEdit].incident.setInitialValue(laneData.attribute, animationToDelete.incident.getInitialValue(laneData.mcid, laneData.attribute));
                        }
                    }
                }
            }
            this.belongingLaneKeysByAnimationId._delete(removedAnimations[i]);
        }
        return affectedLanes;
    }


    /**
     * This method handles edits on the final value of a specific attribute of a specific animation object
     * @param {string} animationId - the id of the Animation object that has been edited
     * @param {string} attr - the name of the attribute that has been edited
     * @param {string} value - the new value of the edited attribute
    */
    updateAttributeOnLanes(animationId, attr, value){
        const belongingLanes = this.belongingLaneKeysByAnimationId._get(animationId);
        let affectedLanes = [];
        for (let i = 0; i < belongingLanes.length; i++) {
            let lane = this.lanes._get(belongingLanes[i]);
            const laneData = helper.getMCIDandAttrOutOfLaneKey(belongingLanes[i]);

            // get the index of the animation on the lane
            let animationIndex = -1;
            for(let k=0; k<lane.length; k++){
                if(lane[k].incident.id === animationId){
                    animationIndex = k;
                    break;
                }
            }

            // if the animation is not the last one on the lane
            if(lane.length-1 != animationIndex){
                lane[animationIndex+1].incident.setInitialValue(laneData.mcid, laneData.attribute, value);
            }

            affectedLanes.push(laneData);
        }

        return affectedLanes;
    }
}

module.exports = LanesHandler;
