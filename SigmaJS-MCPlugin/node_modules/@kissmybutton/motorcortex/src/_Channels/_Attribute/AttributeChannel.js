const Channel = require('../Channel');
const Helper = require('../../_coreUtils/Helper');
const helper = new Helper();
const conf = require('../../configuration/generalConf');

const _filter = require('../../../lodash-custom-build/modularize/lodash.filter/index');
const _sortBy = require('../../../lodash-custom-build/modularize/lodash.sortby/index');

const lanesHandler = require('./LanesHandler');



class AttributeChannel extends Channel {
    constructor(props) {
        super(props);
        
        /*
        comboAttributes are attributes of type object, holding a number of other attributes.
        E.g. CSS "transform" attribute is a combo that holds a number of other attributes such as:
        translateX, translateY, etc. The lanes handler keeps just one lane for the combo attrs 
        in an object format keeping the value of each attribute at any given point.
        Combo attributes are passed on the constructor of the Channel in the format:
        props.comboAttributes: {
            transition: ['translateX', 'translateY', ...],
            <something_else>: ['<attrName1>', '<attrName2>', ...]
        }
        */
        this.comboAttributes = {};
        
        /**
         * For incidents that do not have animatedAttrs there should be only one lane per element. 
         * The attributes Channel will use a default (fake), fixed attribute for this cases so it always ends
         * up with just one lane per element: <element_id>_<this.fixedAttributeName>
        */
        this.fixedAttributeName = "_";
        
        if(props.comboAttributes != null){
            this.comboAttributes = props.comboAttributes;
        }
        
        this.LanesHandler = new lanesHandler({comboAttributes: this.comboAttributes});
        // this.type = "attributes";
    }
    
    static get type(){
        return "attributes";
    }

    setComboAttributes(comboAttributes){
        this.comboAttributes = comboAttributes;
        this.LanesHandler = new lanesHandler({comboAttributes: this.comboAttributes});
    }

    get lanes(){
        return this.LanesHandler.lanes;
    }
    
    _resize(durationFraction){
        this.LanesHandler._resize(durationFraction);
    }

    /**
     * Checks whether the incident has animatedAttrs or not. 
    **/
    _incidentHasAnimatedAttrs(incident){
        if(incident.attrs.hasOwnProperty('animatedAttrs')){
            return true;
        }
        return false;
    }


    /* *******************************************************
     DECISION METHODS
     ********************************************************/

    /**
     * All of the incidents coming to this method are element-attribute incidents meaning that they only
     * target just one element and also they include just a single attribute on the incident.attrs.animatedAttrs
     * object
     *
     * @param {array} incidents - A collection of Incidents in the form:
     * {
     *  millisecond
     *  incident
     *  id
     * }
     * @param {string} type - can be either "all-or-nothing" (default) or "keep-passing". If type = "all-or-nothing"
     *  the addition passes only if all incidents pass. If type = "keep-passing" the method will still return true
     *  but will also include an errors array on its return and also will only include the success callbacks on 
     *  the execute key of its return
     * @returns either:
     *   {
     *       result:true,
     *       execute: // an array of functions that when executed it will add the Incidents on the Channels
     *   }
     *   or
     *   {
     *       result: false,
     *       errors
     *   }
    */
    checkAddition(incidents, type="all-or-nothing"){
        const LanesHandlerSandbox = this.LanesHandler.createTestLanesSanbox();
        /* an array where we keep all affected lanes so we can slip on them at the end. 
        The format for each affected lane we keep is:
        {
            mcid: mcid,
            attribute: attribute
        }
        */
        let affectedLanes = []; 
        

        // while the LanesHandlerSanbox adds lane items it makes decisions of which permanent changes should be made to
        // the permanent and pre-existing objects it handles, such as changes on the initial values of existing animations.
        // Because of the fact the LanesSandboxHandler is only there for testing we don't want to execute these changes
        // during checks but still we need to know them on success. For this, the onSuccessActions array holds all executable
        // functions retured by various LanesHandlerSanbox functions so it can execute them on success.
        let onSuccessActions = [];

        let conflicts = [];
        for (let i = 0; i < incidents.length; i++) {
            let incidentConflicts = false; // a boolean that keeps the information whether the incident conflicts or not
            const laneItem = incidents[i];
            const incident =laneItem.incident;

            const mcid = this.context.getMCID(incident.element);

            // console.log("the incident",incident)
            let attribute = this.fixedAttributeName;
            if(this._incidentHasAnimatedAttrs(incident)){
                attribute = Object.keys(incident.attrs.animatedAttrs)[0];
            }
            

            LanesHandlerSandbox.laneExists(mcid, attribute); // create the lane if it doesn't exist already

            affectedLanes.push({
                mcid: mcid,
                attribute: attribute
            });

            if(LanesHandlerSandbox.animationIDExists(mcid, attribute, incident.id)){
                incidentConflicts = true;
                conflicts.push({
                    type: 'duplicate Animation id',
                    meta: {
                        id:incident.id
                    }
                });
            }

            // **** if the lane did exist before the new addition check for conflicts
            let overlappingAnims = LanesHandlerSandbox.getOverlappingAnims(laneItem, mcid, attribute);

            // helper.log(overlappingAnim)
            if(overlappingAnims.length > 0){
                incidentConflicts = true;
                conflicts.push({
                    type: 'unauthorised, overlapping incidents on the same element',
                    meta: {
                        element_mcid: mcid,
                        attribute: attribute,
                        incident: laneItem,
                        overlappingAnims: overlappingAnims
                    }
                });
            }

            if(!incidentConflicts){
                onSuccessActions.push(function(){
                    LanesHandlerSandbox.addElementToLane(mcid, attribute, laneItem.millisecond, incident);
                    incident._onGetContextOnce();
                });
            }

        } // end for each incident

        // if we have conflicts and the type = "all-or-nothing"
        if(conflicts.length > 0 && type === "all-or-nothing"){
            return {
                result: false,
                errors: conflicts
            }
        } else {
            // as soon as we want all passing additions to get applied the Lanes Handler will create a callback that will be passed to the result.
            // This callback will apply all passing additions.

            // success message
            const that = this;
            const exec = function(){
                for(let i=0; i<onSuccessActions.length; i++){
                    onSuccessActions[i]();
                }
                that.LanesHandler.applySandboxChanges(LanesHandlerSandbox);

                // TODO how exactly are we handling slipping?
                for(let i=0; i<affectedLanes.length; i++){
                    const affectedLane = affectedLanes[i];
                    that.slipIntoLaneForwards(that.LanesHandler.getLane(affectedLane.mcid, affectedLane.attribute), affectedLane, 0, that.runTimeInfo.currentMillisecond);
                }
            }

            return {
                result: true,
                errors: conflicts,
                execute: exec
            }
        }
    }

     /**
     * It initially checks if the edit is allowed and if it is it retuns an array of executable functions
     * that apply the change
     * @param {array} incidents - the list of the lane items to edit in an array format [object, object, ...]
     * @param {int} millisecondsDelta - the milliseconds delta to apply to the incidents
     * @returns {object} -
     * either:
     {
        result: true,
        execute: // array of functions to be executed in order to apply the edit
     }
     or
     {
         result: false,
         errors: // an array including all the errors / conflicts found on edit
     }
    */
    checkEdit(incidents, millisecondsDelta) {

        const affectedIncidentIds = [];
        for(let i=0; i<incidents.length; i++){
            affectedIncidentIds.push(incidents[i].id);
        }

        const LanesHandlerSandbox = this.LanesHandler.createTestLanesSanbox();

        let conflicts = [];
        let affectedLanes = [];

        // for each of the affectedAnimations
        for (let i = 0; i < incidents.length; i++) {
            const incident = incidents[i].incident;
            const incidentId = incident.id;
            const mcid = this.context.getMCID(incident.element);
            let attribute = this.fixedAttributeName;
            if(this._incidentHasAnimatedAttrs(incident)){
                attribute = Object.keys(incident.attrs.animatedAttrs)[0];
            }
            const lane = LanesHandlerSandbox.getLane(mcid, attribute);
            const laneAttrs = {
                mcid: mcid,
                attribute: attribute
            }

            // check for conflicts and edit lane items millisecond
            for (let k = 0; k < lane.length; k++) {
                if (lane[k].incident.id === incidentId) {
                    affectedLanes.push(laneAttrs);
                    let affectedAnim = lane[k];
                    let testLaneElement = LanesHandlerSandbox.getLaneElementsClone(affectedAnim);
                    testLaneElement.millisecond += millisecondsDelta;
                    let overlappingAnims = LanesHandlerSandbox.getOverlappingAnims(testLaneElement, mcid, attribute, affectedIncidentIds);


                    if(overlappingAnims.length > 0){
                        conflicts.push({
                            type: 'anauthorised, overlapping animations on the same element',
                            meta: {
                                element_mcid: mcid,
                                attribute: attribute,
                                newAnimation: testLaneElement,
                                overlappingAnims: overlappingAnims
                            }
                        });
                    }

                    break;
                } // end of if we found the specific animation on the lane's sequence
            } // end of each lane's item


        } // end for each affected animation's id

        if(conflicts.length > 0){
            return {
                result: false,
                errors: conflicts
            }
        } else {
            const that = this;
            const exec = function(){
                // as soon as there are no conflicts the Lanes Handler applies the changes before sending over the
                // success message
                that.LanesHandler.updateLane(affectedIncidentIds, millisecondsDelta);

                for(let i=0; i<affectedLanes.length; i++){
                    const affectedLane = affectedLanes[i];
                    const theActualLane = that.LanesHandler.getLane(affectedLane.mcid, affectedLane.attribute);
                    that.slipIntoLaneForwards(theActualLane, affectedLane, 0, that.runTimeInfo.currentMillisecond);
                }
            }
            return {
                result: true,
                execute: exec
            }

        }
    }


    /**
     * @param {array} affectedAnimations - [{id, start, end, startDelta}]
     * @param {boolean} fullChannelResize - if set to true then the full html channel is resizing. This is a special case as in
     *  that case no checks should be actually perfomed nor the projected candidate should be applied directly
    **/
    checkResizedIncidents(affectedAnimations, fullChannelResize=false){
        const excludeIdsFromCheck = [];
        for(let i=0; i<affectedAnimations.length; i++){
            excludeIdsFromCheck.push(affectedAnimations[i].id);
        }

        const LanesHandlerSandbox = this.LanesHandler.createTestLanesSanbox();

        let conflicts = [];
        let affectedLanes = [];

        // for each of the affectedAnimations
        for (let i = 0; i < affectedAnimations.length; i++) {
            const belongingLanes = LanesHandlerSandbox.belongingLaneKeysByAnimationId._get(affectedAnimations[i].id);
            const testDuration = affectedAnimations[i].end - affectedAnimations[i].start;

            // for each lane the affected Animation appears in
            for (let j in belongingLanes) {
                const lane = LanesHandlerSandbox.lanes._get(belongingLanes[j]);
                let laneData = helper.getMCIDandAttrOutOfLaneKey(belongingLanes[j]);


                // check for conflicts and edit lane items millisecond
                for (let k = 0; k < lane.length; k++) {
                    if (lane[k].incident.id === affectedAnimations[i].id) {
                        affectedLanes.push(laneData);
                        if(fullChannelResize === false){
                            let affectedAnim = lane[k];
                            let testLaneElement = LanesHandlerSandbox.getLaneElementsClone(affectedAnim);
                            testLaneElement.millisecond += affectedAnimations[i].startDelta;
                            let overlappingAnims = LanesHandlerSandbox.getOverlappingAnims(testLaneElement, laneData.mcid, laneData.attribute, excludeIdsFromCheck, testDuration);


                            if(overlappingAnims.length > 0){
                                conflicts.push({
                                    type: 'anauthorised overlapping animations on the same element',
                                    meta: {
                                        element_mcid: laneData.mcid,
                                        attribute: laneData.attribute,
                                        newAnimation: testLaneElement,
                                        overlappingAnims: overlappingAnims
                                    }
                                });
                            }
                        }

                        break;
                    } // end of if we found the specific animation on the lane's sequence
                } // end of each lane's item


            } // end of each belonging lane
        } // end for each affected animation's id

        if(conflicts.length > 0){
            return {
                result: false,
                conflicts: conflicts
            }
        } else {
            // unlike the case of editing the start millisecond of a Scene / Incident on editing the duration of a Scene
            // or an Incident slipping to lanes should occur depends not only on the positioning of the Animations on
            // the lanes but also on their duration. Editing the duration occurs on the Scene that received the editDuration
            // command and thus at that point the HTMLChannel (and its LanesHaldler) is not ready to slip as the affected
            // Animations still have the old (un-edited) duration.
            // For this reason and only on the case of duration edit slip to lanes will take place not here and not now
            // but on the scope of the Scene that got the command, at the point it receives the success ({result:true}).
            // For this we will create a callback function which holds the slipping to lanes commands and pass it on the
            // "callback" key of the result object ({success:true, callback:function(){that slips into lanes}})
            const that = this;

            const exec = function(){
                const slippingCommands = []; // an array that will hold all of the slipping commands in all of the affected lanes

                // updateLanes (only this time animation by animation as the milliseconds delta is not standard for all)
                // as soon as there are no conflicts the Lanes Handler applies the changes before sending over the
                // success message
                for(let i=0; i<affectedAnimations.length; i++){
                    that.LanesHandler.updateLane([affectedAnimations[i].id], affectedAnimations[i].startDelta);
                }

                for(let i=0; i<affectedLanes.length; i++){
                    const affectedLane = affectedLanes[i];
                    const theActualLane = that.LanesHandler.getLane(affectedLane.mcid, affectedLane.attribute);
                    // put the slip command on the slippingCommands array
                    slippingCommands.push(()=>{
                       that.slipIntoLaneForwards(theActualLane, affectedLane, 0, that.runTimeInfo.currentMillisecond);
                    });
                }

                for(let i=0; i<slippingCommands.length; i++){
                    slippingCommands[i]();
                }
            }

            return {
                execute: exec,
                result: true
            }
        }
    }

    /**
     * 
    */
    checkDelete(removedAnimations, props={}) {
        let removedAnimationIds = [];
        for(let i=0; i<removedAnimations.length; i++){
            removedAnimationIds.push(removedAnimations[i].id);
        }

        // no slipping is needed as on deletion the Animations set their elements to their initial values
        const that = this;
        const exec = function(){
            const affectedLanes = that.LanesHandler.deleteAnimations(removedAnimationIds, that.runTimeInfo.currentMillisecond);
             for(let laneKey in affectedLanes){
                const affectedLane = affectedLanes[laneKey];
                const theActualLane = that.LanesHandler.getLane(affectedLane.mcid, affectedLane.attribute);
                if(props.preventSlip != true){
                    that.slipIntoLaneForwards(theActualLane, affectedLane, 0, that.runTimeInfo.currentMillisecond);
                }
            }
            
        }

        return {
            result: true,
            execute: exec
        }

    }

    /**
     * checks if a duration edit is feasible and doesn't cause conflicts
     * @param {int} duration - the new duration
     * @param {array} ids - (optional) if provided it only checks resizes on the given ids (not all incidents have been re)
    **/
    checkDurationEdit(durationFraction, ids=[]){
        // using ProjectionsHanlder it will create the candidates and the projections to pass up to the parent
        // returned object keys: candidateOwnProjectedAnimations, affectedAnimations
        const projectedAnimations = this.projectionsHandler.systoleDiastoleProjections(durationFraction, ids);
        // once it gets the porojectedAnimations from its projections hanlder it will pass it up for check

        // if the ids array is provided that means the checkDurationEdit is been used by an Animation directly
        // belonging to the html channel, so it's not a full channel resize
        const check = this.checkResizedAnimations(projectedAnimations.affectedAnimations, ids.length===0?true:false);

        return check;
    }


    /**
     * Method that is invoked by Animation objects when one of their attributes value is edited
     * The purpose of this method here on the HTMLChannel is to update the lanes accordingly and slip into the
     * corresponding lanes
     * @param {string} animationId - the id of the Animation object that has been edited
     * @param {string} attr - the name of the attribute that has been edited
     * @param {string} value - the new value of the edited attribute
    */
    animationAttributeValueChange(animationId, attr, value){
        const affectedLanes = this.LanesHandler.updateAttributeOnLanes(animationId, attr, value);
        for(let i=0; i<affectedLanes.length; i++){
            const affectedLane = affectedLanes[i];
            const theActualLane = this.LanesHandler.getLane(affectedLane.mcid, affectedLane.attribute);
            this.slipIntoLaneForwards(theActualLane, affectedLane, 0, this.runTimeInfo.currentMillisecond);
        }
    }


    /**
     * Slips to just one lane forwards
     * @param {array} lane - the lane to slip into
     * @param {object} laneData - an object with keys: attribute & mcid
     * @param {int} currentMillisecond - the millisecond the slip starts from
     * @param {int} millisecond - the target millisecond of the slip
     */
    slipIntoLaneForwards(lane, laneData, currentMillisecond, millisecond) {
        // helper.log(lane, currentMillisecond, millisecond);
        let participatingAnims = _filter(lane, laneItem => {
            return (
                (laneItem.millisecond + laneItem.incident.duration >= currentMillisecond &&
                    laneItem.millisecond + laneItem.incident.duration <= millisecond) || // it ends after currentMillisecond and before target millisecond
                (laneItem.incident.duration + laneItem.millisecond >= millisecond &&
                    laneItem.millisecond <= millisecond)
            ); // or it ends after the target millisecond but also starts before it
        });

        if (participatingAnims.length == 0) {
            return true;
        }

        participatingAnims = _sortBy(participatingAnims, [
            laneItem => {
                return laneItem.millisecond;
            }
        ]);

        // now we have all participatingAnims of the slip action in chronological order
        // our first job is to create a variable that will hold the last known value of the lane
        let lastValue = null;
        for (let i = 0; i < participatingAnims.length; i++) {
            const participatingAnim = participatingAnims[i].incident;
            const startMillisecond = participatingAnims[i].millisecond;

            // if the animation has no start values go ahead and calculated them now
            if (
                !participatingAnim.hasInitialValue(laneData.attribute) &&
                lastValue === null
            ) {
                // helper.log('setting initial value: ', laneData.mcid, laneData.attribute, 'calculated');
                participatingAnim.setInitialValue(laneData.mcid, laneData.attribute);
            } else if (
                !participatingAnim.hasInitialValue(laneData.attribute) &&
                lastValue != null
            ) {
                // helper.log('setting initial value: ', laneData.mcid, laneData.attribute, lastValue);
                participatingAnim.setInitialValue(laneData.mcid, laneData.attribute, lastValue);
            }

            // if the animation ends before the target millisecond
            // helper.log('participatingAnim.duration + startMillisecond', participatingAnim.duration + startMillisecond, millisecond);\

            if (participatingAnim.duration + startMillisecond <= millisecond) {
                // helper.log('ends before target')
                if(participatingAnim.attrs.hasOwnProperty('animatedAttrs')){
                    lastValue = participatingAnim.attrs.animatedAttrs[laneData.attribute];
                }
                if (i === participatingAnims.length - 1) {
                    participatingAnim.progress( 1, participatingAnim.duration );
                }
            } else {
                // slip for the specific element and the specific attribute. Set the Animation as paused or playing a
                // and store this info somewhere
                const percentageComplete =
                    (millisecond - startMillisecond) / participatingAnim.duration;
                participatingAnim.progress( percentageComplete, millisecond - startMillisecond );
            }
        }
    }

    /**
     * Slips to just one lane backwards
     * @param {array} lane - the lane to slip into
     * @param {object} laneData - an object with keys: attribute & mcid
     * @param {int} currentMillisecond - the millisecond the slip starts from
     * @parama {int} millisecond - the target millisecond of the slip
     */
    slipToLaneBackwards(lane, laneData, currentMillisecond, millisecond) {
        // we take all Animations that are either currently running or
        // they end after the destination point
        // helper.log('<------');
        let participatingAnims = _filter(lane, laneItem => {
            const laneItemEnd = laneItem.incident.duration + laneItem.millisecond;
            return (
                (laneItemEnd <= millisecond && laneItemEnd >= currentMillisecond) || // they end in the hot area
                (laneItem.millisecond >= currentMillisecond &&
                    laneItem.millisecond <= millisecond) || // they start in the hot area
                (laneItem.millisecond < currentMillisecond && laneItemEnd > millisecond)
            ); // they overlap the hot area
        });

        if (participatingAnims.length == 0) {
            return true;
        }

        participatingAnims = _sortBy(
            participatingAnims,
            [
                laneItem => {
                    return laneItem.millisecond;
                }
            ]
        );


        let lastValue = null;
        for (let i = participatingAnims.length-1; i >=0; i--) {
            const participatingAnim = participatingAnims[i].incident;
            const startMillisecond = participatingAnims[i].millisecond;
            if (startMillisecond >= millisecond) {
                participatingAnim.progress( 0, 0 );
            } else {
                const percentageComplete =
                    (millisecond - startMillisecond) / participatingAnim.duration;

                participatingAnim.progress( percentageComplete, millisecond - startMillisecond );
            }
        }
    }

    /**
     @param {int} from - the millisecond to start from
     @param {int} to - the millisecond to go to
     */
    moveTo(from, to) {
        // step 1: iterate through all lanes
        const laneKeys = this.lanes._keys();
        for (let i=0; i<laneKeys.length; i++) {
            const laneid = laneKeys[i];
            const lane = this.lanes._get(laneid);
            const laneData = helper.getMCIDandAttrOutOfLaneKey(laneid);
            if (from < to) {
                // helper.log(laneid);
                this.slipIntoLaneForwards(
                    lane,
                    laneData,
                    from,
                    to
                );
            } else if (from >= to) {
                this.slipToLaneBackwards(
                    lane,
                    laneData,
                    from,
                    to
                );
            }
        }
    }
}

module.exports = AttributeChannel;
