const Helper = require('../_coreUtils/Helper');
const helper = new Helper();
const conf = require('../configuration/generalConf');


class Channel {
    constructor(props) {
        this.runTimeInfo = props.runTimeInfo;
        this.context = props.context;
        this.onInitialise();
        // this.type = "plain";
    }
    
    static get type(){
        return "plain";
    }

    onInitialise(){
        ;
    }
    
    _resize(){
        helper.log('Please overwite the _resize method of the Channel');
    }

    /**
     * @param {array} incidents - A collection of Incidents in the form:
     * {
     *  millisecond
     *  incident
     *  id
     * }
     * @returns either:
     *   {
     *       result:true,
     *       execute: // an array of functions that when executed it will add the Incidents on the Channels
     *   }
     *   or
     *   {
     *       result: false,
     *       errors
     *   }
    */
    addIncidents(incidents){
        // first check the Incidents addition directly using the checkAddition method of the class
        const result = this.checkAddition(incidents);

        if(result.result === false){
            return {
                result: false,
                errors: result.errors
            }
        } else {
            return {
                result: true,
                execute: result.execute
            }
        }
    }


    /**
     * It initially checks if the edit is allowed and if it is it retuns an array of executable functions
     * that apply the change
     * @param {array} incidents - the list of the incidents to edit in an array format [object, object, ...]
     * @param {int} millisecondsDelta - the milliseconds delta to apply to the incidents
     * @returns {object} -
     * either:
     {
        result: true,
        execute: // array of functions to be executed in order to apply the edit
     }
     or
     {
         result: false,
         errors: // an array including all the errors / conflicts found on edit
     }
    */
    editIncidents(incidents, millisecondsDelta, instantiatedChannels){
        // first check the Incidents addition directly using the checkAddition method of the class
        const result = this.checkEdit(incidents, millisecondsDelta);
        if(result.result === false){
            return {
                result: false,
                errors: result.errors
            }
        } else {
            return {
                result: true,
                execute: result.execute
            }
        }
    }


    /**
     * Method to remove incidents
     * @param {array} incidents - the ids of the incidents to remove in an array format
     * @param {object} props - if passed it supports the preventSlip key which if false the channel should not slip. This case is for 
        flashDOM of DOMAwareIncidents where we have elements deleted so slipping on their lanes is not valid nor necessaryi
     * @retuns {object} -
     * either:
     {
        result: true,
        execute: // array of functions to be executed in order to apply the edit
     }
     or
     {
         result: false,
         errors: // an array including all the errors / conflicts found on edit
     }
    */
    removeIncidents(incidents, props={}){
        // first check the Incidents addition directly using the checkAddition method of the class
        const result = this.checkDelete(incidents, props);
        if(result.result === false){
            return {
                result: false,
                errors: result.errors
            }
        } else {
            return {
                result: true,
                execute: result.execute
            }
        }
    }



    /**
     * On this method the user defines the specific rules that apply on the plugin itself and on the Incidents of the plugin itself
     * The method should either return {result: true} or {result: false, errors:[{error-object}]}, where error-object has the structure:
     *  {
            incident: // reference to the Incident object that has bee discarded
            error: // text
        }
    * @param {array} incidents - a colleciton of all incidents to be added on the form:
    *
        {
            id
            millisecond
            incident
        }
    * @returns {object} -
    * either:
        {
            result:true,
            execute: // a function that when executed it will add the Incidents on the Channels
        }
        or
        {
            result: false,
            errors
        }
    */
    checkAddition(incidents){
        return {result: true, execute: function(){}};
    }


    checkEdit(incidentsArray, millisecondsDelta){
        return {result: true, execute: function(){}};
    }

    checkDelete(incidentIds){
        return {result: true, execute: function(){}};
    }

    checkResizedIncidents(incidents){
        return {result:true, execute: function(){}};
    }

    goTo(millisecond, props={}){
         // first decide the millisecond we want to goTo
        if(millisecond === null || millisecond === undefined){
            millisecond = this.runTimeInfo.currentMillisecond;
        }
        if(props.hasOwnProperty('relativeTo')){
            millisecond += this.getIncidentMillisecond(props.relativeTo);
        }

        let startFrom = this.runTimeInfo.currentMillisecond;
        if(props.hasOwnProperty('previousStop')){
            startFrom = props.previousStop;
        }

        this.moveTo(startFrom, millisecond);
    }

    moveTo(from, to){
        ;
    }
    
    exportState(props){
        return {
            class: this.constructor.name,
            Incident: this.constructor
        }
    }


}

module.exports = Channel;
