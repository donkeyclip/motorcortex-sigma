const Group = require('../_BaseClasses/Group');
const conf = require('../configuration/generalConf');
const Helper = require('../_coreUtils/Helper');
const helper = new Helper();

class AttributesAwareIncident extends Group {
    constructor(incident){
        super(incident.attrs, incident.props);
        this.setUp(incident);
    }
    
    get groupType(){
        return "attribute";
    }
    

    setUp(incident){
        this.IncidentClass = incident.constructor;
        this.toPassToElementIncidents = {
            plugin_channel_class: incident.plugin_channel_class,
            mc_plugin_npm_name: incident.mc_plugin_npm_name
        }
        this.attributeIncidentsByAttribute = {};
        this.cleanProps = Object.assign({}, this.props);
        this.cleanAttrs = Object.assign({}, this.attrs);
        delete this.cleanProps.id;
        this.cleanAttrs.animatedAttrs = {};
        
        for(let attr in this.attrs.animatedAttrs){
            this._createAttributeIncident(attr);
        }  
    }
    
        /**
     * attribute groups
        Can have on their timeline:
        - An incident
        Canâ€™t have on their timeline:
        - A plain group
        - A dom group
        - Another attribute group
     */    
    _prepareInicdentForAddition(incident){
        if(!incident.hasIncidents){ // if it is not a group
            return incident;    
        } else{
            helper.error("attribute groups can not accept groups on their timeline");
            return null;
        }
    }
    
    _createAttributeIncident(attribute){
        let propsToPass = Object.assign({}, this.cleanProps);
        let attrsToPass = Object.assign({}, this.cleanAttrs);
        attrsToPass.animatedAttrs = {};
        if(typeof this.attrs.animatedAttrs[attribute] === 'object' && !Array.isArray(this.attrs.animatedAttrs[attribute])){
            attrsToPass.animatedAttrs[attribute] = Object.assign({}, this.attrs.animatedAttrs[attribute]);
        } else if(typeof this.attrs.animatedAttrs[attribute] === 'object' && Array.isArray(this.attrs.animatedAttrs[attribute])) {
            attrsToPass.animatedAttrs[attribute] = this.attrs.animatedAttrs[attribute].splice(0);
        } else {
            attrsToPass.animatedAttrs[attribute] = this.attrs.animatedAttrs[attribute];
        }
        
        propsToPass.id = `${this.id}_${attribute}`;
        propsToPass.autogeneratedID = true;
        
        const attributeIncident = new this.IncidentClass(attrsToPass, propsToPass);
        attributeIncident.plugin_channel_class = this.toPassToElementIncidents.plugin_channel_class;
        attributeIncident.mc_plugin_npm_name = this.toPassToElementIncidents.mc_plugin_npm_name;
        this.addIncident(attributeIncident, 0);
        this.attributeIncidentsByAttribute[attribute] = attributeIncident;
    }
    
    
    
    attributesChange(newAttrs){
        for(let i=0; i<this.incidents; i++){
            // TODO execute attribute change by passing down the command
        }
    }
}

module.exports = AttributesAwareIncident;