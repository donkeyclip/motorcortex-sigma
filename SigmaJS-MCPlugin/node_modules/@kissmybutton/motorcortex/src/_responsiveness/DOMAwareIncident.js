const Group = require('../_BaseClasses/Group');
const conf = require('../configuration/generalConf');
const Helper = require('../_coreUtils/Helper');
const helper = new Helper();

class DOMAwareIncident extends Group {
    constructor(incident){
        super(incident.attrs, incident.props);
        this.setUp(incident);
    }
    
    get groupType(){
        return "dom";
    }
    
    // props must have the elements collection and the millisecond
    // id is also mandatory
    setUp(incident){
        this.originalIncident = incident;
        this.IncidentClass = incident.constructor;
        this.toPassToElementIncidents = {
            plugin_channel_class: incident.plugin_channel_class,
            mc_plugin_npm_name: incident.mc_plugin_npm_name
        }
        this.elementIncidentsByMCID = {};
        this.cleanProps = Object.assign({}, this.props);
        delete this.cleanProps.id;
        
        if(this.context){
            const elements = Array.from(this.context.document.querySelectorAll(this.props.selector));
            for(let i=0; i<elements.length; i++){
                const element = elements[i];
                this._createElementIncident(element);
            }  
        }
    }
    
    systolDiastole(durationFraction){
        super.systolDiastole(durationFraction);
        this.originalIncident.props.duration*=durationFraction;
    }
    
    /**
     * dom groups
        Can have on their timeline:
        - An incident with no animatedAttrs 
        - An attribute group (this method should actually turn any incident with animatedAttrs to one)
        Canâ€™t have on their timeline:
        - A plain group
        - Another dom group
     */
    _prepareInicdentForAddition(incident){
        if(!incident.attrs.hasOwnProperty('animatedAttrs') && !incident.hasIncidents){ // if the incident is not a group and it has no animatedAttrs proceed normally
            return incident;    
        } else if(incident.groupType === "plain"){// if the Incident is a plain group proceed normally
            helper.error("dom groups can not accept plain groups on their timeline");
            return null;  
        } else if(incident.groupType === "dom"){
            helper.error("dom groups can not accept other dom groups on their timeline");
            return null;
        }
            
        // We need to turn the Incident to an AttrsAwareIncident
        // before adding it to the group
        const AttrsAwareIncident = require('./AttributeAwareIncident');
        const theAttrsAwareIncident = new AttrsAwareIncident(incident);
        return theAttrsAwareIncident;
    }
    
    
    _createElementIncident(element){
        let mcid = this.context.getMCID(element);
        if (!mcid) {
            mcid = helper.getAnId(true);
            this.context.setMCID(element, mcid);
        }
        
        let propsToPass = Object.assign({}, this.cleanProps);
        propsToPass.selector = this.context.getElementSelectorByMCID(mcid);  // '[data-motorocortext2-id="mcid1"]' querySelectorAll()
        propsToPass.mcid = mcid;
        propsToPass.id = `${this.id}_${mcid}`;
        propsToPass.autogeneratedID = true;
        const elementIncident = new this.IncidentClass(this.attrs, propsToPass);
        elementIncident.plugin_channel_class = this.toPassToElementIncidents.plugin_channel_class;
        elementIncident.mc_plugin_npm_name = this.toPassToElementIncidents.mc_plugin_npm_name;
        let result = this.addIncident(elementIncident, 0);
        if(result.result === true){
            this.elementIncidentsByMCID[mcid] = elementIncident;
        } 
        return result;
    }
    
    /**
     * flashDOM method expects the new elements collection and:
     * 1. Identifies which of the existing elementIncidents should go (the dom element does not participate on the DOMAwareGroup any more)
     * 2. Identifies which elements are new and add their elementIncident on the DOMAwareGroup
     * @returns {object} - with keys additions and deletions each of which hold an array of functions that must be
     *  executed for adding the new element incidents and deleting the element incidents that do not apply any more
    */
    flashDOM(){
        const elements = this.context.getElements(this.props.selector);
        
        // deletions and additions of elementIncidents that should take place according to the new elements
        let deletions = [];
        let additions = [];
        
        const that = this;
        
        // an array that will keep all new elements' keys to be used later for identifying deletions
        let stayingElementIncidents = [];
        // first identify additions
        for(let i=0; i<elements.length; i++){ // for each of the new elements
            const element = elements[i];
            let mcid = this.context.getMCID(element); // take its mcid
            
            if (!mcid) { // if the element does not have an mcid yet that means it's a new one
                const addition = function(){
                   return that._createElementIncident(element); 
                } 
                additions.push(addition);
            } else if(!this.elementIncidentsByMCID.hasOwnProperty(mcid)){ // else if the element has an mcid that doesn't already exist on the elementIncidents
                const addition = function(){
                   return that._createElementIncident(element); 
                } 
                additions.push(addition);
            } else {
                stayingElementIncidents.push(mcid);
            }
        }
        
        // next step is to compare the elementIncidents with the existing elements key to see which 
        // are missing from the new set and put them for delete
        const alreadyExistingElementsKeys = Object.keys(this.elementIncidentsByMCID);
        const underDeletion = alreadyExistingElementsKeys.filter(function(key){
            return stayingElementIncidents.indexOf(key) < 0;
        });
        
        for(let i=0; i<underDeletion.length; i++){
            const deletion = function(){
                that.removeIncident(that.elementIncidentsByMCID[underDeletion[i]].id, {preventSlip:true});
                delete that.elementIncidentsByMCID[that.elementIncidentsByMCID[underDeletion[i]].id]
            }
            deletions.push(deletion);
        }
        
        let failedAdditions = [];
        for(let i=0; i<additions.length; i++){
            const additionResult = additions[i]();
            if(additionResult.result === false){
                failedAdditions.push(additionResult);
            }
        }
        
        for(let i=0; i<deletions.length; i++){
            deletions[i]();
        }
        
        return {
            failedAdditions: failedAdditions
        }
        
        // return {
        //     additions: additions,
        //     deletions: deletions
        // }
    }
    
    attributesChange(newAttrs){
        for(let i=0; i<this.incidents; i++){
            // TODO execute attribute change by passing down the command
        }
    }
    
    exportState(props={}){
        if(props.hasOwnProperty('unprocessed')){
            if(props.unprocessed === false){
                return super.exportState(props);
            } else {
                return this.originalIncident.exportState();
            }
        }
        return this.originalIncident.exportState();
    }
}

module.exports = DOMAwareIncident;