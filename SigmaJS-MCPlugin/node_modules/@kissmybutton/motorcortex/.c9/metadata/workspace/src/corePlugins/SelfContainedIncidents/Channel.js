{"changed":true,"filter":false,"title":"Channel.js","tooltip":"/src/corePlugins/SelfContainedIncidents/Channel.js","value":"const Helper = require('../../_coreUtils/Helper');\nconst helper = new Helper();\nconst conf = require('../../configuration/generalConf');\nconst Channel = require('../../_BaseClasses/Channel');\nconst _sortBy = require('../../../modularize/lodash.sortby/index.js');\nconst _filter = require('../../../modularize/lodash.filter/index.js');\n\nclass SCIChannel extends Channel {\n    /*\n    this.incidents is a collection of {incident, id, millisecond} objects always kept in order\n        from lower to higher millisecond\n    this.incidetnsById is an index of the incidents kept by id (this.incidents[incident-id] = Incident)\n    */\n    onInitialise(){\n        this.incidents = [];\n        this.incidentsById = {};\n    }\n    \n    \n    /**\n     * On this method the user defines the specific rules that apply on the plugin itself and on the Incidents of the plugin itself\n     * The method should either return {result: true} or {result: false, errors:[{error-object}]}, where error-object has the structure:\n     *  {\n            incident: // reference to the Incident object that has bee discarded\n            error: // text\n        }\n    * @param {array} incidents - a colleciton of all incidents to be added on the form:\n    * \n        {\n            id\n            millisecond\n            incident\n        }\n    * @returns {object} - \n    * either:\n        {\n            result:true,\n            execute: // a function that when executed it will add the Incidents on the Channels\n        }\n        or\n        {\n            result: false,\n            errors\n        }\n    */\n    checkAddition(incidents){\n        let errors = [];\n        let candidateIncidentsById = {};\n        \n        for(let i=0; i<incidents.length; i++){\n            candidateIncidentsById[incidents[i].id]= incidents[i].incident;\n            if(this.incidentsById.hasOwnProperty(incidents[i].id)){\n                helper.error(`Incident with the id ${incidents[i].id} already exists. Addition is rejected.`);\n                errors.push({\n                    type: 'Already existing id',\n                    meta: {\n                        id: incidents[i].id\n                    }\n                });\n            }\n        }\n        \n        if(errors.length > 0){\n            return {\n                result: false,\n                errors: errors\n            }\n        }\n        \n        const that = this;\n        const exec = function(){\n            that.incidentsById = Object.assign(that.incidentsById, candidateIncidentsById);\n            that.incidents = that.incidents.concat(incidents);\n            that.incidents = _sortBy(that.incidents, [\n                laneItem => {\n                    return laneItem.millisecond;\n                }\n            ]);\n            that.slipToLaneForwards(0, that.runTimeInfo.currentMillisecond);\n        }\n        \n        return {result: true, execute: exec};\n    }\n    \n    \n    /**\n    @param {array} incidentsArray - A collection of the Incidetns to get edited in the form:\n    {\n        id\n        millisecond\n        incident\n    }\n    @param {int} millisecondsDelta- the delta of the star point of the provided incidents\n    */\n    checkEdit(incidentsArray, millisecondsDelta){\n        const that = this;\n        const exec = function(){\n            for(let i=0; i<incidentsArray.length; i++){\n                for(let j=0; j<that.incidents.length; j++){\n                    if(that.incidents[j].id === incidentsArray[i].id){\n                        that.incidents[j].millisecond += millisecondsDelta;\n                        break;\n                    }\n                }\n            }\n            \n            that.incidents = _sortBy(that.incidents, [\n                laneItem => {\n                    return laneItem.millisecond;\n                }\n            ]);\n            \n            that.slipToLaneForwards(0, that.runTimeInfo.currentMillisecond);\n        }\n        \n        return {result: true, execute: exec};\n    }\n    \n    checkDelete(incidentsArray){\n        const that = this;\n        let incidentIds = [];\n        for(let i=0; i<incidentsArray.length; i++){\n            incidentIds.push(incidentsArray[i].id);\n        }\n        \n        const exec = function(){\n            let newIncidents = _filter(that.incidents, incident => {\n                return incidentIds.indexOf(incident.id) === -1;\n            });\n            \n            that.incidents = newIncidents;\n            for(let i=0; i<incidentIds.length; i++){\n                delete that.incidentsById[incidentIds[i]];\n            }\n            \n            that.slipToLaneForwards(0, that.runTimeInfo.currentMillisecond);\n        }\n        \n        return {result: true, execute: exec}; \n    }\n    \n    /**\n    * @param {array} incidents - [{id, start, end, startDelta}] \n    */\n    checkResizedIncidents(incidents){\n        const that = this;\n        const exec = function(){\n            for(let i=0; i<incidents.length; i++){\n                for(let j=0; j<that.incidents.length; j++){\n                    if(that.incidents[j].id === incidents[i].id){\n                        that.incidents[j].millisecond += incidents[i].startDelta;\n                        break;\n                    }\n                }\n            }\n            \n            that.incidents = _sortBy(that.incidents, [\n                laneItem => {\n                    return laneItem.millisecond;\n                }\n            ]);\n            \n            that.slipToLaneForwards(0, that.runTimeInfo.currentMillisecond);\n        }\n        \n        return {result: true, execute: exec};\n    }\n    \n    /**\n     @param {int} from - the millisecond to start from\n     @param {int} to - the millisecond to go to\n     */\n    moveTo(from, to) {\n        if (from < to) {\n            // helper.log(`slipping to lane frowards from ${from} to ${to}`);\n            this.slipToLaneForwards(\n                from,\n                to\n            );\n        } else if (from > to) {\n            // helper.log(`slipping to lane backwards from ${from} to ${to}`);\n            this.slipToLaneBackwards(\n                from,\n                to\n            );\n        } \n\n    }\n    \n    \n}\n\nmodule.exports = SCIChannel;","undoManager":{"mark":-2,"position":14,"stack":[[{"start":{"row":7,"column":6},"end":{"row":7,"column":15},"action":"remove","lines":["PIChannel"],"id":2},{"start":{"row":7,"column":6},"end":{"row":7,"column":7},"action":"insert","lines":["S"]}],[{"start":{"row":7,"column":7},"end":{"row":7,"column":8},"action":"insert","lines":["C"],"id":3}],[{"start":{"row":7,"column":8},"end":{"row":7,"column":9},"action":"insert","lines":["I"],"id":4}],[{"start":{"row":7,"column":9},"end":{"row":7,"column":10},"action":"insert","lines":["C"],"id":5}],[{"start":{"row":7,"column":10},"end":{"row":7,"column":11},"action":"insert","lines":["h"],"id":6}],[{"start":{"row":7,"column":11},"end":{"row":7,"column":12},"action":"insert","lines":["a"],"id":7}],[{"start":{"row":7,"column":12},"end":{"row":7,"column":13},"action":"insert","lines":["n"],"id":8}],[{"start":{"row":7,"column":13},"end":{"row":7,"column":14},"action":"insert","lines":["n"],"id":9}],[{"start":{"row":7,"column":14},"end":{"row":7,"column":15},"action":"insert","lines":["e"],"id":10}],[{"start":{"row":7,"column":15},"end":{"row":7,"column":16},"action":"insert","lines":["l"],"id":11}],[{"start":{"row":218,"column":17},"end":{"row":218,"column":26},"action":"remove","lines":["PIChannel"],"id":12},{"start":{"row":218,"column":17},"end":{"row":218,"column":27},"action":"insert","lines":["SCIChannel"]}],[{"start":{"row":18,"column":2},"end":{"row":43,"column":4},"action":"remove","lines":["  slipToLaneForwards(currentMillisecond, millisecond){","        let participatinIncidents = _filter(this.incidents, laneItem => {","            return (laneItem.millisecond > currentMillisecond && laneItem.millisecond <= millisecond); ","        });","        // helper.log(`participating incidents: `, participatinIncidents);","        ","        for(let i=0; i<participatinIncidents.length; i++){","            participatinIncidents[i].incident.command.forwards();","        }","        ","        // this.runTimeInfo.currentMillisecond = millisecond;","    }","    ","    slipToLaneBackwards(currentMillisecond, millisecond){","        // helper.log(`participating incidents: `, participatinIncidents);","        let participatinIncidents = _filter(this.incidents, laneItem => {","            return (laneItem.millisecond > millisecond && laneItem.millisecond <= currentMillisecond); ","        });","        ","        for(let i=participatinIncidents.length-1; i>=0; i--){","            participatinIncidents[i].incident.command.backwards();","        }","        ","        // this.runTimeInfo.currentMillisecond = millisecond;","    }","    "],"id":13}],[{"start":{"row":18,"column":1},"end":{"row":18,"column":2},"action":"remove","lines":[" "],"id":14}],[{"start":{"row":18,"column":0},"end":{"row":18,"column":1},"action":"remove","lines":[" "],"id":15}],[{"start":{"row":17,"column":4},"end":{"row":18,"column":0},"action":"remove","lines":["",""],"id":16}]]},"ace":{"folds":[],"scrolltop":0,"scrollleft":0,"selection":{"start":{"row":17,"column":4},"end":{"row":17,"column":4},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1524051187827}