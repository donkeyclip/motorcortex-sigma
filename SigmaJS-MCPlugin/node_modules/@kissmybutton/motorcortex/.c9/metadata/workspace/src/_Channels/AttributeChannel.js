{"filter":false,"title":"AttributeChannel.js","tooltip":"/src/_Channels/AttributeChannel.js","undoManager":{"mark":0,"position":0,"stack":[[{"start":{"row":0,"column":0},"end":{"row":600,"column":0},"action":"insert","lines":["const MC = require('@kissmybutton/motorcortex');","","const Channel = MC.Channel;","","const helper = new MC.Helper();","","const _filter = require('./lodash-custom-build/modularize/lodash.filter/index');","const _sortBy = require('./lodash-custom-build/modularize/lodash.sortby/index');","","const conf = MC.conf;","","const lanesHandler = require('./Helpers/LanesHandler');","","/**"," * @classdesc"," * An HTML Channel represents a portion of HTML code within the DOM (all surrounded by a single DOM element named the"," * “channel wrapper element” / from now on CWE) combined with a set of Animation Incidents targeting elements within the CWE."," *"," *"," * An HTML Channel might include other HTML sub-channels within it."," * On the DOM representation, that statement means that a child element of the CWE can be the CWE of another HTML Channel"," * and so on."," *"," *"," * HTML channels can have Scenes on them. The Scenes of an HTML channel are also a special type of Scene and they are"," * called “HTML Scenes”."," *"," *"," * HTML channels maintain the full list of lanes throughout the full continent of them and they are the only responsible"," * for doing so."," * "," *"," * HTML Channel’s Animations can target all elements within the Channel’s CWE but it can’t access elements of child HTML Channels.",""," */","class HTMLChannel extends Channel {","    onInitialise() {","        this.LanesHandler = new lanesHandler();","        this.type = \"attributes\";","    }","","","    get lanes(){","        return this.LanesHandler.lanes;","    }","    ","    ","    /* *******************************************************","     HELPER METHODS","     ********************************************************/","    /**","     * checks if a duration edit is feasible and doesn't cause conflicts","     * @param {int} duration - the new duration ","     * @param {array} ids - (optional) if provided it only checks resizes on the given ids (not all incidents have been re)","    **/","    checkDurationEdit(durationFraction, ids=[]){","        // using ProjectionsHanlder it will create the candidates and the projections to pass up to the parent","        // returned object keys: candidateOwnProjectedAnimations, affectedAnimations","        const projectedAnimations = this.projectionsHandler.systoleDiastoleProjections(durationFraction, ids);","        // once it gets the porojectedAnimations from its projections hanlder it will pass it up for check","        ","        // if the ids array is provided that means the checkDurationEdit is been used by an Animation directly","        // belonging to the html channel, so it's not a full channel resize","        const check = this.checkResizedAnimations(projectedAnimations.affectedAnimations, ids.length===0?true:false);","","        return check;","    }","    ","    ","    /**","    */","    checkAddition(projectedAnimations){","        const LanesHandlerSandbox = this.LanesHandler.createTestLanesSanbox();","        let affectedLanes = [];","        ","        // while the LanesHandlerSanbox adds lane items it makes decisions of which permanent changes should be made to","        // the permanent and pre-existing objects it handles, such as changes on the initial values of existing animations.","        // Because of the fact the LanesSandboxHandler is only there for testing we don't want to execute these changes ","        // during checks but still we need to know them on success. For this, the onSuccessActions array holds all executable","        // functions retured by various LanesHandlerSanbox functions so it can execute them on success.","        let onSuccessActions = [];","        ","        let conflicts = [];","        for (let i = 0; i < projectedAnimations.length; i++) {","            const elements = this.context.document.querySelectorAll(projectedAnimations[i].incident.selector);","            ","            for (let j = 0; j < elements.length; j++) { // for each of the elements of the animation selection","                // get its mcid or create one on the fly","                let mcid = elements[j].getAttribute(conf.elements_data_attribute_name);","                if (!mcid) {","                    mcid = helper.getAnId(true);","                    elements[j].setAttribute(conf.elements_data_attribute_name, mcid);","                }","                ","                // lanes braking","                for (const attr in projectedAnimations[i].incident.attributes) {  // for each of the attributes of the animation","                    const newAnim = projectedAnimations[i];","                    LanesHandlerSandbox.laneExists(mcid, attr, true); // create the lane if it doesn't exist already","                    ","                    affectedLanes.push({","                        mcid: mcid,","                        attribute: attr","                    });","                    ","                    if(LanesHandlerSandbox.animationIDExists(mcid, attr, projectedAnimations[i].incident.id)){","                        conflicts.push({","                            type: 'douplicate Animation id',","                            meta: {","                                id: projectedAnimations[i].incident.id","                            }","                        });","                    }","                    ","                    // **** if the lane did exist before the new addition check for conflicts","                    let overlappingAnims = LanesHandlerSandbox.getOverlappingAnims(newAnim, mcid, attr);","                    ","                    // helper.log(overlappingAnim)","                    if(overlappingAnims.length > 0){","                        conflicts.push({","                            type: 'overlapping attribute animations on the same element',","                            meta: {","                                element_mcid: mcid,","                                attribute: attr,","                                newAnimation: newAnim,","                                overlappingAnims: overlappingAnims","                            }","                        });","                    }","                    ","                    onSuccessActions.push(LanesHandlerSandbox.addElementToLane(mcid, attr, projectedAnimations[i].millisecond, projectedAnimations[i].incident));","","                } // end for each attribute of the animation","            } // end for each element","        } // end for each animation","        ","        if(conflicts.length > 0){","            return {","                result: false,","                errors: conflicts","            }","        } else {","            // as soon as there are no conflicts the Lanes Handler applies the changes before sending over the ","            // success message","            const that = this;","            const exec = function(){","                that.LanesHandler.applySandboxChanges(LanesHandlerSandbox);","                for(let i=0; i<onSuccessActions.length; i++){","                    onSuccessActions[i]();","                }","                ","                for(let i=0; i<affectedLanes.length; i++){","                    const affectedLane = affectedLanes[i];","                    that.slipIntoLaneForwards(that.LanesHandler.getLane(affectedLane.mcid, affectedLane.attribute), affectedLane, 0, that.runTimeInfo.currentMillisecond);","                }","            }","            ","            ","            return {","                result: true,","                execute: exec","            }","        }","    }","    ","    ","    checkEdit(affectedAnimations, millisecondsDelta) {","        const affectedAnimationsIds = [];","        for(let i=0; i<affectedAnimations.length; i++){","            affectedAnimationsIds.push(affectedAnimations[i].id);","        }","        ","        const LanesHandlerSandbox = this.LanesHandler.createTestLanesSanbox();","        ","        let conflicts = [];","        let affectedLanes = [];","        ","        // for each of the affectedAnimations","        for (let i = 0; i < affectedAnimationsIds.length; i++) {","            const belongingLanes = LanesHandlerSandbox.belongingLaneKeysByAnimationId[affectedAnimationsIds[i]];","","            // for each lane the affected Animation appears in","            for (let j = 0; j < belongingLanes.length; j++) {","                const lane = LanesHandlerSandbox.lanes[belongingLanes[j]];","                let laneData = helper.getMCIDandAttrOutOfLaneKey(belongingLanes[j]);","","","                // check for conflicts and edit lane items millisecond","                for (let k = 0; k < lane.length; k++) {","                    if (lane[k].incident.id === affectedAnimationsIds[i]) {","                        affectedLanes.push(laneData);","                        let affectedAnim = lane[k];","                        let testLaneElement = LanesHandlerSandbox.getLaneElementsClone(affectedAnim);","                        testLaneElement.millisecond += millisecondsDelta;","                        let overlappingAnims = LanesHandlerSandbox.getOverlappingAnims(testLaneElement, laneData.mcid, laneData.attribute, affectedAnimationsIds);","","                        ","                        if(overlappingAnims.length > 0){","                            conflicts.push({","                                type: 'overlapping attribute animations on the same element',","                                meta: {","                                    element_mcid: laneData.mcid,","                                    attribute: laneData.attribute,","                                    newAnimation: testLaneElement,","                                    overlappingAnims: overlappingAnims","                                }","                            });","                        }","                        ","                        break;","                    } // end of if we found the specific animation on the lane's sequence","                } // end of each lane's item","                ","                ","            } // end of each belonging lane ","        } // end for each affected animation's id","        ","        if(conflicts.length > 0){","            return {","                result: false,","                errors: conflicts","            }","        } else {","            const that = this;","            const exec = function(){","                // as soon as there are no conflicts the Lanes Handler applies the changes before sending over the ","                // success message","                that.LanesHandler.updateLane(affectedAnimationsIds, millisecondsDelta);","    ","                for(let i=0; i<affectedLanes.length; i++){","                    const affectedLane = affectedLanes[i];","                    const theActualLane = that.LanesHandler.getLane(affectedLane.mcid, affectedLane.attribute);","                    const whatToSet = {};","                    whatToSet[affectedLane.attribute] = theActualLane[0].incident.initialValues[affectedLane.mcid][affectedLane.attribute];","                    Velocity([helper.getElementByMCID(that.context, affectedLane.mcid)], 'style', whatToSet);","                    that.slipIntoLaneForwards(theActualLane, affectedLane, 0, that.runTimeInfo.currentMillisecond);","                }","            }","            return {","                result: true,","                execute: exec","            }","            ","        }","    }","    ","    ","    /**","     * @param {array} affectedAnimations - [{id, start, end, startDelta}]","     * @param {boolean} fullChannelResize - if set to true then the full html channel is resizing. This is a special case as in","     *  that case no checks should be actually perfomed nor the projected candidate should be applied directly","    **/","    checkResizedIncidents(affectedAnimations, fullChannelResize=false){","        const excludeIdsFromCheck = [];","        for(let i=0; i<affectedAnimations.length; i++){","            excludeIdsFromCheck.push(affectedAnimations[i].id);    ","        }","        ","        const LanesHandlerSandbox = this.LanesHandler.createTestLanesSanbox();","        ","        let conflicts = [];","        let affectedLanes = [];","        ","        // for each of the affectedAnimations","        for (let i = 0; i < affectedAnimations.length; i++) {","            const belongingLanes = LanesHandlerSandbox.belongingLaneKeysByAnimationId[affectedAnimations[i].id];","            const testDuration = affectedAnimations[i].end - affectedAnimations[i].start;","","            // for each lane the affected Animation appears in","            for (let j = 0; j < belongingLanes.length; j++) {","                const lane = LanesHandlerSandbox.lanes[belongingLanes[j]];","                let laneData = helper.getMCIDandAttrOutOfLaneKey(belongingLanes[j]);","","","                // check for conflicts and edit lane items millisecond","                for (let k = 0; k < lane.length; k++) {","                    if (lane[k].incident.id === affectedAnimations[i].id) {","                        affectedLanes.push(laneData);","                        if(fullChannelResize === false){","                            let affectedAnim = lane[k];","                            let testLaneElement = LanesHandlerSandbox.getLaneElementsClone(affectedAnim);","                            testLaneElement.millisecond += affectedAnimations[i].startDelta;","                            let overlappingAnims = LanesHandlerSandbox.getOverlappingAnims(testLaneElement, laneData.mcid, laneData.attribute, excludeIdsFromCheck, testDuration);","    ","                            ","                            if(overlappingAnims.length > 0){","                                conflicts.push({","                                    type: 'overlapping attribute animations on the same element',","                                    meta: {","                                        element_mcid: laneData.mcid,","                                        attribute: laneData.attribute,","                                        newAnimation: testLaneElement,","                                        overlappingAnims: overlappingAnims","                                    }","                                });","                            }    ","                        }","                        ","                        break;","                    } // end of if we found the specific animation on the lane's sequence","                } // end of each lane's item","                ","                ","            } // end of each belonging lane ","        } // end for each affected animation's id","        ","        if(conflicts.length > 0){","            return {","                result: false,","                conflicts: conflicts","            }","        } else {","            // unlike the case of editing the start millisecond of a Scene / Incident on editing the duration of a Scene","            // or an Incident slipping to lanes should occur depends not only on the positioning of the Animations on ","            // the lanes but also on their duration. Editing the duration occurs on the Scene that received the editDuration","            // command and thus at that point the HTMLChannel (and its LanesHaldler) is not ready to slip as the affected","            // Animations still have the old (un-edited) duration.","            // For this reason and only on the case of duration edit slip to lanes will take place not here and not now","            // but on the scope of the Scene that got the command, at the point it receives the success ({result:true}).","            // For this we will create a callback function which holds the slipping to lanes commands and pass it on the","            // \"callback\" key of the result object ({success:true, callback:function(){that slips into lanes}})","            const that = this;","            ","            const exec = function(){","                const slippingCommands = []; // an array that will hold all of the slipping commands in all of the affected lanes","            ","                // updateLanes (only this time animation by animation as the milliseconds delta is not standard for all)","                // as soon as there are no conflicts the Lanes Handler applies the changes before sending over the ","                // success message","                for(let i=0; i<affectedAnimations.length; i++){","                    that.LanesHandler.updateLane([affectedAnimations[i].id], affectedAnimations[i].startDelta);    ","                }","                ","                for(let i=0; i<affectedLanes.length; i++){","                    const affectedLane = affectedLanes[i];","                    const theActualLane = that.LanesHandler.getLane(affectedLane.mcid, affectedLane.attribute);","                    const whatToSet = {};","                    whatToSet[affectedLane.attribute] = theActualLane[0].incident.initialValues[affectedLane.mcid][affectedLane.attribute];","                    Velocity([helper.getElementByMCID(that.context, affectedLane.mcid)], 'style', whatToSet);","                    // put the slip command on the slippingCommands array","                    slippingCommands.push(()=>{","                       that.slipIntoLaneForwards(theActualLane, affectedLane, 0, that.runTimeInfo.currentMillisecond);","                    });","                }","    ","                for(let i=0; i<slippingCommands.length; i++){","                    slippingCommands[i]();","                }","            }","            ","            return {","                execute: exec,","                result: true","            }","        }","    }","    ","","    checkDelete(removedAnimations) {","        let removedAnimationIds = [];","        for(let i=0; i<removedAnimations.length; i++){","            removedAnimationIds.push(removedAnimations[i].id);","        }","        ","        // no slipping is needed as on deletion the Animations set their elements to their initial values","        const that = this;","        const exec = function(){","            const affectedLanes = that.LanesHandler.deleteAnimations(removedAnimationIds, that.runTimeInfo.currentMillisecond);","        }","        ","        return {","            result: true,","            execute: exec","        }","        ","    }","","","    /**","     * Method that is invoked by Animation objects when one of their attributes value is edited","     * The purpose of this method here on the HTMLChannel is to update the lanes accordingly and slip into the ","     * corresponding lanes","     * @param {string} animationId - the id of the Animation object that has been edited","     * @param {string} attr - the name of the attribute that has been edited","     * @param {string} value - the new value of the edited attribute","    */","    animationAttributeValueChange(animationId, attr, value){","        const affectedLanes = this.LanesHandler.updateAttributeOnLanes(animationId, attr, value);","        for(let i=0; i<affectedLanes.length; i++){","            const affectedLane = affectedLanes[i];","            const theActualLane = this.LanesHandler.getLane(affectedLane.mcid, affectedLane.attribute);","            const whatToSet = {};","            whatToSet[affectedLane.attribute] = theActualLane[0].incident.initialValues[affectedLane.mcid][affectedLane.attribute];","            Velocity([helper.getElementByMCID(this.context, affectedLane.mcid)], 'style', whatToSet);","            this.slipIntoLaneForwards(theActualLane, affectedLane, 0, this.runTimeInfo.currentMillisecond);","        }","    }","    ","","    /**","     * Slips to just one lane forwards","     * @param {array} lane - the lane to slip into","     * @param {object} laneData - an object with keys: attribute & mcid","     * @param {int} currentMillisecond - the millisecond the slip starts from","     * @param {int} millisecond - the target millisecond of the slip","     */","    slipIntoLaneForwards(lane, laneData, currentMillisecond, millisecond) {","        // helper.log(lane, currentMillisecond, millisecond);","        let participatingAnims = _filter(lane, laneItem => {","            return (","                (laneItem.millisecond + laneItem.incident.duration >= currentMillisecond &&","                    laneItem.millisecond + laneItem.incident.duration <= millisecond) || // it ends after currentMillisecond and before target millisecond","                (laneItem.incident.duration + laneItem.millisecond >= millisecond &&","                    laneItem.millisecond <= millisecond)","            ); // or it ends after the target millisecond but also starts before it","        });","","        if (participatingAnims.length == 0) {","            return true;","        }","","        participatingAnims = _sortBy(participatingAnims, [","            laneItem => {","                return laneItem.millisecond;","            }","        ]);","","        // now we have all participatingAnims of the slip action in chronological order","        // our first job is to create a variable that will hold the last known value of the lane","        let lastValue = null;","        for (let i = 0; i < participatingAnims.length; i++) {","            const participatingAnim = participatingAnims[i].incident;","            const startMillisecond = participatingAnims[i].millisecond;","","            // if the animation has no start values go ahead and calculated them now","            if (","                !participatingAnim.hasInitialValue(laneData.mcid, laneData.attribute) &&","                lastValue === null","            ) {","                // helper.log('setting initial value: ', laneData.mcid, laneData.attribute, 'calculated');","                participatingAnim.setInitialValue(laneData.mcid, laneData.attribute);","            } else if (","                !participatingAnim.hasInitialValue(laneData.mcid, laneData.attribute) &&","                lastValue != null","            ) {","                // helper.log('setting initial value: ', laneData.mcid, laneData.attribute, lastValue);","                participatingAnim.setInitialValue(laneData.mcid, laneData.attribute, lastValue);","            }","","            // if the animation ends before the target millisecond","            // helper.log('participatingAnim.duration + startMillisecond', participatingAnim.duration + startMillisecond, millisecond);","            if (participatingAnim.duration + startMillisecond <= millisecond) {","                // helper.log('ends before target')","                lastValue = participatingAnim.attributes[laneData.attribute];","                if (i === participatingAnims.length - 1) {","                    const whatToSet = {};","                    whatToSet[laneData.attribute] = lastValue;","                    // helper.log('setting style', laneData.mcid, whatToSet, helper.getElementByMCID(laneData.mcid));","                    const elementToAffect = helper.getElementByMCID(this.context, laneData.mcid);","                    Velocity([elementToAffect], 'style', whatToSet);","                }","            } else {","                // slip for the specific element and the specific attribute. Set the Animation as paused or playing a","                // and store this info somewhere","                ","                const attrsToPass = {};","                attrsToPass[laneData.attribute] = [","                    participatingAnim.attributes[laneData.attribute],","                    participatingAnim.initialValues[laneData.mcid][laneData.attribute]","                ];","                const percentageComplete =","                    (millisecond - startMillisecond) / participatingAnim.duration;","","                const element = helper.getElementByMCID(this.context, laneData.mcid);","","                const calculatedSytle = Velocity(","                    [element],","                    'tween',","                    percentageComplete,","                    attrsToPass,","                    participatingAnim.properties.easing || 'linear'","                );","                Velocity([element], 'style', calculatedSytle);","            }","        }","    }","","    /**","     * Slips to just one lane backwards","     * @param {array} lane - the lane to slip into","     * @param {object} laneData - an object with keys: attribute & mcid","     * @param {int} currentMillisecond - the millisecond the slip starts from","     * @parama {int} millisecond - the target millisecond of the slip","     */","    slipToLaneBackwards(lane, laneData, currentMillisecond, millisecond) {","        // we take all Animations that are either currently running or","        // they end after the destination point","        // helper.log('<------');","        let participatingAnims = _filter(lane, laneItem => {","            const laneItemEnd = laneItem.incident.duration + laneItem.millisecond;","            return (","                (laneItemEnd <= millisecond && laneItemEnd >= currentMillisecond) || // they end in the hot area","                (laneItem.millisecond >= currentMillisecond &&","                    laneItem.millisecond <= millisecond) || // they start in the hot area","                (laneItem.millisecond < currentMillisecond && laneItemEnd > millisecond)","            ); // they overlap the hot area","        });","","        if (participatingAnims.length == 0) {","            return true;","        }","","        participatingAnims = _sortBy(","            participatingAnims,","            [","                laneItem => {","                    return laneItem.millisecond;","                }","            ]","        );","        ","","        let lastValue = null;","        for (let i = participatingAnims.length-1; i >=0; i--) {","            const participatingAnim = participatingAnims[i].incident;","            const startMillisecond = participatingAnims[i].millisecond;","","            if (startMillisecond >= millisecond) {","                try {","                    lastValue = participatingAnim.initialValues[laneData.mcid][laneData.attribute];","                } catch (e) {","                    helper.log(e);","                }","                // helper.log('participatingAnim initialValues: ', participatingAnim.initialValues);","                if (i === 0) {","                    const whatToSet = {};","                    whatToSet[laneData.attribute] = lastValue;","                    // helper.log('setting style', laneData.mcid, whatToSet, helper.getElementByMCID(laneData.mcid));","                    const elementToAffect = helper.getElementByMCID(this.context, laneData.mcid);","                    Velocity([elementToAffect], 'style', whatToSet);","                }","            } else {","                const attrsToPass = {};","                try {","                    attrsToPass[laneData.attribute] = [","                        participatingAnim.attributes[laneData.attribute],","                        participatingAnim.initialValues[laneData.mcid][laneData.attribute]","                    ];","                } catch (e) {","                    helper.log(e);","                }","                const percentageComplete =","                    (millisecond - startMillisecond) / participatingAnim.duration;","","                const element = helper.getElementByMCID(this.context, laneData.mcid);","","                const calculatedSytle = Velocity(","                    [element],","                    'tween',","                    percentageComplete,","                    attrsToPass,","                    participatingAnim.properties.easing || 'linear'","                );","                Velocity([element], 'style', calculatedSytle);","            }","        }","    }","","    /**","     @param {int} from - the millisecond to start from","     @param {int} to - the millisecond to go to","     */","    moveTo(from, to) {","        // step 1: iterate through all lanes","        for (const laneid in this.lanes) {","            const lane = this.lanes[laneid];","            const laneData = helper.getMCIDandAttrOutOfLaneKey(laneid);","            if (from < to) {","                // helper.log(laneid);","                this.slipIntoLaneForwards(","                    lane,","                    laneData,","                    from,","                    to","                );","            } else if (from >= to) {","                this.slipToLaneBackwards(","                    lane,","                    laneData,","                    from,","                    to","                );","            } ","        }","        // this.recalcState(millisecond);","        // this.setCurrentMillisecond(millisecond);","        // this.recalcState(millisecond);","    }","}","","module.exports = HTMLChannel;",""],"id":1}]]},"ace":{"folds":[],"scrolltop":0,"scrollleft":0,"selection":{"start":{"row":600,"column":0},"end":{"row":600,"column":0},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1524595690369,"hash":"9367c84cee1f144988694f6e7efd793fd6f4179f"}