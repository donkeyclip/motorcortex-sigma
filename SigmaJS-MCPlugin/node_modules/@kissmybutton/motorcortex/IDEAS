The Incident objects will support the following event handling methods:
- onInitialise normally here we just set our state and params. It could be renamed to "initialState" like React does it
- onGetContext (on replacement of play() and resume() handling as done right now on Animation.js of Velocity.
                onPlay and onResume built-in methods should always and by default call the onGetContext methods
                which in turn will check the flag and either run or skip. Question about the name (?)
- onProgress
- getScratchValue  (that's a method that takes 2 arguments: the element and one of the animatedAttrs' attribute and returns
                    its value as computed by the plugin itself. It's the scratch value of an element's attribute as calculated
                    directly by the dom)
- onDurationChange (alias of systolDiastole) - normally here we set our duration and just run the onGetContext method optionally 
                    The user will be able to pick wether their class want to re-initialise or not on duration change.
 
get duration() // if we demand the duration on the init params of all Inicdents there is no need to have that
set duration() // and we need to store our duration on a specific key of our object

- onComplete
- onPlay
- onWait
- onResume
- etc


Channel
- setInitialState (alias of onInitialise)
- the user will be able to pick wether they:
    - allow overlapping incidents on the same slector / element 
    - define per attribute non-overlapping rules, so the Channel keeps element-attribute lanes
and also they will be able to run their own (extra) code on successfull addiont/edit and delete.
This way the Velocity plugin will only have to set the initial values of the newly entered Animations
and that's because it strongly depends on the lanes. It's good to provide convenient methods built in
such as:
- getPeviousLaneItem
- getNextLaneItem
for the newlly entered, edited or deleted Incidents
goTo method will be absorbed as depending on the lanes structure it will just slip to lanes on goTo.


create a preloader plugin (configurable). The preloader plugin will take care of preloading assets (mainly audio and images)
If the user wants to split the full clip into smaller parts so the preloader can preload things the only thing to do 
is to create clips (either iframe, iframe but no css isolation or nude) and the preloader will know the segments that
load what so it can preload while playing and indicate load on the seek bar.

create a scroll / parallax plugin that will also expose a vertical bar on the right emulating the browser bar but with
touches (such as chapters). Make it feel like chrome has been hacked rather that suggesting a totally new idea.

We need to create a test suite and incorporate it on donkey clip for plugin creators. Needs investigation - v.2


Incidents initialisation:
attrs:{
    animatedAttrs: {
        left: "500px",
        ...
    },
    attrs:{
        other: 53,
        attributes: 3453
    }
},
props:{
    selector: ".the-selector",
    id: "the-id"
}

next job: getInitialValue / should it exist any more? Should be chained with the new AttributeChannel logic. / Logical analysis

After adding incident.onGetContext(); on Attribute channel line 108 maybe the onGetContext on Group is not necessary any more?


NEXT STEPS
1. Plain Clip  -done
2. Never ending Clips
A never ending / open clip will have an initial duration, the normal duration of it as it's calculated by the Incidents it has.
A never ending / open clip can't be paused / resumed / have its speed changed or been seeked. The clip should first close / end and then it becomes a normal clip 
    to which the user can apply any of the mentioned functions.
    While running and once it starts for the first time the clip runs infinitely until it gets the "end" command. 
    While running, the open clip doesn't accept edit or deletion commands, only addition commands of incidents belonging to the future
3. Fix logging (make it parametric)  -done
4. Incidents illustration page
5. React plugin
6. Fractions (Incidents that stop on specific point of their execution)
7. Media Element audio plugin
8. Youtube plugin
9. Video effects plugin (https://github.com/shamadee/web-dsp , https://github.com/shamadee/web-dsp-demo)
10. *** Disallow incidents with the same id to enter on the plain Channel. It's an SOS as now it allows it and it produces buggy clips without warnings
11. Incidents of type Group, exported by plugins (except Clips) should never expose their content incidents on getState, unless the user explicitly states them to

// PERFORMANCE
12. start edits / ready  DONE
see getDurationAfterIncidentAdded on Group and ready() on SCGroup   TODO
13. caching of proxy on LanesHandler (not important)   NOT RELEVANT ANH MORE
14. JSON.parse(JSON.stringify()) on createTestLanesSanbox causes huge delay *** must find a workaround *** DONE
15. getIncidentById causes huge delay DONE
16. On ContextHandler caching of elements of specific mcid would result to huge economy DONE
*** also the getElements of context handler can be cached but there should be a way to clear cache on the contect *** TODO
17. Do not slipToLane on checkAddition on AttributeChannel if Clip has not ran yet  TODO
18. It's completely reasonable to make getIncidentById more performant for the case the user puts many incidents themselves  TODO
19. Chain donkeyclip with jw player


ΆΞΟΝΕΣ ΒΕΛΤΙΩΣΗΣ ΑΠΟΔΟΣΗΣ: 
- getIncidentById (check id on addition)
- sanboxing of lanes handler
- massive editing 