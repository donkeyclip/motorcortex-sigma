/******/ (function(modules) { // webpackBootstrap
/******/ 	function hotDisposeChunk(chunkId) {
/******/ 		delete installedChunks[chunkId];
/******/ 	}
/******/ 	var parentHotUpdateCallback = window["webpackHotUpdate"];
/******/ 	window["webpackHotUpdate"] = // eslint-disable-next-line no-unused-vars
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) {
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if (parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	} ;
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotDownloadUpdateChunk(chunkId) {
/******/ 		var script = document.createElement("script");
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 		if (null) script.crossOrigin = null;
/******/ 		document.head.appendChild(script);
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotDownloadManifest(requestTimeout) {
/******/ 		requestTimeout = requestTimeout || 10000;
/******/ 		return new Promise(function(resolve, reject) {
/******/ 			if (typeof XMLHttpRequest === "undefined") {
/******/ 				return reject(new Error("No browser support"));
/******/ 			}
/******/ 			try {
/******/ 				var request = new XMLHttpRequest();
/******/ 				var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 				request.open("GET", requestPath, true);
/******/ 				request.timeout = requestTimeout;
/******/ 				request.send(null);
/******/ 			} catch (err) {
/******/ 				return reject(err);
/******/ 			}
/******/ 			request.onreadystatechange = function() {
/******/ 				if (request.readyState !== 4) return;
/******/ 				if (request.status === 0) {
/******/ 					// timeout
/******/ 					reject(
/******/ 						new Error("Manifest request to " + requestPath + " timed out.")
/******/ 					);
/******/ 				} else if (request.status === 404) {
/******/ 					// no update available
/******/ 					resolve();
/******/ 				} else if (request.status !== 200 && request.status !== 304) {
/******/ 					// other failure
/******/ 					reject(new Error("Manifest request to " + requestPath + " failed."));
/******/ 				} else {
/******/ 					// success
/******/ 					try {
/******/ 						var update = JSON.parse(request.responseText);
/******/ 					} catch (e) {
/******/ 						reject(e);
/******/ 						return;
/******/ 					}
/******/ 					resolve(update);
/******/ 				}
/******/ 			};
/******/ 		});
/******/ 	}
/******/
/******/ 	var hotApplyOnUpdate = true;
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentHash = "babb55697c293e87c6ef";
/******/ 	var hotRequestTimeout = 10000;
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentChildModule;
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentParents = [];
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentParentsTemp = [];
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotCreateRequire(moduleId) {
/******/ 		var me = installedModules[moduleId];
/******/ 		if (!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if (me.hot.active) {
/******/ 				if (installedModules[request]) {
/******/ 					if (installedModules[request].parents.indexOf(moduleId) === -1) {
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 					}
/******/ 				} else {
/******/ 					hotCurrentParents = [moduleId];
/******/ 					hotCurrentChildModule = request;
/******/ 				}
/******/ 				if (me.children.indexOf(request) === -1) {
/******/ 					me.children.push(request);
/******/ 				}
/******/ 			} else {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" +
/******/ 						request +
/******/ 						") from disposed module " +
/******/ 						moduleId
/******/ 				);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		var ObjectFactory = function ObjectFactory(name) {
/******/ 			return {
/******/ 				configurable: true,
/******/ 				enumerable: true,
/******/ 				get: function() {
/******/ 					return __webpack_require__[name];
/******/ 				},
/******/ 				set: function(value) {
/******/ 					__webpack_require__[name] = value;
/******/ 				}
/******/ 			};
/******/ 		};
/******/ 		for (var name in __webpack_require__) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(__webpack_require__, name) &&
/******/ 				name !== "e" &&
/******/ 				name !== "t"
/******/ 			) {
/******/ 				Object.defineProperty(fn, name, ObjectFactory(name));
/******/ 			}
/******/ 		}
/******/ 		fn.e = function(chunkId) {
/******/ 			if (hotStatus === "ready") hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			return __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {
/******/ 				finishChunkLoading();
/******/ 				throw err;
/******/ 			});
/******/
/******/ 			function finishChunkLoading() {
/******/ 				hotChunksLoading--;
/******/ 				if (hotStatus === "prepare") {
/******/ 					if (!hotWaitingFilesMap[chunkId]) {
/******/ 						hotEnsureUpdateChunk(chunkId);
/******/ 					}
/******/ 					if (hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 						hotUpdateDownloaded();
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		fn.t = function(value, mode) {
/******/ 			if (mode & 1) value = fn(value);
/******/ 			return __webpack_require__.t(value, mode & ~1);
/******/ 		};
/******/ 		return fn;
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotCreateModule(moduleId) {
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/ 			_main: hotCurrentChildModule !== moduleId,
/******/
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if (dep === undefined) hot._selfAccepted = true;
/******/ 				else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 				else if (typeof dep === "object")
/******/ 					for (var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback || function() {};
/******/ 				else hot._acceptedDependencies[dep] = callback || function() {};
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if (dep === undefined) hot._selfDeclined = true;
/******/ 				else if (typeof dep === "object")
/******/ 					for (var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 				else hot._declinedDependencies[dep] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if (!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if (idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		hotCurrentChildModule = undefined;
/******/ 		return hot;
/******/ 	}
/******/
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for (var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailableFilesMap = {};
/******/ 	var hotDeferred;
/******/
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = +id + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/
/******/ 	function hotCheck(apply) {
/******/ 		if (hotStatus !== "idle") {
/******/ 			throw new Error("check() is only allowed in idle status");
/******/ 		}
/******/ 		hotApplyOnUpdate = apply;
/******/ 		hotSetStatus("check");
/******/ 		return hotDownloadManifest(hotRequestTimeout).then(function(update) {
/******/ 			if (!update) {
/******/ 				hotSetStatus("idle");
/******/ 				return null;
/******/ 			}
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			hotAvailableFilesMap = update.c;
/******/ 			hotUpdateNewHash = update.h;
/******/
/******/ 			hotSetStatus("prepare");
/******/ 			var promise = new Promise(function(resolve, reject) {
/******/ 				hotDeferred = {
/******/ 					resolve: resolve,
/******/ 					reject: reject
/******/ 				};
/******/ 			});
/******/ 			hotUpdate = {};
/******/ 			var chunkId = "main";
/******/ 			// eslint-disable-next-line no-lone-blocks
/******/ 			{
/******/ 				/*globals chunkId */
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if (
/******/ 				hotStatus === "prepare" &&
/******/ 				hotChunksLoading === 0 &&
/******/ 				hotWaitingFiles === 0
/******/ 			) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 			return promise;
/******/ 		});
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) {
/******/ 		if (!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for (var moduleId in moreModules) {
/******/ 			if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if (--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if (!hotAvailableFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var deferred = hotDeferred;
/******/ 		hotDeferred = null;
/******/ 		if (!deferred) return;
/******/ 		if (hotApplyOnUpdate) {
/******/ 			// Wrap deferred object in Promise to mark it as a well-handled Promise to
/******/ 			// avoid triggering uncaught exception warning in Chrome.
/******/ 			// See https://bugs.chromium.org/p/chromium/issues/detail?id=465666
/******/ 			Promise.resolve()
/******/ 				.then(function() {
/******/ 					return hotApply(hotApplyOnUpdate);
/******/ 				})
/******/ 				.then(
/******/ 					function(result) {
/******/ 						deferred.resolve(result);
/******/ 					},
/******/ 					function(err) {
/******/ 						deferred.reject(err);
/******/ 					}
/******/ 				);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for (var id in hotUpdate) {
/******/ 				if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			deferred.resolve(outdatedModules);
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotApply(options) {
/******/ 		if (hotStatus !== "ready")
/******/ 			throw new Error("apply() is only allowed in ready status");
/******/ 		options = options || {};
/******/
/******/ 		var cb;
/******/ 		var i;
/******/ 		var j;
/******/ 		var module;
/******/ 		var moduleId;
/******/
/******/ 		function getAffectedStuff(updateModuleId) {
/******/ 			var outdatedModules = [updateModuleId];
/******/ 			var outdatedDependencies = {};
/******/
/******/ 			var queue = outdatedModules.slice().map(function(id) {
/******/ 				return {
/******/ 					chain: [id],
/******/ 					id: id
/******/ 				};
/******/ 			});
/******/ 			while (queue.length > 0) {
/******/ 				var queueItem = queue.pop();
/******/ 				var moduleId = queueItem.id;
/******/ 				var chain = queueItem.chain;
/******/ 				module = installedModules[moduleId];
/******/ 				if (!module || module.hot._selfAccepted) continue;
/******/ 				if (module.hot._selfDeclined) {
/******/ 					return {
/******/ 						type: "self-declined",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				if (module.hot._main) {
/******/ 					return {
/******/ 						type: "unaccepted",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				for (var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if (!parent) continue;
/******/ 					if (parent.hot._declinedDependencies[moduleId]) {
/******/ 						return {
/******/ 							type: "declined",
/******/ 							chain: chain.concat([parentId]),
/******/ 							moduleId: moduleId,
/******/ 							parentId: parentId
/******/ 						};
/******/ 					}
/******/ 					if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 					if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if (!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push({
/******/ 						chain: chain.concat([parentId]),
/******/ 						id: parentId
/******/ 					});
/******/ 				}
/******/ 			}
/******/
/******/ 			return {
/******/ 				type: "accepted",
/******/ 				moduleId: updateModuleId,
/******/ 				outdatedModules: outdatedModules,
/******/ 				outdatedDependencies: outdatedDependencies
/******/ 			};
/******/ 		}
/******/
/******/ 		function addAllToSet(a, b) {
/******/ 			for (var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if (a.indexOf(item) === -1) a.push(item);
/******/ 			}
/******/ 		}
/******/
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/
/******/ 		var warnUnexpectedRequire = function warnUnexpectedRequire() {
/******/ 			console.warn(
/******/ 				"[HMR] unexpected require(" + result.moduleId + ") to disposed module"
/******/ 			);
/******/ 		};
/******/
/******/ 		for (var id in hotUpdate) {
/******/ 			if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				moduleId = toModuleId(id);
/******/ 				/** @type {TODO} */
/******/ 				var result;
/******/ 				if (hotUpdate[id]) {
/******/ 					result = getAffectedStuff(moduleId);
/******/ 				} else {
/******/ 					result = {
/******/ 						type: "disposed",
/******/ 						moduleId: id
/******/ 					};
/******/ 				}
/******/ 				/** @type {Error|false} */
/******/ 				var abortError = false;
/******/ 				var doApply = false;
/******/ 				var doDispose = false;
/******/ 				var chainInfo = "";
/******/ 				if (result.chain) {
/******/ 					chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 				}
/******/ 				switch (result.type) {
/******/ 					case "self-declined":
/******/ 						if (options.onDeclined) options.onDeclined(result);
/******/ 						if (!options.ignoreDeclined)
/******/ 							abortError = new Error(
/******/ 								"Aborted because of self decline: " +
/******/ 									result.moduleId +
/******/ 									chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "declined":
/******/ 						if (options.onDeclined) options.onDeclined(result);
/******/ 						if (!options.ignoreDeclined)
/******/ 							abortError = new Error(
/******/ 								"Aborted because of declined dependency: " +
/******/ 									result.moduleId +
/******/ 									" in " +
/******/ 									result.parentId +
/******/ 									chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "unaccepted":
/******/ 						if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 						if (!options.ignoreUnaccepted)
/******/ 							abortError = new Error(
/******/ 								"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "accepted":
/******/ 						if (options.onAccepted) options.onAccepted(result);
/******/ 						doApply = true;
/******/ 						break;
/******/ 					case "disposed":
/******/ 						if (options.onDisposed) options.onDisposed(result);
/******/ 						doDispose = true;
/******/ 						break;
/******/ 					default:
/******/ 						throw new Error("Unexception type " + result.type);
/******/ 				}
/******/ 				if (abortError) {
/******/ 					hotSetStatus("abort");
/******/ 					return Promise.reject(abortError);
/******/ 				}
/******/ 				if (doApply) {
/******/ 					appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 					addAllToSet(outdatedModules, result.outdatedModules);
/******/ 					for (moduleId in result.outdatedDependencies) {
/******/ 						if (
/******/ 							Object.prototype.hasOwnProperty.call(
/******/ 								result.outdatedDependencies,
/******/ 								moduleId
/******/ 							)
/******/ 						) {
/******/ 							if (!outdatedDependencies[moduleId])
/******/ 								outdatedDependencies[moduleId] = [];
/******/ 							addAllToSet(
/******/ 								outdatedDependencies[moduleId],
/******/ 								result.outdatedDependencies[moduleId]
/******/ 							);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 				if (doDispose) {
/******/ 					addAllToSet(outdatedModules, [result.moduleId]);
/******/ 					appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for (i = 0; i < outdatedModules.length; i++) {
/******/ 			moduleId = outdatedModules[i];
/******/ 			if (
/******/ 				installedModules[moduleId] &&
/******/ 				installedModules[moduleId].hot._selfAccepted
/******/ 			)
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 		}
/******/
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		Object.keys(hotAvailableFilesMap).forEach(function(chunkId) {
/******/ 			if (hotAvailableFilesMap[chunkId] === false) {
/******/ 				hotDisposeChunk(chunkId);
/******/ 			}
/******/ 		});
/******/
/******/ 		var idx;
/******/ 		var queue = outdatedModules.slice();
/******/ 		while (queue.length > 0) {
/******/ 			moduleId = queue.pop();
/******/ 			module = installedModules[moduleId];
/******/ 			if (!module) continue;
/******/
/******/ 			var data = {};
/******/
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for (j = 0; j < disposeHandlers.length; j++) {
/******/ 				cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/
/******/ 			// when disposing there is no need to call dispose handler
/******/ 			delete outdatedDependencies[moduleId];
/******/
/******/ 			// remove "parents" references from all children
/******/ 			for (j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if (!child) continue;
/******/ 				idx = child.parents.indexOf(moduleId);
/******/ 				if (idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// remove outdated dependency from module children
/******/ 		var dependency;
/******/ 		var moduleOutdatedDependencies;
/******/ 		for (moduleId in outdatedDependencies) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
/******/ 			) {
/******/ 				module = installedModules[moduleId];
/******/ 				if (module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 						dependency = moduleOutdatedDependencies[j];
/******/ 						idx = module.children.indexOf(dependency);
/******/ 						if (idx >= 0) module.children.splice(idx, 1);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Not in "apply" phase
/******/ 		hotSetStatus("apply");
/******/
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/
/******/ 		// insert new code
/******/ 		for (moduleId in appliedUpdate) {
/******/ 			if (Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for (moduleId in outdatedDependencies) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
/******/ 			) {
/******/ 				module = installedModules[moduleId];
/******/ 				if (module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					var callbacks = [];
/******/ 					for (i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 						dependency = moduleOutdatedDependencies[i];
/******/ 						cb = module.hot._acceptedDependencies[dependency];
/******/ 						if (cb) {
/******/ 							if (callbacks.indexOf(cb) !== -1) continue;
/******/ 							callbacks.push(cb);
/******/ 						}
/******/ 					}
/******/ 					for (i = 0; i < callbacks.length; i++) {
/******/ 						cb = callbacks[i];
/******/ 						try {
/******/ 							cb(moduleOutdatedDependencies);
/******/ 						} catch (err) {
/******/ 							if (options.onErrored) {
/******/ 								options.onErrored({
/******/ 									type: "accept-errored",
/******/ 									moduleId: moduleId,
/******/ 									dependencyId: moduleOutdatedDependencies[i],
/******/ 									error: err
/******/ 								});
/******/ 							}
/******/ 							if (!options.ignoreErrored) {
/******/ 								if (!error) error = err;
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Load self accepted modules
/******/ 		for (i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch (err) {
/******/ 				if (typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch (err2) {
/******/ 						if (options.onErrored) {
/******/ 							options.onErrored({
/******/ 								type: "self-accept-error-handler-errored",
/******/ 								moduleId: moduleId,
/******/ 								error: err2,
/******/ 								originalError: err
/******/ 							});
/******/ 						}
/******/ 						if (!options.ignoreErrored) {
/******/ 							if (!error) error = err2;
/******/ 						}
/******/ 						if (!error) error = err;
/******/ 					}
/******/ 				} else {
/******/ 					if (options.onErrored) {
/******/ 						options.onErrored({
/******/ 							type: "self-accept-errored",
/******/ 							moduleId: moduleId,
/******/ 							error: err
/******/ 						});
/******/ 					}
/******/ 					if (!options.ignoreErrored) {
/******/ 						if (!error) error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if (error) {
/******/ 			hotSetStatus("fail");
/******/ 			return Promise.reject(error);
/******/ 		}
/******/
/******/ 		hotSetStatus("idle");
/******/ 		return new Promise(function(resolve) {
/******/ 			resolve(outdatedModules);
/******/ 		});
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {},
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),
/******/ 			children: []
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire("./index.js")(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const MotorCortex = __webpack_require__(/*! @kissmybutton/motorcortex/ */ \"./node_modules/@kissmybutton/motorcortex/dist/main.js\");\n\nconst SigmaDefinition = __webpack_require__(/*! ./src/main.js */ \"./src/main.js\");\n\nconst Sigma = MotorCortex.loadPlugin(SigmaDefinition);\n\nconst Player = __webpack_require__(/*! @kissmybutton/motorcortex-player */ \"./node_modules/@kissmybutton/motorcortex-player/dist/Player.js\");\n\nconst host = document.getElementById(\"clip\");\nconst html = `\n    <div id=\"graph-container1\" class=\"graph-container1\"></div>\n    `;\nconst css = `\n    #animation1{\n        background:black;\n        width:90%;\n        height:100%;\n        position:absolute;\n\n    }`;\nconst containerParams = {\n  width: \"90%\",\n  height: \"90%\"\n};\nconst nodes = 1000;\nconst edges = 50;\nconst clusters = 5;\nvar square = {\n  nodes: [],\n  edges: [],\n  name: \"square\"\n};\n\nfor (var i = 0; i < nodes; i++) {\n  const xrand = Math.random() * 10;\n  const yrand = Math.random() * 10;\n  square.nodes.push({\n    id: 'n' + i,\n    label: 'Node ' + i,\n    x: xrand,\n    y: yrand,\n    xFinal: xrand,\n    yFinal: yrand,\n    size: Math.random(),\n    sizeFinal: Math.random(),\n    color: 'rgb(255,255,255)',\n    colorFinal: 'rgb(255,255,255)'\n  });\n}\n\nfor (var i = 0; i < edges; i++) square.edges.push({\n  id: 'e' + i,\n  source: 'n' + (Math.random() * nodes | 0),\n  target: 'n' + (Math.random() * nodes | 0)\n});\n\nvar circle = {\n  nodes: [],\n  edges: [],\n  name: \"circle\"\n};\n\nfor (var i = 0; i < nodes; i++) {\n  var r = 10 * Math.sqrt(Math.random());\n  var theta = Math.random() * 2 * Math.PI;\n  node = {\n    id: 'n' + i,\n    label: 'Node' + i,\n    x: r * Math.cos(theta),\n    y: r * Math.sin(theta),\n    xFinal: r * Math.cos(theta),\n    yFinal: r * Math.sin(theta),\n    size: Math.random(),\n    sizeFinal: Math.random(),\n    color: 'rgb(255,0,255)',\n    colorFinal: 'rgb(255,0,255)'\n  };\n  circle.nodes.push(node);\n}\n\nfor (i = 0; i < edges; i++) circle.edges.push({\n  id: 'e' + i,\n  source: 'n' + (Math.random() * nodes | 0),\n  target: 'n' + (Math.random() * nodes | 0)\n});\n\nwindow.clip = new Sigma.Clip( //attrs\n{\n  attrs: {\n    N: nodes,\n    //nodes of graph\n    E: edges,\n    //edges of graph\n    // C: clusters, // clusters to organize nodes\n    rendererType: 'webgl',\n    customGraph: square,\n    settings: {\n      drawEdges: false,\n      drawLabels: true\n    },\n    options: {\n      drag_nodes: true\n    }\n  }\n}, //props\n{\n  css,\n  host,\n  html: \"<div id='animation1'></div>\",\n  containerParams\n});\nconst animatedInc1 = new Sigma.SigmaAnimPlugin( //attrs\n{\n  attrs: {\n    master: clip\n  },\n  animatedAttrs: {\n    finalG: circle\n  }\n}, //props\n{\n  duration: 1000,\n  selector: \"#animation1\" // repeat:{\n  //     delay: 300,\n  //     times: 1,\n  //     hiatus: 300\n  // }\n\n});\nconst animatedInc2 = new Sigma.SigmaAnimPlugin( //attrs\n{\n  attrs: {\n    master: clip\n  },\n  animatedAttrs: {\n    finalG: square\n  }\n}, //props\n{\n  duration: 1000,\n  selector: \"#animation1\"\n});\nclip.addIncident(animatedInc1, 0);\nclip.addIncident(animatedInc2, 1000);\nwindow.player = new Player({\n  clip,\n  pointerEvents: false\n});\nwindow.tc = new MotorCortex.TimeCapsule(); // var journey = tc.startJourney(player.clip)\n// journey.station(1000)//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2luZGV4LmpzPzQxZjUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgTW90b3JDb3J0ZXggPSByZXF1aXJlKFwiQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9cIik7XHJcbmNvbnN0IFNpZ21hRGVmaW5pdGlvbiA9IHJlcXVpcmUoXCIuL3NyYy9tYWluLmpzXCIpO1xyXG5jb25zdCBTaWdtYSA9IE1vdG9yQ29ydGV4LmxvYWRQbHVnaW4oU2lnbWFEZWZpbml0aW9uKTtcclxuY29uc3QgUGxheWVyID0gcmVxdWlyZShcIkBraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyXCIpO1xyXG5cclxuY29uc3QgaG9zdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2xpcFwiKTtcclxuY29uc3QgaHRtbCA9IGBcclxuICAgIDxkaXYgaWQ9XCJncmFwaC1jb250YWluZXIxXCIgY2xhc3M9XCJncmFwaC1jb250YWluZXIxXCI+PC9kaXY+XHJcbiAgICBgO1xyXG5jb25zdCBjc3MgPSBgXHJcbiAgICAjYW5pbWF0aW9uMXtcclxuICAgICAgICBiYWNrZ3JvdW5kOmJsYWNrO1xyXG4gICAgICAgIHdpZHRoOjkwJTtcclxuICAgICAgICBoZWlnaHQ6MTAwJTtcclxuICAgICAgICBwb3NpdGlvbjphYnNvbHV0ZTtcclxuXHJcbiAgICB9YDtcclxuXHJcbmNvbnN0IGNvbnRhaW5lclBhcmFtcyA9IHtcclxuICAgIHdpZHRoOiBcIjkwJVwiLFxyXG4gICAgaGVpZ2h0OiBcIjkwJVwiXHJcbn1cclxuXHJcblxyXG5jb25zdCBub2RlcyA9IDEwMDA7XHJcbmNvbnN0IGVkZ2VzID0gNTA7XHJcbmNvbnN0IGNsdXN0ZXJzID0gNTtcclxuXHJcbnZhciBzcXVhcmUgPSB7bm9kZXM6W10sIGVkZ2VzOltdLG5hbWU6XCJzcXVhcmVcIn07XHJcbmZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXM7IGkrKykge1xyXG4gICAgY29uc3QgeHJhbmQgPSBNYXRoLnJhbmRvbSgpICogMTA7XHJcbiAgICBjb25zdCB5cmFuZCA9IE1hdGgucmFuZG9tKCkgKiAxMDtcclxuICAgIHNxdWFyZS5ub2Rlcy5wdXNoKHtcclxuICAgICAgICBpZDogJ24nICsgaSxcclxuICAgICAgICBsYWJlbDogJ05vZGUgJyArIGksXHJcbiAgICAgICAgeDp4cmFuZCxcclxuICAgICAgICB5OnlyYW5kLFxyXG4gICAgICAgIHhGaW5hbDp4cmFuZCxcclxuICAgICAgICB5RmluYWw6eXJhbmQsXHJcbiAgICAgICAgc2l6ZTogTWF0aC5yYW5kb20oKSxcclxuICAgICAgICBzaXplRmluYWw6IE1hdGgucmFuZG9tKCksXHJcbiAgICAgICAgY29sb3I6ICdyZ2IoMjU1LDI1NSwyNTUpJyxcclxuICAgICAgICBjb2xvckZpbmFsOiAncmdiKDI1NSwyNTUsMjU1KScsXHJcbiAgICB9KVxyXG59ICBcclxuZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlczsgaSsrKVxyXG5zcXVhcmUuZWRnZXMucHVzaCh7XHJcbiAgICAgICAgaWQ6ICdlJyArIGksXHJcbiAgICAgICAgc291cmNlOiAnbicgKyAoTWF0aC5yYW5kb20oKSAqIG5vZGVzIHwgMCksXHJcbiAgICAgICAgdGFyZ2V0OiAnbicgKyAoTWF0aC5yYW5kb20oKSAqIG5vZGVzIHwgMClcclxufSk7XHJcblxyXG5cclxudmFyIGNpcmNsZSA9IHtub2RlczpbXSwgZWRnZXM6W10sbmFtZTpcImNpcmNsZVwifTtcclxuZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlczsgaSsrKSB7XHJcblxyXG4gICAgdmFyIHIgPSAxMCAqIE1hdGguc3FydChNYXRoLnJhbmRvbSgpKTtcclxuICAgIHZhciB0aGV0YSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcclxuXHJcbiAgICBub2RlID0ge1xyXG4gICAgICAgIGlkOiAnbicgKyBpLFxyXG4gICAgICAgIGxhYmVsOiAnTm9kZScgKyBpLFxyXG4gICAgICAgIHg6IHIgKiBNYXRoLmNvcyh0aGV0YSksXHJcbiAgICAgICAgeTogciAqIE1hdGguc2luKHRoZXRhKSxcclxuICAgICAgICB4RmluYWw6IHIgKiBNYXRoLmNvcyh0aGV0YSksXHJcbiAgICAgICAgeUZpbmFsOiByICogTWF0aC5zaW4odGhldGEpLFxyXG4gICAgICAgIHNpemU6IE1hdGgucmFuZG9tKCksXHJcbiAgICAgICAgc2l6ZUZpbmFsOiBNYXRoLnJhbmRvbSgpLFxyXG4gICAgICAgIGNvbG9yOiAncmdiKDI1NSwwLDI1NSknLFxyXG4gICAgICAgIGNvbG9yRmluYWw6ICdyZ2IoMjU1LDAsMjU1KSdcclxuICAgIH1cclxuICAgIGNpcmNsZS5ub2Rlcy5wdXNoKG5vZGUpO1xyXG59XHJcbmZvciAoaSA9IDA7IGkgPCBlZGdlczsgaSsrKVxyXG5jaXJjbGUuZWRnZXMucHVzaCh7XHJcbiAgICBpZDogJ2UnICsgaSxcclxuICAgIHNvdXJjZTogJ24nICsgKE1hdGgucmFuZG9tKCkgKiBub2RlcyB8IDApLFxyXG4gICAgdGFyZ2V0OiAnbicgKyAoTWF0aC5yYW5kb20oKSAqIG5vZGVzIHwgMClcclxufSk7XHJcblxyXG5cclxud2luZG93LmNsaXAgPSBuZXcgU2lnbWEuQ2xpcChcclxuICAgIC8vYXR0cnNcclxuICAgIHtcclxuICAgICAgICBhdHRyczp7XHJcbiAgICAgICAgICAgIE46IG5vZGVzLCAgLy9ub2RlcyBvZiBncmFwaFxyXG4gICAgICAgICAgICBFOiBlZGdlcywgIC8vZWRnZXMgb2YgZ3JhcGhcclxuICAgICAgICAgICAgLy8gQzogY2x1c3RlcnMsIC8vIGNsdXN0ZXJzIHRvIG9yZ2FuaXplIG5vZGVzXHJcbiAgICAgICAgICAgIHJlbmRlcmVyVHlwZTogJ3dlYmdsJyxcclxuICAgICAgICAgICAgY3VzdG9tR3JhcGg6IHNxdWFyZSxcclxuICAgICAgICAgICAgc2V0dGluZ3M6IHtcclxuICAgICAgICAgICAgICAgIGRyYXdFZGdlczogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBkcmF3TGFiZWxzOiB0cnVlLFxyXG4gICAgICAgICAgICB9LCBcclxuICAgICAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgZHJhZ19ub2RlczogdHJ1ZSxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICAvL3Byb3BzXHJcbiAgICB7XHJcbiAgICAgICAgY3NzLFxyXG4gICAgICAgIGhvc3QsXHJcbiAgICAgICAgaHRtbDpcIjxkaXYgaWQ9J2FuaW1hdGlvbjEnPjwvZGl2PlwiLFxyXG4gICAgICAgIGNvbnRhaW5lclBhcmFtc1xyXG4gICAgfVxyXG4pO1xyXG5cclxuXHJcblxyXG5jb25zdCBhbmltYXRlZEluYzEgPSBuZXcgU2lnbWEuU2lnbWFBbmltUGx1Z2luKFxyXG4gICAgLy9hdHRyc1xyXG4gICAge1xyXG4gICAgICAgIGF0dHJzOntcclxuICAgICAgICAgICAgbWFzdGVyOiBjbGlwXHJcbiAgICAgICAgfSxcclxuICAgICAgICBhbmltYXRlZEF0dHJzOntcclxuICAgICAgICAgICAgZmluYWxHOiBjaXJjbGVcclxuICAgICAgICB9ICAgXHJcbiAgICB9LFxyXG4gICAgLy9wcm9wc1xyXG4gICAge1xyXG4gICAgICAgIGR1cmF0aW9uOiAxMDAwLFxyXG4gICAgICAgIHNlbGVjdG9yOlwiI2FuaW1hdGlvbjFcIixcclxuICAgICAgICAvLyByZXBlYXQ6e1xyXG4gICAgICAgIC8vICAgICBkZWxheTogMzAwLFxyXG4gICAgICAgIC8vICAgICB0aW1lczogMSxcclxuICAgICAgICAvLyAgICAgaGlhdHVzOiAzMDBcclxuICAgICAgICAvLyB9XHJcbiAgICB9XHJcbik7XHJcblxyXG5cclxuXHJcbmNvbnN0IGFuaW1hdGVkSW5jMiA9IG5ldyBTaWdtYS5TaWdtYUFuaW1QbHVnaW4oXHJcbiAgICAvL2F0dHJzXHJcbiAgICB7XHJcbiAgICAgICAgYXR0cnM6e1xyXG4gICAgICAgICAgICBtYXN0ZXI6IGNsaXBcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFuaW1hdGVkQXR0cnM6e1xyXG4gICAgICAgICAgICBmaW5hbEc6IHNxdWFyZVxyXG4gICAgICAgIH0gICBcclxuICAgIH0sXHJcbiAgICAvL3Byb3BzXHJcbiAgICB7XHJcbiAgICAgICAgZHVyYXRpb246IDEwMDAsXHJcbiAgICAgICAgc2VsZWN0b3I6XCIjYW5pbWF0aW9uMVwiXHJcbiAgICB9XHJcbik7XHJcblxyXG5jbGlwLmFkZEluY2lkZW50KGFuaW1hdGVkSW5jMSwgMCk7XHJcbmNsaXAuYWRkSW5jaWRlbnQoYW5pbWF0ZWRJbmMyLCAxMDAwKTtcclxuXHJcbndpbmRvdy5wbGF5ZXIgPSBuZXcgUGxheWVyKHtcclxuICAgIGNsaXAsXHJcbiAgICBwb2ludGVyRXZlbnRzOiBmYWxzZVxyXG59KTtcclxuXHJcbndpbmRvdy50YyA9IG5ldyBNb3RvckNvcnRleC5UaW1lQ2Fwc3VsZSgpO1xyXG4vLyB2YXIgam91cm5leSA9IHRjLnN0YXJ0Sm91cm5leShwbGF5ZXIuY2xpcClcclxuLy8gam91cm5leS5zdGF0aW9uKDEwMDApIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFBQTtBQUdBOzs7Ozs7O0FBQUE7QUFTQTtBQUNBO0FBQ0E7QUFGQTtBQU1BO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQVlBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFNQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFZQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFNQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQURBO0FBVkE7QUFEQTtBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFVQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBSkE7QUFTQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFhQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBSkE7QUFTQTtBQUNBO0FBQ0E7QUFGQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBRUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./index.js\n");

/***/ }),

/***/ "./lib/SigmaAnimationPlugin.js":
/*!*************************************!*\
  !*** ./lib/SigmaAnimationPlugin.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n *  Class that implements the code from SigmaJS Animated Plugin\r\n *  requestAnimationFrame functionality and ability to kill\r\n *  animations and cancelAnimationFrame has been removed and\r\n *  implemented by SigmaAnimPlugin.js through MotorCortex Classes\r\n **/\nclass SigmaAnimation {\n  constructor(id, initialGraph, finalGraph, s, animate, options) {\n    sigma.utils.pkg('sigma.plugins');\n    this.id = id, this._cache = {};\n    this.s = s;\n    this.animate = animate;\n    this.options = options;\n    this.o = null;\n    this.duration = null;\n    this.easing = null;\n    this.start = null;\n    this.finalGraph = finalGraph.nodes;\n    this.initialGraph = initialGraph;\n    this.nodes = null;\n    this.prepAnimation(this.animate, this.options);\n  }\n  /**\r\n   * animating Color\r\n   */\n\n\n  parseColor(val) {\n    if (this._cache[val]) {\n      return this._cache[val];\n    }\n\n    var result = [0, 0, 0];\n\n    if (val.match(/^#/)) {\n      val = (val || '').replace(/^#/, '');\n      result = val.length === 3 ? [parseInt(val.charAt(0) + val.charAt(0), 16), parseInt(val.charAt(1) + val.charAt(1), 16), parseInt(val.charAt(2) + val.charAt(2), 16)] : [parseInt(val.charAt(0) + val.charAt(1), 16), parseInt(val.charAt(2) + val.charAt(3), 16), parseInt(val.charAt(4) + val.charAt(5), 16)];\n    } else if (val.match(/^ *rgba? *\\(/)) {\n      val = val.match(/^ *rgba? *\\( *([0-9]*) *, *([0-9]*) *, *([0-9]*) *(,.*)?\\) *$/);\n      result = [+val[1], +val[2], +val[3]];\n    }\n\n    this._cache[val] = {\n      r: result[0],\n      g: result[1],\n      b: result[2]\n    };\n    return this._cache[val];\n  }\n  /**\r\n   * helper function for animating color change\r\n   */\n\n\n  interpolateColors(c1, c2, p) {\n    c1 = this.parseColor(c1);\n    c2 = this.parseColor(c2);\n    var c = {\n      r: c1.r * (1 - p) + c2.r * p,\n      g: c1.g * (1 - p) + c2.g * p,\n      b: c1.b * (1 - p) + c2.b * p\n    };\n    return 'rgb(' + [c.r | 0, c.g | 0, c.b | 0].join(',') + ')';\n  }\n  /** \r\n   * Prepares the variables of the class so that animations can be \r\n   * performed\r\n   */\n\n\n  prepAnimation(animate, options) {\n    this.o = options || {};\n    this.duration = this.o.duration || this.s.settings('animationsTime');\n    this.easing = typeof this.o.easing === 'string' ? sigma.utils.easings[this.o.easing] : typeof this.o.easing === 'function' ? this.o.easing : sigma.utils.easings.quadraticInOut;\n    this.start = sigma.utils.dateNow();\n    this.nodes = this.s.graph.nodes(); // Store initial positions:\n\n    this.startPositions = this.initialGraph.nodes.reduce((res, node) => {\n      var k;\n      res[node.id] = {};\n\n      for (k in animate) {\n        if (k in node) {\n          res[node.id][k] = node[k];\n          res[node.id][animate[k]] = node[k];\n        }\n      }\n\n      return res;\n    }, {});\n    this.finalGraph = this.finalGraph.reduce((res, node) => {\n      var k;\n      res[node.id] = {};\n\n      for (k in animate) {\n        if (k in node) {\n          res[node.id][k] = node[k];\n          res[node.id][animate[k]] = node[k];\n        }\n      }\n\n      return res;\n    }, {});\n  }\n\n  /**\r\n   * Changes the x/y positions of nodes in the graph to be displayed\r\n   * by the renderer according to p(progress)\r\n   */\n  changeFrame(p) {\n    p = this.easing(p);\n    this.nodes.forEach(node => {\n      for (var k in this.animate) {\n        if (k in this.animate) {\n          if (k.match(/color$/)) {\n            node[k] = this.interpolateColors(this.startPositions[node.id][k], this.finalGraph[node.id][this.animate[k]], p);\n          } else {\n            node[k] = this.finalGraph[node.id][this.animate[k]] * p + this.startPositions[node.id][k] * (1 - p);\n          }\n        }\n      }\n    });\n    this.s.refresh();\n  }\n\n}\n\nmodule.exports = SigmaAnimation;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvU2lnbWFBbmltYXRpb25QbHVnaW4uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvU2lnbWFBbmltYXRpb25QbHVnaW4uanM/OWM1MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogIENsYXNzIHRoYXQgaW1wbGVtZW50cyB0aGUgY29kZSBmcm9tIFNpZ21hSlMgQW5pbWF0ZWQgUGx1Z2luXHJcbiAqICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgZnVuY3Rpb25hbGl0eSBhbmQgYWJpbGl0eSB0byBraWxsXHJcbiAqICBhbmltYXRpb25zIGFuZCBjYW5jZWxBbmltYXRpb25GcmFtZSBoYXMgYmVlbiByZW1vdmVkIGFuZFxyXG4gKiAgaW1wbGVtZW50ZWQgYnkgU2lnbWFBbmltUGx1Z2luLmpzIHRocm91Z2ggTW90b3JDb3J0ZXggQ2xhc3Nlc1xyXG4gKiovXHJcbmNsYXNzIFNpZ21hQW5pbWF0aW9uIHtcclxuICBjb25zdHJ1Y3RvcihpZCwgaW5pdGlhbEdyYXBoLGZpbmFsR3JhcGgsIHMsIGFuaW1hdGUsIG9wdGlvbnMpIHtcclxuICAgIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEucGx1Z2lucycpO1xyXG4gICAgdGhpcy5pZCA9IGlkLFxyXG4gICAgdGhpcy5fY2FjaGUgPSB7fTtcclxuXHJcbiAgICB0aGlzLnMgPSBzO1xyXG4gICAgdGhpcy5hbmltYXRlID0gYW5pbWF0ZTtcclxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcblxyXG4gICAgdGhpcy5vID0gbnVsbDtcclxuICAgIHRoaXMuZHVyYXRpb24gPSBudWxsO1xyXG4gICAgdGhpcy5lYXNpbmcgPSBudWxsO1xyXG4gICAgdGhpcy5zdGFydCAgPSBudWxsO1xyXG4gICAgdGhpcy5maW5hbEdyYXBoID0gZmluYWxHcmFwaC5ub2RlcztcclxuICAgIHRoaXMuaW5pdGlhbEdyYXBoICA9IGluaXRpYWxHcmFwaDtcclxuICAgIHRoaXMubm9kZXMgPSBudWxsO1xyXG4gICAgdGhpcy5wcmVwQW5pbWF0aW9uKCB0aGlzLmFuaW1hdGUsIHRoaXMub3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBhbmltYXRpbmcgQ29sb3JcclxuICAgKi9cclxuICBwYXJzZUNvbG9yKHZhbCkge1xyXG4gICAgaWYgKHRoaXMuX2NhY2hlW3ZhbF0pIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlW3ZhbF07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlc3VsdCA9IFswLCAwLCAwXTtcclxuXHJcbiAgICBpZiAodmFsLm1hdGNoKC9eIy8pKSB7XHJcbiAgICAgIHZhbCA9ICh2YWwgfHwgJycpLnJlcGxhY2UoL14jLywgJycpO1xyXG4gICAgICByZXN1bHQgPSAodmFsLmxlbmd0aCA9PT0gMykgP1xyXG4gICAgICAgIFtcclxuICAgICAgICAgIHBhcnNlSW50KHZhbC5jaGFyQXQoMCkgKyB2YWwuY2hhckF0KDApLCAxNiksXHJcbiAgICAgICAgICBwYXJzZUludCh2YWwuY2hhckF0KDEpICsgdmFsLmNoYXJBdCgxKSwgMTYpLFxyXG4gICAgICAgICAgcGFyc2VJbnQodmFsLmNoYXJBdCgyKSArIHZhbC5jaGFyQXQoMiksIDE2KVxyXG4gICAgICAgIF0gOlxyXG4gICAgICAgIFtcclxuICAgICAgICAgIHBhcnNlSW50KHZhbC5jaGFyQXQoMCkgKyB2YWwuY2hhckF0KDEpLCAxNiksXHJcbiAgICAgICAgICBwYXJzZUludCh2YWwuY2hhckF0KDIpICsgdmFsLmNoYXJBdCgzKSwgMTYpLFxyXG4gICAgICAgICAgcGFyc2VJbnQodmFsLmNoYXJBdCg0KSArIHZhbC5jaGFyQXQoNSksIDE2KVxyXG4gICAgICAgIF07XHJcbiAgICB9IFxyXG4gICAgZWxzZSBpZiAodmFsLm1hdGNoKC9eICpyZ2JhPyAqXFwoLykpIHtcclxuICAgICAgdmFsID0gdmFsLm1hdGNoKFxyXG4gICAgICAgIC9eICpyZ2JhPyAqXFwoICooWzAtOV0qKSAqLCAqKFswLTldKikgKiwgKihbMC05XSopICooLC4qKT9cXCkgKiQvXHJcbiAgICAgICk7XHJcbiAgICAgIHJlc3VsdCA9IFtcclxuICAgICAgICArdmFsWzFdLFxyXG4gICAgICAgICt2YWxbMl0sXHJcbiAgICAgICAgK3ZhbFszXVxyXG4gICAgICBdO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2NhY2hlW3ZhbF0gPSB7XHJcbiAgICAgIHI6IHJlc3VsdFswXSxcclxuICAgICAgZzogcmVzdWx0WzFdLFxyXG4gICAgICBiOiByZXN1bHRbMl1cclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlW3ZhbF07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBoZWxwZXIgZnVuY3Rpb24gZm9yIGFuaW1hdGluZyBjb2xvciBjaGFuZ2VcclxuICAgKi9cclxuICBpbnRlcnBvbGF0ZUNvbG9ycyhjMSwgYzIsIHApIHtcclxuICAgIGMxID0gdGhpcy5wYXJzZUNvbG9yKGMxKTtcclxuICAgIGMyID0gdGhpcy5wYXJzZUNvbG9yKGMyKTtcclxuXHJcbiAgICB2YXIgYyA9IHtcclxuICAgICAgcjogYzEuciAqICgxIC0gcCkgKyBjMi5yICogcCxcclxuICAgICAgZzogYzEuZyAqICgxIC0gcCkgKyBjMi5nICogcCxcclxuICAgICAgYjogYzEuYiAqICgxIC0gcCkgKyBjMi5iICogcFxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gJ3JnYignICsgW2MuciB8IDAsIGMuZyB8IDAsIGMuYiB8IDBdLmpvaW4oJywnKSArICcpJztcclxuICB9XHJcblxyXG5cclxuXHJcbiAgLyoqIFxyXG4gICAqIFByZXBhcmVzIHRoZSB2YXJpYWJsZXMgb2YgdGhlIGNsYXNzIHNvIHRoYXQgYW5pbWF0aW9ucyBjYW4gYmUgXHJcbiAgICogcGVyZm9ybWVkXHJcbiAgICovXHJcbiAgcHJlcEFuaW1hdGlvbiggYW5pbWF0ZSwgb3B0aW9ucykge1xyXG4gICAgdGhpcy5vID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIHRoaXMuZHVyYXRpb24gPSB0aGlzLm8uZHVyYXRpb24gfHwgdGhpcy5zLnNldHRpbmdzKCdhbmltYXRpb25zVGltZScpO1xyXG4gICAgdGhpcy5lYXNpbmcgPSB0eXBlb2YgdGhpcy5vLmVhc2luZyA9PT0gJ3N0cmluZycgP1xyXG4gICAgICBzaWdtYS51dGlscy5lYXNpbmdzW3RoaXMuby5lYXNpbmddIDpcclxuICAgICAgdHlwZW9mIHRoaXMuby5lYXNpbmcgPT09ICdmdW5jdGlvbicgP1xyXG4gICAgICB0aGlzLm8uZWFzaW5nIDpcclxuICAgICAgc2lnbWEudXRpbHMuZWFzaW5ncy5xdWFkcmF0aWNJbk91dDtcclxuICAgICAgdGhpcy5zdGFydCA9IHNpZ21hLnV0aWxzLmRhdGVOb3coKTtcclxuXHJcbiAgICAgIHRoaXMubm9kZXMgPSB0aGlzLnMuZ3JhcGgubm9kZXMoKTtcclxuXHJcblxyXG4gICAgLy8gU3RvcmUgaW5pdGlhbCBwb3NpdGlvbnM6XHJcbiAgICB0aGlzLnN0YXJ0UG9zaXRpb25zID0gdGhpcy5pbml0aWFsR3JhcGgubm9kZXMucmVkdWNlKCAocmVzLCBub2RlKSA9PiB7XHJcbiAgICAgIHZhciBrO1xyXG4gICAgICByZXNbbm9kZS5pZF0gPSB7fTtcclxuICAgICAgZm9yIChrIGluIGFuaW1hdGUpIHtcclxuICAgICAgICBpZiAoayBpbiBub2RlKSB7XHJcbiAgICAgICAgICByZXNbbm9kZS5pZF1ba10gPSBub2RlW2tdO1xyXG4gICAgICAgICAgcmVzW25vZGUuaWRdW2FuaW1hdGVba11dID0gbm9kZVtrXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlcztcclxuICAgIH0sIHt9KTtcclxuXHJcbiAgICB0aGlzLmZpbmFsR3JhcGggPSB0aGlzLmZpbmFsR3JhcGgucmVkdWNlKCAocmVzLCBub2RlKSA9PiB7XHJcbiAgICAgIHZhciBrO1xyXG4gICAgICByZXNbbm9kZS5pZF0gPSB7fTtcclxuICAgICAgZm9yIChrIGluIGFuaW1hdGUpIHtcclxuICAgICAgICBpZiAoayBpbiBub2RlKSB7XHJcbiAgICAgICAgICByZXNbbm9kZS5pZF1ba10gPSBub2RlW2tdO1xyXG4gICAgICAgICAgcmVzW25vZGUuaWRdW2FuaW1hdGVba11dID0gbm9kZVtrXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHJldHVybiByZXM7XHJcbiAgICB9LCB7fSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIENoYW5nZXMgdGhlIHgveSBwb3NpdGlvbnMgb2Ygbm9kZXMgaW4gdGhlIGdyYXBoIHRvIGJlIGRpc3BsYXllZFxyXG4gICAqIGJ5IHRoZSByZW5kZXJlciBhY2NvcmRpbmcgdG8gcChwcm9ncmVzcylcclxuICAgKi9cclxuICBjaGFuZ2VGcmFtZSAocCkge1xyXG4gICAgcCA9IHRoaXMuZWFzaW5nKHApO1xyXG4gICAgdGhpcy5ub2Rlcy5mb3JFYWNoKCAobm9kZSkgPT4ge1xyXG4gICAgICBmb3IgKHZhciBrIGluIHRoaXMuYW5pbWF0ZSkge1xyXG4gICAgICAgIGlmIChrIGluIHRoaXMuYW5pbWF0ZSkge1xyXG4gICAgICAgICAgaWYgKGsubWF0Y2goL2NvbG9yJC8pKSB7XHJcbiAgICAgICAgICAgIG5vZGVba10gPSB0aGlzLmludGVycG9sYXRlQ29sb3JzKFxyXG4gICAgICAgICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbnNbbm9kZS5pZF1ba10sXHJcbiAgICAgICAgICAgICAgdGhpcy5maW5hbEdyYXBoW25vZGUuaWRdW3RoaXMuYW5pbWF0ZVtrXV0sXHJcbiAgICAgICAgICAgICAgcFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5vZGVba10gPVxyXG4gICAgICAgICAgICAgIHRoaXMuZmluYWxHcmFwaFtub2RlLmlkXVt0aGlzLmFuaW1hdGVba11dICogcCArXHJcbiAgICAgICAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uc1tub2RlLmlkXVtrXSAqICgxIC0gcCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHRoaXMucy5yZWZyZXNoKCk7XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNpZ21hQW5pbWF0aW9uOyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFXQTtBQUVBO0FBR0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBQ0E7QUFFQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFDQTtBQUlBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXpKQTtBQUNBO0FBMEpBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/SigmaAnimationPlugin.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex-player/dist/Player.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex-player/dist/Player.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar MC = __webpack_require__(/*! @kissmybutton/motorcortex */ \"./node_modules/@kissmybutton/motorcortex/dist/main.js\");\n\nvar timeCapsule = new MC.TimeCapsule();\nvar mch = new MC.Helper();\n\nvar _require = __webpack_require__(/*! ./helpers */ \"./node_modules/@kissmybutton/motorcortex-player/dist/helpers.js\"),\n    elid = _require.elid,\n    eltag = _require.eltag,\n    elcreate = _require.elcreate;\n\nvar svg = __webpack_require__(/*! ./html/svg */ \"./node_modules/@kissmybutton/motorcortex-player/dist/html/svg.js\");\n\nvar config = __webpack_require__(/*! ./config */ \"./node_modules/@kissmybutton/motorcortex-player/dist/config.js\");\n\nvar confStyle = __webpack_require__(/*! ./html/style */ \"./node_modules/@kissmybutton/motorcortex-player/dist/html/style.js\");\n\nvar confThemes = __webpack_require__(/*! ./html/themes */ \"./node_modules/@kissmybutton/motorcortex-player/dist/html/themes.js\");\n\nvar setElements = __webpack_require__(/*! ./html/setElements */ \"./node_modules/@kissmybutton/motorcortex-player/dist/html/setElements.js\");\n\nvar volumeListener = __webpack_require__(/*! ./listeners/volume */ \"./node_modules/@kissmybutton/motorcortex-player/dist/listeners/volume.js\");\n\nvar loopBarStartListener = __webpack_require__(/*! ./listeners/loopBarStart */ \"./node_modules/@kissmybutton/motorcortex-player/dist/listeners/loopBarStart.js\");\n\nvar loopBarEndListener = __webpack_require__(/*! ./listeners/loopBarEnd */ \"./node_modules/@kissmybutton/motorcortex-player/dist/listeners/loopBarEnd.js\");\n\nvar loopStartEndListener = __webpack_require__(/*! ./listeners/loopStartEnd */ \"./node_modules/@kissmybutton/motorcortex-player/dist/listeners/loopStartEnd.js\");\n\nvar progressBarListener = __webpack_require__(/*! ./listeners/progressBar */ \"./node_modules/@kissmybutton/motorcortex-player/dist/listeners/progressBar.js\");\n\nvar statusBtnListener = __webpack_require__(/*! ./listeners/statusBtn */ \"./node_modules/@kissmybutton/motorcortex-player/dist/listeners/statusBtn.js\");\n\nvar settingsListener = __webpack_require__(/*! ./listeners/settings */ \"./node_modules/@kissmybutton/motorcortex-player/dist/listeners/settings.js\");\n\nvar speedListener = __webpack_require__(/*! ./listeners/speed */ \"./node_modules/@kissmybutton/motorcortex-player/dist/listeners/speed.js\");\n\nvar loopBtnListener = __webpack_require__(/*! ./listeners/loopBtn */ \"./node_modules/@kissmybutton/motorcortex-player/dist/listeners/loopBtn.js\");\n\nvar controlsListener = __webpack_require__(/*! ./listeners/controls */ \"./node_modules/@kissmybutton/motorcortex-player/dist/listeners/controls.js\");\n\nvar fullscreenListener = __webpack_require__(/*! ./listeners/fullscreen */ \"./node_modules/@kissmybutton/motorcortex-player/dist/listeners/fullscreen.js\");\n\nvar donkeyclipListener = __webpack_require__(/*! ./listeners/donkeyclip */ \"./node_modules/@kissmybutton/motorcortex-player/dist/listeners/donkeyclip.js\");\n\nvar previewListener = __webpack_require__(/*! ./listeners/preview */ \"./node_modules/@kissmybutton/motorcortex-player/dist/listeners/preview.js\");\n\nvar bodyListener = __webpack_require__(/*! ./listeners/body */ \"./node_modules/@kissmybutton/motorcortex-player/dist/listeners/body.js\");\n/**\n * @classdesc\n * Timer's purpose is to provide an interface through which any TimedIncident\n * (such as a Scene or a Clip) can both privide info regarding their timing\n * state but also provide an interface for interacting/altering the timing of it\n */\n\n\nvar Player =\n/*#__PURE__*/\nfunction () {\n  function Player(options) {\n    var _this = this;\n\n    _classCallCheck(this, Player);\n\n    // set defaults\n    options.id = options.id || mch.getAnId();\n    options.preview = options.preview || false;\n    options.showVolume = options.showVolume || false;\n    options.theme = options.theme || \"transparent on-top\";\n    options.host = options.host || options.clip.props.host;\n    options.buttons = options.buttons || {};\n\n    if (options.pointerEvents === undefined || options.pointerEvents === null) {\n      options.pointerEvents = true;\n    } else {\n      options.pointerEvents = Boolean(options.pointerEvents);\n    }\n\n    options.onMillisecondChange = options.onMillisecondChange || null;\n    options.speedValues = options.speedValues || [-4, -2, -1, -0.5, 0, 0.5, 1, 2, 4]; // remove strings\n\n    for (var i in options.speedValues) {\n      if (!isFinite(options.speedValues[i])) {\n        options.speedValues.splice(i, 1);\n      }\n    }\n\n    options.speedValues.sort(function (a, b) {\n      return a - b;\n    });\n    this.className = config.name;\n    config.playerName = options.id;\n    this.options = options;\n    this.id = this.options.id;\n    this.name = config.name;\n    this.previewClip = null;\n    this.clip = options.clip; // host to apply the timer\n\n    this.clipClass = options.clipClass;\n    this.listeners = {};\n    this.settings = {\n      volume: 1,\n      journey: null,\n      previousVolume: 1,\n      volumeMute: false,\n      needsUpdate: true,\n      resizeLoop: false,\n      loopJourney: false,\n      previewJourney: null,\n      loopActivated: false,\n      requestingLoop: false,\n      playAfterResize: false,\n      loopStartMillisecond: 0,\n      loopLastPositionXPxls: 0,\n      loopLastPositionXPercentage: 0,\n      loopEndMillisecond: this.clip.duration\n    };\n    this.functions = {\n      millisecondChange: this.millisecondChange,\n      createJourney: this.createJourney\n    }; // create the timer controls main div\n\n    setElements(this);\n    this.setTheme();\n    this.setSpeed();\n    this.subscribeToTimer();\n    this.subscribeToEvents();\n    this.addEventListeners();\n\n    if (this.options.preview) {\n      this.createPreviewDisplay();\n    }\n\n    window.addEventListener(\"resize\", function () {\n      if (_this.options.preview) {\n        _this.setPreviewDimentions();\n      }\n    });\n  }\n\n  _createClass(Player, [{\n    key: \"createJourney\",\n    value: function createJourney(clip, millisecond) {\n      var _this2 = this;\n\n      var clipCommands = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      setTimeout(function () {\n        var def = null;\n        var _clipCommands$before = clipCommands.before,\n            before = _clipCommands$before === void 0 ? def : _clipCommands$before,\n            _clipCommands$after = clipCommands.after,\n            after = _clipCommands$after === void 0 ? def : _clipCommands$after;\n        before ? clip[before]() : null;\n        _this2.settings.journey = timeCapsule.startJourney(clip);\n\n        _this2.settings.journey.station(millisecond);\n\n        _this2.settings.journey.destination();\n\n        after ? clip[after]() : null;\n      }, 0);\n    }\n  }, {\n    key: \"millisecondChange\",\n    value: function millisecondChange(millisecond, timestamp, roundTo, makeJouney) {\n      var executeOnMillisecondChange = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n\n      if (!this.settings.needsUpdate) {\n        this.clip.wait();\n        return 1;\n      }\n\n      var clip = this.clip;\n      var _this$settings = this.settings,\n          loopActivated = _this$settings.loopActivated,\n          loopEndMillisecond = _this$settings.loopEndMillisecond,\n          loopStartMillisecond = _this$settings.loopStartMillisecond;\n      var duration = this.clip.duration;\n      var _this$elements = this.elements,\n          totalBar = _this$elements.totalBar,\n          loopBar = _this$elements.loopBar;\n      var loopBarWidth = loopBar.offsetWidth;\n      var loopBarLeft = loopBar.offsetLeft / totalBar.offsetWidth;\n      var localMillisecond = millisecond - duration * loopBarLeft;\n      var localDuration = duration / totalBar.offsetWidth * loopBarWidth;\n\n      if (millisecond >= loopEndMillisecond && loopActivated) {\n        if (clip.state === \"idle\" || clip.state === \"completed\") {\n          this.createJourney(clip, loopStartMillisecond + 1, {\n            before: \"stop\",\n            after: \"play\"\n          });\n        } else {\n          this.createJourney(clip, loopStartMillisecond + 1, {\n            after: \"resume\"\n          });\n        }\n\n        return 1;\n      } else if (millisecond <= loopStartMillisecond && loopActivated) {\n        if (clip.state === \"idle\" || clip.state === \"completed\") {\n          this.createJourney(clip, loopEndMillisecond - 1, {\n            before: \"stop\",\n            after: \"play\"\n          });\n        } else {\n          this.createJourney(clip, loopEndMillisecond - 1, {\n            after: \"resume\"\n          });\n        }\n\n        return 1;\n      }\n      /*else if (millisecond <= loopStartMillisecond) {\n      this.createJourney(clip, loopStartMillisecond);\n      } else if (millisecond >= loopEndMillisecond) {\n      this.createJourney(clip, loopEndMillisecond);\n      }*/\n\n\n      if (makeJouney) {\n        this.createJourney(clip, millisecond, {\n          after: this.settings.playAfterResize ? \"resume\" : null\n        });\n      }\n\n      this.elements.runningBar.style.width = localMillisecond / localDuration * 100 + \"%\";\n      this.elements.currentTime.innerHTML = millisecond;\n\n      if (this.options.onMillisecondChange && executeOnMillisecondChange) {\n        this.options.onMillisecondChange(millisecond);\n      }\n    }\n  }, {\n    key: \"eventBroadcast\",\n    value: function eventBroadcast(eventName, meta) {\n      if (eventName === \"state-change\") {\n        if (meta.newState === \"waiting\") {\n          this.elements.statusButton.innerHTML = svg.playSVG;\n          this.elements.statusButton.appendChild(this.elements.indicator);\n          this.elements.indicator.innerHTML = \"Waiting\";\n        } else if (meta.newState === \"playing\") {\n          this.elements.statusButton.innerHTML = svg.pauseSVG;\n          this.elements.statusButton.appendChild(this.elements.indicator);\n          this.elements.indicator.innerHTML = \"Playing\";\n        } else if (meta.newState === \"completed\") {\n          this.elements.currentTime.innerHTML = this.clip.duration;\n          this.elements.statusButton.innerHTML = svg.replaySVG;\n          this.elements.statusButton.appendChild(this.elements.indicator);\n          this.elements.indicator.innerHTML = \"Completed\";\n        } else if (meta.newState === \"transitional\") {\n          this.elements.statusButton.innerHTML = svg.playSVG;\n          this.elements.statusButton.appendChild(this.elements.indicator);\n          this.elements.indicator.innerHTML = \"Transitional\";\n        } else if (meta.newState === \"idle\") {\n          this.elements.statusButton.innerHTML = svg.playSVG;\n          this.elements.statusButton.appendChild(this.elements.indicator);\n          this.elements.indicator.innerHTML = \"Idle\";\n        } else {\n          this.elements.indicator.innerHTML = meta.newSTate;\n        }\n      } else if (eventName === \"attribute-rejection\") {\n        mch.log(\"Attributes\", meta.attributes, \"have been rejected from animation with id \".concat(meta.animationID));\n      } else if (eventName === \"animation-rejection\") {\n        mch.log(\"Animation \".concat(meta.animationID, \" has been rejected as all attributes of \\n        it overlap on specific elements because of existing animations\"));\n      } else if (eventName === \"duration-change\") {\n        this.elements.totalTime.innerHTML = this.clip.duration;\n        this.settings.loopEndMillisecond = this.clip.duration;\n        this.millisecondChange(this.clip.runTimeInfo.currentMillisecond);\n      }\n    }\n  }, {\n    key: \"subscribeToEvents\",\n    value: function subscribeToEvents() {\n      this.clip.subscribeToEvents(this.id, this.eventBroadcast.bind(this));\n    }\n  }, {\n    key: \"subscribeToTimer\",\n    value: function subscribeToTimer() {\n      this.clip.subscribe(this.id, this.millisecondChange.bind(this));\n    }\n  }, {\n    key: \"handleDragStart\",\n    value: function handleDragStart() {\n      this.settings.needsUpdate = true;\n      this.settings.journey = timeCapsule.startJourney(this.clip);\n    }\n  }, {\n    key: \"handleDrag\",\n    value: function handleDrag(loopBarPositionX) {\n      var executeOnMillisecondChange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (!isFinite(loopBarPositionX)) {\n        loopBarPositionX = 0;\n      }\n\n      var duration = this.clip.duration;\n      var journey = this.settings.journey;\n      var _this$elements2 = this.elements,\n          loopBar = _this$elements2.loopBar,\n          totalBar = _this$elements2.totalBar,\n          runningBar = _this$elements2.runningBar,\n          currentTime = _this$elements2.currentTime;\n      var totalBarPositionX = loopBarPositionX + loopBar.offsetLeft;\n      var millisecond = Math.round(duration * totalBarPositionX / totalBar.offsetWidth);\n      currentTime.innerHTML = millisecond;\n      runningBar.style.width = loopBarPositionX / loopBar.offsetWidth * 100 + \"%\";\n      journey.station(millisecond);\n\n      if (this.options.onMillisecondChange && executeOnMillisecondChange) {\n        this.options.onMillisecondChange(millisecond);\n      }\n    }\n  }, {\n    key: \"handleDragEnd\",\n    value: function handleDragEnd() {\n      this.settings.journey.destination();\n    }\n  }, {\n    key: \"createProgressDrag\",\n    value: function createProgressDrag(loopBarPositionX) {\n      this.handleDragStart();\n      this.handleDrag(loopBarPositionX);\n      this.handleDragEnd();\n    }\n  }, {\n    key: \"addEventListeners\",\n    value: function addEventListeners() {\n      loopBarEndListener(this);\n      progressBarListener(this);\n      loopBarStartListener(this);\n      loopStartEndListener(this);\n      volumeListener(this);\n      statusBtnListener(this);\n      settingsListener(this);\n      speedListener(this);\n      loopBtnListener(this);\n      controlsListener(this);\n      fullscreenListener(this);\n      donkeyclipListener(this);\n      previewListener(this);\n      bodyListener(this);\n    }\n  }, {\n    key: \"launchIntoFullscreen\",\n    value: function launchIntoFullscreen(element) {\n      if (this.options.preview) {\n        this.setPreviewDimentions();\n      }\n\n      this.elements.mcPlayer.classList.toggle(\"full-screen\");\n\n      if (element.requestFullscreen) {\n        element.requestFullscreen();\n      } else if (element.mozRequestFullScreen) {\n        element.mozRequestFullScreen();\n      } else if (element.webkitRequestFullscreen) {\n        element.webkitRequestFullscreen();\n      } else if (element.msRequestFullscreen) {\n        element.msRequestFullscreen();\n      }\n    }\n  }, {\n    key: \"exitFullscreen\",\n    value: function exitFullscreen() {\n      if (this.options.preview) {\n        this.setPreviewDimentions();\n      }\n\n      this.elements.mcPlayer.classList.toggle(\"full-screen\");\n\n      if (document.exitFullscreen) {\n        document.exitFullscreen();\n      } else if (document.mozCancelFullScreen) {\n        document.mozCancelFullScreen();\n      } else if (document.webkitExitFullscreen) {\n        document.webkitExitFullscreen();\n      }\n    }\n  }, {\n    key: \"setTheme\",\n    value: function setTheme() {\n      // replace multiple spaces with one space\n      this.options.theme.replace(/\\s\\s+/g, \" \");\n      this.options.theme.trim();\n\n      if (!this.options.theme.includes(\"on-top\") && !this.options.theme.includes(\"position-default\")) {\n        this.options.theme += \" position-default\";\n      }\n\n      var theme = {};\n\n      for (var i in this.options.theme.split(\" \")) {\n        var confTheme = confThemes(this.options.theme.split(\" \")[i]);\n\n        for (var q in confTheme || {}) {\n          theme[q] = confTheme[q];\n        }\n      }\n\n      var css = confStyle(theme, this.name, this.options);\n      var style = elcreate(\"style\");\n      style.styleSheet ? style.styleSheet.cssText = css : style.appendChild(document.createTextNode(css)); // append player style to document\n\n      eltag(\"head\")[0].appendChild(style);\n    }\n  }, {\n    key: \"setSpeed\",\n    value: function setSpeed() {\n      var _this3 = this;\n\n      var currentSpeed;\n      this.clip.speed == 1 ? currentSpeed = \"Normal\" : currentSpeed = this.clip.speed;\n      this.elements.speedCurrent.innerHTML = currentSpeed;\n\n      var targetZone = function () {\n        for (var i = 0; i < _this3.options.speedValues.length - 1; i++) {\n          if (_this3.options.speedValues[i] <= _this3.clip.speed && _this3.options.speedValues[i + 1] > _this3.clip.speed) {\n            return i + Math.abs((_this3.clip.speed - _this3.options.speedValues[i]) / (_this3.options.speedValues[i] - _this3.options.speedValues[i + 1]));\n          }\n        }\n      }();\n\n      var step = 1 / (this.options.speedValues.length - 1);\n      var positionY = (targetZone * step - 1) * -1 * (this.options.speedValues.length - 1) * 16;\n      elid(\"\".concat(this.name, \"-speed-cursor\")).style.top = positionY + \"px\";\n    }\n  }, {\n    key: \"calculateSpeed\",\n    value: function calculateSpeed(step, arrayOfValues, currentPercentage) {\n      var botLimitIndex = Math.floor(currentPercentage / step);\n\n      if (botLimitIndex === arrayOfValues.length - 1) {\n        return arrayOfValues[botLimitIndex].toFixed(1);\n      }\n\n      var limitZonePercentage = currentPercentage / step % 1;\n      var limitZoneLength = Math.abs(arrayOfValues[botLimitIndex] - arrayOfValues[botLimitIndex + 1]);\n      var realZoneSpeed = limitZonePercentage * limitZoneLength;\n      var realSpeed = (realZoneSpeed + arrayOfValues[botLimitIndex]).toFixed(1);\n\n      if (realSpeed == 0) {\n        return \"0.0\";\n      }\n\n      return realSpeed;\n    }\n  }, {\n    key: \"createPreviewDisplay\",\n    value: function createPreviewDisplay() {\n      var definition = this.clip.exportState({\n        unprocessed: true\n      });\n      definition.props.host = elid(\"\".concat(this.name, \"-hover-display\"));\n      definition.props.isPreviewClip = true;\n      this.previewClip = MC.ClipFromDefinition(definition, this.clipClass);\n      var previewClip = this.previewClip.rootElement;\n      this.previewClip.ownContext.isPreviewClip = true;\n      previewClip.style.position = \"absolute\";\n      previewClip.style.zIndex = 1;\n      this.setPreviewDimentions();\n    }\n  }, {\n    key: \"setPreviewDimentions\",\n    value: function setPreviewDimentions() {\n      var clip = this.clip.rootElement;\n      var previewClip = this.previewClip.rootElement;\n      var clipWidth = clip.offsetWidth;\n      var clipHeight = clip.offsetHeight;\n      var previewRatio = 0.25;\n      var previewWidth = clipWidth * previewRatio; // max width is 300\n\n      if (previewWidth > parseFloat(elid(\"\".concat(this.name, \"-hover-display\")).style.maxWidth)) {\n        previewWidth = parseFloat(elid(\"\".concat(this.name, \"-hover-display\")).style.maxWidth);\n      }\n\n      elid(\"\".concat(this.name, \"-hover-display\")).style.width = previewWidth + \"px\";\n      var previewHeight = clipHeight / clipWidth * previewWidth;\n      elid(\"\".concat(this.name, \"-hover-display\")).style.height = previewHeight + \"px\";\n      var scaleY = previewHeight / clipHeight;\n      var scaleX = previewWidth / clipWidth;\n      previewClip.style.transform = \"scale(\".concat(scaleX, \",\").concat(scaleY, \")\");\n      previewClip.style.transformOrigin = \"center bottom\";\n      previewClip.style.boxSizing = \"border-box\"; // check if width of iframe is percentage\n\n      if (this.clip.props.containerParams.width.includes(\"%\")) {\n        if (previewWidth / previewRatio - 2 / previewRatio > parseFloat(elid(\"\".concat(this.name, \"-hover-display\")).style.maxWidth)) {\n          previewClip.style.width = \"298px\";\n        } else {\n          previewClip.style.width = previewWidth / previewRatio - 2 / previewRatio + \"px\";\n        }\n      }\n\n      if (this.clip.props.containerParams.height.includes(\"%\")) {\n        if (previewWidth / previewRatio - 2 / previewRatio > parseFloat(elid(\"\".concat(this.name, \"-hover-display\")).style.maxWidth)) {\n          previewClip.style.height = clipHeight / clipWidth * 300 - 2 + \"px\";\n        } else {\n          previewClip.style.height = previewHeight / previewRatio - 2 / previewRatio + \"px\";\n        }\n      }\n    }\n  }]);\n\n  return Player;\n}();\n\nmodule.exports = Player;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC1wbGF5ZXIvZGlzdC9QbGF5ZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC1wbGF5ZXIvZGlzdC9QbGF5ZXIuanM/OWNiMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgTUMgPSByZXF1aXJlKFwiQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleFwiKTtcblxudmFyIHRpbWVDYXBzdWxlID0gbmV3IE1DLlRpbWVDYXBzdWxlKCk7XG52YXIgbWNoID0gbmV3IE1DLkhlbHBlcigpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpLFxuICAgIGVsaWQgPSBfcmVxdWlyZS5lbGlkLFxuICAgIGVsdGFnID0gX3JlcXVpcmUuZWx0YWcsXG4gICAgZWxjcmVhdGUgPSBfcmVxdWlyZS5lbGNyZWF0ZTtcblxudmFyIHN2ZyA9IHJlcXVpcmUoXCIuL2h0bWwvc3ZnXCIpO1xuXG52YXIgY29uZmlnID0gcmVxdWlyZShcIi4vY29uZmlnXCIpO1xuXG52YXIgY29uZlN0eWxlID0gcmVxdWlyZShcIi4vaHRtbC9zdHlsZVwiKTtcblxudmFyIGNvbmZUaGVtZXMgPSByZXF1aXJlKFwiLi9odG1sL3RoZW1lc1wiKTtcblxudmFyIHNldEVsZW1lbnRzID0gcmVxdWlyZShcIi4vaHRtbC9zZXRFbGVtZW50c1wiKTtcblxudmFyIHZvbHVtZUxpc3RlbmVyID0gcmVxdWlyZShcIi4vbGlzdGVuZXJzL3ZvbHVtZVwiKTtcblxudmFyIGxvb3BCYXJTdGFydExpc3RlbmVyID0gcmVxdWlyZShcIi4vbGlzdGVuZXJzL2xvb3BCYXJTdGFydFwiKTtcblxudmFyIGxvb3BCYXJFbmRMaXN0ZW5lciA9IHJlcXVpcmUoXCIuL2xpc3RlbmVycy9sb29wQmFyRW5kXCIpO1xuXG52YXIgbG9vcFN0YXJ0RW5kTGlzdGVuZXIgPSByZXF1aXJlKFwiLi9saXN0ZW5lcnMvbG9vcFN0YXJ0RW5kXCIpO1xuXG52YXIgcHJvZ3Jlc3NCYXJMaXN0ZW5lciA9IHJlcXVpcmUoXCIuL2xpc3RlbmVycy9wcm9ncmVzc0JhclwiKTtcblxudmFyIHN0YXR1c0J0bkxpc3RlbmVyID0gcmVxdWlyZShcIi4vbGlzdGVuZXJzL3N0YXR1c0J0blwiKTtcblxudmFyIHNldHRpbmdzTGlzdGVuZXIgPSByZXF1aXJlKFwiLi9saXN0ZW5lcnMvc2V0dGluZ3NcIik7XG5cbnZhciBzcGVlZExpc3RlbmVyID0gcmVxdWlyZShcIi4vbGlzdGVuZXJzL3NwZWVkXCIpO1xuXG52YXIgbG9vcEJ0bkxpc3RlbmVyID0gcmVxdWlyZShcIi4vbGlzdGVuZXJzL2xvb3BCdG5cIik7XG5cbnZhciBjb250cm9sc0xpc3RlbmVyID0gcmVxdWlyZShcIi4vbGlzdGVuZXJzL2NvbnRyb2xzXCIpO1xuXG52YXIgZnVsbHNjcmVlbkxpc3RlbmVyID0gcmVxdWlyZShcIi4vbGlzdGVuZXJzL2Z1bGxzY3JlZW5cIik7XG5cbnZhciBkb25rZXljbGlwTGlzdGVuZXIgPSByZXF1aXJlKFwiLi9saXN0ZW5lcnMvZG9ua2V5Y2xpcFwiKTtcblxudmFyIHByZXZpZXdMaXN0ZW5lciA9IHJlcXVpcmUoXCIuL2xpc3RlbmVycy9wcmV2aWV3XCIpO1xuXG52YXIgYm9keUxpc3RlbmVyID0gcmVxdWlyZShcIi4vbGlzdGVuZXJzL2JvZHlcIik7XG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFRpbWVyJ3MgcHVycG9zZSBpcyB0byBwcm92aWRlIGFuIGludGVyZmFjZSB0aHJvdWdoIHdoaWNoIGFueSBUaW1lZEluY2lkZW50XG4gKiAoc3VjaCBhcyBhIFNjZW5lIG9yIGEgQ2xpcCkgY2FuIGJvdGggcHJpdmlkZSBpbmZvIHJlZ2FyZGluZyB0aGVpciB0aW1pbmdcbiAqIHN0YXRlIGJ1dCBhbHNvIHByb3ZpZGUgYW4gaW50ZXJmYWNlIGZvciBpbnRlcmFjdGluZy9hbHRlcmluZyB0aGUgdGltaW5nIG9mIGl0XG4gKi9cblxuXG52YXIgUGxheWVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGxheWVyKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBsYXllcik7XG5cbiAgICAvLyBzZXQgZGVmYXVsdHNcbiAgICBvcHRpb25zLmlkID0gb3B0aW9ucy5pZCB8fCBtY2guZ2V0QW5JZCgpO1xuICAgIG9wdGlvbnMucHJldmlldyA9IG9wdGlvbnMucHJldmlldyB8fCBmYWxzZTtcbiAgICBvcHRpb25zLnNob3dWb2x1bWUgPSBvcHRpb25zLnNob3dWb2x1bWUgfHwgZmFsc2U7XG4gICAgb3B0aW9ucy50aGVtZSA9IG9wdGlvbnMudGhlbWUgfHwgXCJ0cmFuc3BhcmVudCBvbi10b3BcIjtcbiAgICBvcHRpb25zLmhvc3QgPSBvcHRpb25zLmhvc3QgfHwgb3B0aW9ucy5jbGlwLnByb3BzLmhvc3Q7XG4gICAgb3B0aW9ucy5idXR0b25zID0gb3B0aW9ucy5idXR0b25zIHx8IHt9O1xuXG4gICAgaWYgKG9wdGlvbnMucG9pbnRlckV2ZW50cyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucG9pbnRlckV2ZW50cyA9PT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy5wb2ludGVyRXZlbnRzID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy5wb2ludGVyRXZlbnRzID0gQm9vbGVhbihvcHRpb25zLnBvaW50ZXJFdmVudHMpO1xuICAgIH1cblxuICAgIG9wdGlvbnMub25NaWxsaXNlY29uZENoYW5nZSA9IG9wdGlvbnMub25NaWxsaXNlY29uZENoYW5nZSB8fCBudWxsO1xuICAgIG9wdGlvbnMuc3BlZWRWYWx1ZXMgPSBvcHRpb25zLnNwZWVkVmFsdWVzIHx8IFstNCwgLTIsIC0xLCAtMC41LCAwLCAwLjUsIDEsIDIsIDRdOyAvLyByZW1vdmUgc3RyaW5nc1xuXG4gICAgZm9yICh2YXIgaSBpbiBvcHRpb25zLnNwZWVkVmFsdWVzKSB7XG4gICAgICBpZiAoIWlzRmluaXRlKG9wdGlvbnMuc3BlZWRWYWx1ZXNbaV0pKSB7XG4gICAgICAgIG9wdGlvbnMuc3BlZWRWYWx1ZXMuc3BsaWNlKGksIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG9wdGlvbnMuc3BlZWRWYWx1ZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEgLSBiO1xuICAgIH0pO1xuICAgIHRoaXMuY2xhc3NOYW1lID0gY29uZmlnLm5hbWU7XG4gICAgY29uZmlnLnBsYXllck5hbWUgPSBvcHRpb25zLmlkO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5pZCA9IHRoaXMub3B0aW9ucy5pZDtcbiAgICB0aGlzLm5hbWUgPSBjb25maWcubmFtZTtcbiAgICB0aGlzLnByZXZpZXdDbGlwID0gbnVsbDtcbiAgICB0aGlzLmNsaXAgPSBvcHRpb25zLmNsaXA7IC8vIGhvc3QgdG8gYXBwbHkgdGhlIHRpbWVyXG5cbiAgICB0aGlzLmNsaXBDbGFzcyA9IG9wdGlvbnMuY2xpcENsYXNzO1xuICAgIHRoaXMubGlzdGVuZXJzID0ge307XG4gICAgdGhpcy5zZXR0aW5ncyA9IHtcbiAgICAgIHZvbHVtZTogMSxcbiAgICAgIGpvdXJuZXk6IG51bGwsXG4gICAgICBwcmV2aW91c1ZvbHVtZTogMSxcbiAgICAgIHZvbHVtZU11dGU6IGZhbHNlLFxuICAgICAgbmVlZHNVcGRhdGU6IHRydWUsXG4gICAgICByZXNpemVMb29wOiBmYWxzZSxcbiAgICAgIGxvb3BKb3VybmV5OiBmYWxzZSxcbiAgICAgIHByZXZpZXdKb3VybmV5OiBudWxsLFxuICAgICAgbG9vcEFjdGl2YXRlZDogZmFsc2UsXG4gICAgICByZXF1ZXN0aW5nTG9vcDogZmFsc2UsXG4gICAgICBwbGF5QWZ0ZXJSZXNpemU6IGZhbHNlLFxuICAgICAgbG9vcFN0YXJ0TWlsbGlzZWNvbmQ6IDAsXG4gICAgICBsb29wTGFzdFBvc2l0aW9uWFB4bHM6IDAsXG4gICAgICBsb29wTGFzdFBvc2l0aW9uWFBlcmNlbnRhZ2U6IDAsXG4gICAgICBsb29wRW5kTWlsbGlzZWNvbmQ6IHRoaXMuY2xpcC5kdXJhdGlvblxuICAgIH07XG4gICAgdGhpcy5mdW5jdGlvbnMgPSB7XG4gICAgICBtaWxsaXNlY29uZENoYW5nZTogdGhpcy5taWxsaXNlY29uZENoYW5nZSxcbiAgICAgIGNyZWF0ZUpvdXJuZXk6IHRoaXMuY3JlYXRlSm91cm5leVxuICAgIH07IC8vIGNyZWF0ZSB0aGUgdGltZXIgY29udHJvbHMgbWFpbiBkaXZcblxuICAgIHNldEVsZW1lbnRzKHRoaXMpO1xuICAgIHRoaXMuc2V0VGhlbWUoKTtcbiAgICB0aGlzLnNldFNwZWVkKCk7XG4gICAgdGhpcy5zdWJzY3JpYmVUb1RpbWVyKCk7XG4gICAgdGhpcy5zdWJzY3JpYmVUb0V2ZW50cygpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMucHJldmlldykge1xuICAgICAgdGhpcy5jcmVhdGVQcmV2aWV3RGlzcGxheSgpO1xuICAgIH1cblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpcy5vcHRpb25zLnByZXZpZXcpIHtcbiAgICAgICAgX3RoaXMuc2V0UHJldmlld0RpbWVudGlvbnMoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQbGF5ZXIsIFt7XG4gICAga2V5OiBcImNyZWF0ZUpvdXJuZXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlSm91cm5leShjbGlwLCBtaWxsaXNlY29uZCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBjbGlwQ29tbWFuZHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZWYgPSBudWxsO1xuICAgICAgICB2YXIgX2NsaXBDb21tYW5kcyRiZWZvcmUgPSBjbGlwQ29tbWFuZHMuYmVmb3JlLFxuICAgICAgICAgICAgYmVmb3JlID0gX2NsaXBDb21tYW5kcyRiZWZvcmUgPT09IHZvaWQgMCA/IGRlZiA6IF9jbGlwQ29tbWFuZHMkYmVmb3JlLFxuICAgICAgICAgICAgX2NsaXBDb21tYW5kcyRhZnRlciA9IGNsaXBDb21tYW5kcy5hZnRlcixcbiAgICAgICAgICAgIGFmdGVyID0gX2NsaXBDb21tYW5kcyRhZnRlciA9PT0gdm9pZCAwID8gZGVmIDogX2NsaXBDb21tYW5kcyRhZnRlcjtcbiAgICAgICAgYmVmb3JlID8gY2xpcFtiZWZvcmVdKCkgOiBudWxsO1xuICAgICAgICBfdGhpczIuc2V0dGluZ3Muam91cm5leSA9IHRpbWVDYXBzdWxlLnN0YXJ0Sm91cm5leShjbGlwKTtcblxuICAgICAgICBfdGhpczIuc2V0dGluZ3Muam91cm5leS5zdGF0aW9uKG1pbGxpc2Vjb25kKTtcblxuICAgICAgICBfdGhpczIuc2V0dGluZ3Muam91cm5leS5kZXN0aW5hdGlvbigpO1xuXG4gICAgICAgIGFmdGVyID8gY2xpcFthZnRlcl0oKSA6IG51bGw7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWlsbGlzZWNvbmRDaGFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWlsbGlzZWNvbmRDaGFuZ2UobWlsbGlzZWNvbmQsIHRpbWVzdGFtcCwgcm91bmRUbywgbWFrZUpvdW5leSkge1xuICAgICAgdmFyIGV4ZWN1dGVPbk1pbGxpc2Vjb25kQ2hhbmdlID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB0cnVlO1xuXG4gICAgICBpZiAoIXRoaXMuc2V0dGluZ3MubmVlZHNVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5jbGlwLndhaXQoKTtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBjbGlwID0gdGhpcy5jbGlwO1xuICAgICAgdmFyIF90aGlzJHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncyxcbiAgICAgICAgICBsb29wQWN0aXZhdGVkID0gX3RoaXMkc2V0dGluZ3MubG9vcEFjdGl2YXRlZCxcbiAgICAgICAgICBsb29wRW5kTWlsbGlzZWNvbmQgPSBfdGhpcyRzZXR0aW5ncy5sb29wRW5kTWlsbGlzZWNvbmQsXG4gICAgICAgICAgbG9vcFN0YXJ0TWlsbGlzZWNvbmQgPSBfdGhpcyRzZXR0aW5ncy5sb29wU3RhcnRNaWxsaXNlY29uZDtcbiAgICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuY2xpcC5kdXJhdGlvbjtcbiAgICAgIHZhciBfdGhpcyRlbGVtZW50cyA9IHRoaXMuZWxlbWVudHMsXG4gICAgICAgICAgdG90YWxCYXIgPSBfdGhpcyRlbGVtZW50cy50b3RhbEJhcixcbiAgICAgICAgICBsb29wQmFyID0gX3RoaXMkZWxlbWVudHMubG9vcEJhcjtcbiAgICAgIHZhciBsb29wQmFyV2lkdGggPSBsb29wQmFyLm9mZnNldFdpZHRoO1xuICAgICAgdmFyIGxvb3BCYXJMZWZ0ID0gbG9vcEJhci5vZmZzZXRMZWZ0IC8gdG90YWxCYXIub2Zmc2V0V2lkdGg7XG4gICAgICB2YXIgbG9jYWxNaWxsaXNlY29uZCA9IG1pbGxpc2Vjb25kIC0gZHVyYXRpb24gKiBsb29wQmFyTGVmdDtcbiAgICAgIHZhciBsb2NhbER1cmF0aW9uID0gZHVyYXRpb24gLyB0b3RhbEJhci5vZmZzZXRXaWR0aCAqIGxvb3BCYXJXaWR0aDtcblxuICAgICAgaWYgKG1pbGxpc2Vjb25kID49IGxvb3BFbmRNaWxsaXNlY29uZCAmJiBsb29wQWN0aXZhdGVkKSB7XG4gICAgICAgIGlmIChjbGlwLnN0YXRlID09PSBcImlkbGVcIiB8fCBjbGlwLnN0YXRlID09PSBcImNvbXBsZXRlZFwiKSB7XG4gICAgICAgICAgdGhpcy5jcmVhdGVKb3VybmV5KGNsaXAsIGxvb3BTdGFydE1pbGxpc2Vjb25kICsgMSwge1xuICAgICAgICAgICAgYmVmb3JlOiBcInN0b3BcIixcbiAgICAgICAgICAgIGFmdGVyOiBcInBsYXlcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY3JlYXRlSm91cm5leShjbGlwLCBsb29wU3RhcnRNaWxsaXNlY29uZCArIDEsIHtcbiAgICAgICAgICAgIGFmdGVyOiBcInJlc3VtZVwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSBpZiAobWlsbGlzZWNvbmQgPD0gbG9vcFN0YXJ0TWlsbGlzZWNvbmQgJiYgbG9vcEFjdGl2YXRlZCkge1xuICAgICAgICBpZiAoY2xpcC5zdGF0ZSA9PT0gXCJpZGxlXCIgfHwgY2xpcC5zdGF0ZSA9PT0gXCJjb21wbGV0ZWRcIikge1xuICAgICAgICAgIHRoaXMuY3JlYXRlSm91cm5leShjbGlwLCBsb29wRW5kTWlsbGlzZWNvbmQgLSAxLCB7XG4gICAgICAgICAgICBiZWZvcmU6IFwic3RvcFwiLFxuICAgICAgICAgICAgYWZ0ZXI6IFwicGxheVwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jcmVhdGVKb3VybmV5KGNsaXAsIGxvb3BFbmRNaWxsaXNlY29uZCAtIDEsIHtcbiAgICAgICAgICAgIGFmdGVyOiBcInJlc3VtZVwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIC8qZWxzZSBpZiAobWlsbGlzZWNvbmQgPD0gbG9vcFN0YXJ0TWlsbGlzZWNvbmQpIHtcbiAgICAgIHRoaXMuY3JlYXRlSm91cm5leShjbGlwLCBsb29wU3RhcnRNaWxsaXNlY29uZCk7XG4gICAgICB9IGVsc2UgaWYgKG1pbGxpc2Vjb25kID49IGxvb3BFbmRNaWxsaXNlY29uZCkge1xuICAgICAgdGhpcy5jcmVhdGVKb3VybmV5KGNsaXAsIGxvb3BFbmRNaWxsaXNlY29uZCk7XG4gICAgICB9Ki9cblxuXG4gICAgICBpZiAobWFrZUpvdW5leSkge1xuICAgICAgICB0aGlzLmNyZWF0ZUpvdXJuZXkoY2xpcCwgbWlsbGlzZWNvbmQsIHtcbiAgICAgICAgICBhZnRlcjogdGhpcy5zZXR0aW5ncy5wbGF5QWZ0ZXJSZXNpemUgPyBcInJlc3VtZVwiIDogbnVsbFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbGVtZW50cy5ydW5uaW5nQmFyLnN0eWxlLndpZHRoID0gbG9jYWxNaWxsaXNlY29uZCAvIGxvY2FsRHVyYXRpb24gKiAxMDAgKyBcIiVcIjtcbiAgICAgIHRoaXMuZWxlbWVudHMuY3VycmVudFRpbWUuaW5uZXJIVE1MID0gbWlsbGlzZWNvbmQ7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub25NaWxsaXNlY29uZENoYW5nZSAmJiBleGVjdXRlT25NaWxsaXNlY29uZENoYW5nZSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25NaWxsaXNlY29uZENoYW5nZShtaWxsaXNlY29uZCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV2ZW50QnJvYWRjYXN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV2ZW50QnJvYWRjYXN0KGV2ZW50TmFtZSwgbWV0YSkge1xuICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gXCJzdGF0ZS1jaGFuZ2VcIikge1xuICAgICAgICBpZiAobWV0YS5uZXdTdGF0ZSA9PT0gXCJ3YWl0aW5nXCIpIHtcbiAgICAgICAgICB0aGlzLmVsZW1lbnRzLnN0YXR1c0J1dHRvbi5pbm5lckhUTUwgPSBzdmcucGxheVNWRztcbiAgICAgICAgICB0aGlzLmVsZW1lbnRzLnN0YXR1c0J1dHRvbi5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnRzLmluZGljYXRvcik7XG4gICAgICAgICAgdGhpcy5lbGVtZW50cy5pbmRpY2F0b3IuaW5uZXJIVE1MID0gXCJXYWl0aW5nXCI7XG4gICAgICAgIH0gZWxzZSBpZiAobWV0YS5uZXdTdGF0ZSA9PT0gXCJwbGF5aW5nXCIpIHtcbiAgICAgICAgICB0aGlzLmVsZW1lbnRzLnN0YXR1c0J1dHRvbi5pbm5lckhUTUwgPSBzdmcucGF1c2VTVkc7XG4gICAgICAgICAgdGhpcy5lbGVtZW50cy5zdGF0dXNCdXR0b24uYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50cy5pbmRpY2F0b3IpO1xuICAgICAgICAgIHRoaXMuZWxlbWVudHMuaW5kaWNhdG9yLmlubmVySFRNTCA9IFwiUGxheWluZ1wiO1xuICAgICAgICB9IGVsc2UgaWYgKG1ldGEubmV3U3RhdGUgPT09IFwiY29tcGxldGVkXCIpIHtcbiAgICAgICAgICB0aGlzLmVsZW1lbnRzLmN1cnJlbnRUaW1lLmlubmVySFRNTCA9IHRoaXMuY2xpcC5kdXJhdGlvbjtcbiAgICAgICAgICB0aGlzLmVsZW1lbnRzLnN0YXR1c0J1dHRvbi5pbm5lckhUTUwgPSBzdmcucmVwbGF5U1ZHO1xuICAgICAgICAgIHRoaXMuZWxlbWVudHMuc3RhdHVzQnV0dG9uLmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudHMuaW5kaWNhdG9yKTtcbiAgICAgICAgICB0aGlzLmVsZW1lbnRzLmluZGljYXRvci5pbm5lckhUTUwgPSBcIkNvbXBsZXRlZFwiO1xuICAgICAgICB9IGVsc2UgaWYgKG1ldGEubmV3U3RhdGUgPT09IFwidHJhbnNpdGlvbmFsXCIpIHtcbiAgICAgICAgICB0aGlzLmVsZW1lbnRzLnN0YXR1c0J1dHRvbi5pbm5lckhUTUwgPSBzdmcucGxheVNWRztcbiAgICAgICAgICB0aGlzLmVsZW1lbnRzLnN0YXR1c0J1dHRvbi5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnRzLmluZGljYXRvcik7XG4gICAgICAgICAgdGhpcy5lbGVtZW50cy5pbmRpY2F0b3IuaW5uZXJIVE1MID0gXCJUcmFuc2l0aW9uYWxcIjtcbiAgICAgICAgfSBlbHNlIGlmIChtZXRhLm5ld1N0YXRlID09PSBcImlkbGVcIikge1xuICAgICAgICAgIHRoaXMuZWxlbWVudHMuc3RhdHVzQnV0dG9uLmlubmVySFRNTCA9IHN2Zy5wbGF5U1ZHO1xuICAgICAgICAgIHRoaXMuZWxlbWVudHMuc3RhdHVzQnV0dG9uLmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudHMuaW5kaWNhdG9yKTtcbiAgICAgICAgICB0aGlzLmVsZW1lbnRzLmluZGljYXRvci5pbm5lckhUTUwgPSBcIklkbGVcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVsZW1lbnRzLmluZGljYXRvci5pbm5lckhUTUwgPSBtZXRhLm5ld1NUYXRlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50TmFtZSA9PT0gXCJhdHRyaWJ1dGUtcmVqZWN0aW9uXCIpIHtcbiAgICAgICAgbWNoLmxvZyhcIkF0dHJpYnV0ZXNcIiwgbWV0YS5hdHRyaWJ1dGVzLCBcImhhdmUgYmVlbiByZWplY3RlZCBmcm9tIGFuaW1hdGlvbiB3aXRoIGlkIFwiLmNvbmNhdChtZXRhLmFuaW1hdGlvbklEKSk7XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50TmFtZSA9PT0gXCJhbmltYXRpb24tcmVqZWN0aW9uXCIpIHtcbiAgICAgICAgbWNoLmxvZyhcIkFuaW1hdGlvbiBcIi5jb25jYXQobWV0YS5hbmltYXRpb25JRCwgXCIgaGFzIGJlZW4gcmVqZWN0ZWQgYXMgYWxsIGF0dHJpYnV0ZXMgb2YgXFxuICAgICAgICBpdCBvdmVybGFwIG9uIHNwZWNpZmljIGVsZW1lbnRzIGJlY2F1c2Ugb2YgZXhpc3RpbmcgYW5pbWF0aW9uc1wiKSk7XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50TmFtZSA9PT0gXCJkdXJhdGlvbi1jaGFuZ2VcIikge1xuICAgICAgICB0aGlzLmVsZW1lbnRzLnRvdGFsVGltZS5pbm5lckhUTUwgPSB0aGlzLmNsaXAuZHVyYXRpb247XG4gICAgICAgIHRoaXMuc2V0dGluZ3MubG9vcEVuZE1pbGxpc2Vjb25kID0gdGhpcy5jbGlwLmR1cmF0aW9uO1xuICAgICAgICB0aGlzLm1pbGxpc2Vjb25kQ2hhbmdlKHRoaXMuY2xpcC5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdWJzY3JpYmVUb0V2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdWJzY3JpYmVUb0V2ZW50cygpIHtcbiAgICAgIHRoaXMuY2xpcC5zdWJzY3JpYmVUb0V2ZW50cyh0aGlzLmlkLCB0aGlzLmV2ZW50QnJvYWRjYXN0LmJpbmQodGhpcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdWJzY3JpYmVUb1RpbWVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN1YnNjcmliZVRvVGltZXIoKSB7XG4gICAgICB0aGlzLmNsaXAuc3Vic2NyaWJlKHRoaXMuaWQsIHRoaXMubWlsbGlzZWNvbmRDaGFuZ2UuYmluZCh0aGlzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZURyYWdTdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVEcmFnU3RhcnQoKSB7XG4gICAgICB0aGlzLnNldHRpbmdzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2V0dGluZ3Muam91cm5leSA9IHRpbWVDYXBzdWxlLnN0YXJ0Sm91cm5leSh0aGlzLmNsaXApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVEcmFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZURyYWcobG9vcEJhclBvc2l0aW9uWCkge1xuICAgICAgdmFyIGV4ZWN1dGVPbk1pbGxpc2Vjb25kQ2hhbmdlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG4gICAgICBpZiAoIWlzRmluaXRlKGxvb3BCYXJQb3NpdGlvblgpKSB7XG4gICAgICAgIGxvb3BCYXJQb3NpdGlvblggPSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgZHVyYXRpb24gPSB0aGlzLmNsaXAuZHVyYXRpb247XG4gICAgICB2YXIgam91cm5leSA9IHRoaXMuc2V0dGluZ3Muam91cm5leTtcbiAgICAgIHZhciBfdGhpcyRlbGVtZW50czIgPSB0aGlzLmVsZW1lbnRzLFxuICAgICAgICAgIGxvb3BCYXIgPSBfdGhpcyRlbGVtZW50czIubG9vcEJhcixcbiAgICAgICAgICB0b3RhbEJhciA9IF90aGlzJGVsZW1lbnRzMi50b3RhbEJhcixcbiAgICAgICAgICBydW5uaW5nQmFyID0gX3RoaXMkZWxlbWVudHMyLnJ1bm5pbmdCYXIsXG4gICAgICAgICAgY3VycmVudFRpbWUgPSBfdGhpcyRlbGVtZW50czIuY3VycmVudFRpbWU7XG4gICAgICB2YXIgdG90YWxCYXJQb3NpdGlvblggPSBsb29wQmFyUG9zaXRpb25YICsgbG9vcEJhci5vZmZzZXRMZWZ0O1xuICAgICAgdmFyIG1pbGxpc2Vjb25kID0gTWF0aC5yb3VuZChkdXJhdGlvbiAqIHRvdGFsQmFyUG9zaXRpb25YIC8gdG90YWxCYXIub2Zmc2V0V2lkdGgpO1xuICAgICAgY3VycmVudFRpbWUuaW5uZXJIVE1MID0gbWlsbGlzZWNvbmQ7XG4gICAgICBydW5uaW5nQmFyLnN0eWxlLndpZHRoID0gbG9vcEJhclBvc2l0aW9uWCAvIGxvb3BCYXIub2Zmc2V0V2lkdGggKiAxMDAgKyBcIiVcIjtcbiAgICAgIGpvdXJuZXkuc3RhdGlvbihtaWxsaXNlY29uZCk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub25NaWxsaXNlY29uZENoYW5nZSAmJiBleGVjdXRlT25NaWxsaXNlY29uZENoYW5nZSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25NaWxsaXNlY29uZENoYW5nZShtaWxsaXNlY29uZCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZURyYWdFbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlRHJhZ0VuZCgpIHtcbiAgICAgIHRoaXMuc2V0dGluZ3Muam91cm5leS5kZXN0aW5hdGlvbigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVQcm9ncmVzc0RyYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlUHJvZ3Jlc3NEcmFnKGxvb3BCYXJQb3NpdGlvblgpIHtcbiAgICAgIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0KCk7XG4gICAgICB0aGlzLmhhbmRsZURyYWcobG9vcEJhclBvc2l0aW9uWCk7XG4gICAgICB0aGlzLmhhbmRsZURyYWdFbmQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkRXZlbnRMaXN0ZW5lcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICBsb29wQmFyRW5kTGlzdGVuZXIodGhpcyk7XG4gICAgICBwcm9ncmVzc0Jhckxpc3RlbmVyKHRoaXMpO1xuICAgICAgbG9vcEJhclN0YXJ0TGlzdGVuZXIodGhpcyk7XG4gICAgICBsb29wU3RhcnRFbmRMaXN0ZW5lcih0aGlzKTtcbiAgICAgIHZvbHVtZUxpc3RlbmVyKHRoaXMpO1xuICAgICAgc3RhdHVzQnRuTGlzdGVuZXIodGhpcyk7XG4gICAgICBzZXR0aW5nc0xpc3RlbmVyKHRoaXMpO1xuICAgICAgc3BlZWRMaXN0ZW5lcih0aGlzKTtcbiAgICAgIGxvb3BCdG5MaXN0ZW5lcih0aGlzKTtcbiAgICAgIGNvbnRyb2xzTGlzdGVuZXIodGhpcyk7XG4gICAgICBmdWxsc2NyZWVuTGlzdGVuZXIodGhpcyk7XG4gICAgICBkb25rZXljbGlwTGlzdGVuZXIodGhpcyk7XG4gICAgICBwcmV2aWV3TGlzdGVuZXIodGhpcyk7XG4gICAgICBib2R5TGlzdGVuZXIodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxhdW5jaEludG9GdWxsc2NyZWVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxhdW5jaEludG9GdWxsc2NyZWVuKGVsZW1lbnQpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucHJldmlldykge1xuICAgICAgICB0aGlzLnNldFByZXZpZXdEaW1lbnRpb25zKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWxlbWVudHMubWNQbGF5ZXIuY2xhc3NMaXN0LnRvZ2dsZShcImZ1bGwtc2NyZWVuXCIpO1xuXG4gICAgICBpZiAoZWxlbWVudC5yZXF1ZXN0RnVsbHNjcmVlbikge1xuICAgICAgICBlbGVtZW50LnJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnQubW96UmVxdWVzdEZ1bGxTY3JlZW4pIHtcbiAgICAgICAgZWxlbWVudC5tb3pSZXF1ZXN0RnVsbFNjcmVlbigpO1xuICAgICAgfSBlbHNlIGlmIChlbGVtZW50LndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgICAgIGVsZW1lbnQud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5tc1JlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgICAgIGVsZW1lbnQubXNSZXF1ZXN0RnVsbHNjcmVlbigpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJleGl0RnVsbHNjcmVlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleGl0RnVsbHNjcmVlbigpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucHJldmlldykge1xuICAgICAgICB0aGlzLnNldFByZXZpZXdEaW1lbnRpb25zKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWxlbWVudHMubWNQbGF5ZXIuY2xhc3NMaXN0LnRvZ2dsZShcImZ1bGwtc2NyZWVuXCIpO1xuXG4gICAgICBpZiAoZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4oKTtcbiAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQubW96Q2FuY2VsRnVsbFNjcmVlbikge1xuICAgICAgICBkb2N1bWVudC5tb3pDYW5jZWxGdWxsU2NyZWVuKCk7XG4gICAgICB9IGVsc2UgaWYgKGRvY3VtZW50LndlYmtpdEV4aXRGdWxsc2NyZWVuKSB7XG4gICAgICAgIGRvY3VtZW50LndlYmtpdEV4aXRGdWxsc2NyZWVuKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFRoZW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFRoZW1lKCkge1xuICAgICAgLy8gcmVwbGFjZSBtdWx0aXBsZSBzcGFjZXMgd2l0aCBvbmUgc3BhY2VcbiAgICAgIHRoaXMub3B0aW9ucy50aGVtZS5yZXBsYWNlKC9cXHNcXHMrL2csIFwiIFwiKTtcbiAgICAgIHRoaXMub3B0aW9ucy50aGVtZS50cmltKCk7XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnRoZW1lLmluY2x1ZGVzKFwib24tdG9wXCIpICYmICF0aGlzLm9wdGlvbnMudGhlbWUuaW5jbHVkZXMoXCJwb3NpdGlvbi1kZWZhdWx0XCIpKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy50aGVtZSArPSBcIiBwb3NpdGlvbi1kZWZhdWx0XCI7XG4gICAgICB9XG5cbiAgICAgIHZhciB0aGVtZSA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpIGluIHRoaXMub3B0aW9ucy50aGVtZS5zcGxpdChcIiBcIikpIHtcbiAgICAgICAgdmFyIGNvbmZUaGVtZSA9IGNvbmZUaGVtZXModGhpcy5vcHRpb25zLnRoZW1lLnNwbGl0KFwiIFwiKVtpXSk7XG5cbiAgICAgICAgZm9yICh2YXIgcSBpbiBjb25mVGhlbWUgfHwge30pIHtcbiAgICAgICAgICB0aGVtZVtxXSA9IGNvbmZUaGVtZVtxXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY3NzID0gY29uZlN0eWxlKHRoZW1lLCB0aGlzLm5hbWUsIHRoaXMub3B0aW9ucyk7XG4gICAgICB2YXIgc3R5bGUgPSBlbGNyZWF0ZShcInN0eWxlXCIpO1xuICAgICAgc3R5bGUuc3R5bGVTaGVldCA/IHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcyA6IHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpOyAvLyBhcHBlbmQgcGxheWVyIHN0eWxlIHRvIGRvY3VtZW50XG5cbiAgICAgIGVsdGFnKFwiaGVhZFwiKVswXS5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFNwZWVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNwZWVkKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBjdXJyZW50U3BlZWQ7XG4gICAgICB0aGlzLmNsaXAuc3BlZWQgPT0gMSA/IGN1cnJlbnRTcGVlZCA9IFwiTm9ybWFsXCIgOiBjdXJyZW50U3BlZWQgPSB0aGlzLmNsaXAuc3BlZWQ7XG4gICAgICB0aGlzLmVsZW1lbnRzLnNwZWVkQ3VycmVudC5pbm5lckhUTUwgPSBjdXJyZW50U3BlZWQ7XG5cbiAgICAgIHZhciB0YXJnZXRab25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzMy5vcHRpb25zLnNwZWVkVmFsdWVzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgIGlmIChfdGhpczMub3B0aW9ucy5zcGVlZFZhbHVlc1tpXSA8PSBfdGhpczMuY2xpcC5zcGVlZCAmJiBfdGhpczMub3B0aW9ucy5zcGVlZFZhbHVlc1tpICsgMV0gPiBfdGhpczMuY2xpcC5zcGVlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGkgKyBNYXRoLmFicygoX3RoaXMzLmNsaXAuc3BlZWQgLSBfdGhpczMub3B0aW9ucy5zcGVlZFZhbHVlc1tpXSkgLyAoX3RoaXMzLm9wdGlvbnMuc3BlZWRWYWx1ZXNbaV0gLSBfdGhpczMub3B0aW9ucy5zcGVlZFZhbHVlc1tpICsgMV0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0oKTtcblxuICAgICAgdmFyIHN0ZXAgPSAxIC8gKHRoaXMub3B0aW9ucy5zcGVlZFZhbHVlcy5sZW5ndGggLSAxKTtcbiAgICAgIHZhciBwb3NpdGlvblkgPSAodGFyZ2V0Wm9uZSAqIHN0ZXAgLSAxKSAqIC0xICogKHRoaXMub3B0aW9ucy5zcGVlZFZhbHVlcy5sZW5ndGggLSAxKSAqIDE2O1xuICAgICAgZWxpZChcIlwiLmNvbmNhdCh0aGlzLm5hbWUsIFwiLXNwZWVkLWN1cnNvclwiKSkuc3R5bGUudG9wID0gcG9zaXRpb25ZICsgXCJweFwiO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYWxjdWxhdGVTcGVlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVTcGVlZChzdGVwLCBhcnJheU9mVmFsdWVzLCBjdXJyZW50UGVyY2VudGFnZSkge1xuICAgICAgdmFyIGJvdExpbWl0SW5kZXggPSBNYXRoLmZsb29yKGN1cnJlbnRQZXJjZW50YWdlIC8gc3RlcCk7XG5cbiAgICAgIGlmIChib3RMaW1pdEluZGV4ID09PSBhcnJheU9mVmFsdWVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5T2ZWYWx1ZXNbYm90TGltaXRJbmRleF0udG9GaXhlZCgxKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxpbWl0Wm9uZVBlcmNlbnRhZ2UgPSBjdXJyZW50UGVyY2VudGFnZSAvIHN0ZXAgJSAxO1xuICAgICAgdmFyIGxpbWl0Wm9uZUxlbmd0aCA9IE1hdGguYWJzKGFycmF5T2ZWYWx1ZXNbYm90TGltaXRJbmRleF0gLSBhcnJheU9mVmFsdWVzW2JvdExpbWl0SW5kZXggKyAxXSk7XG4gICAgICB2YXIgcmVhbFpvbmVTcGVlZCA9IGxpbWl0Wm9uZVBlcmNlbnRhZ2UgKiBsaW1pdFpvbmVMZW5ndGg7XG4gICAgICB2YXIgcmVhbFNwZWVkID0gKHJlYWxab25lU3BlZWQgKyBhcnJheU9mVmFsdWVzW2JvdExpbWl0SW5kZXhdKS50b0ZpeGVkKDEpO1xuXG4gICAgICBpZiAocmVhbFNwZWVkID09IDApIHtcbiAgICAgICAgcmV0dXJuIFwiMC4wXCI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZWFsU3BlZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVByZXZpZXdEaXNwbGF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVByZXZpZXdEaXNwbGF5KCkge1xuICAgICAgdmFyIGRlZmluaXRpb24gPSB0aGlzLmNsaXAuZXhwb3J0U3RhdGUoe1xuICAgICAgICB1bnByb2Nlc3NlZDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBkZWZpbml0aW9uLnByb3BzLmhvc3QgPSBlbGlkKFwiXCIuY29uY2F0KHRoaXMubmFtZSwgXCItaG92ZXItZGlzcGxheVwiKSk7XG4gICAgICBkZWZpbml0aW9uLnByb3BzLmlzUHJldmlld0NsaXAgPSB0cnVlO1xuICAgICAgdGhpcy5wcmV2aWV3Q2xpcCA9IE1DLkNsaXBGcm9tRGVmaW5pdGlvbihkZWZpbml0aW9uLCB0aGlzLmNsaXBDbGFzcyk7XG4gICAgICB2YXIgcHJldmlld0NsaXAgPSB0aGlzLnByZXZpZXdDbGlwLnJvb3RFbGVtZW50O1xuICAgICAgdGhpcy5wcmV2aWV3Q2xpcC5vd25Db250ZXh0LmlzUHJldmlld0NsaXAgPSB0cnVlO1xuICAgICAgcHJldmlld0NsaXAuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICBwcmV2aWV3Q2xpcC5zdHlsZS56SW5kZXggPSAxO1xuICAgICAgdGhpcy5zZXRQcmV2aWV3RGltZW50aW9ucygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRQcmV2aWV3RGltZW50aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQcmV2aWV3RGltZW50aW9ucygpIHtcbiAgICAgIHZhciBjbGlwID0gdGhpcy5jbGlwLnJvb3RFbGVtZW50O1xuICAgICAgdmFyIHByZXZpZXdDbGlwID0gdGhpcy5wcmV2aWV3Q2xpcC5yb290RWxlbWVudDtcbiAgICAgIHZhciBjbGlwV2lkdGggPSBjbGlwLm9mZnNldFdpZHRoO1xuICAgICAgdmFyIGNsaXBIZWlnaHQgPSBjbGlwLm9mZnNldEhlaWdodDtcbiAgICAgIHZhciBwcmV2aWV3UmF0aW8gPSAwLjI1O1xuICAgICAgdmFyIHByZXZpZXdXaWR0aCA9IGNsaXBXaWR0aCAqIHByZXZpZXdSYXRpbzsgLy8gbWF4IHdpZHRoIGlzIDMwMFxuXG4gICAgICBpZiAocHJldmlld1dpZHRoID4gcGFyc2VGbG9hdChlbGlkKFwiXCIuY29uY2F0KHRoaXMubmFtZSwgXCItaG92ZXItZGlzcGxheVwiKSkuc3R5bGUubWF4V2lkdGgpKSB7XG4gICAgICAgIHByZXZpZXdXaWR0aCA9IHBhcnNlRmxvYXQoZWxpZChcIlwiLmNvbmNhdCh0aGlzLm5hbWUsIFwiLWhvdmVyLWRpc3BsYXlcIikpLnN0eWxlLm1heFdpZHRoKTtcbiAgICAgIH1cblxuICAgICAgZWxpZChcIlwiLmNvbmNhdCh0aGlzLm5hbWUsIFwiLWhvdmVyLWRpc3BsYXlcIikpLnN0eWxlLndpZHRoID0gcHJldmlld1dpZHRoICsgXCJweFwiO1xuICAgICAgdmFyIHByZXZpZXdIZWlnaHQgPSBjbGlwSGVpZ2h0IC8gY2xpcFdpZHRoICogcHJldmlld1dpZHRoO1xuICAgICAgZWxpZChcIlwiLmNvbmNhdCh0aGlzLm5hbWUsIFwiLWhvdmVyLWRpc3BsYXlcIikpLnN0eWxlLmhlaWdodCA9IHByZXZpZXdIZWlnaHQgKyBcInB4XCI7XG4gICAgICB2YXIgc2NhbGVZID0gcHJldmlld0hlaWdodCAvIGNsaXBIZWlnaHQ7XG4gICAgICB2YXIgc2NhbGVYID0gcHJldmlld1dpZHRoIC8gY2xpcFdpZHRoO1xuICAgICAgcHJldmlld0NsaXAuc3R5bGUudHJhbnNmb3JtID0gXCJzY2FsZShcIi5jb25jYXQoc2NhbGVYLCBcIixcIikuY29uY2F0KHNjYWxlWSwgXCIpXCIpO1xuICAgICAgcHJldmlld0NsaXAuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gXCJjZW50ZXIgYm90dG9tXCI7XG4gICAgICBwcmV2aWV3Q2xpcC5zdHlsZS5ib3hTaXppbmcgPSBcImJvcmRlci1ib3hcIjsgLy8gY2hlY2sgaWYgd2lkdGggb2YgaWZyYW1lIGlzIHBlcmNlbnRhZ2VcblxuICAgICAgaWYgKHRoaXMuY2xpcC5wcm9wcy5jb250YWluZXJQYXJhbXMud2lkdGguaW5jbHVkZXMoXCIlXCIpKSB7XG4gICAgICAgIGlmIChwcmV2aWV3V2lkdGggLyBwcmV2aWV3UmF0aW8gLSAyIC8gcHJldmlld1JhdGlvID4gcGFyc2VGbG9hdChlbGlkKFwiXCIuY29uY2F0KHRoaXMubmFtZSwgXCItaG92ZXItZGlzcGxheVwiKSkuc3R5bGUubWF4V2lkdGgpKSB7XG4gICAgICAgICAgcHJldmlld0NsaXAuc3R5bGUud2lkdGggPSBcIjI5OHB4XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlld0NsaXAuc3R5bGUud2lkdGggPSBwcmV2aWV3V2lkdGggLyBwcmV2aWV3UmF0aW8gLSAyIC8gcHJldmlld1JhdGlvICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNsaXAucHJvcHMuY29udGFpbmVyUGFyYW1zLmhlaWdodC5pbmNsdWRlcyhcIiVcIikpIHtcbiAgICAgICAgaWYgKHByZXZpZXdXaWR0aCAvIHByZXZpZXdSYXRpbyAtIDIgLyBwcmV2aWV3UmF0aW8gPiBwYXJzZUZsb2F0KGVsaWQoXCJcIi5jb25jYXQodGhpcy5uYW1lLCBcIi1ob3Zlci1kaXNwbGF5XCIpKS5zdHlsZS5tYXhXaWR0aCkpIHtcbiAgICAgICAgICBwcmV2aWV3Q2xpcC5zdHlsZS5oZWlnaHQgPSBjbGlwSGVpZ2h0IC8gY2xpcFdpZHRoICogMzAwIC0gMiArIFwicHhcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aWV3Q2xpcC5zdHlsZS5oZWlnaHQgPSBwcmV2aWV3SGVpZ2h0IC8gcHJldmlld1JhdGlvIC0gMiAvIHByZXZpZXdSYXRpbyArIFwicHhcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQbGF5ZXI7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gUGxheWVyOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex-player/dist/Player.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex-player/dist/config.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex-player/dist/config.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = {\n  // the players start name\n  name: \"mc-player\",\n\n  // set the players total name\n  set playerName(name) {\n    this.name += \"-\" + name;\n  }\n\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC1wbGF5ZXIvZGlzdC9jb25maWcuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC1wbGF5ZXIvZGlzdC9jb25maWcuanM/NmJiNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIHRoZSBwbGF5ZXJzIHN0YXJ0IG5hbWVcbiAgbmFtZTogXCJtYy1wbGF5ZXJcIixcblxuICAvLyBzZXQgdGhlIHBsYXllcnMgdG90YWwgbmFtZVxuICBzZXQgcGxheWVyTmFtZShuYW1lKSB7XG4gICAgdGhpcy5uYW1lICs9IFwiLVwiICsgbmFtZTtcbiAgfVxuXG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex-player/dist/config.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex-player/dist/helpers.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex-player/dist/helpers.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = {\n  el: function el(selector) {\n    return document.querySelectorAll(selector);\n  },\n  elid: function elid(id) {\n    return document.getElementById(id);\n  },\n  eltag: function eltag(tag) {\n    return document.getElementsByTagName(tag);\n  },\n  elcreate: function elcreate(tag) {\n    return document.createElement(tag);\n  },\n  addListener: function addListener() {\n    var _document;\n\n    return (_document = document).addEventListener.apply(_document, arguments);\n  },\n  removeListener: function removeListener() {\n    var _document2;\n\n    return (_document2 = document).removeEventListener.apply(_document2, arguments);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC1wbGF5ZXIvZGlzdC9oZWxwZXJzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyL2Rpc3QvaGVscGVycy5qcz83OTUyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZWw6IGZ1bmN0aW9uIGVsKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICB9LFxuICBlbGlkOiBmdW5jdGlvbiBlbGlkKGlkKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgfSxcbiAgZWx0YWc6IGZ1bmN0aW9uIGVsdGFnKHRhZykge1xuICAgIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWcpO1xuICB9LFxuICBlbGNyZWF0ZTogZnVuY3Rpb24gZWxjcmVhdGUodGFnKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgfSxcbiAgYWRkTGlzdGVuZXI6IGZ1bmN0aW9uIGFkZExpc3RlbmVyKCkge1xuICAgIHZhciBfZG9jdW1lbnQ7XG5cbiAgICByZXR1cm4gKF9kb2N1bWVudCA9IGRvY3VtZW50KS5hZGRFdmVudExpc3RlbmVyLmFwcGx5KF9kb2N1bWVudCwgYXJndW1lbnRzKTtcbiAgfSxcbiAgcmVtb3ZlTGlzdGVuZXI6IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKCkge1xuICAgIHZhciBfZG9jdW1lbnQyO1xuXG4gICAgcmV0dXJuIChfZG9jdW1lbnQyID0gZG9jdW1lbnQpLnJlbW92ZUV2ZW50TGlzdGVuZXIuYXBwbHkoX2RvY3VtZW50MiwgYXJndW1lbnRzKTtcbiAgfVxufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex-player/dist/helpers.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex-player/dist/html/playerHTML.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex-player/dist/html/playerHTML.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function (config) {\n  return \"\\n  <div\\n    class=\\\"pointer-event-panel\\\"\\n    id=\\\"\".concat(config.name, \"-pointer-event-panel\\\"\\n  ></div>\\n  <div\\n    class=\\\"pointer-event-panel\\\"\\n    id=\\\"\").concat(config.name, \"-listener-helper\\\"\\n  ></div>\\n  <div class=\\\"grad\\\"></div>\\n  <div class=\\\"background\\\"></div>\\n  <div id=\\\"\").concat(config.name, \"-controls\\\">\\n    <div id=\\\"\").concat(config.name, \"-totalbar\\\">\\n      <div id=\\\"\").concat(config.name, \"-hover-display\\\">\\n        <div id=\\\"\").concat(config.name, \"-hover-millisecond\\\"></div>\\n      </div>\\n      <div id=\\\"\").concat(config.name, \"-loopbar\\\">\\n        <div\\n          class=\\\"\").concat(config.name, \"-loop-boundaries\\\"\\n          id=\\\"\").concat(config.name, \"-loopbar-start\\\"\\n        ></div>\\n        <div\\n          class=\\\"\").concat(config.name, \"-loop-boundaries\\\"\\n          id=\\\"\").concat(config.name, \"-loopbar-end\\\"\\n        ></div>\\n        <div id=\\\"\").concat(config.name, \"-helperbar\\\"></div>\\n        <div id=\\\"\").concat(config.name, \"-runningbar\\\">\\n          <div id=\\\"\").concat(config.name, \"-cursor\\\"></div>\\n        </div>\\n      </div>\\n    </div>\\n    <div id=\\\"\").concat(config.name, \"-left-controls\\\">\\n      <div id=\\\"\").concat(config.name, \"-status-btn\\\">\\n        \").concat(config.svg.playSVG, \"\\n        <span id=\\\"\").concat(config.name, \"-indicator\\\"></span>\\n      </div>\\n      <div id=\\\"\").concat(config.name, \"-volume\\\">\\n        <div id=\\\"\").concat(config.name, \"-volume-btn\\\">\\n          \").concat(config.svg.volumeSVG, \"\\n        </div>\\n        <div id=\\\"\").concat(config.name, \"-volumebar-helper\\\"></div>\\n        <div id=\\\"\").concat(config.name, \"-volumebar\\\">\\n            <div id=\\\"\").concat(config.name, \"-volumebar-active\\\">\\n              <div id=\\\"\").concat(config.name, \"-volume-cursor\\\"></div>\\n            </div>\\n        </div>\\n      </div>\\n      <div id=\\\"\").concat(config.name, \"-time-display\\\">\\n        <span id=\\\"\").concat(config.name, \"-time-current\\\"></span>\\n        <span id=\\\"\").concat(config.name, \"-time-separator\\\"></span>\\n        <span id=\\\"\").concat(config.name, \"-time-total\\\"></span>\\n      </div>\\n    </div>\\n    <div\\n      id=\\\"\").concat(config.name, \"-full-screen-btn\\\"\\n      class=\\\"\").concat(config.name, \"-mc-right-controls\\\"\\n    >\").concat(config.svg.fullScreenSVG, \"</div>\\n    <div\\n      id=\\\"\").concat(config.name, \"-settings-btn\\\"\\n      class=\\\"\").concat(config.name, \"-mc-right-controls\\\"\\n    >\").concat(config.svg.settingsSVG, \"</div>\\n    <div\\n      id=\\\"\").concat(config.name, \"-dc-btn\\\"\\n      class=\\\"\").concat(config.name, \"-mc-right-controls\\\"\\n    >\\n      \").concat(config.svg.dcSVG, \"\\n    </div>\\n    <div\\n      id=\\\"\").concat(config.name, \"-loop-btn-container\\\"\\n      class=\\\"\").concat(config.name, \"-mc-right-controls\\\"\\n    >\\n      <div\\n        id=\\\"\").concat(config.name, \"-loop-btn\\\"\\n        class=\\\"\").concat(config.name, \"-mc-right-controls\\\"\\n      >\").concat(config.svg.loopSVG, \"</div>\\n      <div\\n        id=\\\"\").concat(config.name, \"-loop-time\\\"\\n        class=\\\"\").concat(config.name, \"-mc-right-controls\\\"\\n      >\\n        <span\\n          id=\\\"\").concat(config.name, \"-loopbar-start-time\\\"\\n          class=\\\"\").concat(config.name, \"-loopbar-time\\\"\\n        ></span>\\n        <span>:</span>\\n        <span\\n          id=\\\"\").concat(config.name, \"-loopbar-end-time\\\"\\n          class=\\\"\").concat(config.name, \"-loopbar-time\\\"\\n        ></span>\\n      </div>\\n    </div>\\n\\n  </div>\\n  <div id=\\\"\").concat(config.name, \"-settings-panel\\\">\\n    <ul id=\\\"\").concat(config.name, \"-main-settings\\\">\\n      <li id=\\\"\").concat(config.name, \"-settings-pointer-events\\\">\\n        <label>Pointer Events</label>\\n        <label class=\\\"switch settings-switch\\\">\\n          <input id=\\\"\").concat(config.name, \"-pointer-events-checkbox\\\" type=\\\"checkbox\\\">\\n          <span class=\\\"slider round\\\"></span>\\n        </label>\\n      </li>\\n      <li id=\\\"\").concat(config.name, \"-settings-preview\\\">\\n        <label>Show Preview</label>\\n        <label class=\\\"switch settings-switch\\\">\\n          <input id=\\\"\").concat(config.name, \"-show-preview-checkbox\\\" type=\\\"checkbox\\\">\\n          <span class=\\\"slider round\\\"></span>\\n        </label>\\n      </li>\\n      <li id=\\\"\").concat(config.name, \"-settings-indicator\\\">\\n        <label>Show Indicator</label>\\n        <label class=\\\"switch settings-switch\\\">\\n          <input id=\\\"\").concat(config.name, \"-show-indicator-checkbox\\\" type=\\\"checkbox\\\">\\n          <span class=\\\"slider round\\\"></span>\\n        </label>\\n      </li>\\n      <li id=\\\"\").concat(config.name, \"-settings-volume\\\">\\n        <label>Show Volume</label>\\n        <label class=\\\"switch settings-switch\\\">\\n          <input id=\\\"\").concat(config.name, \"-show-volume-checkbox\\\" type=\\\"checkbox\\\">\\n          <span class=\\\"slider round\\\"></span>\\n        </label>\\n      </li>\\n      <li id=\\\"\").concat(config.name, \"-settings-speed-show\\\">\\n        <label>Speed</label>\\n        <div class=\\\"\").concat(config.name, \"-speed-btn\\\">\").concat(config.svg.arrowRightSVG, \"</div>\\n        <span id=\\\"\").concat(config.name, \"-speed-current\\\"></span>\\n      </li>\\n    </ul>\\n    <ul id=\\\"\").concat(config.name, \"-speed-settings\\\">\\n      <li id=\\\"\").concat(config.name, \"-settings-speed-hide\\\">\\n        <div class=\\\"\").concat(config.name, \"-speed-btn\\\">\").concat(config.svg.arrowLeftSVG, \"</div>\\n        <label id=\").concat(config.name, \"-speed-runtime>Speed</label>\\n      </li>\\n      <li>\\n        <div id=\\\"\").concat(config.name, \"-speed-value-helperbar\\\"></div>\\n        <div id=\\\"\").concat(config.name, \"-speed-value-bar\\\">\\n          <div\\n            class=\\\"\").concat(config.name, \"-speed-value-step\\\"\\n            id=\\\"\").concat(config.name, \"-speed-cursor\\\"\\n          >\\n            <div></div>\\n          </div>\\n        </div>\\n        <div id=\\\"\").concat(config.name, \"-speed-value\\\">\\n        </div>\\n      </li>\\n    </ul>\\n  </div>\\n\");\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC1wbGF5ZXIvZGlzdC9odG1sL3BsYXllckhUTUwuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC1wbGF5ZXIvZGlzdC9odG1sL3BsYXllckhUTUwuanM/ZmIzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHJldHVybiBcIlxcbiAgPGRpdlxcbiAgICBjbGFzcz1cXFwicG9pbnRlci1ldmVudC1wYW5lbFxcXCJcXG4gICAgaWQ9XFxcIlwiLmNvbmNhdChjb25maWcubmFtZSwgXCItcG9pbnRlci1ldmVudC1wYW5lbFxcXCJcXG4gID48L2Rpdj5cXG4gIDxkaXZcXG4gICAgY2xhc3M9XFxcInBvaW50ZXItZXZlbnQtcGFuZWxcXFwiXFxuICAgIGlkPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi1saXN0ZW5lci1oZWxwZXJcXFwiXFxuICA+PC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJncmFkXFxcIj48L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcImJhY2tncm91bmRcXFwiPjwvZGl2PlxcbiAgPGRpdiBpZD1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItY29udHJvbHNcXFwiPlxcbiAgICA8ZGl2IGlkPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi10b3RhbGJhclxcXCI+XFxuICAgICAgPGRpdiBpZD1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItaG92ZXItZGlzcGxheVxcXCI+XFxuICAgICAgICA8ZGl2IGlkPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi1ob3Zlci1taWxsaXNlY29uZFxcXCI+PC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBpZD1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItbG9vcGJhclxcXCI+XFxuICAgICAgICA8ZGl2XFxuICAgICAgICAgIGNsYXNzPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi1sb29wLWJvdW5kYXJpZXNcXFwiXFxuICAgICAgICAgIGlkPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi1sb29wYmFyLXN0YXJ0XFxcIlxcbiAgICAgICAgPjwvZGl2PlxcbiAgICAgICAgPGRpdlxcbiAgICAgICAgICBjbGFzcz1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItbG9vcC1ib3VuZGFyaWVzXFxcIlxcbiAgICAgICAgICBpZD1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItbG9vcGJhci1lbmRcXFwiXFxuICAgICAgICA+PC9kaXY+XFxuICAgICAgICA8ZGl2IGlkPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi1oZWxwZXJiYXJcXFwiPjwvZGl2PlxcbiAgICAgICAgPGRpdiBpZD1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItcnVubmluZ2JhclxcXCI+XFxuICAgICAgICAgIDxkaXYgaWQ9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLWN1cnNvclxcXCI+PC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgaWQ9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLWxlZnQtY29udHJvbHNcXFwiPlxcbiAgICAgIDxkaXYgaWQ9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLXN0YXR1cy1idG5cXFwiPlxcbiAgICAgICAgXCIpLmNvbmNhdChjb25maWcuc3ZnLnBsYXlTVkcsIFwiXFxuICAgICAgICA8c3BhbiBpZD1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItaW5kaWNhdG9yXFxcIj48L3NwYW4+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBpZD1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItdm9sdW1lXFxcIj5cXG4gICAgICAgIDxkaXYgaWQ9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLXZvbHVtZS1idG5cXFwiPlxcbiAgICAgICAgICBcIikuY29uY2F0KGNvbmZpZy5zdmcudm9sdW1lU1ZHLCBcIlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2IGlkPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi12b2x1bWViYXItaGVscGVyXFxcIj48L2Rpdj5cXG4gICAgICAgIDxkaXYgaWQ9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLXZvbHVtZWJhclxcXCI+XFxuICAgICAgICAgICAgPGRpdiBpZD1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItdm9sdW1lYmFyLWFjdGl2ZVxcXCI+XFxuICAgICAgICAgICAgICA8ZGl2IGlkPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi12b2x1bWUtY3Vyc29yXFxcIj48L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgaWQ9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLXRpbWUtZGlzcGxheVxcXCI+XFxuICAgICAgICA8c3BhbiBpZD1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItdGltZS1jdXJyZW50XFxcIj48L3NwYW4+XFxuICAgICAgICA8c3BhbiBpZD1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItdGltZS1zZXBhcmF0b3JcXFwiPjwvc3Bhbj5cXG4gICAgICAgIDxzcGFuIGlkPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi10aW1lLXRvdGFsXFxcIj48L3NwYW4+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2XFxuICAgICAgaWQ9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLWZ1bGwtc2NyZWVuLWJ0blxcXCJcXG4gICAgICBjbGFzcz1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItbWMtcmlnaHQtY29udHJvbHNcXFwiXFxuICAgID5cIikuY29uY2F0KGNvbmZpZy5zdmcuZnVsbFNjcmVlblNWRywgXCI8L2Rpdj5cXG4gICAgPGRpdlxcbiAgICAgIGlkPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi1zZXR0aW5ncy1idG5cXFwiXFxuICAgICAgY2xhc3M9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLW1jLXJpZ2h0LWNvbnRyb2xzXFxcIlxcbiAgICA+XCIpLmNvbmNhdChjb25maWcuc3ZnLnNldHRpbmdzU1ZHLCBcIjwvZGl2PlxcbiAgICA8ZGl2XFxuICAgICAgaWQ9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLWRjLWJ0blxcXCJcXG4gICAgICBjbGFzcz1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItbWMtcmlnaHQtY29udHJvbHNcXFwiXFxuICAgID5cXG4gICAgICBcIikuY29uY2F0KGNvbmZpZy5zdmcuZGNTVkcsIFwiXFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2XFxuICAgICAgaWQ9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLWxvb3AtYnRuLWNvbnRhaW5lclxcXCJcXG4gICAgICBjbGFzcz1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItbWMtcmlnaHQtY29udHJvbHNcXFwiXFxuICAgID5cXG4gICAgICA8ZGl2XFxuICAgICAgICBpZD1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItbG9vcC1idG5cXFwiXFxuICAgICAgICBjbGFzcz1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItbWMtcmlnaHQtY29udHJvbHNcXFwiXFxuICAgICAgPlwiKS5jb25jYXQoY29uZmlnLnN2Zy5sb29wU1ZHLCBcIjwvZGl2PlxcbiAgICAgIDxkaXZcXG4gICAgICAgIGlkPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi1sb29wLXRpbWVcXFwiXFxuICAgICAgICBjbGFzcz1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItbWMtcmlnaHQtY29udHJvbHNcXFwiXFxuICAgICAgPlxcbiAgICAgICAgPHNwYW5cXG4gICAgICAgICAgaWQ9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLWxvb3BiYXItc3RhcnQtdGltZVxcXCJcXG4gICAgICAgICAgY2xhc3M9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLWxvb3BiYXItdGltZVxcXCJcXG4gICAgICAgID48L3NwYW4+XFxuICAgICAgICA8c3Bhbj46PC9zcGFuPlxcbiAgICAgICAgPHNwYW5cXG4gICAgICAgICAgaWQ9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLWxvb3BiYXItZW5kLXRpbWVcXFwiXFxuICAgICAgICAgIGNsYXNzPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi1sb29wYmFyLXRpbWVcXFwiXFxuICAgICAgICA+PC9zcGFuPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG4gIDwvZGl2PlxcbiAgPGRpdiBpZD1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItc2V0dGluZ3MtcGFuZWxcXFwiPlxcbiAgICA8dWwgaWQ9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLW1haW4tc2V0dGluZ3NcXFwiPlxcbiAgICAgIDxsaSBpZD1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItc2V0dGluZ3MtcG9pbnRlci1ldmVudHNcXFwiPlxcbiAgICAgICAgPGxhYmVsPlBvaW50ZXIgRXZlbnRzPC9sYWJlbD5cXG4gICAgICAgIDxsYWJlbCBjbGFzcz1cXFwic3dpdGNoIHNldHRpbmdzLXN3aXRjaFxcXCI+XFxuICAgICAgICAgIDxpbnB1dCBpZD1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItcG9pbnRlci1ldmVudHMtY2hlY2tib3hcXFwiIHR5cGU9XFxcImNoZWNrYm94XFxcIj5cXG4gICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNsaWRlciByb3VuZFxcXCI+PC9zcGFuPlxcbiAgICAgICAgPC9sYWJlbD5cXG4gICAgICA8L2xpPlxcbiAgICAgIDxsaSBpZD1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItc2V0dGluZ3MtcHJldmlld1xcXCI+XFxuICAgICAgICA8bGFiZWw+U2hvdyBQcmV2aWV3PC9sYWJlbD5cXG4gICAgICAgIDxsYWJlbCBjbGFzcz1cXFwic3dpdGNoIHNldHRpbmdzLXN3aXRjaFxcXCI+XFxuICAgICAgICAgIDxpbnB1dCBpZD1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItc2hvdy1wcmV2aWV3LWNoZWNrYm94XFxcIiB0eXBlPVxcXCJjaGVja2JveFxcXCI+XFxuICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzbGlkZXIgcm91bmRcXFwiPjwvc3Bhbj5cXG4gICAgICAgIDwvbGFiZWw+XFxuICAgICAgPC9saT5cXG4gICAgICA8bGkgaWQ9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLXNldHRpbmdzLWluZGljYXRvclxcXCI+XFxuICAgICAgICA8bGFiZWw+U2hvdyBJbmRpY2F0b3I8L2xhYmVsPlxcbiAgICAgICAgPGxhYmVsIGNsYXNzPVxcXCJzd2l0Y2ggc2V0dGluZ3Mtc3dpdGNoXFxcIj5cXG4gICAgICAgICAgPGlucHV0IGlkPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi1zaG93LWluZGljYXRvci1jaGVja2JveFxcXCIgdHlwZT1cXFwiY2hlY2tib3hcXFwiPlxcbiAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwic2xpZGVyIHJvdW5kXFxcIj48L3NwYW4+XFxuICAgICAgICA8L2xhYmVsPlxcbiAgICAgIDwvbGk+XFxuICAgICAgPGxpIGlkPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi1zZXR0aW5ncy12b2x1bWVcXFwiPlxcbiAgICAgICAgPGxhYmVsPlNob3cgVm9sdW1lPC9sYWJlbD5cXG4gICAgICAgIDxsYWJlbCBjbGFzcz1cXFwic3dpdGNoIHNldHRpbmdzLXN3aXRjaFxcXCI+XFxuICAgICAgICAgIDxpbnB1dCBpZD1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItc2hvdy12b2x1bWUtY2hlY2tib3hcXFwiIHR5cGU9XFxcImNoZWNrYm94XFxcIj5cXG4gICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNsaWRlciByb3VuZFxcXCI+PC9zcGFuPlxcbiAgICAgICAgPC9sYWJlbD5cXG4gICAgICA8L2xpPlxcbiAgICAgIDxsaSBpZD1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItc2V0dGluZ3Mtc3BlZWQtc2hvd1xcXCI+XFxuICAgICAgICA8bGFiZWw+U3BlZWQ8L2xhYmVsPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItc3BlZWQtYnRuXFxcIj5cIikuY29uY2F0KGNvbmZpZy5zdmcuYXJyb3dSaWdodFNWRywgXCI8L2Rpdj5cXG4gICAgICAgIDxzcGFuIGlkPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi1zcGVlZC1jdXJyZW50XFxcIj48L3NwYW4+XFxuICAgICAgPC9saT5cXG4gICAgPC91bD5cXG4gICAgPHVsIGlkPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi1zcGVlZC1zZXR0aW5nc1xcXCI+XFxuICAgICAgPGxpIGlkPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi1zZXR0aW5ncy1zcGVlZC1oaWRlXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLXNwZWVkLWJ0blxcXCI+XCIpLmNvbmNhdChjb25maWcuc3ZnLmFycm93TGVmdFNWRywgXCI8L2Rpdj5cXG4gICAgICAgIDxsYWJlbCBpZD1cIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi1zcGVlZC1ydW50aW1lPlNwZWVkPC9sYWJlbD5cXG4gICAgICA8L2xpPlxcbiAgICAgIDxsaT5cXG4gICAgICAgIDxkaXYgaWQ9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLXNwZWVkLXZhbHVlLWhlbHBlcmJhclxcXCI+PC9kaXY+XFxuICAgICAgICA8ZGl2IGlkPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi1zcGVlZC12YWx1ZS1iYXJcXFwiPlxcbiAgICAgICAgICA8ZGl2XFxuICAgICAgICAgICAgY2xhc3M9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLXNwZWVkLXZhbHVlLXN0ZXBcXFwiXFxuICAgICAgICAgICAgaWQ9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLXNwZWVkLWN1cnNvclxcXCJcXG4gICAgICAgICAgPlxcbiAgICAgICAgICAgIDxkaXY+PC9kaXY+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2IGlkPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi1zcGVlZC12YWx1ZVxcXCI+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2xpPlxcbiAgICA8L3VsPlxcbiAgPC9kaXY+XFxuXCIpO1xufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex-player/dist/html/playerHTML.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex-player/dist/html/setElements.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex-player/dist/html/setElements.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _require = __webpack_require__(/*! ../helpers */ \"./node_modules/@kissmybutton/motorcortex-player/dist/helpers.js\"),\n    elid = _require.elid,\n    elcreate = _require.elcreate;\n\nvar svg = __webpack_require__(/*! ./svg */ \"./node_modules/@kissmybutton/motorcortex-player/dist/html/svg.js\");\n\nvar playerHTML = __webpack_require__(/*! ./playerHTML */ \"./node_modules/@kissmybutton/motorcortex-player/dist/html/playerHTML.js\");\n\nmodule.exports = function (_this) {\n  _this.elements = {};\n  var clipIframe = _this.clip.rootElement; // set _this.clip position to relative\n\n  clipIframe.style.display = \"block\";\n  clipIframe.style.margin = \"0 auto\";\n  _this.clip.props.host.style.position = \"relative\";\n  _this.clip.props.host.style.zIndex = \"0\";\n  _this.elements.mcPlayer = elcreate(\"div\");\n  _this.elements.mcPlayer.id = \"\".concat(_this.name);\n  _this.elements.mcPlayer.className = \"\".concat(_this.className);\n  _this.elements.mcPlayer.innerHTML = playerHTML({\n    svg: svg,\n    name: _this.name\n  });\n\n  _this.options.host.appendChild(_this.elements.mcPlayer);\n\n  _this.elements.pointerEventPanel = elid(\"\".concat(_this.name, \"-pointer-event-panel\"));\n  _this.elements.listenerHelper = elid(\"\".concat(_this.name, \"-listener-helper\"));\n  _this.elements.loopBar = elid(\"\".concat(_this.name, \"-loopbar\"));\n  _this.elements.totalBar = elid(\"\".concat(_this.name, \"-totalbar\"));\n  _this.elements.indicator = elid(\"\".concat(_this.name, \"-indicator\"));\n  _this.elements.loopButton = elid(\"\".concat(_this.name, \"-loop-btn\"));\n  _this.elements.volumeBar = elid(\"\".concat(_this.name, \"-volumebar\"));\n  _this.elements.totalTime = elid(\"\".concat(_this.name, \"-time-total\"));\n  _this.elements.volumeControl = elid(\"\".concat(_this.name, \"-volume\"));\n  _this.elements.volumeBtn = elid(\"\".concat(_this.name, \"-volume-btn\"));\n  _this.elements.runningBar = elid(\"\".concat(_this.name, \"-runningbar\"));\n  _this.elements.loopBarEnd = elid(\"\".concat(_this.name, \"-loopbar-end\"));\n  _this.elements.statusButton = elid(\"\".concat(_this.name, \"-status-btn\"));\n  _this.elements.speedBar = elid(\"\".concat(_this.name, \"-speed-value-bar\"));\n  _this.elements.currentTime = elid(\"\".concat(_this.name, \"-time-current\"));\n  _this.elements.timeDisplay = elid(\"\".concat(_this.name, \"-time-display\"));\n  _this.elements.speedCurrent = elid(\"\".concat(_this.name, \"-speed-current\"));\n  _this.elements.loopBarStart = elid(\"\".concat(_this.name, \"-loopbar-start\"));\n  _this.elements.volumeCursor = elid(\"\".concat(_this.name, \"-volume-cursor\"));\n  _this.elements.settingsButton = elid(\"\".concat(_this.name, \"-settings-btn\"));\n  _this.elements.donkeyclipButton = elid(\"\".concat(_this.name, \"-dc-btn\"));\n  _this.elements.timeSeparator = elid(\"\".concat(_this.name, \"-time-separator\"));\n  _this.elements.settingsPanel = elid(\"\".concat(_this.name, \"-settings-panel\"));\n  _this.elements.settingsMainPanel = elid(\"\".concat(_this.name, \"-main-settings\"));\n  _this.elements.fullScreenButton = elid(\"\".concat(_this.name, \"-full-screen-btn\"));\n  _this.elements.volumeBarHelper = elid(\"\".concat(_this.name, \"-volumebar-helper\"));\n  _this.elements.volumeBarActive = elid(\"\".concat(_this.name, \"-volumebar-active\"));\n  _this.elements.settingsSpeedPanel = elid(\"\".concat(_this.name, \"-speed-settings\"));\n  _this.elements.settingsShowVolume = elid(\"\".concat(_this.name, \"-settings-volume\"));\n  _this.elements.settingsShowPreview = elid(\"\".concat(_this.name, \"-settings-preview\"));\n  _this.elements.settingsPointerEvents = elid(\"\".concat(_this.name, \"-settings-pointer-events\"));\n  _this.elements.speedBarHelper = elid(\"\".concat(_this.name, \"-speed-value-helperbar\"));\n  _this.elements.settingsShowIndicator = elid(\"\".concat(_this.name, \"-settings-indicator\"));\n  _this.elements.settingsSpeedButtonShow = elid(\"\".concat(_this.name, \"-settings-speed-show\"));\n  _this.elements.settingsSpeedButtonHide = elid(\"\".concat(_this.name, \"-settings-speed-hide\"));\n  _this.elements.volumeBarActive.style.width = _this.settings.volume * 100 + \"%\";\n  _this.elements.currentTime.innerHTML = 0;\n  _this.elements.totalTime.innerHTML = _this.clip.duration;\n  _this.elements.timeSeparator.innerHTML = \"/\";\n\n  _this.elements.settingsPanel.classList.add(\"m-fadeOut\", \"\".concat(_this.name, \"-hide\"));\n\n  _this.elements.indicator.style.visibility = \"hidden\";\n  _this.elements.indicator.innerHTML = _this.clip.state;\n  _this.elements.settingsSpeedPanel.style.display = \"none\";\n\n  _this.elements.settingsSpeedPanel.getElementsByTagName(\"li\")[1].classList.add(\"no-hover\");\n\n  _this.elements.loopBarStart.style.left = \"0%\";\n\n  _this.elements.loopBarStart.classList.add(\"m-fadeOut\", \"\".concat(_this.name, \"-hide\"));\n\n  _this.elements.loopBarEnd.style.left = \"100%\";\n\n  _this.elements.loopBarEnd.classList.add(\"m-fadeOut\", \"\".concat(_this.name, \"-hide\"));\n\n  _this.elements.loopStartTime = elid(\"\".concat(_this.name, \"-loopbar-start-time\"));\n  _this.elements.loopEndTime = elid(\"\".concat(_this.name, \"-loopbar-end-time\"));\n  _this.elements.editableLoopStartTime = document.createElement(\"input\");\n  _this.elements.editableLoopStartTime.type = \"text\";\n  _this.elements.editableLoopStartTime.size = elid(\"\".concat(_this.name, \"-time-total\")).innerHTML.length + 1;\n  _this.elements.editableLoopStartTime.maxLength = elid(\"\".concat(_this.name, \"-time-total\")).innerHTML.length;\n  _this.elements.editableLoopStartTime.style.height = elid(\"\".concat(_this.name, \"-time-total\")).offsetHeight;\n  _this.elements.editableLoopStartTime.value = elid(\"\".concat(_this.name, \"-loopbar-start-time\")).innerHTML;\n  _this.elements.editableLoopStartTime.style.fontSize = \"8px\";\n  _this.elements.editableLoopEndTime = document.createElement(\"input\");\n  _this.elements.editableLoopEndTime.type = \"text\";\n  _this.elements.editableLoopEndTime.size = elid(\"\".concat(_this.name, \"-time-total\")).innerHTML.length + 1;\n  _this.elements.editableLoopEndTime.maxLength = elid(\"\".concat(_this.name, \"-time-total\")).innerHTML.length;\n  _this.elements.editableLoopEndTime.style.height = elid(\"\".concat(_this.name, \"-time-total\")).offsetHeight;\n  _this.elements.editableLoopEndTime.value = elid(\"\".concat(_this.name, \"-loopbar-start-time\")).innerHTML;\n  _this.elements.editableLoopEndTime.pattern = \"d*\";\n  _this.elements.editableLoopEndTime.style.fontSize = \"8px\";\n  elid(\"\".concat(_this.name, \"-loop-time\")).classList.add(\"m-fadeOut\", \"\".concat(_this.name, \"-hide\"));\n  elid(\"\".concat(_this.name, \"-hover-display\")).classList.add(\"m-fadeOut\", \"\".concat(_this.name, \"-hide\"));\n  elid(\"\".concat(_this.name, \"-show-volume-checkbox\")).checked = _this.options.showVolume;\n  elid(\"\".concat(_this.name, \"-show-preview-checkbox\")).checked = _this.options.preview;\n  elid(\"\".concat(_this.name, \"-pointer-events-checkbox\")).checked = _this.options.pointerEvents;\n\n  if (_this.options.pointerEvents) {\n    _this.elements.mcPlayer.style.pointerEvents = \"none\";\n    _this.elements.pointerEventPanel.style.pointerEvents = \"auto\";\n    elid(\"\".concat(_this.name, \"-controls\")).style.pointerEvents = \"auto\";\n    _this.elements.settingsPanel.style.pointerEvents = \"auto\";\n  } else {\n    _this.elements.mcPlayer.style.pointerEvents = \"none\";\n    _this.elements.pointerEventPanel.style.pointerEvents = \"none\";\n    elid(\"\".concat(_this.name, \"-controls\")).style.pointerEvents = \"auto\";\n    _this.elements.settingsPanel.style.pointerEvents = \"auto\";\n  }\n\n  _this.elements.listenerHelper.style.pointerEvents = \"none\";\n\n  if (!_this.options.showVolume) {\n    _this.elements.timeDisplay.style.left = \"45px\";\n    _this.elements.volumeControl.style.visibility = \"hidden\";\n\n    _this.elements.volumeBar.classList.toggle(\"\".concat(_this.name, \"-hide\"));\n\n    _this.elements.volumeBar.classList.toggle(\"\".concat(_this.name, \"-volume-width-transition\"));\n  } else {\n    _this.elements.timeDisplay.style.left = \"\";\n    _this.elements.volumeControl.style.visibility = \"visible\";\n  }\n\n  for (var i in _this.options.speedValues) {\n    var barDiv = elcreate(\"div\");\n    barDiv.className = \"\".concat(_this.name, \"-speed-value-step\");\n    var valueDiv = elcreate(\"div\");\n    valueDiv.className = \"\".concat(_this.name, \"-speed-value\");\n    valueDiv.dataset.speedValue = _this.options.speedValues[i];\n    valueDiv.innerHTML = _this.options.speedValues[i];\n    valueDiv.dataset.zone = i;\n    elid(\"\".concat(_this.name, \"-speed-value\")).prepend(valueDiv);\n\n    _this.elements.speedBar.prepend(barDiv);\n  } // show hide buttons\n\n\n  if (_this.options.buttons.fullScreen === false) {\n    _this.elements.fullScreenButton.remove();\n  }\n\n  if (_this.options.buttons.settings === false) {\n    _this.elements.settingsButton.remove();\n  }\n\n  if (_this.options.buttons.donkeyclip === false) {\n    _this.elements.donkeyclipButton.remove();\n  }\n\n  if (_this.options.buttons.loop === false) {\n    _this.elements.loopButton.remove();\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC1wbGF5ZXIvZGlzdC9odG1sL3NldEVsZW1lbnRzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyL2Rpc3QvaHRtbC9zZXRFbGVtZW50cy5qcz80Nzg2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi4vaGVscGVyc1wiKSxcbiAgICBlbGlkID0gX3JlcXVpcmUuZWxpZCxcbiAgICBlbGNyZWF0ZSA9IF9yZXF1aXJlLmVsY3JlYXRlO1xuXG52YXIgc3ZnID0gcmVxdWlyZShcIi4vc3ZnXCIpO1xuXG52YXIgcGxheWVySFRNTCA9IHJlcXVpcmUoXCIuL3BsYXllckhUTUxcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF90aGlzKSB7XG4gIF90aGlzLmVsZW1lbnRzID0ge307XG4gIHZhciBjbGlwSWZyYW1lID0gX3RoaXMuY2xpcC5yb290RWxlbWVudDsgLy8gc2V0IF90aGlzLmNsaXAgcG9zaXRpb24gdG8gcmVsYXRpdmVcblxuICBjbGlwSWZyYW1lLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gIGNsaXBJZnJhbWUuc3R5bGUubWFyZ2luID0gXCIwIGF1dG9cIjtcbiAgX3RoaXMuY2xpcC5wcm9wcy5ob3N0LnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICBfdGhpcy5jbGlwLnByb3BzLmhvc3Quc3R5bGUuekluZGV4ID0gXCIwXCI7XG4gIF90aGlzLmVsZW1lbnRzLm1jUGxheWVyID0gZWxjcmVhdGUoXCJkaXZcIik7XG4gIF90aGlzLmVsZW1lbnRzLm1jUGxheWVyLmlkID0gXCJcIi5jb25jYXQoX3RoaXMubmFtZSk7XG4gIF90aGlzLmVsZW1lbnRzLm1jUGxheWVyLmNsYXNzTmFtZSA9IFwiXCIuY29uY2F0KF90aGlzLmNsYXNzTmFtZSk7XG4gIF90aGlzLmVsZW1lbnRzLm1jUGxheWVyLmlubmVySFRNTCA9IHBsYXllckhUTUwoe1xuICAgIHN2Zzogc3ZnLFxuICAgIG5hbWU6IF90aGlzLm5hbWVcbiAgfSk7XG5cbiAgX3RoaXMub3B0aW9ucy5ob3N0LmFwcGVuZENoaWxkKF90aGlzLmVsZW1lbnRzLm1jUGxheWVyKTtcblxuICBfdGhpcy5lbGVtZW50cy5wb2ludGVyRXZlbnRQYW5lbCA9IGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItcG9pbnRlci1ldmVudC1wYW5lbFwiKSk7XG4gIF90aGlzLmVsZW1lbnRzLmxpc3RlbmVySGVscGVyID0gZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1saXN0ZW5lci1oZWxwZXJcIikpO1xuICBfdGhpcy5lbGVtZW50cy5sb29wQmFyID0gZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1sb29wYmFyXCIpKTtcbiAgX3RoaXMuZWxlbWVudHMudG90YWxCYXIgPSBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXRvdGFsYmFyXCIpKTtcbiAgX3RoaXMuZWxlbWVudHMuaW5kaWNhdG9yID0gZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1pbmRpY2F0b3JcIikpO1xuICBfdGhpcy5lbGVtZW50cy5sb29wQnV0dG9uID0gZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1sb29wLWJ0blwiKSk7XG4gIF90aGlzLmVsZW1lbnRzLnZvbHVtZUJhciA9IGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItdm9sdW1lYmFyXCIpKTtcbiAgX3RoaXMuZWxlbWVudHMudG90YWxUaW1lID0gZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi10aW1lLXRvdGFsXCIpKTtcbiAgX3RoaXMuZWxlbWVudHMudm9sdW1lQ29udHJvbCA9IGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItdm9sdW1lXCIpKTtcbiAgX3RoaXMuZWxlbWVudHMudm9sdW1lQnRuID0gZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi12b2x1bWUtYnRuXCIpKTtcbiAgX3RoaXMuZWxlbWVudHMucnVubmluZ0JhciA9IGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItcnVubmluZ2JhclwiKSk7XG4gIF90aGlzLmVsZW1lbnRzLmxvb3BCYXJFbmQgPSBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLWxvb3BiYXItZW5kXCIpKTtcbiAgX3RoaXMuZWxlbWVudHMuc3RhdHVzQnV0dG9uID0gZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1zdGF0dXMtYnRuXCIpKTtcbiAgX3RoaXMuZWxlbWVudHMuc3BlZWRCYXIgPSBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXNwZWVkLXZhbHVlLWJhclwiKSk7XG4gIF90aGlzLmVsZW1lbnRzLmN1cnJlbnRUaW1lID0gZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi10aW1lLWN1cnJlbnRcIikpO1xuICBfdGhpcy5lbGVtZW50cy50aW1lRGlzcGxheSA9IGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItdGltZS1kaXNwbGF5XCIpKTtcbiAgX3RoaXMuZWxlbWVudHMuc3BlZWRDdXJyZW50ID0gZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1zcGVlZC1jdXJyZW50XCIpKTtcbiAgX3RoaXMuZWxlbWVudHMubG9vcEJhclN0YXJ0ID0gZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1sb29wYmFyLXN0YXJ0XCIpKTtcbiAgX3RoaXMuZWxlbWVudHMudm9sdW1lQ3Vyc29yID0gZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi12b2x1bWUtY3Vyc29yXCIpKTtcbiAgX3RoaXMuZWxlbWVudHMuc2V0dGluZ3NCdXR0b24gPSBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXNldHRpbmdzLWJ0blwiKSk7XG4gIF90aGlzLmVsZW1lbnRzLmRvbmtleWNsaXBCdXR0b24gPSBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLWRjLWJ0blwiKSk7XG4gIF90aGlzLmVsZW1lbnRzLnRpbWVTZXBhcmF0b3IgPSBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXRpbWUtc2VwYXJhdG9yXCIpKTtcbiAgX3RoaXMuZWxlbWVudHMuc2V0dGluZ3NQYW5lbCA9IGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItc2V0dGluZ3MtcGFuZWxcIikpO1xuICBfdGhpcy5lbGVtZW50cy5zZXR0aW5nc01haW5QYW5lbCA9IGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItbWFpbi1zZXR0aW5nc1wiKSk7XG4gIF90aGlzLmVsZW1lbnRzLmZ1bGxTY3JlZW5CdXR0b24gPSBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLWZ1bGwtc2NyZWVuLWJ0blwiKSk7XG4gIF90aGlzLmVsZW1lbnRzLnZvbHVtZUJhckhlbHBlciA9IGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItdm9sdW1lYmFyLWhlbHBlclwiKSk7XG4gIF90aGlzLmVsZW1lbnRzLnZvbHVtZUJhckFjdGl2ZSA9IGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItdm9sdW1lYmFyLWFjdGl2ZVwiKSk7XG4gIF90aGlzLmVsZW1lbnRzLnNldHRpbmdzU3BlZWRQYW5lbCA9IGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItc3BlZWQtc2V0dGluZ3NcIikpO1xuICBfdGhpcy5lbGVtZW50cy5zZXR0aW5nc1Nob3dWb2x1bWUgPSBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXNldHRpbmdzLXZvbHVtZVwiKSk7XG4gIF90aGlzLmVsZW1lbnRzLnNldHRpbmdzU2hvd1ByZXZpZXcgPSBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXNldHRpbmdzLXByZXZpZXdcIikpO1xuICBfdGhpcy5lbGVtZW50cy5zZXR0aW5nc1BvaW50ZXJFdmVudHMgPSBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXNldHRpbmdzLXBvaW50ZXItZXZlbnRzXCIpKTtcbiAgX3RoaXMuZWxlbWVudHMuc3BlZWRCYXJIZWxwZXIgPSBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXNwZWVkLXZhbHVlLWhlbHBlcmJhclwiKSk7XG4gIF90aGlzLmVsZW1lbnRzLnNldHRpbmdzU2hvd0luZGljYXRvciA9IGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItc2V0dGluZ3MtaW5kaWNhdG9yXCIpKTtcbiAgX3RoaXMuZWxlbWVudHMuc2V0dGluZ3NTcGVlZEJ1dHRvblNob3cgPSBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXNldHRpbmdzLXNwZWVkLXNob3dcIikpO1xuICBfdGhpcy5lbGVtZW50cy5zZXR0aW5nc1NwZWVkQnV0dG9uSGlkZSA9IGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItc2V0dGluZ3Mtc3BlZWQtaGlkZVwiKSk7XG4gIF90aGlzLmVsZW1lbnRzLnZvbHVtZUJhckFjdGl2ZS5zdHlsZS53aWR0aCA9IF90aGlzLnNldHRpbmdzLnZvbHVtZSAqIDEwMCArIFwiJVwiO1xuICBfdGhpcy5lbGVtZW50cy5jdXJyZW50VGltZS5pbm5lckhUTUwgPSAwO1xuICBfdGhpcy5lbGVtZW50cy50b3RhbFRpbWUuaW5uZXJIVE1MID0gX3RoaXMuY2xpcC5kdXJhdGlvbjtcbiAgX3RoaXMuZWxlbWVudHMudGltZVNlcGFyYXRvci5pbm5lckhUTUwgPSBcIi9cIjtcblxuICBfdGhpcy5lbGVtZW50cy5zZXR0aW5nc1BhbmVsLmNsYXNzTGlzdC5hZGQoXCJtLWZhZGVPdXRcIiwgXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItaGlkZVwiKSk7XG5cbiAgX3RoaXMuZWxlbWVudHMuaW5kaWNhdG9yLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICBfdGhpcy5lbGVtZW50cy5pbmRpY2F0b3IuaW5uZXJIVE1MID0gX3RoaXMuY2xpcC5zdGF0ZTtcbiAgX3RoaXMuZWxlbWVudHMuc2V0dGluZ3NTcGVlZFBhbmVsLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcblxuICBfdGhpcy5lbGVtZW50cy5zZXR0aW5nc1NwZWVkUGFuZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJsaVwiKVsxXS5jbGFzc0xpc3QuYWRkKFwibm8taG92ZXJcIik7XG5cbiAgX3RoaXMuZWxlbWVudHMubG9vcEJhclN0YXJ0LnN0eWxlLmxlZnQgPSBcIjAlXCI7XG5cbiAgX3RoaXMuZWxlbWVudHMubG9vcEJhclN0YXJ0LmNsYXNzTGlzdC5hZGQoXCJtLWZhZGVPdXRcIiwgXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItaGlkZVwiKSk7XG5cbiAgX3RoaXMuZWxlbWVudHMubG9vcEJhckVuZC5zdHlsZS5sZWZ0ID0gXCIxMDAlXCI7XG5cbiAgX3RoaXMuZWxlbWVudHMubG9vcEJhckVuZC5jbGFzc0xpc3QuYWRkKFwibS1mYWRlT3V0XCIsIFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLWhpZGVcIikpO1xuXG4gIF90aGlzLmVsZW1lbnRzLmxvb3BTdGFydFRpbWUgPSBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLWxvb3BiYXItc3RhcnQtdGltZVwiKSk7XG4gIF90aGlzLmVsZW1lbnRzLmxvb3BFbmRUaW1lID0gZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1sb29wYmFyLWVuZC10aW1lXCIpKTtcbiAgX3RoaXMuZWxlbWVudHMuZWRpdGFibGVMb29wU3RhcnRUaW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICBfdGhpcy5lbGVtZW50cy5lZGl0YWJsZUxvb3BTdGFydFRpbWUudHlwZSA9IFwidGV4dFwiO1xuICBfdGhpcy5lbGVtZW50cy5lZGl0YWJsZUxvb3BTdGFydFRpbWUuc2l6ZSA9IGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItdGltZS10b3RhbFwiKSkuaW5uZXJIVE1MLmxlbmd0aCArIDE7XG4gIF90aGlzLmVsZW1lbnRzLmVkaXRhYmxlTG9vcFN0YXJ0VGltZS5tYXhMZW5ndGggPSBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXRpbWUtdG90YWxcIikpLmlubmVySFRNTC5sZW5ndGg7XG4gIF90aGlzLmVsZW1lbnRzLmVkaXRhYmxlTG9vcFN0YXJ0VGltZS5zdHlsZS5oZWlnaHQgPSBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXRpbWUtdG90YWxcIikpLm9mZnNldEhlaWdodDtcbiAgX3RoaXMuZWxlbWVudHMuZWRpdGFibGVMb29wU3RhcnRUaW1lLnZhbHVlID0gZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1sb29wYmFyLXN0YXJ0LXRpbWVcIikpLmlubmVySFRNTDtcbiAgX3RoaXMuZWxlbWVudHMuZWRpdGFibGVMb29wU3RhcnRUaW1lLnN0eWxlLmZvbnRTaXplID0gXCI4cHhcIjtcbiAgX3RoaXMuZWxlbWVudHMuZWRpdGFibGVMb29wRW5kVGltZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgX3RoaXMuZWxlbWVudHMuZWRpdGFibGVMb29wRW5kVGltZS50eXBlID0gXCJ0ZXh0XCI7XG4gIF90aGlzLmVsZW1lbnRzLmVkaXRhYmxlTG9vcEVuZFRpbWUuc2l6ZSA9IGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItdGltZS10b3RhbFwiKSkuaW5uZXJIVE1MLmxlbmd0aCArIDE7XG4gIF90aGlzLmVsZW1lbnRzLmVkaXRhYmxlTG9vcEVuZFRpbWUubWF4TGVuZ3RoID0gZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi10aW1lLXRvdGFsXCIpKS5pbm5lckhUTUwubGVuZ3RoO1xuICBfdGhpcy5lbGVtZW50cy5lZGl0YWJsZUxvb3BFbmRUaW1lLnN0eWxlLmhlaWdodCA9IGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItdGltZS10b3RhbFwiKSkub2Zmc2V0SGVpZ2h0O1xuICBfdGhpcy5lbGVtZW50cy5lZGl0YWJsZUxvb3BFbmRUaW1lLnZhbHVlID0gZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1sb29wYmFyLXN0YXJ0LXRpbWVcIikpLmlubmVySFRNTDtcbiAgX3RoaXMuZWxlbWVudHMuZWRpdGFibGVMb29wRW5kVGltZS5wYXR0ZXJuID0gXCJkKlwiO1xuICBfdGhpcy5lbGVtZW50cy5lZGl0YWJsZUxvb3BFbmRUaW1lLnN0eWxlLmZvbnRTaXplID0gXCI4cHhcIjtcbiAgZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1sb29wLXRpbWVcIikpLmNsYXNzTGlzdC5hZGQoXCJtLWZhZGVPdXRcIiwgXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItaGlkZVwiKSk7XG4gIGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItaG92ZXItZGlzcGxheVwiKSkuY2xhc3NMaXN0LmFkZChcIm0tZmFkZU91dFwiLCBcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1oaWRlXCIpKTtcbiAgZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1zaG93LXZvbHVtZS1jaGVja2JveFwiKSkuY2hlY2tlZCA9IF90aGlzLm9wdGlvbnMuc2hvd1ZvbHVtZTtcbiAgZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1zaG93LXByZXZpZXctY2hlY2tib3hcIikpLmNoZWNrZWQgPSBfdGhpcy5vcHRpb25zLnByZXZpZXc7XG4gIGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItcG9pbnRlci1ldmVudHMtY2hlY2tib3hcIikpLmNoZWNrZWQgPSBfdGhpcy5vcHRpb25zLnBvaW50ZXJFdmVudHM7XG5cbiAgaWYgKF90aGlzLm9wdGlvbnMucG9pbnRlckV2ZW50cykge1xuICAgIF90aGlzLmVsZW1lbnRzLm1jUGxheWVyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcbiAgICBfdGhpcy5lbGVtZW50cy5wb2ludGVyRXZlbnRQYW5lbC5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJhdXRvXCI7XG4gICAgZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1jb250cm9sc1wiKSkuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwiYXV0b1wiO1xuICAgIF90aGlzLmVsZW1lbnRzLnNldHRpbmdzUGFuZWwuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwiYXV0b1wiO1xuICB9IGVsc2Uge1xuICAgIF90aGlzLmVsZW1lbnRzLm1jUGxheWVyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcbiAgICBfdGhpcy5lbGVtZW50cy5wb2ludGVyRXZlbnRQYW5lbC5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gICAgZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1jb250cm9sc1wiKSkuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwiYXV0b1wiO1xuICAgIF90aGlzLmVsZW1lbnRzLnNldHRpbmdzUGFuZWwuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwiYXV0b1wiO1xuICB9XG5cbiAgX3RoaXMuZWxlbWVudHMubGlzdGVuZXJIZWxwZXIuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuXG4gIGlmICghX3RoaXMub3B0aW9ucy5zaG93Vm9sdW1lKSB7XG4gICAgX3RoaXMuZWxlbWVudHMudGltZURpc3BsYXkuc3R5bGUubGVmdCA9IFwiNDVweFwiO1xuICAgIF90aGlzLmVsZW1lbnRzLnZvbHVtZUNvbnRyb2wuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG5cbiAgICBfdGhpcy5lbGVtZW50cy52b2x1bWVCYXIuY2xhc3NMaXN0LnRvZ2dsZShcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1oaWRlXCIpKTtcblxuICAgIF90aGlzLmVsZW1lbnRzLnZvbHVtZUJhci5jbGFzc0xpc3QudG9nZ2xlKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXZvbHVtZS13aWR0aC10cmFuc2l0aW9uXCIpKTtcbiAgfSBlbHNlIHtcbiAgICBfdGhpcy5lbGVtZW50cy50aW1lRGlzcGxheS5zdHlsZS5sZWZ0ID0gXCJcIjtcbiAgICBfdGhpcy5lbGVtZW50cy52b2x1bWVDb250cm9sLnN0eWxlLnZpc2liaWxpdHkgPSBcInZpc2libGVcIjtcbiAgfVxuXG4gIGZvciAodmFyIGkgaW4gX3RoaXMub3B0aW9ucy5zcGVlZFZhbHVlcykge1xuICAgIHZhciBiYXJEaXYgPSBlbGNyZWF0ZShcImRpdlwiKTtcbiAgICBiYXJEaXYuY2xhc3NOYW1lID0gXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItc3BlZWQtdmFsdWUtc3RlcFwiKTtcbiAgICB2YXIgdmFsdWVEaXYgPSBlbGNyZWF0ZShcImRpdlwiKTtcbiAgICB2YWx1ZURpdi5jbGFzc05hbWUgPSBcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1zcGVlZC12YWx1ZVwiKTtcbiAgICB2YWx1ZURpdi5kYXRhc2V0LnNwZWVkVmFsdWUgPSBfdGhpcy5vcHRpb25zLnNwZWVkVmFsdWVzW2ldO1xuICAgIHZhbHVlRGl2LmlubmVySFRNTCA9IF90aGlzLm9wdGlvbnMuc3BlZWRWYWx1ZXNbaV07XG4gICAgdmFsdWVEaXYuZGF0YXNldC56b25lID0gaTtcbiAgICBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXNwZWVkLXZhbHVlXCIpKS5wcmVwZW5kKHZhbHVlRGl2KTtcblxuICAgIF90aGlzLmVsZW1lbnRzLnNwZWVkQmFyLnByZXBlbmQoYmFyRGl2KTtcbiAgfSAvLyBzaG93IGhpZGUgYnV0dG9uc1xuXG5cbiAgaWYgKF90aGlzLm9wdGlvbnMuYnV0dG9ucy5mdWxsU2NyZWVuID09PSBmYWxzZSkge1xuICAgIF90aGlzLmVsZW1lbnRzLmZ1bGxTY3JlZW5CdXR0b24ucmVtb3ZlKCk7XG4gIH1cblxuICBpZiAoX3RoaXMub3B0aW9ucy5idXR0b25zLnNldHRpbmdzID09PSBmYWxzZSkge1xuICAgIF90aGlzLmVsZW1lbnRzLnNldHRpbmdzQnV0dG9uLnJlbW92ZSgpO1xuICB9XG5cbiAgaWYgKF90aGlzLm9wdGlvbnMuYnV0dG9ucy5kb25rZXljbGlwID09PSBmYWxzZSkge1xuICAgIF90aGlzLmVsZW1lbnRzLmRvbmtleWNsaXBCdXR0b24ucmVtb3ZlKCk7XG4gIH1cblxuICBpZiAoX3RoaXMub3B0aW9ucy5idXR0b25zLmxvb3AgPT09IGZhbHNlKSB7XG4gICAgX3RoaXMuZWxlbWVudHMubG9vcEJ1dHRvbi5yZW1vdmUoKTtcbiAgfVxufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex-player/dist/html/setElements.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex-player/dist/html/style.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex-player/dist/html/style.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function (theme, name, options) {\n  return \"\\n.background {\\n  background-color: black;\\n  width:100%;\\n  height:\".concat(theme[\"background-height\"], \";;\\n  position:absolute;\\n  top:0px;\\n  left:0px;\\n  z-index:-2000;\\n}\\n\\n.full-screen #\").concat(name, \"-controls {\\n  position:fixed;\\n  left:0px;\\n  bottom:0px;\\n}\\n\\n.full-screen #\").concat(name, \"-settings-panel {\\n  position:fixed;\\n  bottom: 45px;\\n}\\n\\n.svg {\\n  fill: \").concat(theme[\"svg-color\"], \";\\n  stroke: \").concat(theme[\"svg-color\"], \";\\n}\\n\\n.pointer-event-panel {\\n  height: \").concat(theme[\"pointer-event-panel-height\"], \";\\n}\\n#\").concat(name, \"-pointer-event-panel{\\n  width:100%;\\n  position:absolute;\\n  z-index:100;\\n}\\n#\").concat(name, \"-listener-helper{\\n  width:100%;\\n  height:calc( 100% - 45px );\\n  position:absolute;\\n  z-index:110;\\n}\\n.svg-selected svg{\\n  fill: \").concat(theme[\"svg-selected-color\"], \";\\n  stroke: \").concat(theme[\"svg-selected-color\"], \";\\n}\\n#\").concat(name, \"-hover-display{\\n    border: \").concat(theme[\"preview-border\"], \";\\n    max-width:300px;\\n    display: flex;\\n    overflow:hidden;\\n    background-color: black;\\n    position: absolute;\\n    bottom: 14px;\\n    left: 0px;\\n    align-items: flex-end;\\n    justify-content: center;\\n}\\n\\n#\").concat(name, \"-hover-millisecond {\\n  background-color: \").concat(theme[\"hms-background-color\"], \";\\n  padding:3px;\\n  height:18px;\\n  margin:0px;\\n  line-height:12px;\\n  font-size:10px;\\n  text-align: center;\\n  min-width:20px;\\n  max-width:100px;\\n  z-index:2;\\n}\\n#\").concat(name, \",\\n#\").concat(name, \" ::before,\\n#\").concat(name, \" ::after,\\n#\").concat(name, \" div,\\n#\").concat(name, \" p,\\n#\").concat(name, \" span,\\n#\").concat(name, \" ul,\\n#\").concat(name, \" li {\\n  font-weight: 400;\\n  line-height: 1.9 !important;\\n  color: \").concat(theme[\"color\"], \";\\n  font-family: \\\"Century Gothic\\\", CenturyGothic, AppleGothic, sans-serif;\\n  box-sizing:border-box;\\n  -webkit-touch-callout: none;\\n  -webkit-user-select: none;\\n  -moz-user-select: none;\\n  -ms-user-select: none;\\n  user-select: none;\\n}\\n#\").concat(name, \" {\\n  line-height: 1.9;\\n  font-size: 12px;\\n  overflow:hidden;\\n  height: calc(100% + \").concat(theme[\"controls-position\"], \");\\n  width:100%;\\n  position: absolute;\\n  top: 0px;\\n  left: 0px;\\n  \\n}\\n\\n#\").concat(name, \"-settings-speed-hide {\\n  text-align:right;\\n}\\n\\n.grad {\\n  background-image: linear-gradient(\\n    rgba(100,100,100,00.01),\\n    rgba(100,100,100,00.02),\\n    rgba(100,100,100,00.03),\\n    rgba(100,100,100,0.04),\\n    rgba(100,100,100,0.05),\\n    rgba(0,0,0,0.06),\\n    rgba(0,0,0,0.07),\\n    rgba(0,0,0,0.08),\\n    rgba(0,0,0,0.09),\\n    rgba(0,0,0,0.1),\\n    rgba(0,0,0,0.2),\\n    rgba(0,0,0,0.3),\\n    rgba(0,0,0,0.4),\\n    rgba(0,0,0,0.4),\\n    rgba(0,0,0,0.5),\\n    rgba(0,0,0,0.6),\\n    rgba(0,0,0,0.7),\\n    rgba(0,0,0,0.8),\\n    rgba(0,0,0,0.9),\\n    rgba(0,0,0,1)\\n  );\\n  position:absolute;\\n  width:100%;\\n  height:\").concat(theme[\"grad-height\"], \";\\n  left:0px;\\n  bottom:0px;\\n}\\n\\n#\").concat(name, \"-controls {\\n  touch-action: none;\\n  background-color: \").concat(theme[\"background-color\"], \";\\n  border: \").concat(theme[\"controls-border\"], \";\\n  position: absolute;\\n  bottom: \").concat(theme[\"controls-bottom\"], \";\\n  left: 0px;\\n  width: 100%;\\n  height: 40px;\\n  z-index:100;\\n}\\n\\n#\").concat(name, \"-totalbar {\\n  width: calc(100% - 20px);\\n  height: 5px;\\n  margin: 0px 10px 0px 10px;\\n  background-color: #505056;\\n  position: relative;\\n  top: 0px;\\n  left: 0px;\\n}\\n\\n#\").concat(name, \"-loopbar {\\n  position: absolute;\\n  height: 100%;\\n  width: 100%;\\n  top: 0px;\\n  left: 0px;\\n  background-color: \").concat(theme[\"loopbar-color\"], \";\\n}\\n\\n.\").concat(name, \"-loop-boundaries {\\n  transform:translate(-50%,-37%);\\n  position:absolute;\\n  width:18px;\\n  background-color:\").concat(theme[\"loopbar-color\"], \";\\n  height:18px;\\n  border-radius:10px;\\n  z-index:40;\\n}\\n\\n#\").concat(name, \"-helperbar {\\n  position: absolute;\\n  height: 20px;\\n  top: -10px;\\n  left: 0px;\\n  right: 0px;\\n  z-index:2;\\n}\\n\\n#\").concat(name, \"-runningbar {\\n  position: relative;\\n  width: 0px;\\n  max-width:100%;\\n  height: 100%;\\n  background-color: \").concat(theme[\"runningbar-color\"], \";\\n}\\n\\n#\").concat(name, \"-cursor {\\n  transform:translate(50%,-36%);\\n  right: 0px;\\n  top: 0px;\\n  width: 0px;\\n  height: 0px;\\n  position: absolute;\\n  background-color: \").concat(theme[\"cursor-color\"], \";\\n  border-radius: 10px;\\n  z-index: 5;\\n}\\n\\n#\").concat(name, \"-left-controls {\\n  display:inline-block;\\n  width:200px;\\n  height:35px;\\n}\\n#\").concat(name, \"-time-display {\\n  display: table;\\n  text-align: center;\\n  width: auto;\\n  height: 34px;\\n  position: absolute;\\n  left: 90px;\\n  -webkit-transition: left 0.1s ease;\\n  -moz-transition: left 0.1s ease;\\n  transition: left 0.1s ease;\\n}\\n\\n#\").concat(name, \"-time-display span {\\n  display: table-cell;\\n  vertical-align: middle;\\n}\\n\\n#\").concat(name, \"-status-btn {\\n  opacity: \").concat(theme[\"button-opacity\"], \";\\n  background-repeat: no-repeat;\\n  background-size: 100% 100%;\\n  width: 40px;\\n  height: 25px;\\n  position: absolute;\\n  overflow:visible;\\n  left: 0px;\\n  bottom: 0px;\\n  margin: 10px 5px 5px 5px;\\n  text-align: center;\\n  z-index:3;\\n}\\n\\n#\").concat(name, \"-volume {\\n  opacity: \").concat(theme[\"button-opacity\"], \";\\n  background-repeat: no-repeat;\\n  background-size: 100% 100%;\\n  position: absolute;\\n  left: 45px;\\n  bottom: 5px;\\n  margin: 10px 5px 5px 5px;\\n  text-align: center;\\n  z-index:3;\\n}\\n#\").concat(name, \"-volume-btn {\\n  width: 20px;\\n  height: 15px;\\n}\\n\\n#\").concat(name, \"-volumebar {\\n  width: 0px;\\n  height: 3px;\\n  background-color: \").concat(theme[\"loopbar-color\"], \";\\n  position:absolute;\\n  left:25px;\\n  bottom:6px;\\n  -webkit-transition: left 0.1s ease;\\n  -moz-transition: left 0.1s ease;\\n  transition: left 0.1s ease;\\n}\\n\\n#\").concat(name, \"-volumebar-helper {\\n  position: absolute;\\n  width: 0px;\\n  height: 15px;\\n  left:25px;\\n  bottom:0px;\\n  z-index:10;\\n}\\n\\n#\").concat(name, \"-volumebar-active {\\n  position: relative;\\n  width: 0%;\\n  height: 100%;\\n  background-color: \").concat(theme[\"color\"], \";\\n  position:relative;\\n  left:0px;\\n  bottom:0px;\\n}\\n\\n#\").concat(name, \"-volume-cursor {\\n  transform:translate(50%,-36%);\\n  right: 0px;\\n  top: 0px;\\n  width: 0px;\\n  height: 0px;\\n  position: absolute;\\n  background-color: \").concat(theme[\"color\"], \";\\n  border-radius: 10px;\\n  z-index: 5;\\n}\\n\\n.\").concat(name, \"-loopbar-time {\\n  width:auto;\\n  height:12px;\\n  background-color:\").concat(theme[\"background-color\"], \";\\n  line-height:10px;\\n  font-size:10px;\\n}\\n\\n#\").concat(name, \"-loop-time {\\n  margin: 7px;\\n}\\n\\n#\").concat(name, \"-dc-btn {\\n    opacity: 0.8;\\n    background-repeat: no-repeat;\\n    background-size: 100% 100%;\\n    width: 20px;\\n    height: 15px;\\n    margin: 7px 10px 5px 0px;\\n    transform: scale(1.5,1.5);\\n}\\n\\n#\").concat(name, \"-loop-btn {\\n  opacity: \").concat(theme[\"button-opacity\"], \";\\n  background-repeat: no-repeat;\\n  background-size: 100% 100%;\\n  width: 15px;\\n  height: 15px;\\n  margin: 10px 5px 5px 5px;\\n}\\n\\n\\n#\").concat(name, \"-settings-btn {\\n  opacity: \").concat(theme[\"button-opacity\"], \";\\n  background-repeat: no-repeat;\\n  background-size: 100% 100%;\\n  width: 15px;\\n  height: 15px;\\n  margin: 10px 5px 5px 5px;\\n}\\n\\n#\").concat(name, \"-full-screen-btn {\\n  opacity: \").concat(theme[\"button-opacity\"], \";\\n  background-repeat: no-repeat;\\n  background-size: 100% 100%;\\n  width: 15px;\\n  height: 15px;\\n  margin: 10px 5px 5px 5px;\\n}\\n\\n.\").concat(name, \"-speed-btn {\\n  position: relative;\\n  opacity: \").concat(theme[\"button-opacity\"], \";\\n  width: 10px;\\n  height: 10px;\\n  display: inline-block;\\n}\\n\\n#\").concat(name, \"-settings-panel {\\n  touch-action: none;\\n  box-sizing: border-box;\\n  position: absolute;\\n  z-index:101;\\n  background-color: \").concat(theme[\"settings-background-color\"], \";\\n  bottom: \").concat(theme[\"settings-panel-bottom\"], \";\\n  border: \").concat(theme[\"border\"], \";\\n  right: 5px;\\n  width: 164px;\\n  height: 175px;\\n  padding: 5px;\\n  margin: 0px;\\n  -webkit-transition: all 0.3s ease;\\n  -moz-transition: all 0.3s ease;\\n  transition: all 0.3s ease;\\n}\\n\\n.\").concat(name, \"-mc-right-controls {\\n  float: right;\\n}\\n\\n.\").concat(name, \"-hide {\\n  display:none !important;\\n}\\n\\n#\").concat(name, \"-speed-value-bar {\\n  position: relative;\\n  width: 5px;\\n  background-color: \").concat(theme[\"speedbar-color\"], \";\\n  display: inline-block;\\n  box-sizing: border-box;\\n  height: \").concat(options.speedValues.length * 16, \"px;\\n  float: left;\\n  margin-right:15px;\\n}\\n\\n#\").concat(name, \"-speed-value-helperbar {\\n  position: absolute;\\n  width: 25px;\\n  height: \").concat(options.speedValues.length * 16, \"px;\\n  float: left;\\n  left: -5px;\\n  z-index:10;\\n}\\n\\n\\n#\").concat(name, \"-speed-value-bar:hover,\\n#\").concat(name, \"-speed-value-helperbar {\\n  cursor: pointer;\\n}\\n\\n#\").concat(name, \"-volumebar:hover,\\n#\").concat(name, \"-volumebar-helper:hover,\\n#\").concat(name, \"-volume-btn:hover,\\n#\").concat(name, \"-volumebar:active,\\n#\").concat(name, \"-volumebar-helper:active,\\n#\").concat(name, \"-volume-btn:active {\\n  cursor:pointer;\\n}\\n\\n#\").concat(name, \"-speed-cursor {\\n  position: absolute;\\n  background-color: \").concat(theme[\"speedbar-cursor-color\"], \";\\n  top: 0px;\\n  left: 0px;\\n}\\n\\n#\").concat(name, \"-speed-cursor div {\\n  position: absolute;\\n  background-color: \").concat(theme[\"speedbar-cursor-color\"], \";\\n  left: -2.5px;\\n  top: -4px;\\n  width: 10px;\\n  height: 10px;\\n  border-radius: 5px;\\n}\\n\\n#\").concat(name, \"-speed-cursor:hover {\\n  cursor: pointer;\\n}\\n\\n.\").concat(name, \"-speed-value-step {\\n  width: 16px;\\n  background-color: \").concat(theme[\"speedbar-color\"], \";\\n  display: inline-block;\\n  box-sizing: border-box;\\n  height: 2px;\\n  margin-top: 7px;\\n  margin-bottom: 7px;\\n  float: left;\\n}\\n\\n#\").concat(name, \"-speed-value {\\n  display: inline-block;\\n  box-sizing: border-box;\\n  height: \").concat(options.speedValues.length * 16, \"px;\\n  text-align: left;\\n}\\n\\n.\").concat(name, \"-speed-value {\\n  box-sizing: border-box;\\n  height: 16px;\\n  font-size: 12px;\\n}\\n\\n#\").concat(name, \"-indicator {\\n  font-size: 8px !important;\\n  position: relative;\\n  bottom: 15px;\\n  color: \").concat(theme[\"color\"], \";\\n  white-space: nowrap;\\n}\\n\\n#\").concat(name, \"-speed-settings {\\n  height: \").concat(options.speedValues.length * 16 + 32 + 10 - 2, \"px;\\n}\\n\\n#\").concat(name, \"-speed-settings li.no-hover { \\n  height: \").concat(options.speedValues.length * 16 + 10 - 2, \"px; \\n}\\n#\").concat(name, \"-settings-panel.\").concat(name, \"-settings-speed-panel {\\n  overflow: hidden;\\n  width: 80px;\\n  height: \").concat(options.speedValues.length * 16 + 32 + 20, \"px;\\n  -webkit-transition: all 0.3s ease;\\n  -moz-transition: all 0.3s ease;\\n  transition: all 0.3s ease;\\n}\\n\\n#\").concat(name, \"-settings-panel.\").concat(name, \"-settings-speed-panel .\").concat(name, \"-speed-btn {\\n  float: left;\\n}\\n\\n.\").concat(name, \"-settings-speed-panel ul:first-child {\\n  text-align: right;\\n}\\n\\n#\").concat(name, \"-speed-current {\\n  float: right;\\n  padding-right: 10px\\n}\\n\\n#\").concat(name, \"-settings-panel .\").concat(name, \"-speed-btn {\\n  float: right;\\n}\\n\\n#\").concat(name, \"-settings-panel ul {\\n  width: 100%;\\n  margin: 0px;\\n  padding: 0px;\\n  overflow: hidden;\\n}\\n\\n#\").concat(name, \"-settings-panel.\").concat(name, \"-settings-speed-panel ul li {\\n  min-width: 70px;\\n}\\n\\n#\").concat(name, \"-settings-panel ul li.no-hover:hover {\\n  background-color: transparent;\\n  cursor: default;\\n}\\n\\ndiv.\").concat(name, \"-speed-value:hover {\\n  background-color: \").concat(theme[\"hover-color\"], \";\\n  cursor: pointer;\\n}\\n\\n#\").concat(name, \"-settings-panel ul li {\\n  position: relative;\\n  width: 100%;\\n  min-width: 154px;\\n  list-style-type: none;\\n  margin: 0px;\\n  padding: 5px;\\n}\\n\\n#\").concat(name, \"-settings-panel ul li label {\\n  margin: 0px;\\n}\\n\\n.switch {\\n  position: relative;\\n  display: inline-block;\\n  width: 35px;\\n  height: 18px;\\n}\\n\\n.switch input {\\n  display: none;\\n}\\n\\n.settings-switch {\\n  float: right;\\n}\\n\\n.settings-switch:after {\\n  clear: both;\\n}\\n\\n.slider {\\n  position: absolute;\\n  cursor: pointer;\\n  top: 0;\\n  left: 0;\\n  right: 0;\\n  bottom: 0;\\n  background-color: \").concat(theme[\"slider-off-color\"], \";\\n  -webkit-transition: .4s;\\n  transition: .4s;\\n}\\n\\n.slider:before {\\n  position: absolute;\\n  content: \\\"\\\";\\n  height: 16px;\\n  width: 16px;\\n  left: 1px;\\n  bottom: 1px;\\n  background-color: white;\\n  -webkit-transition: .4s;\\n  transition: .4s;\\n}\\n\\ninput:checked+.slider {\\n  background-color: \").concat(theme[\"slider-on-color\"], \";\\n}\\n\\ninput:focus+.slider {\\n  box-shadow: 0 0 1px \").concat(theme[\"slider-on-color\"], \";\\n}\\n\\ninput:checked+.slider:before {\\n  -webkit-transform: translateX(16px);\\n  -ms-transform: translateX(16px);\\n  transform: translateX(16px);\\n}\\n\\n\\n/* Rounded sliders */\\n\\n.slider.round {\\n  border-radius: 34px;\\n}\\n\\n.slider.round:before {\\n  border-radius: 50%;\\n}\\n\\n\\n.m-fadeOut {\\n  visibility: hidden;\\n  opacity: 0;\\n  transition: visibility 0s linear 300ms, opacity 300ms;\\n}\\n\\n.m-fadeIn {\\n  visibility: visible;\\n  opacity: 1;\\n  transition: visibility 0s linear 0s, opacity 300ms;\\n}\\n\\n#\").concat(name, \"-settings-panel ul li:hover {\\n  background-color: \").concat(theme[\"hover-color\"], \";\\n  cursor: pointer;\\n}\\n\\n#\").concat(name, \"-settings-panel ul li label:hover {\\n  cursor: pointer;\\n}\\n\\n#\").concat(name, \"-loopbar:hover {\\n  cursor: pointer;\\n}\\n\\n#\").concat(name, \"-status-btn:hover {\\n  cursor: pointer;\\n}\\n\\n#\").concat(name, \"-controls:active #\").concat(name, \"-cursor,\\n#\").concat(name, \"-controls:hover #\").concat(name, \"-cursor  {\\n  width: 16px;\\n  height: 16px;\\n  -webkit-transition: all 0.3s ease;\\n  -moz-transition: all 0.3s ease;\\n  transition: all 0.3s ease;\\n}\\n\\n#\").concat(name, \"-volume .\").concat(name, \"-volume-cursor-transition {\\n  width: 12px;\\n  height: 12px;\\n  -webkit-transition: all 0.3s ease;\\n  -moz-transition: all 0.3s ease;\\n  transition: all 0.3s ease;\\n}\\n\\n#\").concat(name, \"-volume .\").concat(name, \"-volume-width-transition\\n {\\n  width: 50px;\\n  -webkit-transition: all 0.3s ease;\\n  -moz-transition: all 0.3s ease;\\n  transition: all 0.3s ease;\\n}\\n\\n#\").concat(name, \"-time-display.\").concat(name, \"-time-width-transition {\\n  left: 140px;\\n  -webkit-transition: left 0.3s ease;\\n  -moz-transition: left 0.3s ease;\\n  transition: left 0.3s ease;\\n}\\n\\n#\").concat(name, \"-settings-speed:hover .\").concat(name, \"-speed-btn {\\n  opacity: 1;\\n  -webkit-transition: all 0.3s ease;\\n  -moz-transition: all 0.3s ease;\\n  transition: all 0.3s ease;\\n}\\n\\n#\").concat(name, \"-status-btn:hover {\\n  opacity: 1;\\n  -webkit-transition: all 0.3s ease;\\n  -moz-transition: all 0.3s ease;\\n  transition: all 0.3s ease;\\n}\\n\\n#\").concat(name, \"-loop-btn:hover,\\n#\").concat(name, \"-dc-btn:hover\\n {\\n  cursor: pointer;\\n  opacity: 1;\\n  -webkit-transition: all 0.3s ease;\\n  -moz-transition: all 0.3s ease;\\n  transition: all 0.3s ease;\\n}\\n#\").concat(name, \"-settings-btn:hover {\\n  cursor: pointer;\\n  opacity: 1;\\n  -webkit-transition: all 0.3s ease;\\n  -moz-transition: all 0.3s ease;\\n  transition: all 0.3s ease;\\n}\\n\\n#\").concat(name, \"-full-screen-btn:hover {\\n  cursor: pointer;\\n  opacity: 1;\\n  -webkit-transition: all 0.3s ease;\\n  -moz-transition: all 0.3s ease;\\n  transition: all 0.3s ease;\\n}\");\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC1wbGF5ZXIvZGlzdC9odG1sL3N0eWxlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyL2Rpc3QvaHRtbC9zdHlsZS5qcz9lMGUxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGVtZSwgbmFtZSwgb3B0aW9ucykge1xuICByZXR1cm4gXCJcXG4uYmFja2dyb3VuZCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBibGFjaztcXG4gIHdpZHRoOjEwMCU7XFxuICBoZWlnaHQ6XCIuY29uY2F0KHRoZW1lW1wiYmFja2dyb3VuZC1oZWlnaHRcIl0sIFwiOztcXG4gIHBvc2l0aW9uOmFic29sdXRlO1xcbiAgdG9wOjBweDtcXG4gIGxlZnQ6MHB4O1xcbiAgei1pbmRleDotMjAwMDtcXG59XFxuXFxuLmZ1bGwtc2NyZWVuICNcIikuY29uY2F0KG5hbWUsIFwiLWNvbnRyb2xzIHtcXG4gIHBvc2l0aW9uOmZpeGVkO1xcbiAgbGVmdDowcHg7XFxuICBib3R0b206MHB4O1xcbn1cXG5cXG4uZnVsbC1zY3JlZW4gI1wiKS5jb25jYXQobmFtZSwgXCItc2V0dGluZ3MtcGFuZWwge1xcbiAgcG9zaXRpb246Zml4ZWQ7XFxuICBib3R0b206IDQ1cHg7XFxufVxcblxcbi5zdmcge1xcbiAgZmlsbDogXCIpLmNvbmNhdCh0aGVtZVtcInN2Zy1jb2xvclwiXSwgXCI7XFxuICBzdHJva2U6IFwiKS5jb25jYXQodGhlbWVbXCJzdmctY29sb3JcIl0sIFwiO1xcbn1cXG5cXG4ucG9pbnRlci1ldmVudC1wYW5lbCB7XFxuICBoZWlnaHQ6IFwiKS5jb25jYXQodGhlbWVbXCJwb2ludGVyLWV2ZW50LXBhbmVsLWhlaWdodFwiXSwgXCI7XFxufVxcbiNcIikuY29uY2F0KG5hbWUsIFwiLXBvaW50ZXItZXZlbnQtcGFuZWx7XFxuICB3aWR0aDoxMDAlO1xcbiAgcG9zaXRpb246YWJzb2x1dGU7XFxuICB6LWluZGV4OjEwMDtcXG59XFxuI1wiKS5jb25jYXQobmFtZSwgXCItbGlzdGVuZXItaGVscGVye1xcbiAgd2lkdGg6MTAwJTtcXG4gIGhlaWdodDpjYWxjKCAxMDAlIC0gNDVweCApO1xcbiAgcG9zaXRpb246YWJzb2x1dGU7XFxuICB6LWluZGV4OjExMDtcXG59XFxuLnN2Zy1zZWxlY3RlZCBzdmd7XFxuICBmaWxsOiBcIikuY29uY2F0KHRoZW1lW1wic3ZnLXNlbGVjdGVkLWNvbG9yXCJdLCBcIjtcXG4gIHN0cm9rZTogXCIpLmNvbmNhdCh0aGVtZVtcInN2Zy1zZWxlY3RlZC1jb2xvclwiXSwgXCI7XFxufVxcbiNcIikuY29uY2F0KG5hbWUsIFwiLWhvdmVyLWRpc3BsYXl7XFxuICAgIGJvcmRlcjogXCIpLmNvbmNhdCh0aGVtZVtcInByZXZpZXctYm9yZGVyXCJdLCBcIjtcXG4gICAgbWF4LXdpZHRoOjMwMHB4O1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBvdmVyZmxvdzpoaWRkZW47XFxuICAgIGJhY2tncm91bmQtY29sb3I6IGJsYWNrO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGJvdHRvbTogMTRweDtcXG4gICAgbGVmdDogMHB4O1xcbiAgICBhbGlnbi1pdGVtczogZmxleC1lbmQ7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbn1cXG5cXG4jXCIpLmNvbmNhdChuYW1lLCBcIi1ob3Zlci1taWxsaXNlY29uZCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBcIikuY29uY2F0KHRoZW1lW1wiaG1zLWJhY2tncm91bmQtY29sb3JcIl0sIFwiO1xcbiAgcGFkZGluZzozcHg7XFxuICBoZWlnaHQ6MThweDtcXG4gIG1hcmdpbjowcHg7XFxuICBsaW5lLWhlaWdodDoxMnB4O1xcbiAgZm9udC1zaXplOjEwcHg7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBtaW4td2lkdGg6MjBweDtcXG4gIG1heC13aWR0aDoxMDBweDtcXG4gIHotaW5kZXg6MjtcXG59XFxuI1wiKS5jb25jYXQobmFtZSwgXCIsXFxuI1wiKS5jb25jYXQobmFtZSwgXCIgOjpiZWZvcmUsXFxuI1wiKS5jb25jYXQobmFtZSwgXCIgOjphZnRlcixcXG4jXCIpLmNvbmNhdChuYW1lLCBcIiBkaXYsXFxuI1wiKS5jb25jYXQobmFtZSwgXCIgcCxcXG4jXCIpLmNvbmNhdChuYW1lLCBcIiBzcGFuLFxcbiNcIikuY29uY2F0KG5hbWUsIFwiIHVsLFxcbiNcIikuY29uY2F0KG5hbWUsIFwiIGxpIHtcXG4gIGZvbnQtd2VpZ2h0OiA0MDA7XFxuICBsaW5lLWhlaWdodDogMS45ICFpbXBvcnRhbnQ7XFxuICBjb2xvcjogXCIpLmNvbmNhdCh0aGVtZVtcImNvbG9yXCJdLCBcIjtcXG4gIGZvbnQtZmFtaWx5OiBcXFwiQ2VudHVyeSBHb3RoaWNcXFwiLCBDZW50dXJ5R290aGljLCBBcHBsZUdvdGhpYywgc2Fucy1zZXJpZjtcXG4gIGJveC1zaXppbmc6Ym9yZGVyLWJveDtcXG4gIC13ZWJraXQtdG91Y2gtY2FsbG91dDogbm9uZTtcXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbiAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XFxufVxcbiNcIikuY29uY2F0KG5hbWUsIFwiIHtcXG4gIGxpbmUtaGVpZ2h0OiAxLjk7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBvdmVyZmxvdzpoaWRkZW47XFxuICBoZWlnaHQ6IGNhbGMoMTAwJSArIFwiKS5jb25jYXQodGhlbWVbXCJjb250cm9scy1wb3NpdGlvblwiXSwgXCIpO1xcbiAgd2lkdGg6MTAwJTtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMHB4O1xcbiAgbGVmdDogMHB4O1xcbiAgXFxufVxcblxcbiNcIikuY29uY2F0KG5hbWUsIFwiLXNldHRpbmdzLXNwZWVkLWhpZGUge1xcbiAgdGV4dC1hbGlnbjpyaWdodDtcXG59XFxuXFxuLmdyYWQge1xcbiAgYmFja2dyb3VuZC1pbWFnZTogbGluZWFyLWdyYWRpZW50KFxcbiAgICByZ2JhKDEwMCwxMDAsMTAwLDAwLjAxKSxcXG4gICAgcmdiYSgxMDAsMTAwLDEwMCwwMC4wMiksXFxuICAgIHJnYmEoMTAwLDEwMCwxMDAsMDAuMDMpLFxcbiAgICByZ2JhKDEwMCwxMDAsMTAwLDAuMDQpLFxcbiAgICByZ2JhKDEwMCwxMDAsMTAwLDAuMDUpLFxcbiAgICByZ2JhKDAsMCwwLDAuMDYpLFxcbiAgICByZ2JhKDAsMCwwLDAuMDcpLFxcbiAgICByZ2JhKDAsMCwwLDAuMDgpLFxcbiAgICByZ2JhKDAsMCwwLDAuMDkpLFxcbiAgICByZ2JhKDAsMCwwLDAuMSksXFxuICAgIHJnYmEoMCwwLDAsMC4yKSxcXG4gICAgcmdiYSgwLDAsMCwwLjMpLFxcbiAgICByZ2JhKDAsMCwwLDAuNCksXFxuICAgIHJnYmEoMCwwLDAsMC40KSxcXG4gICAgcmdiYSgwLDAsMCwwLjUpLFxcbiAgICByZ2JhKDAsMCwwLDAuNiksXFxuICAgIHJnYmEoMCwwLDAsMC43KSxcXG4gICAgcmdiYSgwLDAsMCwwLjgpLFxcbiAgICByZ2JhKDAsMCwwLDAuOSksXFxuICAgIHJnYmEoMCwwLDAsMSlcXG4gICk7XFxuICBwb3NpdGlvbjphYnNvbHV0ZTtcXG4gIHdpZHRoOjEwMCU7XFxuICBoZWlnaHQ6XCIpLmNvbmNhdCh0aGVtZVtcImdyYWQtaGVpZ2h0XCJdLCBcIjtcXG4gIGxlZnQ6MHB4O1xcbiAgYm90dG9tOjBweDtcXG59XFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItY29udHJvbHMge1xcbiAgdG91Y2gtYWN0aW9uOiBub25lO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogXCIpLmNvbmNhdCh0aGVtZVtcImJhY2tncm91bmQtY29sb3JcIl0sIFwiO1xcbiAgYm9yZGVyOiBcIikuY29uY2F0KHRoZW1lW1wiY29udHJvbHMtYm9yZGVyXCJdLCBcIjtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGJvdHRvbTogXCIpLmNvbmNhdCh0aGVtZVtcImNvbnRyb2xzLWJvdHRvbVwiXSwgXCI7XFxuICBsZWZ0OiAwcHg7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogNDBweDtcXG4gIHotaW5kZXg6MTAwO1xcbn1cXG5cXG4jXCIpLmNvbmNhdChuYW1lLCBcIi10b3RhbGJhciB7XFxuICB3aWR0aDogY2FsYygxMDAlIC0gMjBweCk7XFxuICBoZWlnaHQ6IDVweDtcXG4gIG1hcmdpbjogMHB4IDEwcHggMHB4IDEwcHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjNTA1MDU2O1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgdG9wOiAwcHg7XFxuICBsZWZ0OiAwcHg7XFxufVxcblxcbiNcIikuY29uY2F0KG5hbWUsIFwiLWxvb3BiYXIge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgd2lkdGg6IDEwMCU7XFxuICB0b3A6IDBweDtcXG4gIGxlZnQ6IDBweDtcXG4gIGJhY2tncm91bmQtY29sb3I6IFwiKS5jb25jYXQodGhlbWVbXCJsb29wYmFyLWNvbG9yXCJdLCBcIjtcXG59XFxuXFxuLlwiKS5jb25jYXQobmFtZSwgXCItbG9vcC1ib3VuZGFyaWVzIHtcXG4gIHRyYW5zZm9ybTp0cmFuc2xhdGUoLTUwJSwtMzclKTtcXG4gIHBvc2l0aW9uOmFic29sdXRlO1xcbiAgd2lkdGg6MThweDtcXG4gIGJhY2tncm91bmQtY29sb3I6XCIpLmNvbmNhdCh0aGVtZVtcImxvb3BiYXItY29sb3JcIl0sIFwiO1xcbiAgaGVpZ2h0OjE4cHg7XFxuICBib3JkZXItcmFkaXVzOjEwcHg7XFxuICB6LWluZGV4OjQwO1xcbn1cXG5cXG4jXCIpLmNvbmNhdChuYW1lLCBcIi1oZWxwZXJiYXIge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgaGVpZ2h0OiAyMHB4O1xcbiAgdG9wOiAtMTBweDtcXG4gIGxlZnQ6IDBweDtcXG4gIHJpZ2h0OiAwcHg7XFxuICB6LWluZGV4OjI7XFxufVxcblxcbiNcIikuY29uY2F0KG5hbWUsIFwiLXJ1bm5pbmdiYXIge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgd2lkdGg6IDBweDtcXG4gIG1heC13aWR0aDoxMDAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogXCIpLmNvbmNhdCh0aGVtZVtcInJ1bm5pbmdiYXItY29sb3JcIl0sIFwiO1xcbn1cXG5cXG4jXCIpLmNvbmNhdChuYW1lLCBcIi1jdXJzb3Ige1xcbiAgdHJhbnNmb3JtOnRyYW5zbGF0ZSg1MCUsLTM2JSk7XFxuICByaWdodDogMHB4O1xcbiAgdG9wOiAwcHg7XFxuICB3aWR0aDogMHB4O1xcbiAgaGVpZ2h0OiAwcHg7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBcIikuY29uY2F0KHRoZW1lW1wiY3Vyc29yLWNvbG9yXCJdLCBcIjtcXG4gIGJvcmRlci1yYWRpdXM6IDEwcHg7XFxuICB6LWluZGV4OiA1O1xcbn1cXG5cXG4jXCIpLmNvbmNhdChuYW1lLCBcIi1sZWZ0LWNvbnRyb2xzIHtcXG4gIGRpc3BsYXk6aW5saW5lLWJsb2NrO1xcbiAgd2lkdGg6MjAwcHg7XFxuICBoZWlnaHQ6MzVweDtcXG59XFxuI1wiKS5jb25jYXQobmFtZSwgXCItdGltZS1kaXNwbGF5IHtcXG4gIGRpc3BsYXk6IHRhYmxlO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgd2lkdGg6IGF1dG87XFxuICBoZWlnaHQ6IDM0cHg7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBsZWZ0OiA5MHB4O1xcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBsZWZ0IDAuMXMgZWFzZTtcXG4gIC1tb3otdHJhbnNpdGlvbjogbGVmdCAwLjFzIGVhc2U7XFxuICB0cmFuc2l0aW9uOiBsZWZ0IDAuMXMgZWFzZTtcXG59XFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItdGltZS1kaXNwbGF5IHNwYW4ge1xcbiAgZGlzcGxheTogdGFibGUtY2VsbDtcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxufVxcblxcbiNcIikuY29uY2F0KG5hbWUsIFwiLXN0YXR1cy1idG4ge1xcbiAgb3BhY2l0eTogXCIpLmNvbmNhdCh0aGVtZVtcImJ1dHRvbi1vcGFjaXR5XCJdLCBcIjtcXG4gIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICBiYWNrZ3JvdW5kLXNpemU6IDEwMCUgMTAwJTtcXG4gIHdpZHRoOiA0MHB4O1xcbiAgaGVpZ2h0OiAyNXB4O1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgb3ZlcmZsb3c6dmlzaWJsZTtcXG4gIGxlZnQ6IDBweDtcXG4gIGJvdHRvbTogMHB4O1xcbiAgbWFyZ2luOiAxMHB4IDVweCA1cHggNXB4O1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgei1pbmRleDozO1xcbn1cXG5cXG4jXCIpLmNvbmNhdChuYW1lLCBcIi12b2x1bWUge1xcbiAgb3BhY2l0eTogXCIpLmNvbmNhdCh0aGVtZVtcImJ1dHRvbi1vcGFjaXR5XCJdLCBcIjtcXG4gIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICBiYWNrZ3JvdW5kLXNpemU6IDEwMCUgMTAwJTtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGxlZnQ6IDQ1cHg7XFxuICBib3R0b206IDVweDtcXG4gIG1hcmdpbjogMTBweCA1cHggNXB4IDVweDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIHotaW5kZXg6MztcXG59XFxuI1wiKS5jb25jYXQobmFtZSwgXCItdm9sdW1lLWJ0biB7XFxuICB3aWR0aDogMjBweDtcXG4gIGhlaWdodDogMTVweDtcXG59XFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItdm9sdW1lYmFyIHtcXG4gIHdpZHRoOiAwcHg7XFxuICBoZWlnaHQ6IDNweDtcXG4gIGJhY2tncm91bmQtY29sb3I6IFwiKS5jb25jYXQodGhlbWVbXCJsb29wYmFyLWNvbG9yXCJdLCBcIjtcXG4gIHBvc2l0aW9uOmFic29sdXRlO1xcbiAgbGVmdDoyNXB4O1xcbiAgYm90dG9tOjZweDtcXG4gIC13ZWJraXQtdHJhbnNpdGlvbjogbGVmdCAwLjFzIGVhc2U7XFxuICAtbW96LXRyYW5zaXRpb246IGxlZnQgMC4xcyBlYXNlO1xcbiAgdHJhbnNpdGlvbjogbGVmdCAwLjFzIGVhc2U7XFxufVxcblxcbiNcIikuY29uY2F0KG5hbWUsIFwiLXZvbHVtZWJhci1oZWxwZXIge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgd2lkdGg6IDBweDtcXG4gIGhlaWdodDogMTVweDtcXG4gIGxlZnQ6MjVweDtcXG4gIGJvdHRvbTowcHg7XFxuICB6LWluZGV4OjEwO1xcbn1cXG5cXG4jXCIpLmNvbmNhdChuYW1lLCBcIi12b2x1bWViYXItYWN0aXZlIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHdpZHRoOiAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIGJhY2tncm91bmQtY29sb3I6IFwiKS5jb25jYXQodGhlbWVbXCJjb2xvclwiXSwgXCI7XFxuICBwb3NpdGlvbjpyZWxhdGl2ZTtcXG4gIGxlZnQ6MHB4O1xcbiAgYm90dG9tOjBweDtcXG59XFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItdm9sdW1lLWN1cnNvciB7XFxuICB0cmFuc2Zvcm06dHJhbnNsYXRlKDUwJSwtMzYlKTtcXG4gIHJpZ2h0OiAwcHg7XFxuICB0b3A6IDBweDtcXG4gIHdpZHRoOiAwcHg7XFxuICBoZWlnaHQ6IDBweDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGJhY2tncm91bmQtY29sb3I6IFwiKS5jb25jYXQodGhlbWVbXCJjb2xvclwiXSwgXCI7XFxuICBib3JkZXItcmFkaXVzOiAxMHB4O1xcbiAgei1pbmRleDogNTtcXG59XFxuXFxuLlwiKS5jb25jYXQobmFtZSwgXCItbG9vcGJhci10aW1lIHtcXG4gIHdpZHRoOmF1dG87XFxuICBoZWlnaHQ6MTJweDtcXG4gIGJhY2tncm91bmQtY29sb3I6XCIpLmNvbmNhdCh0aGVtZVtcImJhY2tncm91bmQtY29sb3JcIl0sIFwiO1xcbiAgbGluZS1oZWlnaHQ6MTBweDtcXG4gIGZvbnQtc2l6ZToxMHB4O1xcbn1cXG5cXG4jXCIpLmNvbmNhdChuYW1lLCBcIi1sb29wLXRpbWUge1xcbiAgbWFyZ2luOiA3cHg7XFxufVxcblxcbiNcIikuY29uY2F0KG5hbWUsIFwiLWRjLWJ0biB7XFxuICAgIG9wYWNpdHk6IDAuODtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG4gICAgYmFja2dyb3VuZC1zaXplOiAxMDAlIDEwMCU7XFxuICAgIHdpZHRoOiAyMHB4O1xcbiAgICBoZWlnaHQ6IDE1cHg7XFxuICAgIG1hcmdpbjogN3B4IDEwcHggNXB4IDBweDtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgxLjUsMS41KTtcXG59XFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItbG9vcC1idG4ge1xcbiAgb3BhY2l0eTogXCIpLmNvbmNhdCh0aGVtZVtcImJ1dHRvbi1vcGFjaXR5XCJdLCBcIjtcXG4gIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICBiYWNrZ3JvdW5kLXNpemU6IDEwMCUgMTAwJTtcXG4gIHdpZHRoOiAxNXB4O1xcbiAgaGVpZ2h0OiAxNXB4O1xcbiAgbWFyZ2luOiAxMHB4IDVweCA1cHggNXB4O1xcbn1cXG5cXG5cXG4jXCIpLmNvbmNhdChuYW1lLCBcIi1zZXR0aW5ncy1idG4ge1xcbiAgb3BhY2l0eTogXCIpLmNvbmNhdCh0aGVtZVtcImJ1dHRvbi1vcGFjaXR5XCJdLCBcIjtcXG4gIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICBiYWNrZ3JvdW5kLXNpemU6IDEwMCUgMTAwJTtcXG4gIHdpZHRoOiAxNXB4O1xcbiAgaGVpZ2h0OiAxNXB4O1xcbiAgbWFyZ2luOiAxMHB4IDVweCA1cHggNXB4O1xcbn1cXG5cXG4jXCIpLmNvbmNhdChuYW1lLCBcIi1mdWxsLXNjcmVlbi1idG4ge1xcbiAgb3BhY2l0eTogXCIpLmNvbmNhdCh0aGVtZVtcImJ1dHRvbi1vcGFjaXR5XCJdLCBcIjtcXG4gIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICBiYWNrZ3JvdW5kLXNpemU6IDEwMCUgMTAwJTtcXG4gIHdpZHRoOiAxNXB4O1xcbiAgaGVpZ2h0OiAxNXB4O1xcbiAgbWFyZ2luOiAxMHB4IDVweCA1cHggNXB4O1xcbn1cXG5cXG4uXCIpLmNvbmNhdChuYW1lLCBcIi1zcGVlZC1idG4ge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgb3BhY2l0eTogXCIpLmNvbmNhdCh0aGVtZVtcImJ1dHRvbi1vcGFjaXR5XCJdLCBcIjtcXG4gIHdpZHRoOiAxMHB4O1xcbiAgaGVpZ2h0OiAxMHB4O1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbn1cXG5cXG4jXCIpLmNvbmNhdChuYW1lLCBcIi1zZXR0aW5ncy1wYW5lbCB7XFxuICB0b3VjaC1hY3Rpb246IG5vbmU7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgei1pbmRleDoxMDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBcIikuY29uY2F0KHRoZW1lW1wic2V0dGluZ3MtYmFja2dyb3VuZC1jb2xvclwiXSwgXCI7XFxuICBib3R0b206IFwiKS5jb25jYXQodGhlbWVbXCJzZXR0aW5ncy1wYW5lbC1ib3R0b21cIl0sIFwiO1xcbiAgYm9yZGVyOiBcIikuY29uY2F0KHRoZW1lW1wiYm9yZGVyXCJdLCBcIjtcXG4gIHJpZ2h0OiA1cHg7XFxuICB3aWR0aDogMTY0cHg7XFxuICBoZWlnaHQ6IDE3NXB4O1xcbiAgcGFkZGluZzogNXB4O1xcbiAgbWFyZ2luOiAwcHg7XFxuICAtd2Via2l0LXRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XFxuICAtbW96LXRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XFxuICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xcbn1cXG5cXG4uXCIpLmNvbmNhdChuYW1lLCBcIi1tYy1yaWdodC1jb250cm9scyB7XFxuICBmbG9hdDogcmlnaHQ7XFxufVxcblxcbi5cIikuY29uY2F0KG5hbWUsIFwiLWhpZGUge1xcbiAgZGlzcGxheTpub25lICFpbXBvcnRhbnQ7XFxufVxcblxcbiNcIikuY29uY2F0KG5hbWUsIFwiLXNwZWVkLXZhbHVlLWJhciB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB3aWR0aDogNXB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogXCIpLmNvbmNhdCh0aGVtZVtcInNwZWVkYmFyLWNvbG9yXCJdLCBcIjtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBoZWlnaHQ6IFwiKS5jb25jYXQob3B0aW9ucy5zcGVlZFZhbHVlcy5sZW5ndGggKiAxNiwgXCJweDtcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgbWFyZ2luLXJpZ2h0OjE1cHg7XFxufVxcblxcbiNcIikuY29uY2F0KG5hbWUsIFwiLXNwZWVkLXZhbHVlLWhlbHBlcmJhciB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB3aWR0aDogMjVweDtcXG4gIGhlaWdodDogXCIpLmNvbmNhdChvcHRpb25zLnNwZWVkVmFsdWVzLmxlbmd0aCAqIDE2LCBcInB4O1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICBsZWZ0OiAtNXB4O1xcbiAgei1pbmRleDoxMDtcXG59XFxuXFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItc3BlZWQtdmFsdWUtYmFyOmhvdmVyLFxcbiNcIikuY29uY2F0KG5hbWUsIFwiLXNwZWVkLXZhbHVlLWhlbHBlcmJhciB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbiNcIikuY29uY2F0KG5hbWUsIFwiLXZvbHVtZWJhcjpob3ZlcixcXG4jXCIpLmNvbmNhdChuYW1lLCBcIi12b2x1bWViYXItaGVscGVyOmhvdmVyLFxcbiNcIikuY29uY2F0KG5hbWUsIFwiLXZvbHVtZS1idG46aG92ZXIsXFxuI1wiKS5jb25jYXQobmFtZSwgXCItdm9sdW1lYmFyOmFjdGl2ZSxcXG4jXCIpLmNvbmNhdChuYW1lLCBcIi12b2x1bWViYXItaGVscGVyOmFjdGl2ZSxcXG4jXCIpLmNvbmNhdChuYW1lLCBcIi12b2x1bWUtYnRuOmFjdGl2ZSB7XFxuICBjdXJzb3I6cG9pbnRlcjtcXG59XFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItc3BlZWQtY3Vyc29yIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGJhY2tncm91bmQtY29sb3I6IFwiKS5jb25jYXQodGhlbWVbXCJzcGVlZGJhci1jdXJzb3ItY29sb3JcIl0sIFwiO1xcbiAgdG9wOiAwcHg7XFxuICBsZWZ0OiAwcHg7XFxufVxcblxcbiNcIikuY29uY2F0KG5hbWUsIFwiLXNwZWVkLWN1cnNvciBkaXYge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogXCIpLmNvbmNhdCh0aGVtZVtcInNwZWVkYmFyLWN1cnNvci1jb2xvclwiXSwgXCI7XFxuICBsZWZ0OiAtMi41cHg7XFxuICB0b3A6IC00cHg7XFxuICB3aWR0aDogMTBweDtcXG4gIGhlaWdodDogMTBweDtcXG4gIGJvcmRlci1yYWRpdXM6IDVweDtcXG59XFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItc3BlZWQtY3Vyc29yOmhvdmVyIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuLlwiKS5jb25jYXQobmFtZSwgXCItc3BlZWQtdmFsdWUtc3RlcCB7XFxuICB3aWR0aDogMTZweDtcXG4gIGJhY2tncm91bmQtY29sb3I6IFwiKS5jb25jYXQodGhlbWVbXCJzcGVlZGJhci1jb2xvclwiXSwgXCI7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgaGVpZ2h0OiAycHg7XFxuICBtYXJnaW4tdG9wOiA3cHg7XFxuICBtYXJnaW4tYm90dG9tOiA3cHg7XFxuICBmbG9hdDogbGVmdDtcXG59XFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItc3BlZWQtdmFsdWUge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIGhlaWdodDogXCIpLmNvbmNhdChvcHRpb25zLnNwZWVkVmFsdWVzLmxlbmd0aCAqIDE2LCBcInB4O1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG59XFxuXFxuLlwiKS5jb25jYXQobmFtZSwgXCItc3BlZWQtdmFsdWUge1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIGhlaWdodDogMTZweDtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG59XFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItaW5kaWNhdG9yIHtcXG4gIGZvbnQtc2l6ZTogOHB4ICFpbXBvcnRhbnQ7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBib3R0b206IDE1cHg7XFxuICBjb2xvcjogXCIpLmNvbmNhdCh0aGVtZVtcImNvbG9yXCJdLCBcIjtcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxufVxcblxcbiNcIikuY29uY2F0KG5hbWUsIFwiLXNwZWVkLXNldHRpbmdzIHtcXG4gIGhlaWdodDogXCIpLmNvbmNhdChvcHRpb25zLnNwZWVkVmFsdWVzLmxlbmd0aCAqIDE2ICsgMzIgKyAxMCAtIDIsIFwicHg7XFxufVxcblxcbiNcIikuY29uY2F0KG5hbWUsIFwiLXNwZWVkLXNldHRpbmdzIGxpLm5vLWhvdmVyIHsgXFxuICBoZWlnaHQ6IFwiKS5jb25jYXQob3B0aW9ucy5zcGVlZFZhbHVlcy5sZW5ndGggKiAxNiArIDEwIC0gMiwgXCJweDsgXFxufVxcbiNcIikuY29uY2F0KG5hbWUsIFwiLXNldHRpbmdzLXBhbmVsLlwiKS5jb25jYXQobmFtZSwgXCItc2V0dGluZ3Mtc3BlZWQtcGFuZWwge1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIHdpZHRoOiA4MHB4O1xcbiAgaGVpZ2h0OiBcIikuY29uY2F0KG9wdGlvbnMuc3BlZWRWYWx1ZXMubGVuZ3RoICogMTYgKyAzMiArIDIwLCBcInB4O1xcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xcbiAgLW1vei10cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xcbiAgdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZTtcXG59XFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItc2V0dGluZ3MtcGFuZWwuXCIpLmNvbmNhdChuYW1lLCBcIi1zZXR0aW5ncy1zcGVlZC1wYW5lbCAuXCIpLmNvbmNhdChuYW1lLCBcIi1zcGVlZC1idG4ge1xcbiAgZmxvYXQ6IGxlZnQ7XFxufVxcblxcbi5cIikuY29uY2F0KG5hbWUsIFwiLXNldHRpbmdzLXNwZWVkLXBhbmVsIHVsOmZpcnN0LWNoaWxkIHtcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcbn1cXG5cXG4jXCIpLmNvbmNhdChuYW1lLCBcIi1zcGVlZC1jdXJyZW50IHtcXG4gIGZsb2F0OiByaWdodDtcXG4gIHBhZGRpbmctcmlnaHQ6IDEwcHhcXG59XFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItc2V0dGluZ3MtcGFuZWwgLlwiKS5jb25jYXQobmFtZSwgXCItc3BlZWQtYnRuIHtcXG4gIGZsb2F0OiByaWdodDtcXG59XFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItc2V0dGluZ3MtcGFuZWwgdWwge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBtYXJnaW46IDBweDtcXG4gIHBhZGRpbmc6IDBweDtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxufVxcblxcbiNcIikuY29uY2F0KG5hbWUsIFwiLXNldHRpbmdzLXBhbmVsLlwiKS5jb25jYXQobmFtZSwgXCItc2V0dGluZ3Mtc3BlZWQtcGFuZWwgdWwgbGkge1xcbiAgbWluLXdpZHRoOiA3MHB4O1xcbn1cXG5cXG4jXCIpLmNvbmNhdChuYW1lLCBcIi1zZXR0aW5ncy1wYW5lbCB1bCBsaS5uby1ob3Zlcjpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIGN1cnNvcjogZGVmYXVsdDtcXG59XFxuXFxuZGl2LlwiKS5jb25jYXQobmFtZSwgXCItc3BlZWQtdmFsdWU6aG92ZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogXCIpLmNvbmNhdCh0aGVtZVtcImhvdmVyLWNvbG9yXCJdLCBcIjtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItc2V0dGluZ3MtcGFuZWwgdWwgbGkge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBtaW4td2lkdGg6IDE1NHB4O1xcbiAgbGlzdC1zdHlsZS10eXBlOiBub25lO1xcbiAgbWFyZ2luOiAwcHg7XFxuICBwYWRkaW5nOiA1cHg7XFxufVxcblxcbiNcIikuY29uY2F0KG5hbWUsIFwiLXNldHRpbmdzLXBhbmVsIHVsIGxpIGxhYmVsIHtcXG4gIG1hcmdpbjogMHB4O1xcbn1cXG5cXG4uc3dpdGNoIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIHdpZHRoOiAzNXB4O1xcbiAgaGVpZ2h0OiAxOHB4O1xcbn1cXG5cXG4uc3dpdGNoIGlucHV0IHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcblxcbi5zZXR0aW5ncy1zd2l0Y2gge1xcbiAgZmxvYXQ6IHJpZ2h0O1xcbn1cXG5cXG4uc2V0dGluZ3Mtc3dpdGNoOmFmdGVyIHtcXG4gIGNsZWFyOiBib3RoO1xcbn1cXG5cXG4uc2xpZGVyIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDA7XFxuICByaWdodDogMDtcXG4gIGJvdHRvbTogMDtcXG4gIGJhY2tncm91bmQtY29sb3I6IFwiKS5jb25jYXQodGhlbWVbXCJzbGlkZXItb2ZmLWNvbG9yXCJdLCBcIjtcXG4gIC13ZWJraXQtdHJhbnNpdGlvbjogLjRzO1xcbiAgdHJhbnNpdGlvbjogLjRzO1xcbn1cXG5cXG4uc2xpZGVyOmJlZm9yZSB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBjb250ZW50OiBcXFwiXFxcIjtcXG4gIGhlaWdodDogMTZweDtcXG4gIHdpZHRoOiAxNnB4O1xcbiAgbGVmdDogMXB4O1xcbiAgYm90dG9tOiAxcHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXG4gIC13ZWJraXQtdHJhbnNpdGlvbjogLjRzO1xcbiAgdHJhbnNpdGlvbjogLjRzO1xcbn1cXG5cXG5pbnB1dDpjaGVja2VkKy5zbGlkZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogXCIpLmNvbmNhdCh0aGVtZVtcInNsaWRlci1vbi1jb2xvclwiXSwgXCI7XFxufVxcblxcbmlucHV0OmZvY3VzKy5zbGlkZXIge1xcbiAgYm94LXNoYWRvdzogMCAwIDFweCBcIikuY29uY2F0KHRoZW1lW1wic2xpZGVyLW9uLWNvbG9yXCJdLCBcIjtcXG59XFxuXFxuaW5wdXQ6Y2hlY2tlZCsuc2xpZGVyOmJlZm9yZSB7XFxuICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWCgxNnB4KTtcXG4gIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMTZweCk7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMTZweCk7XFxufVxcblxcblxcbi8qIFJvdW5kZWQgc2xpZGVycyAqL1xcblxcbi5zbGlkZXIucm91bmQge1xcbiAgYm9yZGVyLXJhZGl1czogMzRweDtcXG59XFxuXFxuLnNsaWRlci5yb3VuZDpiZWZvcmUge1xcbiAgYm9yZGVyLXJhZGl1czogNTAlO1xcbn1cXG5cXG5cXG4ubS1mYWRlT3V0IHtcXG4gIHZpc2liaWxpdHk6IGhpZGRlbjtcXG4gIG9wYWNpdHk6IDA7XFxuICB0cmFuc2l0aW9uOiB2aXNpYmlsaXR5IDBzIGxpbmVhciAzMDBtcywgb3BhY2l0eSAzMDBtcztcXG59XFxuXFxuLm0tZmFkZUluIHtcXG4gIHZpc2liaWxpdHk6IHZpc2libGU7XFxuICBvcGFjaXR5OiAxO1xcbiAgdHJhbnNpdGlvbjogdmlzaWJpbGl0eSAwcyBsaW5lYXIgMHMsIG9wYWNpdHkgMzAwbXM7XFxufVxcblxcbiNcIikuY29uY2F0KG5hbWUsIFwiLXNldHRpbmdzLXBhbmVsIHVsIGxpOmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IFwiKS5jb25jYXQodGhlbWVbXCJob3Zlci1jb2xvclwiXSwgXCI7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbiNcIikuY29uY2F0KG5hbWUsIFwiLXNldHRpbmdzLXBhbmVsIHVsIGxpIGxhYmVsOmhvdmVyIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItbG9vcGJhcjpob3ZlciB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbiNcIikuY29uY2F0KG5hbWUsIFwiLXN0YXR1cy1idG46aG92ZXIge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5cXG4jXCIpLmNvbmNhdChuYW1lLCBcIi1jb250cm9sczphY3RpdmUgI1wiKS5jb25jYXQobmFtZSwgXCItY3Vyc29yLFxcbiNcIikuY29uY2F0KG5hbWUsIFwiLWNvbnRyb2xzOmhvdmVyICNcIikuY29uY2F0KG5hbWUsIFwiLWN1cnNvciAge1xcbiAgd2lkdGg6IDE2cHg7XFxuICBoZWlnaHQ6IDE2cHg7XFxuICAtd2Via2l0LXRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XFxuICAtbW96LXRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XFxuICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xcbn1cXG5cXG4jXCIpLmNvbmNhdChuYW1lLCBcIi12b2x1bWUgLlwiKS5jb25jYXQobmFtZSwgXCItdm9sdW1lLWN1cnNvci10cmFuc2l0aW9uIHtcXG4gIHdpZHRoOiAxMnB4O1xcbiAgaGVpZ2h0OiAxMnB4O1xcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xcbiAgLW1vei10cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xcbiAgdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZTtcXG59XFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItdm9sdW1lIC5cIikuY29uY2F0KG5hbWUsIFwiLXZvbHVtZS13aWR0aC10cmFuc2l0aW9uXFxuIHtcXG4gIHdpZHRoOiA1MHB4O1xcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xcbiAgLW1vei10cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xcbiAgdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZTtcXG59XFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItdGltZS1kaXNwbGF5LlwiKS5jb25jYXQobmFtZSwgXCItdGltZS13aWR0aC10cmFuc2l0aW9uIHtcXG4gIGxlZnQ6IDE0MHB4O1xcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBsZWZ0IDAuM3MgZWFzZTtcXG4gIC1tb3otdHJhbnNpdGlvbjogbGVmdCAwLjNzIGVhc2U7XFxuICB0cmFuc2l0aW9uOiBsZWZ0IDAuM3MgZWFzZTtcXG59XFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItc2V0dGluZ3Mtc3BlZWQ6aG92ZXIgLlwiKS5jb25jYXQobmFtZSwgXCItc3BlZWQtYnRuIHtcXG4gIG9wYWNpdHk6IDE7XFxuICAtd2Via2l0LXRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XFxuICAtbW96LXRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XFxuICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xcbn1cXG5cXG4jXCIpLmNvbmNhdChuYW1lLCBcIi1zdGF0dXMtYnRuOmhvdmVyIHtcXG4gIG9wYWNpdHk6IDE7XFxuICAtd2Via2l0LXRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XFxuICAtbW96LXRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XFxuICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xcbn1cXG5cXG4jXCIpLmNvbmNhdChuYW1lLCBcIi1sb29wLWJ0bjpob3ZlcixcXG4jXCIpLmNvbmNhdChuYW1lLCBcIi1kYy1idG46aG92ZXJcXG4ge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgb3BhY2l0eTogMTtcXG4gIC13ZWJraXQtdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZTtcXG4gIC1tb3otdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZTtcXG4gIHRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XFxufVxcbiNcIikuY29uY2F0KG5hbWUsIFwiLXNldHRpbmdzLWJ0bjpob3ZlciB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBvcGFjaXR5OiAxO1xcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xcbiAgLW1vei10cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xcbiAgdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZTtcXG59XFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItZnVsbC1zY3JlZW4tYnRuOmhvdmVyIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIG9wYWNpdHk6IDE7XFxuICAtd2Via2l0LXRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XFxuICAtbW96LXRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XFxuICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xcbn1cIik7XG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex-player/dist/html/style.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex-player/dist/html/svg.js":
/*!************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex-player/dist/html/svg.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar svg = module.exports = {};\nsvg.playSVG = \"\\n  <svg width=\\\"100%\\\" class=\\\"svg\\\" height=\\\"100%\\\" viewBox=\\\"0 0 36 36\\\" >\\n    <path id=\\\"play-icon\\\" data-state=\\\"paused\\\"  d=\\\"M11,10 L18,13.74 18,22.28 11,26 M18,13.74 L26,18 26,18 18,22.28\\\" />\\n  </svg>\\n\";\nsvg.dcSVG = \"\\n  <svg class=\\\"svg\\\" width=\\\"100%\\\" height=\\\"100%\\\" version=\\\"1.1\\\" id=\\\"Capa_1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" x=\\\"0px\\\" y=\\\"0px\\\"\\n   viewBox=\\\"0 0 400 400\\\" style=\\\"enable-background:new 0 0 286.374 286.374;\\\" xml:space=\\\"preserve\\\">\\n<path stroke-width=\\\"10.00\\\" stroke-linecap=\\\"butt\\\" stroke-linejoin=\\\"miter\\\" opacity=\\\"1\\\" d=\\\"M 120.17407989501953 162.04714965820312 L 121.16549682617188 320.6739196777344 Q 279.79229736328125 321.66534423828125 280.78369140625 241.36053466796875 Q 281.77508544921875 161.05572509765625 439.41046142578125 160.06431579589844 L 439.41046142578125 200.71243286132812 Q 281.7751159667969 163.03857421875 280.78369140625 241.36053466796875 Q 279.7922668457031 319.6824951171875 159.8307647705078 281.0172424316406 L 158.83935546875 198.72959899902344 Q 281.7751159667969 161.05572509765625 280.78369140625 241.36053466796875 Q 279.7922668457031 321.66534423828125 440.40185546875 320.6739196777344 L 440.40185546875 280.02581787109375 Q 280.78369140625 321.66534423828125 280.78369140625 241.36053466796875 C 280.78369140625 161.05572509765625 161.8135986328125 161.05572509765625 120.17407989501953 162.04714965820312 Z\\\" selected=\\\"true\\\" transform=\\\"matrix(1 0 0 1 0 0)\\\"></path></svg>\";\nsvg.pauseSVG = \"\\n  <svg class=\\\"svg\\\" width=\\\"100%\\\" height=\\\"100%\\\" viewBox=\\\"0 0 36 36\\\" >\\n    <path id=\\\"pause-icon\\\" data-state=\\\"playing\\\" d=\\\"M11,10 L17,10 17,26 11,26 M20,10 L26,10 26,26 20,26\\\" />\\n  </svg>\\n\";\nsvg.replaySVG = \"\\n  <svg class=\\\"svg\\\" width=\\\"100%\\\" height=\\\"100%\\\" version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" x=\\\"0px\\\" y=\\\"0px\\\" viewBox=\\\"0 0 1000 1000\\\" enable-background=\\\"new 0 0 1000 1000\\\" xml:space=\\\"preserve\\\">\\n    <metadata> Svg Vector Icons : http://www.onlinewebfonts.com/icon </metadata>\\n    <g><g transform=\\\"translate(0.000000,511.000000) scale(0.100000,-0.100000)\\\">\\n      <path d=\\\"M5356.3,4203.8c-1247.8-153.1-2324.2-811.3-3000.7-1839.7c-379.4-578.2-596.5-1209-660.5-1933.4l-27.4-294.8H883.9c-431.9,0-783.9-6.9-783.9-18.3c0-9.2,477.6-493.7,1062.7-1078.7l1062.7-1062.7L3288.1-961.1C3873.1-376,4350.8,108.5,4350.8,117.6c0,11.4-356.5,18.3-790.7,18.3h-793l18.3,189.7C2831,876.3,2991,1338,3288.1,1779.1C4122.3,3026.9,5706,3472.5,7065.8,2841.8C7639.4,2578.9,8197,2035,8487.3,1461.4C8581,1274,8709,896.9,8754.7,666.1c48-246.8,54.8-811.3,9.1-1055.8C8567.3-1491.3,7788-2394,6720.7-2750.5c-315.4-107.4-541.6-139.4-941.6-139.4c-287.9,0-415.9,11.4-598.8,50.3c-523.3,112-973.6,335.9-1371.2,681c-75.4,68.6-148.5,123.4-160,123.4c-9.1,0-187.4-169.1-393.1-374.8c-434.2-434.2-420.5-363.4-105.1-628.5c852.4-710.7,1972.3-1055.8,3046.4-937c1627.2,176,2977.8,1257,3489.8,2790.4c457.1,1368.9,169.1,2843-777,3969.7C8322.7,3484,7417.8,4000.4,6503.6,4160.4C6197.4,4213,5619.2,4235.8,5356.3,4203.8z\\\"/>\\n      <path d=\\\"M4990.7,124.5c0-1503.8,4.6-1794,32-1778c16,9.1,505.1,413.6,1085.6,895.8C7113.8,78.8,7161.8,122.2,7122.9,161c-80,75.4-2109.4,1757.5-2120.8,1757.5C4995.3,1918.5,4990.7,1111.8,4990.7,124.5z\\\"/>\\n    </g></g>\\n  </svg>\\n\";\nsvg.volumeSVG = \"\\n  <svg class=\\\"svg\\\" width=\\\"100%\\\" height=\\\"100%\\\" version=\\\"1.1\\\" id=\\\"Capa_1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" x=\\\"0px\\\" y=\\\"0px\\\"\\n   viewBox=\\\"0 0 286.374 286.374\\\" style=\\\"enable-background:new 0 0 286.374 286.374;\\\" xml:space=\\\"preserve\\\">\\n    <g id=\\\"Volume_2\\\">\\n      <path style=\\\"fill-rule:evenodd;clip-rule:evenodd;\\\" d=\\\"M233.636,26.767l-33.372,28.5c25.659,21.07,42.006,52.616,42.006,87.92\\n        c0,35.305-16.347,66.851-42.006,87.921l33.372,28.499c32.324-28.869,52.738-70.268,52.738-116.421\\n        C286.374,97.034,265.96,55.635,233.636,26.767z M177.737,74.513l-34.69,29.64c15.14,6.818,27.19,21.681,27.19,39.034\\n        s-12.05,32.216-27.19,39.034l34.69,29.64c21.294-15.717,36.051-40.586,36.051-68.674C213.788,115.099,199.03,90.23,177.737,74.513z\\n         M108.672,48.317L44.746,98.441H17.898C4.671,98.441,0,103.268,0,116.34v53.695c0,13.072,4.951,17.898,17.898,17.898h26.848\\n        l63.926,50.068c7.668,4.948,16.558,6.505,16.558-7.365V55.683C125.23,41.813,116.34,43.37,108.672,48.317z\\\"/>\\n    </g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g>\\n  </svg>\\n\";\nsvg.volumeMuteSVG = \"\\n  <svg class=\\\"svg\\\" width=\\\"100%\\\" height=\\\"100%\\\" version=\\\"1.1\\\" id=\\\"Capa_1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" x=\\\"0px\\\" y=\\\"0px\\\"\\n   viewBox=\\\"0 0 286.277 286.277\\\" style=\\\"enable-background:new 0 0 286.277 286.277;\\\" xml:space=\\\"preserve\\\">\\n    <g id=\\\"Volume_none\\\">\\n      <path style=\\\"fill-rule:evenodd;clip-rule:evenodd;\\\" d=\\\"M245.102,143.151l36.98-37.071c5.593-5.605,5.593-14.681,0-20.284\\n        l-10.124-10.142c-5.593-5.604-14.655-5.604-20.247,0l-36.98,37.071l-36.977-37.043c-5.594-5.603-14.654-5.603-20.247,0\\n        l-10.124,10.143c-5.594,5.603-5.594,14.679,0,20.282l36.987,37.053l-36.961,37.051c-5.591,5.604-5.591,14.681,0,20.284\\n        l10.126,10.141c5.593,5.604,14.654,5.604,20.247,0l36.96-37.05l36.97,37.035c5.592,5.605,14.654,5.605,20.247,0l10.124-10.141\\n        c5.593-5.603,5.593-14.68,0-20.282L245.102,143.151z M108.674,48.296L44.747,98.42H17.9c-13.228,0-17.899,4.826-17.899,17.898\\n        L0,142.719l0.001,27.295c0,13.072,4.951,17.898,17.899,17.898h26.847l63.927,50.068c7.667,4.948,16.557,6.505,16.557-7.365V55.662\\n        C125.23,41.792,116.341,43.349,108.674,48.296z\\\"/>\\n    </g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g>\\n  </svg>\\n\";\nsvg.settingsSVG = \"\\n  <svg class=\\\"svg\\\" width=\\\"100%\\\" height=\\\"100%\\\" version=\\\"1.1\\\" id=\\\"Capa_1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" x=\\\"0px\\\" y=\\\"0px\\\" viewBox=\\\"0 0 268.765 268.765\\\" style=\\\"enable-background:new 0 0 268.765 268.765;\\\" xml:space=\\\"preserve\\\">\\n    <g id=\\\"Settings\\\">\\n      <g>\\n        <path style=\\\"fill-rule:evenodd;clip-rule:evenodd;\\\" d=\\\"M267.92,119.461c-0.425-3.778-4.83-6.617-8.639-6.617\\n          c-12.315,0-23.243-7.231-27.826-18.414c-4.682-11.454-1.663-24.812,7.515-33.231c2.889-2.641,3.24-7.062,0.817-10.133\\n          c-6.303-8.004-13.467-15.234-21.289-21.5c-3.063-2.458-7.557-2.116-10.213,0.825c-8.01,8.871-22.398,12.168-33.516,7.529\\n          c-11.57-4.867-18.866-16.591-18.152-29.176c0.235-3.953-2.654-7.39-6.595-7.849c-10.038-1.161-20.164-1.197-30.232-0.08\\n          c-3.896,0.43-6.785,3.786-6.654,7.689c0.438,12.461-6.946,23.98-18.401,28.672c-10.985,4.487-25.272,1.218-33.266-7.574\\n          c-2.642-2.896-7.063-3.252-10.141-0.853c-8.054,6.319-15.379,13.555-21.74,21.493c-2.481,3.086-2.116,7.559,0.802,10.214\\n          c9.353,8.47,12.373,21.944,7.514,33.53c-4.639,11.046-16.109,18.165-29.24,18.165c-4.261-0.137-7.296,2.723-7.762,6.597\\n          c-1.182,10.096-1.196,20.383-0.058,30.561c0.422,3.794,4.961,6.608,8.812,6.608c11.702-0.299,22.937,6.946,27.65,18.415\\n          c4.698,11.454,1.678,24.804-7.514,33.23c-2.875,2.641-3.24,7.055-0.817,10.126c6.244,7.953,13.409,15.19,21.259,21.508\\n          c3.079,2.481,7.559,2.131,10.228-0.81c8.04-8.893,22.427-12.184,33.501-7.536c11.599,4.852,18.895,16.575,18.181,29.167\\n          c-0.233,3.955,2.67,7.398,6.595,7.85c5.135,0.599,10.301,0.898,15.481,0.898c4.917,0,9.835-0.27,14.752-0.817\\n          c3.897-0.43,6.784-3.786,6.653-7.696c-0.451-12.454,6.946-23.973,18.386-28.657c11.059-4.517,25.286-1.211,33.281,7.572\\n          c2.657,2.89,7.047,3.239,10.142,0.848c8.039-6.304,15.349-13.534,21.74-21.494c2.48-3.079,2.13-7.559-0.803-10.213\\n          c-9.353-8.47-12.388-21.946-7.529-33.524c4.568-10.899,15.612-18.217,27.491-18.217l1.662,0.043\\n          c3.853,0.313,7.398-2.655,7.865-6.588C269.044,139.917,269.058,129.639,267.92,119.461z M134.595,179.491\\n          c-24.718,0-44.824-20.106-44.824-44.824c0-24.717,20.106-44.824,44.824-44.824c24.717,0,44.823,20.107,44.823,44.824\\n          C179.418,159.385,159.312,179.491,134.595,179.491z\\\"/>\\n      </g>\\n    </g>\\n  <g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g>\\n  </svg>\\n\";\nsvg.arrowRightSVG = \"\\n  <svg class=\\\"svg\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" width=\\\"100%\\\" height=\\\"100%\\\" viewBox=\\\"0 0 50 80\\\" xml:space=\\\"preserve\\\">\\n    <polyline fill=\\\"none\\\" stroke-width=\\\"10\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" points=\\\"0.375,0.375 45.63,38.087 0.375,75.8 \\\"/>\\n  </svg>\\n\";\nsvg.arrowLeftSVG = \"\\n  <svg class=\\\"svg\\\" class=\\\"svg\\\" width=\\\"100%\\\" height=\\\"100%\\\" viewBox=\\\"0 0 50 80\\\" xml:space=\\\"preserve\\\">\\n    <polyline fill=\\\"none\\\" stroke-width=\\\"10\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" points=\\\"45.63,75.8 0.375,38.087 45.63,0.375 \\\"/>\\n  </svg> \\n\";\nsvg.fullScreenSVG = \"\\n  <svg class=\\\"svg\\\" width=\\\"100%\\\" height=\\\"100%\\\" version=\\\"1.1\\\" id=\\\"Capa_1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" x=\\\"0px\\\" y=\\\"0px\\\" viewBox=\\\"0 0 298.667 298.667\\\" style=\\\"enable-background:new 0 0 298.667 298.667;\\\" xml:space=\\\"preserve\\\">\\n    <g>\\n      <g>\\n        <g>\\n          <polygon points=\\\"42.667,192 0,192 0,298.667 106.667,298.667 106.667,256 42.667,256\\\"/>\\n          <polygon points=\\\"0,106.667 42.667,106.667 42.667,42.667 106.667,42.667 106.667,0 0,0\\\"/>\\n          <polygon points=\\\"192,0 192,42.667 256,42.667 256,106.667 298.667,106.667 298.667,0\\\"/>\\n          <polygon points=\\\"256,256 192,256 192,298.667 298.667,298.667 298.667,192 256,192\\\"/>\\n        </g>\\n      </g>\\n    </g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g>\\n  </svg>\\n\";\nsvg.loopSVG = \"\\n<svg class=\\\"svg\\\" width=\\\"100%\\\" height=\\\"100%\\\" version=\\\"1.1\\\" id=\\\"Capa_1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" x=\\\"0px\\\" y=\\\"0px\\\" viewBox=\\\"0 0 32 32\\\" style=\\\"enable-background:new 0 0 32 32;\\\" xml:space=\\\"preserve\\\">\\n  <g>\\n    <g id=\\\"loop_x5F_alt3\\\">\\n      <g>\\n        <path d=\\\"M28,16v2c0,1.102-0.898,2-2,2H11.996L12,16l-8,6l8,6l-0.004-4H26c3.309,0,6-2.695,6-6v-2H28z\\\"/>\\n        <path d=\\\"M4,14c0-1.105,0.898-2,2-2h14v4l7.992-6L20,4v4H6c-3.309,0-6,2.688-6,6v2h4V14z\\\"/>\\n      </g>\\n    </g>\\n  </g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g>\\n</svg>\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC1wbGF5ZXIvZGlzdC9odG1sL3N2Zy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4LXBsYXllci9kaXN0L2h0bWwvc3ZnLmpzPzU5NmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBzdmcgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuc3ZnLnBsYXlTVkcgPSBcIlxcbiAgPHN2ZyB3aWR0aD1cXFwiMTAwJVxcXCIgY2xhc3M9XFxcInN2Z1xcXCIgaGVpZ2h0PVxcXCIxMDAlXFxcIiB2aWV3Qm94PVxcXCIwIDAgMzYgMzZcXFwiID5cXG4gICAgPHBhdGggaWQ9XFxcInBsYXktaWNvblxcXCIgZGF0YS1zdGF0ZT1cXFwicGF1c2VkXFxcIiAgZD1cXFwiTTExLDEwIEwxOCwxMy43NCAxOCwyMi4yOCAxMSwyNiBNMTgsMTMuNzQgTDI2LDE4IDI2LDE4IDE4LDIyLjI4XFxcIiAvPlxcbiAgPC9zdmc+XFxuXCI7XG5zdmcuZGNTVkcgPSBcIlxcbiAgPHN2ZyBjbGFzcz1cXFwic3ZnXFxcIiB3aWR0aD1cXFwiMTAwJVxcXCIgaGVpZ2h0PVxcXCIxMDAlXFxcIiB2ZXJzaW9uPVxcXCIxLjFcXFwiIGlkPVxcXCJDYXBhXzFcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgeG1sbnM6eGxpbms9XFxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcXFwiIHg9XFxcIjBweFxcXCIgeT1cXFwiMHB4XFxcIlxcbiAgIHZpZXdCb3g9XFxcIjAgMCA0MDAgNDAwXFxcIiBzdHlsZT1cXFwiZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCAyODYuMzc0IDI4Ni4zNzQ7XFxcIiB4bWw6c3BhY2U9XFxcInByZXNlcnZlXFxcIj5cXG48cGF0aCBzdHJva2Utd2lkdGg9XFxcIjEwLjAwXFxcIiBzdHJva2UtbGluZWNhcD1cXFwiYnV0dFxcXCIgc3Ryb2tlLWxpbmVqb2luPVxcXCJtaXRlclxcXCIgb3BhY2l0eT1cXFwiMVxcXCIgZD1cXFwiTSAxMjAuMTc0MDc5ODk1MDE5NTMgMTYyLjA0NzE0OTY1ODIwMzEyIEwgMTIxLjE2NTQ5NjgyNjE3MTg4IDMyMC42NzM5MTk2Nzc3MzQ0IFEgMjc5Ljc5MjI5NzM2MzI4MTI1IDMyMS42NjUzNDQyMzgyODEyNSAyODAuNzgzNjkxNDA2MjUgMjQxLjM2MDUzNDY2Nzk2ODc1IFEgMjgxLjc3NTA4NTQ0OTIxODc1IDE2MS4wNTU3MjUwOTc2NTYyNSA0MzkuNDEwNDYxNDI1NzgxMjUgMTYwLjA2NDMxNTc5NTg5ODQ0IEwgNDM5LjQxMDQ2MTQyNTc4MTI1IDIwMC43MTI0MzI4NjEzMjgxMiBRIDI4MS43NzUxMTU5NjY3OTY5IDE2My4wMzg1NzQyMTg3NSAyODAuNzgzNjkxNDA2MjUgMjQxLjM2MDUzNDY2Nzk2ODc1IFEgMjc5Ljc5MjI2Njg0NTcwMzEgMzE5LjY4MjQ5NTExNzE4NzUgMTU5LjgzMDc2NDc3MDUwNzggMjgxLjAxNzI0MjQzMTY0MDYgTCAxNTguODM5MzU1NDY4NzUgMTk4LjcyOTU5ODk5OTAyMzQ0IFEgMjgxLjc3NTExNTk2Njc5NjkgMTYxLjA1NTcyNTA5NzY1NjI1IDI4MC43ODM2OTE0MDYyNSAyNDEuMzYwNTM0NjY3OTY4NzUgUSAyNzkuNzkyMjY2ODQ1NzAzMSAzMjEuNjY1MzQ0MjM4MjgxMjUgNDQwLjQwMTg1NTQ2ODc1IDMyMC42NzM5MTk2Nzc3MzQ0IEwgNDQwLjQwMTg1NTQ2ODc1IDI4MC4wMjU4MTc4NzEwOTM3NSBRIDI4MC43ODM2OTE0MDYyNSAzMjEuNjY1MzQ0MjM4MjgxMjUgMjgwLjc4MzY5MTQwNjI1IDI0MS4zNjA1MzQ2Njc5Njg3NSBDIDI4MC43ODM2OTE0MDYyNSAxNjEuMDU1NzI1MDk3NjU2MjUgMTYxLjgxMzU5ODYzMjgxMjUgMTYxLjA1NTcyNTA5NzY1NjI1IDEyMC4xNzQwNzk4OTUwMTk1MyAxNjIuMDQ3MTQ5NjU4MjAzMTIgWlxcXCIgc2VsZWN0ZWQ9XFxcInRydWVcXFwiIHRyYW5zZm9ybT1cXFwibWF0cml4KDEgMCAwIDEgMCAwKVxcXCI+PC9wYXRoPjwvc3ZnPlwiO1xuc3ZnLnBhdXNlU1ZHID0gXCJcXG4gIDxzdmcgY2xhc3M9XFxcInN2Z1xcXCIgd2lkdGg9XFxcIjEwMCVcXFwiIGhlaWdodD1cXFwiMTAwJVxcXCIgdmlld0JveD1cXFwiMCAwIDM2IDM2XFxcIiA+XFxuICAgIDxwYXRoIGlkPVxcXCJwYXVzZS1pY29uXFxcIiBkYXRhLXN0YXRlPVxcXCJwbGF5aW5nXFxcIiBkPVxcXCJNMTEsMTAgTDE3LDEwIDE3LDI2IDExLDI2IE0yMCwxMCBMMjYsMTAgMjYsMjYgMjAsMjZcXFwiIC8+XFxuICA8L3N2Zz5cXG5cIjtcbnN2Zy5yZXBsYXlTVkcgPSBcIlxcbiAgPHN2ZyBjbGFzcz1cXFwic3ZnXFxcIiB3aWR0aD1cXFwiMTAwJVxcXCIgaGVpZ2h0PVxcXCIxMDAlXFxcIiB2ZXJzaW9uPVxcXCIxLjFcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgeG1sbnM6eGxpbms9XFxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcXFwiIHg9XFxcIjBweFxcXCIgeT1cXFwiMHB4XFxcIiB2aWV3Qm94PVxcXCIwIDAgMTAwMCAxMDAwXFxcIiBlbmFibGUtYmFja2dyb3VuZD1cXFwibmV3IDAgMCAxMDAwIDEwMDBcXFwiIHhtbDpzcGFjZT1cXFwicHJlc2VydmVcXFwiPlxcbiAgICA8bWV0YWRhdGE+IFN2ZyBWZWN0b3IgSWNvbnMgOiBodHRwOi8vd3d3Lm9ubGluZXdlYmZvbnRzLmNvbS9pY29uIDwvbWV0YWRhdGE+XFxuICAgIDxnPjxnIHRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKDAuMDAwMDAwLDUxMS4wMDAwMDApIHNjYWxlKDAuMTAwMDAwLC0wLjEwMDAwMClcXFwiPlxcbiAgICAgIDxwYXRoIGQ9XFxcIk01MzU2LjMsNDIwMy44Yy0xMjQ3LjgtMTUzLjEtMjMyNC4yLTgxMS4zLTMwMDAuNy0xODM5LjdjLTM3OS40LTU3OC4yLTU5Ni41LTEyMDktNjYwLjUtMTkzMy40bC0yNy40LTI5NC44SDg4My45Yy00MzEuOSwwLTc4My45LTYuOS03ODMuOS0xOC4zYzAtOS4yLDQ3Ny42LTQ5My43LDEwNjIuNy0xMDc4LjdsMTA2Mi43LTEwNjIuN0wzMjg4LjEtOTYxLjFDMzg3My4xLTM3Niw0MzUwLjgsMTA4LjUsNDM1MC44LDExNy42YzAsMTEuNC0zNTYuNSwxOC4zLTc5MC43LDE4LjNoLTc5M2wxOC4zLDE4OS43QzI4MzEsODc2LjMsMjk5MSwxMzM4LDMyODguMSwxNzc5LjFDNDEyMi4zLDMwMjYuOSw1NzA2LDM0NzIuNSw3MDY1LjgsMjg0MS44Qzc2MzkuNCwyNTc4LjksODE5NywyMDM1LDg0ODcuMywxNDYxLjRDODU4MSwxMjc0LDg3MDksODk2LjksODc1NC43LDY2Ni4xYzQ4LTI0Ni44LDU0LjgtODExLjMsOS4xLTEwNTUuOEM4NTY3LjMtMTQ5MS4zLDc3ODgtMjM5NCw2NzIwLjctMjc1MC41Yy0zMTUuNC0xMDcuNC01NDEuNi0xMzkuNC05NDEuNi0xMzkuNGMtMjg3LjksMC00MTUuOSwxMS40LTU5OC44LDUwLjNjLTUyMy4zLDExMi05NzMuNiwzMzUuOS0xMzcxLjIsNjgxYy03NS40LDY4LjYtMTQ4LjUsMTIzLjQtMTYwLDEyMy40Yy05LjEsMC0xODcuNC0xNjkuMS0zOTMuMS0zNzQuOGMtNDM0LjItNDM0LjItNDIwLjUtMzYzLjQtMTA1LjEtNjI4LjVjODUyLjQtNzEwLjcsMTk3Mi4zLTEwNTUuOCwzMDQ2LjQtOTM3YzE2MjcuMiwxNzYsMjk3Ny44LDEyNTcsMzQ4OS44LDI3OTAuNGM0NTcuMSwxMzY4LjksMTY5LjEsMjg0My03NzcsMzk2OS43QzgzMjIuNywzNDg0LDc0MTcuOCw0MDAwLjQsNjUwMy42LDQxNjAuNEM2MTk3LjQsNDIxMyw1NjE5LjIsNDIzNS44LDUzNTYuMyw0MjAzLjh6XFxcIi8+XFxuICAgICAgPHBhdGggZD1cXFwiTTQ5OTAuNywxMjQuNWMwLTE1MDMuOCw0LjYtMTc5NCwzMi0xNzc4YzE2LDkuMSw1MDUuMSw0MTMuNiwxMDg1LjYsODk1LjhDNzExMy44LDc4LjgsNzE2MS44LDEyMi4yLDcxMjIuOSwxNjFjLTgwLDc1LjQtMjEwOS40LDE3NTcuNS0yMTIwLjgsMTc1Ny41QzQ5OTUuMywxOTE4LjUsNDk5MC43LDExMTEuOCw0OTkwLjcsMTI0LjV6XFxcIi8+XFxuICAgIDwvZz48L2c+XFxuICA8L3N2Zz5cXG5cIjtcbnN2Zy52b2x1bWVTVkcgPSBcIlxcbiAgPHN2ZyBjbGFzcz1cXFwic3ZnXFxcIiB3aWR0aD1cXFwiMTAwJVxcXCIgaGVpZ2h0PVxcXCIxMDAlXFxcIiB2ZXJzaW9uPVxcXCIxLjFcXFwiIGlkPVxcXCJDYXBhXzFcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgeG1sbnM6eGxpbms9XFxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcXFwiIHg9XFxcIjBweFxcXCIgeT1cXFwiMHB4XFxcIlxcbiAgIHZpZXdCb3g9XFxcIjAgMCAyODYuMzc0IDI4Ni4zNzRcXFwiIHN0eWxlPVxcXCJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDI4Ni4zNzQgMjg2LjM3NDtcXFwiIHhtbDpzcGFjZT1cXFwicHJlc2VydmVcXFwiPlxcbiAgICA8ZyBpZD1cXFwiVm9sdW1lXzJcXFwiPlxcbiAgICAgIDxwYXRoIHN0eWxlPVxcXCJmaWxsLXJ1bGU6ZXZlbm9kZDtjbGlwLXJ1bGU6ZXZlbm9kZDtcXFwiIGQ9XFxcIk0yMzMuNjM2LDI2Ljc2N2wtMzMuMzcyLDI4LjVjMjUuNjU5LDIxLjA3LDQyLjAwNiw1Mi42MTYsNDIuMDA2LDg3LjkyXFxuICAgICAgICBjMCwzNS4zMDUtMTYuMzQ3LDY2Ljg1MS00Mi4wMDYsODcuOTIxbDMzLjM3MiwyOC40OTljMzIuMzI0LTI4Ljg2OSw1Mi43MzgtNzAuMjY4LDUyLjczOC0xMTYuNDIxXFxuICAgICAgICBDMjg2LjM3NCw5Ny4wMzQsMjY1Ljk2LDU1LjYzNSwyMzMuNjM2LDI2Ljc2N3ogTTE3Ny43MzcsNzQuNTEzbC0zNC42OSwyOS42NGMxNS4xNCw2LjgxOCwyNy4xOSwyMS42ODEsMjcuMTksMzkuMDM0XFxuICAgICAgICBzLTEyLjA1LDMyLjIxNi0yNy4xOSwzOS4wMzRsMzQuNjksMjkuNjRjMjEuMjk0LTE1LjcxNywzNi4wNTEtNDAuNTg2LDM2LjA1MS02OC42NzRDMjEzLjc4OCwxMTUuMDk5LDE5OS4wMyw5MC4yMywxNzcuNzM3LDc0LjUxM3pcXG4gICAgICAgICBNMTA4LjY3Miw0OC4zMTdMNDQuNzQ2LDk4LjQ0MUgxNy44OThDNC42NzEsOTguNDQxLDAsMTAzLjI2OCwwLDExNi4zNHY1My42OTVjMCwxMy4wNzIsNC45NTEsMTcuODk4LDE3Ljg5OCwxNy44OThoMjYuODQ4XFxuICAgICAgICBsNjMuOTI2LDUwLjA2OGM3LjY2OCw0Ljk0OCwxNi41NTgsNi41MDUsMTYuNTU4LTcuMzY1VjU1LjY4M0MxMjUuMjMsNDEuODEzLDExNi4zNCw0My4zNywxMDguNjcyLDQ4LjMxN3pcXFwiLz5cXG4gICAgPC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPlxcbiAgPC9zdmc+XFxuXCI7XG5zdmcudm9sdW1lTXV0ZVNWRyA9IFwiXFxuICA8c3ZnIGNsYXNzPVxcXCJzdmdcXFwiIHdpZHRoPVxcXCIxMDAlXFxcIiBoZWlnaHQ9XFxcIjEwMCVcXFwiIHZlcnNpb249XFxcIjEuMVxcXCIgaWQ9XFxcIkNhcGFfMVxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB4bWxuczp4bGluaz1cXFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1xcXCIgeD1cXFwiMHB4XFxcIiB5PVxcXCIwcHhcXFwiXFxuICAgdmlld0JveD1cXFwiMCAwIDI4Ni4yNzcgMjg2LjI3N1xcXCIgc3R5bGU9XFxcImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMjg2LjI3NyAyODYuMjc3O1xcXCIgeG1sOnNwYWNlPVxcXCJwcmVzZXJ2ZVxcXCI+XFxuICAgIDxnIGlkPVxcXCJWb2x1bWVfbm9uZVxcXCI+XFxuICAgICAgPHBhdGggc3R5bGU9XFxcImZpbGwtcnVsZTpldmVub2RkO2NsaXAtcnVsZTpldmVub2RkO1xcXCIgZD1cXFwiTTI0NS4xMDIsMTQzLjE1MWwzNi45OC0zNy4wNzFjNS41OTMtNS42MDUsNS41OTMtMTQuNjgxLDAtMjAuMjg0XFxuICAgICAgICBsLTEwLjEyNC0xMC4xNDJjLTUuNTkzLTUuNjA0LTE0LjY1NS01LjYwNC0yMC4yNDcsMGwtMzYuOTgsMzcuMDcxbC0zNi45NzctMzcuMDQzYy01LjU5NC01LjYwMy0xNC42NTQtNS42MDMtMjAuMjQ3LDBcXG4gICAgICAgIGwtMTAuMTI0LDEwLjE0M2MtNS41OTQsNS42MDMtNS41OTQsMTQuNjc5LDAsMjAuMjgybDM2Ljk4NywzNy4wNTNsLTM2Ljk2MSwzNy4wNTFjLTUuNTkxLDUuNjA0LTUuNTkxLDE0LjY4MSwwLDIwLjI4NFxcbiAgICAgICAgbDEwLjEyNiwxMC4xNDFjNS41OTMsNS42MDQsMTQuNjU0LDUuNjA0LDIwLjI0NywwbDM2Ljk2LTM3LjA1bDM2Ljk3LDM3LjAzNWM1LjU5Miw1LjYwNSwxNC42NTQsNS42MDUsMjAuMjQ3LDBsMTAuMTI0LTEwLjE0MVxcbiAgICAgICAgYzUuNTkzLTUuNjAzLDUuNTkzLTE0LjY4LDAtMjAuMjgyTDI0NS4xMDIsMTQzLjE1MXogTTEwOC42NzQsNDguMjk2TDQ0Ljc0Nyw5OC40MkgxNy45Yy0xMy4yMjgsMC0xNy44OTksNC44MjYtMTcuODk5LDE3Ljg5OFxcbiAgICAgICAgTDAsMTQyLjcxOWwwLjAwMSwyNy4yOTVjMCwxMy4wNzIsNC45NTEsMTcuODk4LDE3Ljg5OSwxNy44OThoMjYuODQ3bDYzLjkyNyw1MC4wNjhjNy42NjcsNC45NDgsMTYuNTU3LDYuNTA1LDE2LjU1Ny03LjM2NVY1NS42NjJcXG4gICAgICAgIEMxMjUuMjMsNDEuNzkyLDExNi4zNDEsNDMuMzQ5LDEwOC42NzQsNDguMjk2elxcXCIvPlxcbiAgICA8L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+XFxuICA8L3N2Zz5cXG5cIjtcbnN2Zy5zZXR0aW5nc1NWRyA9IFwiXFxuICA8c3ZnIGNsYXNzPVxcXCJzdmdcXFwiIHdpZHRoPVxcXCIxMDAlXFxcIiBoZWlnaHQ9XFxcIjEwMCVcXFwiIHZlcnNpb249XFxcIjEuMVxcXCIgaWQ9XFxcIkNhcGFfMVxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB4bWxuczp4bGluaz1cXFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1xcXCIgeD1cXFwiMHB4XFxcIiB5PVxcXCIwcHhcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNjguNzY1IDI2OC43NjVcXFwiIHN0eWxlPVxcXCJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDI2OC43NjUgMjY4Ljc2NTtcXFwiIHhtbDpzcGFjZT1cXFwicHJlc2VydmVcXFwiPlxcbiAgICA8ZyBpZD1cXFwiU2V0dGluZ3NcXFwiPlxcbiAgICAgIDxnPlxcbiAgICAgICAgPHBhdGggc3R5bGU9XFxcImZpbGwtcnVsZTpldmVub2RkO2NsaXAtcnVsZTpldmVub2RkO1xcXCIgZD1cXFwiTTI2Ny45MiwxMTkuNDYxYy0wLjQyNS0zLjc3OC00LjgzLTYuNjE3LTguNjM5LTYuNjE3XFxuICAgICAgICAgIGMtMTIuMzE1LDAtMjMuMjQzLTcuMjMxLTI3LjgyNi0xOC40MTRjLTQuNjgyLTExLjQ1NC0xLjY2My0yNC44MTIsNy41MTUtMzMuMjMxYzIuODg5LTIuNjQxLDMuMjQtNy4wNjIsMC44MTctMTAuMTMzXFxuICAgICAgICAgIGMtNi4zMDMtOC4wMDQtMTMuNDY3LTE1LjIzNC0yMS4yODktMjEuNWMtMy4wNjMtMi40NTgtNy41NTctMi4xMTYtMTAuMjEzLDAuODI1Yy04LjAxLDguODcxLTIyLjM5OCwxMi4xNjgtMzMuNTE2LDcuNTI5XFxuICAgICAgICAgIGMtMTEuNTctNC44NjctMTguODY2LTE2LjU5MS0xOC4xNTItMjkuMTc2YzAuMjM1LTMuOTUzLTIuNjU0LTcuMzktNi41OTUtNy44NDljLTEwLjAzOC0xLjE2MS0yMC4xNjQtMS4xOTctMzAuMjMyLTAuMDhcXG4gICAgICAgICAgYy0zLjg5NiwwLjQzLTYuNzg1LDMuNzg2LTYuNjU0LDcuNjg5YzAuNDM4LDEyLjQ2MS02Ljk0NiwyMy45OC0xOC40MDEsMjguNjcyYy0xMC45ODUsNC40ODctMjUuMjcyLDEuMjE4LTMzLjI2Ni03LjU3NFxcbiAgICAgICAgICBjLTIuNjQyLTIuODk2LTcuMDYzLTMuMjUyLTEwLjE0MS0wLjg1M2MtOC4wNTQsNi4zMTktMTUuMzc5LDEzLjU1NS0yMS43NCwyMS40OTNjLTIuNDgxLDMuMDg2LTIuMTE2LDcuNTU5LDAuODAyLDEwLjIxNFxcbiAgICAgICAgICBjOS4zNTMsOC40NywxMi4zNzMsMjEuOTQ0LDcuNTE0LDMzLjUzYy00LjYzOSwxMS4wNDYtMTYuMTA5LDE4LjE2NS0yOS4yNCwxOC4xNjVjLTQuMjYxLTAuMTM3LTcuMjk2LDIuNzIzLTcuNzYyLDYuNTk3XFxuICAgICAgICAgIGMtMS4xODIsMTAuMDk2LTEuMTk2LDIwLjM4My0wLjA1OCwzMC41NjFjMC40MjIsMy43OTQsNC45NjEsNi42MDgsOC44MTIsNi42MDhjMTEuNzAyLTAuMjk5LDIyLjkzNyw2Ljk0NiwyNy42NSwxOC40MTVcXG4gICAgICAgICAgYzQuNjk4LDExLjQ1NCwxLjY3OCwyNC44MDQtNy41MTQsMzMuMjNjLTIuODc1LDIuNjQxLTMuMjQsNy4wNTUtMC44MTcsMTAuMTI2YzYuMjQ0LDcuOTUzLDEzLjQwOSwxNS4xOSwyMS4yNTksMjEuNTA4XFxuICAgICAgICAgIGMzLjA3OSwyLjQ4MSw3LjU1OSwyLjEzMSwxMC4yMjgtMC44MWM4LjA0LTguODkzLDIyLjQyNy0xMi4xODQsMzMuNTAxLTcuNTM2YzExLjU5OSw0Ljg1MiwxOC44OTUsMTYuNTc1LDE4LjE4MSwyOS4xNjdcXG4gICAgICAgICAgYy0wLjIzMywzLjk1NSwyLjY3LDcuMzk4LDYuNTk1LDcuODVjNS4xMzUsMC41OTksMTAuMzAxLDAuODk4LDE1LjQ4MSwwLjg5OGM0LjkxNywwLDkuODM1LTAuMjcsMTQuNzUyLTAuODE3XFxuICAgICAgICAgIGMzLjg5Ny0wLjQzLDYuNzg0LTMuNzg2LDYuNjUzLTcuNjk2Yy0wLjQ1MS0xMi40NTQsNi45NDYtMjMuOTczLDE4LjM4Ni0yOC42NTdjMTEuMDU5LTQuNTE3LDI1LjI4Ni0xLjIxMSwzMy4yODEsNy41NzJcXG4gICAgICAgICAgYzIuNjU3LDIuODksNy4wNDcsMy4yMzksMTAuMTQyLDAuODQ4YzguMDM5LTYuMzA0LDE1LjM0OS0xMy41MzQsMjEuNzQtMjEuNDk0YzIuNDgtMy4wNzksMi4xMy03LjU1OS0wLjgwMy0xMC4yMTNcXG4gICAgICAgICAgYy05LjM1My04LjQ3LTEyLjM4OC0yMS45NDYtNy41MjktMzMuNTI0YzQuNTY4LTEwLjg5OSwxNS42MTItMTguMjE3LDI3LjQ5MS0xOC4yMTdsMS42NjIsMC4wNDNcXG4gICAgICAgICAgYzMuODUzLDAuMzEzLDcuMzk4LTIuNjU1LDcuODY1LTYuNTg4QzI2OS4wNDQsMTM5LjkxNywyNjkuMDU4LDEyOS42MzksMjY3LjkyLDExOS40NjF6IE0xMzQuNTk1LDE3OS40OTFcXG4gICAgICAgICAgYy0yNC43MTgsMC00NC44MjQtMjAuMTA2LTQ0LjgyNC00NC44MjRjMC0yNC43MTcsMjAuMTA2LTQ0LjgyNCw0NC44MjQtNDQuODI0YzI0LjcxNywwLDQ0LjgyMywyMC4xMDcsNDQuODIzLDQ0LjgyNFxcbiAgICAgICAgICBDMTc5LjQxOCwxNTkuMzg1LDE1OS4zMTIsMTc5LjQ5MSwxMzQuNTk1LDE3OS40OTF6XFxcIi8+XFxuICAgICAgPC9nPlxcbiAgICA8L2c+XFxuICA8Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz5cXG4gIDwvc3ZnPlxcblwiO1xuc3ZnLmFycm93UmlnaHRTVkcgPSBcIlxcbiAgPHN2ZyBjbGFzcz1cXFwic3ZnXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHhtbG5zOnhsaW5rPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXFxcIiB3aWR0aD1cXFwiMTAwJVxcXCIgaGVpZ2h0PVxcXCIxMDAlXFxcIiB2aWV3Qm94PVxcXCIwIDAgNTAgODBcXFwiIHhtbDpzcGFjZT1cXFwicHJlc2VydmVcXFwiPlxcbiAgICA8cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxMFxcXCIgc3Ryb2tlLWxpbmVjYXA9XFxcInJvdW5kXFxcIiBzdHJva2UtbGluZWpvaW49XFxcInJvdW5kXFxcIiBwb2ludHM9XFxcIjAuMzc1LDAuMzc1IDQ1LjYzLDM4LjA4NyAwLjM3NSw3NS44IFxcXCIvPlxcbiAgPC9zdmc+XFxuXCI7XG5zdmcuYXJyb3dMZWZ0U1ZHID0gXCJcXG4gIDxzdmcgY2xhc3M9XFxcInN2Z1xcXCIgY2xhc3M9XFxcInN2Z1xcXCIgd2lkdGg9XFxcIjEwMCVcXFwiIGhlaWdodD1cXFwiMTAwJVxcXCIgdmlld0JveD1cXFwiMCAwIDUwIDgwXFxcIiB4bWw6c3BhY2U9XFxcInByZXNlcnZlXFxcIj5cXG4gICAgPHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZS13aWR0aD1cXFwiMTBcXFwiIHN0cm9rZS1saW5lY2FwPVxcXCJyb3VuZFxcXCIgc3Ryb2tlLWxpbmVqb2luPVxcXCJyb3VuZFxcXCIgcG9pbnRzPVxcXCI0NS42Myw3NS44IDAuMzc1LDM4LjA4NyA0NS42MywwLjM3NSBcXFwiLz5cXG4gIDwvc3ZnPiBcXG5cIjtcbnN2Zy5mdWxsU2NyZWVuU1ZHID0gXCJcXG4gIDxzdmcgY2xhc3M9XFxcInN2Z1xcXCIgd2lkdGg9XFxcIjEwMCVcXFwiIGhlaWdodD1cXFwiMTAwJVxcXCIgdmVyc2lvbj1cXFwiMS4xXFxcIiBpZD1cXFwiQ2FwYV8xXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHhtbG5zOnhsaW5rPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXFxcIiB4PVxcXCIwcHhcXFwiIHk9XFxcIjBweFxcXCIgdmlld0JveD1cXFwiMCAwIDI5OC42NjcgMjk4LjY2N1xcXCIgc3R5bGU9XFxcImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMjk4LjY2NyAyOTguNjY3O1xcXCIgeG1sOnNwYWNlPVxcXCJwcmVzZXJ2ZVxcXCI+XFxuICAgIDxnPlxcbiAgICAgIDxnPlxcbiAgICAgICAgPGc+XFxuICAgICAgICAgIDxwb2x5Z29uIHBvaW50cz1cXFwiNDIuNjY3LDE5MiAwLDE5MiAwLDI5OC42NjcgMTA2LjY2NywyOTguNjY3IDEwNi42NjcsMjU2IDQyLjY2NywyNTZcXFwiLz5cXG4gICAgICAgICAgPHBvbHlnb24gcG9pbnRzPVxcXCIwLDEwNi42NjcgNDIuNjY3LDEwNi42NjcgNDIuNjY3LDQyLjY2NyAxMDYuNjY3LDQyLjY2NyAxMDYuNjY3LDAgMCwwXFxcIi8+XFxuICAgICAgICAgIDxwb2x5Z29uIHBvaW50cz1cXFwiMTkyLDAgMTkyLDQyLjY2NyAyNTYsNDIuNjY3IDI1NiwxMDYuNjY3IDI5OC42NjcsMTA2LjY2NyAyOTguNjY3LDBcXFwiLz5cXG4gICAgICAgICAgPHBvbHlnb24gcG9pbnRzPVxcXCIyNTYsMjU2IDE5MiwyNTYgMTkyLDI5OC42NjcgMjk4LjY2NywyOTguNjY3IDI5OC42NjcsMTkyIDI1NiwxOTJcXFwiLz5cXG4gICAgICAgIDwvZz5cXG4gICAgICA8L2c+XFxuICAgIDwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz5cXG4gIDwvc3ZnPlxcblwiO1xuc3ZnLmxvb3BTVkcgPSBcIlxcbjxzdmcgY2xhc3M9XFxcInN2Z1xcXCIgd2lkdGg9XFxcIjEwMCVcXFwiIGhlaWdodD1cXFwiMTAwJVxcXCIgdmVyc2lvbj1cXFwiMS4xXFxcIiBpZD1cXFwiQ2FwYV8xXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHhtbG5zOnhsaW5rPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXFxcIiB4PVxcXCIwcHhcXFwiIHk9XFxcIjBweFxcXCIgdmlld0JveD1cXFwiMCAwIDMyIDMyXFxcIiBzdHlsZT1cXFwiZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCAzMiAzMjtcXFwiIHhtbDpzcGFjZT1cXFwicHJlc2VydmVcXFwiPlxcbiAgPGc+XFxuICAgIDxnIGlkPVxcXCJsb29wX3g1Rl9hbHQzXFxcIj5cXG4gICAgICA8Zz5cXG4gICAgICAgIDxwYXRoIGQ9XFxcIk0yOCwxNnYyYzAsMS4xMDItMC44OTgsMi0yLDJIMTEuOTk2TDEyLDE2bC04LDZsOCw2bC0wLjAwNC00SDI2YzMuMzA5LDAsNi0yLjY5NSw2LTZ2LTJIMjh6XFxcIi8+XFxuICAgICAgICA8cGF0aCBkPVxcXCJNNCwxNGMwLTEuMTA1LDAuODk4LTIsMi0yaDE0djRsNy45OTItNkwyMCw0djRINmMtMy4zMDksMC02LDIuNjg4LTYsNnYyaDRWMTR6XFxcIi8+XFxuICAgICAgPC9nPlxcbiAgICA8L2c+XFxuICA8L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+XFxuPC9zdmc+XCI7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex-player/dist/html/svg.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex-player/dist/html/themes.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex-player/dist/html/themes.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar themes = {\n  default: {\n    \"settings-background-color\": \"whitesmoke\",\n    \"hms-background-color\": \"whitesmoke\",\n    \"background-color\": \"whitesmoke\",\n    \"grad-height\": \"0px\",\n    color: \"black\",\n    \"svg-color\": \"black\",\n    \"loopbar-color\": \"#808086\",\n    \"speedbar-color\": \"#666\",\n    \"runningbar-color\": \"red\",\n    \"cursor-color\": \"red\",\n    \"speedbar-cursor-color\": \"red\",\n    \"button-opacity\": \"0.8\",\n    \"hover-color\": \"rgba(200, 200, 200, 0.5)\",\n    \"slider-off-color\": \"#ccc\",\n    \"slider-on-color\": \"red\",\n    \"preview-border\": \"1px solid rgba(0,0,0,1)\",\n    border: \"1px solid rgba(255,255,255,0.2)\",\n    \"controls-border\": \"none\",\n    \"svg-selected-color\": \"red\"\n  },\n  dark: {\n    \"settings-background-color\": \"black\",\n    \"hms-background-color\": \"black\",\n    \"background-color\": \"black\",\n    \"grad-height\": \"0px\",\n    color: \"white\",\n    \"svg-color\": \"white\",\n    \"loopbar-color\": \"#808086\",\n    \"speedbar-color\": \"#666\",\n    \"runningbar-color\": \"red\",\n    \"cursor-color\": \"red\",\n    \"speedbar-cursor-color\": \"red\",\n    \"button-opacity\": \"0.8\",\n    \"hover-color\": \"rgba(90, 90, 90, 0.5)\",\n    \"slider-off-color\": \"#ccc\",\n    \"slider-on-color\": \"red\",\n    \"preview-border\": \"1px solid rgba(0,0,0,1)\",\n    border: \"1px solid rgba(255,255,255,0.2)\",\n    \"controls-border\": \"none\",\n    \"svg-selected-color\": \"red\"\n  },\n  whiteGold: {\n    \"settings-background-color\": \"white\",\n    \"hms-background-color\": \"white\",\n    \"background-color\": \"white\",\n    \"grad-height\": \"0px\",\n    color: \"#a17f1a\",\n    \"svg-color\": \"#a17f1a\",\n    \"loopbar-color\": \"#808086\",\n    \"speedbar-color\": \"#666\",\n    \"runningbar-color\": \"#a17f1a\",\n    \"cursor-color\": \"#a17f1a\",\n    \"speedbar-cursor-color\": \"#a17f1a\",\n    \"button-opacity\": \"0.8\",\n    \"hover-color\": \"rgba(200, 200, 200, 0.5)\",\n    \"slider-off-color\": \"#ccc\",\n    \"slider-on-color\": \"#a17f1a\",\n    \"preview-border\": \"1px solid rgba(0,0,0,1)\",\n    border: \"1px solid rgba(255,255,255,0.2)\",\n    \"controls-border\": \"none\",\n    \"svg-selected-color\": \"red\"\n  },\n  darkGold: {\n    \"settings-background-color\": \"black\",\n    \"hms-background-color\": \"black\",\n    \"background-color\": \"black\",\n    \"grad-height\": \"0px\",\n    color: \"#a17f1a\",\n    \"svg-color\": \"#a17f1a\",\n    \"loopbar-color\": \"#808086\",\n    \"speedbar-color\": \"#666\",\n    \"runningbar-color\": \"#a17f1a\",\n    \"cursor-color\": \"#a17f1a\",\n    \"speedbar-cursor-color\": \"#a17f1a\",\n    \"button-opacity\": \"0.8\",\n    \"hover-color\": \"rgba(90, 90, 90, 0.5)\",\n    \"slider-off-color\": \"#ccc\",\n    \"slider-on-color\": \"#a17f1a\",\n    \"preview-border\": \"1px solid rgba(0,0,0,1)\",\n    border: \"1px solid rgba(255,255,255,0.2)\",\n    \"controls-border\": \"none\",\n    \"svg-selected-color\": \"red\"\n  },\n  transparent: {\n    \"background-color\": \"transparent\",\n    \"settings-background-color\": \"rgba(0,0,0,0.5)\",\n    \"hms-background-color\": \"rgba(0,0,0,0.5)\",\n    \"preview-border\": \"1px solid rgba(0,0,0,1)\",\n    color: \"white\",\n    \"grad-height\": \"60px\",\n    \"svg-color\": \"white\",\n    \"loopbar-color\": \"#808086\",\n    \"speedbar-color\": \"#666\",\n    \"runningbar-color\": \"red\",\n    \"cursor-color\": \"red\",\n    \"speedbar-cursor-color\": \"red\",\n    \"button-opacity\": \"0.8\",\n    \"hover-color\": \"rgba(200, 200, 200, 0.5)\",\n    \"slider-off-color\": \"#ccc\",\n    \"slider-on-color\": \"red\",\n    border: \"1px solid rgba(255,255,255,0.1)\",\n    \"controls-border\": \"1px solid rgba(255,255,255,0.1)\",\n    \"svg-selected-color\": \"red\"\n  },\n  \"on-top\": {\n    \"background-height\": \"100%\",\n    \"pointer-event-panel-height\": \"calc(100% - 45px)\",\n    \"controls-bottom\": \"0px\",\n    \"settings-panel-bottom\": \"45px\",\n    \"controls-position\": \"0px\"\n  },\n  \"position-default\": {\n    \"background-height\": \"calc(100% - 40px)\",\n    \"pointer-event-panel-height\": \"calc(100% - 40px)\",\n    \"controls-bottom\": \"-0px\",\n    \"settings-panel-bottom\": \"45px\",\n    \"controls-position\": \"40px\"\n  }\n};\n\nmodule.exports = function (theme) {\n  return themes[theme];\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC1wbGF5ZXIvZGlzdC9odG1sL3RoZW1lcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4LXBsYXllci9kaXN0L2h0bWwvdGhlbWVzLmpzP2I1MDIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB0aGVtZXMgPSB7XG4gIGRlZmF1bHQ6IHtcbiAgICBcInNldHRpbmdzLWJhY2tncm91bmQtY29sb3JcIjogXCJ3aGl0ZXNtb2tlXCIsXG4gICAgXCJobXMtYmFja2dyb3VuZC1jb2xvclwiOiBcIndoaXRlc21va2VcIixcbiAgICBcImJhY2tncm91bmQtY29sb3JcIjogXCJ3aGl0ZXNtb2tlXCIsXG4gICAgXCJncmFkLWhlaWdodFwiOiBcIjBweFwiLFxuICAgIGNvbG9yOiBcImJsYWNrXCIsXG4gICAgXCJzdmctY29sb3JcIjogXCJibGFja1wiLFxuICAgIFwibG9vcGJhci1jb2xvclwiOiBcIiM4MDgwODZcIixcbiAgICBcInNwZWVkYmFyLWNvbG9yXCI6IFwiIzY2NlwiLFxuICAgIFwicnVubmluZ2Jhci1jb2xvclwiOiBcInJlZFwiLFxuICAgIFwiY3Vyc29yLWNvbG9yXCI6IFwicmVkXCIsXG4gICAgXCJzcGVlZGJhci1jdXJzb3ItY29sb3JcIjogXCJyZWRcIixcbiAgICBcImJ1dHRvbi1vcGFjaXR5XCI6IFwiMC44XCIsXG4gICAgXCJob3Zlci1jb2xvclwiOiBcInJnYmEoMjAwLCAyMDAsIDIwMCwgMC41KVwiLFxuICAgIFwic2xpZGVyLW9mZi1jb2xvclwiOiBcIiNjY2NcIixcbiAgICBcInNsaWRlci1vbi1jb2xvclwiOiBcInJlZFwiLFxuICAgIFwicHJldmlldy1ib3JkZXJcIjogXCIxcHggc29saWQgcmdiYSgwLDAsMCwxKVwiLFxuICAgIGJvcmRlcjogXCIxcHggc29saWQgcmdiYSgyNTUsMjU1LDI1NSwwLjIpXCIsXG4gICAgXCJjb250cm9scy1ib3JkZXJcIjogXCJub25lXCIsXG4gICAgXCJzdmctc2VsZWN0ZWQtY29sb3JcIjogXCJyZWRcIlxuICB9LFxuICBkYXJrOiB7XG4gICAgXCJzZXR0aW5ncy1iYWNrZ3JvdW5kLWNvbG9yXCI6IFwiYmxhY2tcIixcbiAgICBcImhtcy1iYWNrZ3JvdW5kLWNvbG9yXCI6IFwiYmxhY2tcIixcbiAgICBcImJhY2tncm91bmQtY29sb3JcIjogXCJibGFja1wiLFxuICAgIFwiZ3JhZC1oZWlnaHRcIjogXCIwcHhcIixcbiAgICBjb2xvcjogXCJ3aGl0ZVwiLFxuICAgIFwic3ZnLWNvbG9yXCI6IFwid2hpdGVcIixcbiAgICBcImxvb3BiYXItY29sb3JcIjogXCIjODA4MDg2XCIsXG4gICAgXCJzcGVlZGJhci1jb2xvclwiOiBcIiM2NjZcIixcbiAgICBcInJ1bm5pbmdiYXItY29sb3JcIjogXCJyZWRcIixcbiAgICBcImN1cnNvci1jb2xvclwiOiBcInJlZFwiLFxuICAgIFwic3BlZWRiYXItY3Vyc29yLWNvbG9yXCI6IFwicmVkXCIsXG4gICAgXCJidXR0b24tb3BhY2l0eVwiOiBcIjAuOFwiLFxuICAgIFwiaG92ZXItY29sb3JcIjogXCJyZ2JhKDkwLCA5MCwgOTAsIDAuNSlcIixcbiAgICBcInNsaWRlci1vZmYtY29sb3JcIjogXCIjY2NjXCIsXG4gICAgXCJzbGlkZXItb24tY29sb3JcIjogXCJyZWRcIixcbiAgICBcInByZXZpZXctYm9yZGVyXCI6IFwiMXB4IHNvbGlkIHJnYmEoMCwwLDAsMSlcIixcbiAgICBib3JkZXI6IFwiMXB4IHNvbGlkIHJnYmEoMjU1LDI1NSwyNTUsMC4yKVwiLFxuICAgIFwiY29udHJvbHMtYm9yZGVyXCI6IFwibm9uZVwiLFxuICAgIFwic3ZnLXNlbGVjdGVkLWNvbG9yXCI6IFwicmVkXCJcbiAgfSxcbiAgd2hpdGVHb2xkOiB7XG4gICAgXCJzZXR0aW5ncy1iYWNrZ3JvdW5kLWNvbG9yXCI6IFwid2hpdGVcIixcbiAgICBcImhtcy1iYWNrZ3JvdW5kLWNvbG9yXCI6IFwid2hpdGVcIixcbiAgICBcImJhY2tncm91bmQtY29sb3JcIjogXCJ3aGl0ZVwiLFxuICAgIFwiZ3JhZC1oZWlnaHRcIjogXCIwcHhcIixcbiAgICBjb2xvcjogXCIjYTE3ZjFhXCIsXG4gICAgXCJzdmctY29sb3JcIjogXCIjYTE3ZjFhXCIsXG4gICAgXCJsb29wYmFyLWNvbG9yXCI6IFwiIzgwODA4NlwiLFxuICAgIFwic3BlZWRiYXItY29sb3JcIjogXCIjNjY2XCIsXG4gICAgXCJydW5uaW5nYmFyLWNvbG9yXCI6IFwiI2ExN2YxYVwiLFxuICAgIFwiY3Vyc29yLWNvbG9yXCI6IFwiI2ExN2YxYVwiLFxuICAgIFwic3BlZWRiYXItY3Vyc29yLWNvbG9yXCI6IFwiI2ExN2YxYVwiLFxuICAgIFwiYnV0dG9uLW9wYWNpdHlcIjogXCIwLjhcIixcbiAgICBcImhvdmVyLWNvbG9yXCI6IFwicmdiYSgyMDAsIDIwMCwgMjAwLCAwLjUpXCIsXG4gICAgXCJzbGlkZXItb2ZmLWNvbG9yXCI6IFwiI2NjY1wiLFxuICAgIFwic2xpZGVyLW9uLWNvbG9yXCI6IFwiI2ExN2YxYVwiLFxuICAgIFwicHJldmlldy1ib3JkZXJcIjogXCIxcHggc29saWQgcmdiYSgwLDAsMCwxKVwiLFxuICAgIGJvcmRlcjogXCIxcHggc29saWQgcmdiYSgyNTUsMjU1LDI1NSwwLjIpXCIsXG4gICAgXCJjb250cm9scy1ib3JkZXJcIjogXCJub25lXCIsXG4gICAgXCJzdmctc2VsZWN0ZWQtY29sb3JcIjogXCJyZWRcIlxuICB9LFxuICBkYXJrR29sZDoge1xuICAgIFwic2V0dGluZ3MtYmFja2dyb3VuZC1jb2xvclwiOiBcImJsYWNrXCIsXG4gICAgXCJobXMtYmFja2dyb3VuZC1jb2xvclwiOiBcImJsYWNrXCIsXG4gICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwiYmxhY2tcIixcbiAgICBcImdyYWQtaGVpZ2h0XCI6IFwiMHB4XCIsXG4gICAgY29sb3I6IFwiI2ExN2YxYVwiLFxuICAgIFwic3ZnLWNvbG9yXCI6IFwiI2ExN2YxYVwiLFxuICAgIFwibG9vcGJhci1jb2xvclwiOiBcIiM4MDgwODZcIixcbiAgICBcInNwZWVkYmFyLWNvbG9yXCI6IFwiIzY2NlwiLFxuICAgIFwicnVubmluZ2Jhci1jb2xvclwiOiBcIiNhMTdmMWFcIixcbiAgICBcImN1cnNvci1jb2xvclwiOiBcIiNhMTdmMWFcIixcbiAgICBcInNwZWVkYmFyLWN1cnNvci1jb2xvclwiOiBcIiNhMTdmMWFcIixcbiAgICBcImJ1dHRvbi1vcGFjaXR5XCI6IFwiMC44XCIsXG4gICAgXCJob3Zlci1jb2xvclwiOiBcInJnYmEoOTAsIDkwLCA5MCwgMC41KVwiLFxuICAgIFwic2xpZGVyLW9mZi1jb2xvclwiOiBcIiNjY2NcIixcbiAgICBcInNsaWRlci1vbi1jb2xvclwiOiBcIiNhMTdmMWFcIixcbiAgICBcInByZXZpZXctYm9yZGVyXCI6IFwiMXB4IHNvbGlkIHJnYmEoMCwwLDAsMSlcIixcbiAgICBib3JkZXI6IFwiMXB4IHNvbGlkIHJnYmEoMjU1LDI1NSwyNTUsMC4yKVwiLFxuICAgIFwiY29udHJvbHMtYm9yZGVyXCI6IFwibm9uZVwiLFxuICAgIFwic3ZnLXNlbGVjdGVkLWNvbG9yXCI6IFwicmVkXCJcbiAgfSxcbiAgdHJhbnNwYXJlbnQ6IHtcbiAgICBcImJhY2tncm91bmQtY29sb3JcIjogXCJ0cmFuc3BhcmVudFwiLFxuICAgIFwic2V0dGluZ3MtYmFja2dyb3VuZC1jb2xvclwiOiBcInJnYmEoMCwwLDAsMC41KVwiLFxuICAgIFwiaG1zLWJhY2tncm91bmQtY29sb3JcIjogXCJyZ2JhKDAsMCwwLDAuNSlcIixcbiAgICBcInByZXZpZXctYm9yZGVyXCI6IFwiMXB4IHNvbGlkIHJnYmEoMCwwLDAsMSlcIixcbiAgICBjb2xvcjogXCJ3aGl0ZVwiLFxuICAgIFwiZ3JhZC1oZWlnaHRcIjogXCI2MHB4XCIsXG4gICAgXCJzdmctY29sb3JcIjogXCJ3aGl0ZVwiLFxuICAgIFwibG9vcGJhci1jb2xvclwiOiBcIiM4MDgwODZcIixcbiAgICBcInNwZWVkYmFyLWNvbG9yXCI6IFwiIzY2NlwiLFxuICAgIFwicnVubmluZ2Jhci1jb2xvclwiOiBcInJlZFwiLFxuICAgIFwiY3Vyc29yLWNvbG9yXCI6IFwicmVkXCIsXG4gICAgXCJzcGVlZGJhci1jdXJzb3ItY29sb3JcIjogXCJyZWRcIixcbiAgICBcImJ1dHRvbi1vcGFjaXR5XCI6IFwiMC44XCIsXG4gICAgXCJob3Zlci1jb2xvclwiOiBcInJnYmEoMjAwLCAyMDAsIDIwMCwgMC41KVwiLFxuICAgIFwic2xpZGVyLW9mZi1jb2xvclwiOiBcIiNjY2NcIixcbiAgICBcInNsaWRlci1vbi1jb2xvclwiOiBcInJlZFwiLFxuICAgIGJvcmRlcjogXCIxcHggc29saWQgcmdiYSgyNTUsMjU1LDI1NSwwLjEpXCIsXG4gICAgXCJjb250cm9scy1ib3JkZXJcIjogXCIxcHggc29saWQgcmdiYSgyNTUsMjU1LDI1NSwwLjEpXCIsXG4gICAgXCJzdmctc2VsZWN0ZWQtY29sb3JcIjogXCJyZWRcIlxuICB9LFxuICBcIm9uLXRvcFwiOiB7XG4gICAgXCJiYWNrZ3JvdW5kLWhlaWdodFwiOiBcIjEwMCVcIixcbiAgICBcInBvaW50ZXItZXZlbnQtcGFuZWwtaGVpZ2h0XCI6IFwiY2FsYygxMDAlIC0gNDVweClcIixcbiAgICBcImNvbnRyb2xzLWJvdHRvbVwiOiBcIjBweFwiLFxuICAgIFwic2V0dGluZ3MtcGFuZWwtYm90dG9tXCI6IFwiNDVweFwiLFxuICAgIFwiY29udHJvbHMtcG9zaXRpb25cIjogXCIwcHhcIlxuICB9LFxuICBcInBvc2l0aW9uLWRlZmF1bHRcIjoge1xuICAgIFwiYmFja2dyb3VuZC1oZWlnaHRcIjogXCJjYWxjKDEwMCUgLSA0MHB4KVwiLFxuICAgIFwicG9pbnRlci1ldmVudC1wYW5lbC1oZWlnaHRcIjogXCJjYWxjKDEwMCUgLSA0MHB4KVwiLFxuICAgIFwiY29udHJvbHMtYm90dG9tXCI6IFwiLTBweFwiLFxuICAgIFwic2V0dGluZ3MtcGFuZWwtYm90dG9tXCI6IFwiNDVweFwiLFxuICAgIFwiY29udHJvbHMtcG9zaXRpb25cIjogXCI0MHB4XCJcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGhlbWUpIHtcbiAgcmV0dXJuIHRoZW1lc1t0aGVtZV07XG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex-player/dist/html/themes.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex-player/dist/listeners/body.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex-player/dist/listeners/body.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _require = __webpack_require__(/*! ../helpers */ \"./node_modules/@kissmybutton/motorcortex-player/dist/helpers.js\"),\n    el = _require.el,\n    elid = _require.elid;\n\nmodule.exports = function (_this) {\n  el(\"body\")[0].addEventListener(\"click\", function (e) {\n    if (e.target.className === \"\".concat(_this.name, \"-speed-value\")) {\n      var speedDisplay = e.target.dataset.speedValue - 0;\n      _this.clip.executionSpeed = e.target.dataset.speedValue;\n      _this.clip.speed == 1 ? speedDisplay = \"Normal\" : speedDisplay = _this.clip.speed;\n      _this.elements.speedCurrent.innerHTML = speedDisplay;\n      var step = 1 / (_this.options.speedValues.length - 1);\n      var positionY = (e.target.dataset.zone * step - 1) * -1 * ((_this.options.speedValues.length - 1) * 16);\n      elid(\"\".concat(_this.name, \"-speed-cursor\")).style.top = positionY + \"px\";\n    }\n  });\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC1wbGF5ZXIvZGlzdC9saXN0ZW5lcnMvYm9keS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4LXBsYXllci9kaXN0L2xpc3RlbmVycy9ib2R5LmpzPzkwZGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzXCIpLFxuICAgIGVsID0gX3JlcXVpcmUuZWwsXG4gICAgZWxpZCA9IF9yZXF1aXJlLmVsaWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF90aGlzKSB7XG4gIGVsKFwiYm9keVwiKVswXS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS50YXJnZXQuY2xhc3NOYW1lID09PSBcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1zcGVlZC12YWx1ZVwiKSkge1xuICAgICAgdmFyIHNwZWVkRGlzcGxheSA9IGUudGFyZ2V0LmRhdGFzZXQuc3BlZWRWYWx1ZSAtIDA7XG4gICAgICBfdGhpcy5jbGlwLmV4ZWN1dGlvblNwZWVkID0gZS50YXJnZXQuZGF0YXNldC5zcGVlZFZhbHVlO1xuICAgICAgX3RoaXMuY2xpcC5zcGVlZCA9PSAxID8gc3BlZWREaXNwbGF5ID0gXCJOb3JtYWxcIiA6IHNwZWVkRGlzcGxheSA9IF90aGlzLmNsaXAuc3BlZWQ7XG4gICAgICBfdGhpcy5lbGVtZW50cy5zcGVlZEN1cnJlbnQuaW5uZXJIVE1MID0gc3BlZWREaXNwbGF5O1xuICAgICAgdmFyIHN0ZXAgPSAxIC8gKF90aGlzLm9wdGlvbnMuc3BlZWRWYWx1ZXMubGVuZ3RoIC0gMSk7XG4gICAgICB2YXIgcG9zaXRpb25ZID0gKGUudGFyZ2V0LmRhdGFzZXQuem9uZSAqIHN0ZXAgLSAxKSAqIC0xICogKChfdGhpcy5vcHRpb25zLnNwZWVkVmFsdWVzLmxlbmd0aCAtIDEpICogMTYpO1xuICAgICAgZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1zcGVlZC1jdXJzb3JcIikpLnN0eWxlLnRvcCA9IHBvc2l0aW9uWSArIFwicHhcIjtcbiAgICB9XG4gIH0pO1xufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex-player/dist/listeners/body.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex-player/dist/listeners/controls.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex-player/dist/listeners/controls.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _require = __webpack_require__(/*! ../helpers */ \"./node_modules/@kissmybutton/motorcortex-player/dist/helpers.js\"),\n    elid = _require.elid;\n\nmodule.exports = function (_this) {\n  elid(\"\".concat(_this.name, \"-controls\")).onmouseover = function () {\n    if (!_this.settings.loopActivated) {\n      return;\n    }\n\n    _this.elements.loopBarStart.classList.remove(\"m-fadeOut\");\n\n    _this.elements.loopBarEnd.classList.remove(\"m-fadeOut\");\n\n    _this.elements.loopBarStart.classList.add(\"m-fadeIn\");\n\n    _this.elements.loopBarEnd.classList.add(\"m-fadeIn\");\n  };\n\n  elid(\"\".concat(_this.name, \"-controls\")).onmouseout = function (event) {\n    var e = event.toElement || event.relatedTarget || event.target;\n\n    if (isDescendant(this, e) || e === this) {\n      return;\n    }\n\n    if (!_this.settings.loopActivated) {\n      return;\n    }\n\n    _this.elements.loopBarStart.classList.add(\"m-fadeOut\");\n\n    _this.elements.loopBarEnd.classList.add(\"m-fadeOut\");\n\n    _this.elements.loopBarStart.classList.remove(\"m-fadeIn\");\n\n    _this.elements.loopBarEnd.classList.remove(\"m-fadeIn\");\n  };\n\n  var twt = false;\n\n  elid(\"\".concat(_this.name, \"-controls\")).ontouchstart = function (event) {\n    var e = event.toElement || event.relatedTarget || event.target;\n\n    if (isDescendant(_this.elements.statusButton, e) || e === _this.elements.statusButton || isDescendant(_this.elements.settingsButton, e) || e === _this.elements.settingsButton || isDescendant(_this.elements.fullScreenButton, e) || e === _this.elements.fullScreenButton || isDescendant(_this.elements.loopButton, e) || e === _this.elements.loopButton || isDescendant(_this.elements.totalBar, e) || e === _this.elements.totalBar) {\n      return;\n    }\n\n    _this.elements.volumeControl.className = \"\".concat(_this.name, \"-volume-width-transition\");\n    _this.elements.volumeBar.className = \"\".concat(_this.name, \"-volume-width-transition\");\n    _this.elements.volumeBarHelper.className = \"\".concat(_this.name, \"-volume-width-transition\");\n    _this.elements.timeDisplay.className = \"\".concat(_this.name, \"-time-width-transition\");\n    _this.elements.volumeCursor.className = \"\".concat(_this.name, \"-volume-cursor-transition\");\n    twt = true;\n  };\n\n  window.addEventListener(\"touchstart\", function (event) {\n    var e = event.toElement || event.relatedTarget || event.target;\n\n    if (isDescendant(elid(\"\".concat(_this.name, \"-controls\")), e) || e === elid(\"\".concat(_this.name, \"-controls\"))) {\n      return;\n    }\n\n    if (twt) {\n      _this.elements.volumeControl.className = \"\";\n      _this.elements.volumeBar.className = \"\";\n      _this.elements.volumeBarHelper.className = \"\";\n      _this.elements.timeDisplay.className = \"\";\n      _this.elements.volumeCursor.className = \"\";\n    }\n  }); // elid(`${_this.name}-left-controls`).ontouchstart = function (event) {\n  //   const e = event.toElement || event.relatedTarget || event.target;\n  //     if (isDescendant(_this.elements.statusBtn, e) || e === _this.elements.statusBtn) {\n  //       return false;\n  //     }\n  //     return \"\";\n  // };\n};\n\nfunction isDescendant(parent, child) {\n  var node = child.parentNode;\n\n  while (node != null) {\n    if (node == parent) {\n      return true;\n    }\n\n    node = node.parentNode;\n  }\n\n  return false;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC1wbGF5ZXIvZGlzdC9saXN0ZW5lcnMvY29udHJvbHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC1wbGF5ZXIvZGlzdC9saXN0ZW5lcnMvY29udHJvbHMuanM/MmZkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4uL2hlbHBlcnNcIiksXG4gICAgZWxpZCA9IF9yZXF1aXJlLmVsaWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF90aGlzKSB7XG4gIGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItY29udHJvbHNcIikpLm9ubW91c2VvdmVyID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghX3RoaXMuc2V0dGluZ3MubG9vcEFjdGl2YXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIF90aGlzLmVsZW1lbnRzLmxvb3BCYXJTdGFydC5jbGFzc0xpc3QucmVtb3ZlKFwibS1mYWRlT3V0XCIpO1xuXG4gICAgX3RoaXMuZWxlbWVudHMubG9vcEJhckVuZC5jbGFzc0xpc3QucmVtb3ZlKFwibS1mYWRlT3V0XCIpO1xuXG4gICAgX3RoaXMuZWxlbWVudHMubG9vcEJhclN0YXJ0LmNsYXNzTGlzdC5hZGQoXCJtLWZhZGVJblwiKTtcblxuICAgIF90aGlzLmVsZW1lbnRzLmxvb3BCYXJFbmQuY2xhc3NMaXN0LmFkZChcIm0tZmFkZUluXCIpO1xuICB9O1xuXG4gIGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItY29udHJvbHNcIikpLm9ubW91c2VvdXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZSA9IGV2ZW50LnRvRWxlbWVudCB8fCBldmVudC5yZWxhdGVkVGFyZ2V0IHx8IGV2ZW50LnRhcmdldDtcblxuICAgIGlmIChpc0Rlc2NlbmRhbnQodGhpcywgZSkgfHwgZSA9PT0gdGhpcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghX3RoaXMuc2V0dGluZ3MubG9vcEFjdGl2YXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIF90aGlzLmVsZW1lbnRzLmxvb3BCYXJTdGFydC5jbGFzc0xpc3QuYWRkKFwibS1mYWRlT3V0XCIpO1xuXG4gICAgX3RoaXMuZWxlbWVudHMubG9vcEJhckVuZC5jbGFzc0xpc3QuYWRkKFwibS1mYWRlT3V0XCIpO1xuXG4gICAgX3RoaXMuZWxlbWVudHMubG9vcEJhclN0YXJ0LmNsYXNzTGlzdC5yZW1vdmUoXCJtLWZhZGVJblwiKTtcblxuICAgIF90aGlzLmVsZW1lbnRzLmxvb3BCYXJFbmQuY2xhc3NMaXN0LnJlbW92ZShcIm0tZmFkZUluXCIpO1xuICB9O1xuXG4gIHZhciB0d3QgPSBmYWxzZTtcblxuICBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLWNvbnRyb2xzXCIpKS5vbnRvdWNoc3RhcnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZSA9IGV2ZW50LnRvRWxlbWVudCB8fCBldmVudC5yZWxhdGVkVGFyZ2V0IHx8IGV2ZW50LnRhcmdldDtcblxuICAgIGlmIChpc0Rlc2NlbmRhbnQoX3RoaXMuZWxlbWVudHMuc3RhdHVzQnV0dG9uLCBlKSB8fCBlID09PSBfdGhpcy5lbGVtZW50cy5zdGF0dXNCdXR0b24gfHwgaXNEZXNjZW5kYW50KF90aGlzLmVsZW1lbnRzLnNldHRpbmdzQnV0dG9uLCBlKSB8fCBlID09PSBfdGhpcy5lbGVtZW50cy5zZXR0aW5nc0J1dHRvbiB8fCBpc0Rlc2NlbmRhbnQoX3RoaXMuZWxlbWVudHMuZnVsbFNjcmVlbkJ1dHRvbiwgZSkgfHwgZSA9PT0gX3RoaXMuZWxlbWVudHMuZnVsbFNjcmVlbkJ1dHRvbiB8fCBpc0Rlc2NlbmRhbnQoX3RoaXMuZWxlbWVudHMubG9vcEJ1dHRvbiwgZSkgfHwgZSA9PT0gX3RoaXMuZWxlbWVudHMubG9vcEJ1dHRvbiB8fCBpc0Rlc2NlbmRhbnQoX3RoaXMuZWxlbWVudHMudG90YWxCYXIsIGUpIHx8IGUgPT09IF90aGlzLmVsZW1lbnRzLnRvdGFsQmFyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX3RoaXMuZWxlbWVudHMudm9sdW1lQ29udHJvbC5jbGFzc05hbWUgPSBcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi12b2x1bWUtd2lkdGgtdHJhbnNpdGlvblwiKTtcbiAgICBfdGhpcy5lbGVtZW50cy52b2x1bWVCYXIuY2xhc3NOYW1lID0gXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItdm9sdW1lLXdpZHRoLXRyYW5zaXRpb25cIik7XG4gICAgX3RoaXMuZWxlbWVudHMudm9sdW1lQmFySGVscGVyLmNsYXNzTmFtZSA9IFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXZvbHVtZS13aWR0aC10cmFuc2l0aW9uXCIpO1xuICAgIF90aGlzLmVsZW1lbnRzLnRpbWVEaXNwbGF5LmNsYXNzTmFtZSA9IFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXRpbWUtd2lkdGgtdHJhbnNpdGlvblwiKTtcbiAgICBfdGhpcy5lbGVtZW50cy52b2x1bWVDdXJzb3IuY2xhc3NOYW1lID0gXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItdm9sdW1lLWN1cnNvci10cmFuc2l0aW9uXCIpO1xuICAgIHR3dCA9IHRydWU7XG4gIH07XG5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBlID0gZXZlbnQudG9FbGVtZW50IHx8IGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgZXZlbnQudGFyZ2V0O1xuXG4gICAgaWYgKGlzRGVzY2VuZGFudChlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLWNvbnRyb2xzXCIpKSwgZSkgfHwgZSA9PT0gZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1jb250cm9sc1wiKSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHd0KSB7XG4gICAgICBfdGhpcy5lbGVtZW50cy52b2x1bWVDb250cm9sLmNsYXNzTmFtZSA9IFwiXCI7XG4gICAgICBfdGhpcy5lbGVtZW50cy52b2x1bWVCYXIuY2xhc3NOYW1lID0gXCJcIjtcbiAgICAgIF90aGlzLmVsZW1lbnRzLnZvbHVtZUJhckhlbHBlci5jbGFzc05hbWUgPSBcIlwiO1xuICAgICAgX3RoaXMuZWxlbWVudHMudGltZURpc3BsYXkuY2xhc3NOYW1lID0gXCJcIjtcbiAgICAgIF90aGlzLmVsZW1lbnRzLnZvbHVtZUN1cnNvci5jbGFzc05hbWUgPSBcIlwiO1xuICAgIH1cbiAgfSk7IC8vIGVsaWQoYCR7X3RoaXMubmFtZX0tbGVmdC1jb250cm9sc2ApLm9udG91Y2hzdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAvLyAgIGNvbnN0IGUgPSBldmVudC50b0VsZW1lbnQgfHwgZXZlbnQucmVsYXRlZFRhcmdldCB8fCBldmVudC50YXJnZXQ7XG4gIC8vICAgICBpZiAoaXNEZXNjZW5kYW50KF90aGlzLmVsZW1lbnRzLnN0YXR1c0J0biwgZSkgfHwgZSA9PT0gX3RoaXMuZWxlbWVudHMuc3RhdHVzQnRuKSB7XG4gIC8vICAgICAgIHJldHVybiBmYWxzZTtcbiAgLy8gICAgIH1cbiAgLy8gICAgIHJldHVybiBcIlwiO1xuICAvLyB9O1xufTtcblxuZnVuY3Rpb24gaXNEZXNjZW5kYW50KHBhcmVudCwgY2hpbGQpIHtcbiAgdmFyIG5vZGUgPSBjaGlsZC5wYXJlbnROb2RlO1xuXG4gIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICBpZiAobm9kZSA9PSBwYXJlbnQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex-player/dist/listeners/controls.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex-player/dist/listeners/donkeyclip.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex-player/dist/listeners/donkeyclip.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function (_this) {\n  _this.elements.donkeyclipButton.addEventListener(\"click\", function () {\n    var u = create_UUID();\n    var popupDC = window.open(\"https://donkeyclip.com?u=\".concat(u));\n\n    var definition = _this.clip.exportState({\n      unprocessed: true\n    });\n\n    var clipClass = _this.clipClass;\n    window.addEventListener(\"message\", receiveMessage, false);\n\n    function receiveMessage(event) {\n      if (event.data === u) {\n        popupDC.postMessage(JSON.stringify({\n          definition: definition,\n          clipClass: clipClass,\n          u: u\n        }), \"*\");\n      }\n    }\n  });\n};\n\nfunction create_UUID() {\n  var dt = new Date().getTime();\n  var uuid = \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n    var r = (dt + Math.random() * 16) % 16 | 0;\n    dt = Math.floor(dt / 16);\n    return (c == \"x\" ? r : r & 0x3 | 0x8).toString(16);\n  });\n  return uuid;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC1wbGF5ZXIvZGlzdC9saXN0ZW5lcnMvZG9ua2V5Y2xpcC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4LXBsYXllci9kaXN0L2xpc3RlbmVycy9kb25rZXljbGlwLmpzP2MzMjAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF90aGlzKSB7XG4gIF90aGlzLmVsZW1lbnRzLmRvbmtleWNsaXBCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdSA9IGNyZWF0ZV9VVUlEKCk7XG4gICAgdmFyIHBvcHVwREMgPSB3aW5kb3cub3BlbihcImh0dHBzOi8vZG9ua2V5Y2xpcC5jb20/dT1cIi5jb25jYXQodSkpO1xuXG4gICAgdmFyIGRlZmluaXRpb24gPSBfdGhpcy5jbGlwLmV4cG9ydFN0YXRlKHtcbiAgICAgIHVucHJvY2Vzc2VkOiB0cnVlXG4gICAgfSk7XG5cbiAgICB2YXIgY2xpcENsYXNzID0gX3RoaXMuY2xpcENsYXNzO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCByZWNlaXZlTWVzc2FnZSwgZmFsc2UpO1xuXG4gICAgZnVuY3Rpb24gcmVjZWl2ZU1lc3NhZ2UoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5kYXRhID09PSB1KSB7XG4gICAgICAgIHBvcHVwREMucG9zdE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGRlZmluaXRpb246IGRlZmluaXRpb24sXG4gICAgICAgICAgY2xpcENsYXNzOiBjbGlwQ2xhc3MsXG4gICAgICAgICAgdTogdVxuICAgICAgICB9KSwgXCIqXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVfVVVJRCgpIHtcbiAgdmFyIGR0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIHZhciB1dWlkID0gXCJ4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHhcIi5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgdmFyIHIgPSAoZHQgKyBNYXRoLnJhbmRvbSgpICogMTYpICUgMTYgfCAwO1xuICAgIGR0ID0gTWF0aC5mbG9vcihkdCAvIDE2KTtcbiAgICByZXR1cm4gKGMgPT0gXCJ4XCIgPyByIDogciAmIDB4MyB8IDB4OCkudG9TdHJpbmcoMTYpO1xuICB9KTtcbiAgcmV0dXJuIHV1aWQ7XG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex-player/dist/listeners/donkeyclip.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex-player/dist/listeners/fullscreen.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex-player/dist/listeners/fullscreen.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function (_this) {\n  _this.elements.fullScreenButton.addEventListener(\"click\", function () {\n    var elFullScreen = _this.clip.props.host.className.includes(\"full-screen\");\n\n    _this.clip.props.host !== _this.options.host && !elFullScreen ? _this.clip.props.host.appendChild(_this.elements.mcPlayer) : null;\n    _this.clip.props.host !== _this.options.host && elFullScreen ? _this.options.host.appendChild(_this.elements.mcPlayer) : null;\n    elFullScreen ? _this.exitFullscreen() : _this.launchIntoFullscreen(_this.clip.props.host);\n\n    _this.clip.props.host.classList.toggle(\"full-screen\");\n  });\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC1wbGF5ZXIvZGlzdC9saXN0ZW5lcnMvZnVsbHNjcmVlbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4LXBsYXllci9kaXN0L2xpc3RlbmVycy9mdWxsc2NyZWVuLmpzPzhmNGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF90aGlzKSB7XG4gIF90aGlzLmVsZW1lbnRzLmZ1bGxTY3JlZW5CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWxGdWxsU2NyZWVuID0gX3RoaXMuY2xpcC5wcm9wcy5ob3N0LmNsYXNzTmFtZS5pbmNsdWRlcyhcImZ1bGwtc2NyZWVuXCIpO1xuXG4gICAgX3RoaXMuY2xpcC5wcm9wcy5ob3N0ICE9PSBfdGhpcy5vcHRpb25zLmhvc3QgJiYgIWVsRnVsbFNjcmVlbiA/IF90aGlzLmNsaXAucHJvcHMuaG9zdC5hcHBlbmRDaGlsZChfdGhpcy5lbGVtZW50cy5tY1BsYXllcikgOiBudWxsO1xuICAgIF90aGlzLmNsaXAucHJvcHMuaG9zdCAhPT0gX3RoaXMub3B0aW9ucy5ob3N0ICYmIGVsRnVsbFNjcmVlbiA/IF90aGlzLm9wdGlvbnMuaG9zdC5hcHBlbmRDaGlsZChfdGhpcy5lbGVtZW50cy5tY1BsYXllcikgOiBudWxsO1xuICAgIGVsRnVsbFNjcmVlbiA/IF90aGlzLmV4aXRGdWxsc2NyZWVuKCkgOiBfdGhpcy5sYXVuY2hJbnRvRnVsbHNjcmVlbihfdGhpcy5jbGlwLnByb3BzLmhvc3QpO1xuXG4gICAgX3RoaXMuY2xpcC5wcm9wcy5ob3N0LmNsYXNzTGlzdC50b2dnbGUoXCJmdWxsLXNjcmVlblwiKTtcbiAgfSk7XG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex-player/dist/listeners/fullscreen.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex-player/dist/listeners/loopBarEnd.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex-player/dist/listeners/loopBarEnd.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _require = __webpack_require__(/*! ../helpers */ \"./node_modules/@kissmybutton/motorcortex-player/dist/helpers.js\"),\n    addListener = _require.addListener,\n    removeListener = _require.removeListener;\n\nmodule.exports = function (_this) {\n  // let pe = false;\n  _this.listeners.onCursorMoveLoopEnd = function (e) {\n    e.preventDefault();\n    var clientX = e.clientX || ((e.touches || [])[0] || {}).clientX;\n\n    var viewportOffset = _this.elements.totalBar.getBoundingClientRect();\n\n    var positionX = clientX - viewportOffset.left;\n\n    if (positionX < 0) {\n      positionX = 0;\n    } else if (positionX > _this.elements.totalBar.offsetWidth) {\n      positionX = _this.elements.totalBar.offsetWidth;\n    }\n\n    if (_this.elements.runningBar.offsetWidth >= _this.elements.loopBar.offsetWidth) {\n      _this.elements.runningBar.style.width = _this.elements.loopBar.offsetWidth + \"px\";\n    }\n\n    if (_this.settings.loopLastPositionXPxls - positionX < 0) {\n      _this.elements.loopBar.style.width = Math.abs(_this.settings.loopLastPositionXPxls - positionX) + \"px\";\n    } else {\n      _this.elements.loopBar.style.left = positionX + \"px\";\n      _this.settings.loopLastPositionXPxls = positionX;\n    }\n\n    _this.settings.loopEndMillisecond = Math.round(_this.clip.duration * ((parseFloat(_this.elements.loopBar.style.left) || 0) + parseFloat(_this.elements.loopBar.style.width)) / _this.elements.totalBar.offsetWidth);\n\n    if (_this.settings.loopEndMillisecond < _this.clip.runTimeInfo.currentMillisecond) {\n      _this.settings.loopJourney = true;\n    }\n\n    if (_this.settings.loopStartMillisecond > _this.settings.loopEndMillisecond) {\n      _this.settings.loopStartMillisecond = _this.settings.loopEndMillisecond;\n      _this.settings.loopJourney = true;\n    }\n\n    _this.elements.loopEndTime.innerHTML = _this.settings.loopEndMillisecond;\n    _this.elements.loopStartTime.innerHTML = _this.settings.loopStartMillisecond;\n  };\n\n  _this.listeners.onMouseUpLoopEnd = function (e) {\n    _this.elements.listenerHelper.style.pointerEvents = \"none\"; // if (pe) {\n    //   _this.elements.settingsPointerEvents.click();\n    // }\n\n    _this.settings.resizeLoop = false;\n    e.preventDefault();\n    _this.elements.runningBar.style.width = _this.elements.runningBar.offsetWidth / _this.elements.loopBar.offsetWidth * 100 + \"%\";\n    _this.elements.loopBar.style.left = _this.elements.loopBar.offsetLeft / _this.elements.totalBar.offsetWidth * 100 + \"%\";\n    _this.elements.loopBar.style.width = _this.elements.loopBar.offsetWidth / _this.elements.totalBar.offsetWidth * 100 + \"%\";\n\n    if (_this.settings.loopJourney) {\n      _this.createProgressDrag(_this.elements.runningBar.offsetWidth);\n\n      _this.settings.loopJourney = false;\n    }\n\n    removeListener(\"mouseup\", _this.listeners.onMouseUpLoopEnd, false);\n    removeListener(\"touchend\", _this.listeners.onMouseUpLoopEnd, false);\n    removeListener(\"mousemove\", _this.listeners.onCursorMoveLoopEnd, false);\n    removeListener(\"touchmove\", _this.listeners.onCursorMoveLoopEnd, false);\n\n    _this.elements.loopBar.addEventListener(\"mousedown\", _this.listeners.onMouseDown, false);\n\n    _this.elements.loopBar.addEventListener(\"touchstart\", _this.listeners.onMouseDown, {\n      passive: true\n    }, false);\n\n    if (_this.settings.playAfterResize) {\n      if (_this.clip.state === \"idle\") {\n        var loopms;\n\n        if (_this.clip.speed >= 0) {\n          loopms = _this.settings.loopStartMillisecond + 1;\n        } else {\n          loopms = _this.settings.loopEndMillisecond - 1;\n        }\n\n        _this.settings.needsUpdate = true;\n\n        _this.createJourney(_this.clip, loopms, {\n          before: \"stop\",\n          after: \"play\"\n        });\n      } else if (_this.clip.state === \"completed\") {\n        var _loopms;\n\n        if (_this.clip.speed >= 0) {\n          _loopms = _this.settings.loopStartMillisecond + 1;\n        } else {\n          _loopms = _this.settings.loopEndMillisecond - 1;\n        }\n\n        _this.settings.needsUpdate = true;\n\n        _this.createJourney(_this.clip, _loopms, {\n          before: \"stop\",\n          after: \"play\"\n        });\n      } else {\n        _this.clip.resume();\n      }\n\n      _this.settings.playAfterResize = false;\n    }\n  };\n\n  _this.listeners.onMouseDownLoopEnd = function (e) {\n    _this.elements.listenerHelper.style.pointerEvents = \"auto\"; // if (!_this.options.pointerEvents) {\n    //   pe = true;\n    //   _this.elements.settingsPointerEvents.click();\n    // }\n\n    _this.settings.resizeLoop = true;\n    _this.settings.needsUpdate = true;\n\n    if (_this.clip.state === \"playing\") {\n      _this.clip.wait();\n\n      _this.settings.playAfterResize = true;\n    }\n\n    e.preventDefault();\n    _this.elements.runningBar.style.width = _this.elements.runningBar.offsetWidth + \"px\";\n    _this.elements.loopBar.style.left = _this.elements.loopBar.offsetLeft + \"px\";\n    _this.elements.loopBar.style.width = _this.elements.loopBar.offsetWidth + \"px\";\n\n    _this.elements.loopBar.removeEventListener(\"mousedown\", _this.listeners.onMouseDown, false);\n\n    _this.elements.loopBar.removeEventListener(\"touchstart\", _this.listeners.onMouseDown, false);\n\n    _this.listeners.onCursorMoveLoopEnd(e);\n\n    addListener(\"mouseup\", _this.listeners.onMouseUpLoopEnd, false);\n    addListener(\"touchend\", _this.listeners.onMouseUpLoopEnd, false);\n    addListener(\"mousemove\", _this.listeners.onCursorMoveLoopEnd, false);\n    addListener(\"touchmove\", _this.listeners.onCursorMoveLoopEnd, false);\n  };\n\n  _this.elements.loopBarEnd.addEventListener(\"mousedown\", _this.listeners.onMouseDownLoopEnd, false);\n\n  _this.elements.loopBarEnd.addEventListener(\"touchstart\", _this.listeners.onMouseDownLoopEnd, {\n    passive: false\n  }, false);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC1wbGF5ZXIvZGlzdC9saXN0ZW5lcnMvbG9vcEJhckVuZC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4LXBsYXllci9kaXN0L2xpc3RlbmVycy9sb29wQmFyRW5kLmpzPzE3ZGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzXCIpLFxuICAgIGFkZExpc3RlbmVyID0gX3JlcXVpcmUuYWRkTGlzdGVuZXIsXG4gICAgcmVtb3ZlTGlzdGVuZXIgPSBfcmVxdWlyZS5yZW1vdmVMaXN0ZW5lcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoX3RoaXMpIHtcbiAgLy8gbGV0IHBlID0gZmFsc2U7XG4gIF90aGlzLmxpc3RlbmVycy5vbkN1cnNvck1vdmVMb29wRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyIGNsaWVudFggPSBlLmNsaWVudFggfHwgKChlLnRvdWNoZXMgfHwgW10pWzBdIHx8IHt9KS5jbGllbnRYO1xuXG4gICAgdmFyIHZpZXdwb3J0T2Zmc2V0ID0gX3RoaXMuZWxlbWVudHMudG90YWxCYXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICB2YXIgcG9zaXRpb25YID0gY2xpZW50WCAtIHZpZXdwb3J0T2Zmc2V0LmxlZnQ7XG5cbiAgICBpZiAocG9zaXRpb25YIDwgMCkge1xuICAgICAgcG9zaXRpb25YID0gMDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uWCA+IF90aGlzLmVsZW1lbnRzLnRvdGFsQmFyLm9mZnNldFdpZHRoKSB7XG4gICAgICBwb3NpdGlvblggPSBfdGhpcy5lbGVtZW50cy50b3RhbEJhci5vZmZzZXRXaWR0aDtcbiAgICB9XG5cbiAgICBpZiAoX3RoaXMuZWxlbWVudHMucnVubmluZ0Jhci5vZmZzZXRXaWR0aCA+PSBfdGhpcy5lbGVtZW50cy5sb29wQmFyLm9mZnNldFdpZHRoKSB7XG4gICAgICBfdGhpcy5lbGVtZW50cy5ydW5uaW5nQmFyLnN0eWxlLndpZHRoID0gX3RoaXMuZWxlbWVudHMubG9vcEJhci5vZmZzZXRXaWR0aCArIFwicHhcIjtcbiAgICB9XG5cbiAgICBpZiAoX3RoaXMuc2V0dGluZ3MubG9vcExhc3RQb3NpdGlvblhQeGxzIC0gcG9zaXRpb25YIDwgMCkge1xuICAgICAgX3RoaXMuZWxlbWVudHMubG9vcEJhci5zdHlsZS53aWR0aCA9IE1hdGguYWJzKF90aGlzLnNldHRpbmdzLmxvb3BMYXN0UG9zaXRpb25YUHhscyAtIHBvc2l0aW9uWCkgKyBcInB4XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIF90aGlzLmVsZW1lbnRzLmxvb3BCYXIuc3R5bGUubGVmdCA9IHBvc2l0aW9uWCArIFwicHhcIjtcbiAgICAgIF90aGlzLnNldHRpbmdzLmxvb3BMYXN0UG9zaXRpb25YUHhscyA9IHBvc2l0aW9uWDtcbiAgICB9XG5cbiAgICBfdGhpcy5zZXR0aW5ncy5sb29wRW5kTWlsbGlzZWNvbmQgPSBNYXRoLnJvdW5kKF90aGlzLmNsaXAuZHVyYXRpb24gKiAoKHBhcnNlRmxvYXQoX3RoaXMuZWxlbWVudHMubG9vcEJhci5zdHlsZS5sZWZ0KSB8fCAwKSArIHBhcnNlRmxvYXQoX3RoaXMuZWxlbWVudHMubG9vcEJhci5zdHlsZS53aWR0aCkpIC8gX3RoaXMuZWxlbWVudHMudG90YWxCYXIub2Zmc2V0V2lkdGgpO1xuXG4gICAgaWYgKF90aGlzLnNldHRpbmdzLmxvb3BFbmRNaWxsaXNlY29uZCA8IF90aGlzLmNsaXAucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kKSB7XG4gICAgICBfdGhpcy5zZXR0aW5ncy5sb29wSm91cm5leSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKF90aGlzLnNldHRpbmdzLmxvb3BTdGFydE1pbGxpc2Vjb25kID4gX3RoaXMuc2V0dGluZ3MubG9vcEVuZE1pbGxpc2Vjb25kKSB7XG4gICAgICBfdGhpcy5zZXR0aW5ncy5sb29wU3RhcnRNaWxsaXNlY29uZCA9IF90aGlzLnNldHRpbmdzLmxvb3BFbmRNaWxsaXNlY29uZDtcbiAgICAgIF90aGlzLnNldHRpbmdzLmxvb3BKb3VybmV5ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBfdGhpcy5lbGVtZW50cy5sb29wRW5kVGltZS5pbm5lckhUTUwgPSBfdGhpcy5zZXR0aW5ncy5sb29wRW5kTWlsbGlzZWNvbmQ7XG4gICAgX3RoaXMuZWxlbWVudHMubG9vcFN0YXJ0VGltZS5pbm5lckhUTUwgPSBfdGhpcy5zZXR0aW5ncy5sb29wU3RhcnRNaWxsaXNlY29uZDtcbiAgfTtcblxuICBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZVVwTG9vcEVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgX3RoaXMuZWxlbWVudHMubGlzdGVuZXJIZWxwZXIuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiOyAvLyBpZiAocGUpIHtcbiAgICAvLyAgIF90aGlzLmVsZW1lbnRzLnNldHRpbmdzUG9pbnRlckV2ZW50cy5jbGljaygpO1xuICAgIC8vIH1cblxuICAgIF90aGlzLnNldHRpbmdzLnJlc2l6ZUxvb3AgPSBmYWxzZTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgX3RoaXMuZWxlbWVudHMucnVubmluZ0Jhci5zdHlsZS53aWR0aCA9IF90aGlzLmVsZW1lbnRzLnJ1bm5pbmdCYXIub2Zmc2V0V2lkdGggLyBfdGhpcy5lbGVtZW50cy5sb29wQmFyLm9mZnNldFdpZHRoICogMTAwICsgXCIlXCI7XG4gICAgX3RoaXMuZWxlbWVudHMubG9vcEJhci5zdHlsZS5sZWZ0ID0gX3RoaXMuZWxlbWVudHMubG9vcEJhci5vZmZzZXRMZWZ0IC8gX3RoaXMuZWxlbWVudHMudG90YWxCYXIub2Zmc2V0V2lkdGggKiAxMDAgKyBcIiVcIjtcbiAgICBfdGhpcy5lbGVtZW50cy5sb29wQmFyLnN0eWxlLndpZHRoID0gX3RoaXMuZWxlbWVudHMubG9vcEJhci5vZmZzZXRXaWR0aCAvIF90aGlzLmVsZW1lbnRzLnRvdGFsQmFyLm9mZnNldFdpZHRoICogMTAwICsgXCIlXCI7XG5cbiAgICBpZiAoX3RoaXMuc2V0dGluZ3MubG9vcEpvdXJuZXkpIHtcbiAgICAgIF90aGlzLmNyZWF0ZVByb2dyZXNzRHJhZyhfdGhpcy5lbGVtZW50cy5ydW5uaW5nQmFyLm9mZnNldFdpZHRoKTtcblxuICAgICAgX3RoaXMuc2V0dGluZ3MubG9vcEpvdXJuZXkgPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZW1vdmVMaXN0ZW5lcihcIm1vdXNldXBcIiwgX3RoaXMubGlzdGVuZXJzLm9uTW91c2VVcExvb3BFbmQsIGZhbHNlKTtcbiAgICByZW1vdmVMaXN0ZW5lcihcInRvdWNoZW5kXCIsIF90aGlzLmxpc3RlbmVycy5vbk1vdXNlVXBMb29wRW5kLCBmYWxzZSk7XG4gICAgcmVtb3ZlTGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgX3RoaXMubGlzdGVuZXJzLm9uQ3Vyc29yTW92ZUxvb3BFbmQsIGZhbHNlKTtcbiAgICByZW1vdmVMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBfdGhpcy5saXN0ZW5lcnMub25DdXJzb3JNb3ZlTG9vcEVuZCwgZmFsc2UpO1xuXG4gICAgX3RoaXMuZWxlbWVudHMubG9vcEJhci5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIF90aGlzLmxpc3RlbmVycy5vbk1vdXNlRG93biwgZmFsc2UpO1xuXG4gICAgX3RoaXMuZWxlbWVudHMubG9vcEJhci5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZURvd24sIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9LCBmYWxzZSk7XG5cbiAgICBpZiAoX3RoaXMuc2V0dGluZ3MucGxheUFmdGVyUmVzaXplKSB7XG4gICAgICBpZiAoX3RoaXMuY2xpcC5zdGF0ZSA9PT0gXCJpZGxlXCIpIHtcbiAgICAgICAgdmFyIGxvb3BtcztcblxuICAgICAgICBpZiAoX3RoaXMuY2xpcC5zcGVlZCA+PSAwKSB7XG4gICAgICAgICAgbG9vcG1zID0gX3RoaXMuc2V0dGluZ3MubG9vcFN0YXJ0TWlsbGlzZWNvbmQgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvb3BtcyA9IF90aGlzLnNldHRpbmdzLmxvb3BFbmRNaWxsaXNlY29uZCAtIDE7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5zZXR0aW5ncy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgX3RoaXMuY3JlYXRlSm91cm5leShfdGhpcy5jbGlwLCBsb29wbXMsIHtcbiAgICAgICAgICBiZWZvcmU6IFwic3RvcFwiLFxuICAgICAgICAgIGFmdGVyOiBcInBsYXlcIlxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoX3RoaXMuY2xpcC5zdGF0ZSA9PT0gXCJjb21wbGV0ZWRcIikge1xuICAgICAgICB2YXIgX2xvb3BtcztcblxuICAgICAgICBpZiAoX3RoaXMuY2xpcC5zcGVlZCA+PSAwKSB7XG4gICAgICAgICAgX2xvb3BtcyA9IF90aGlzLnNldHRpbmdzLmxvb3BTdGFydE1pbGxpc2Vjb25kICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfbG9vcG1zID0gX3RoaXMuc2V0dGluZ3MubG9vcEVuZE1pbGxpc2Vjb25kIC0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLnNldHRpbmdzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICBfdGhpcy5jcmVhdGVKb3VybmV5KF90aGlzLmNsaXAsIF9sb29wbXMsIHtcbiAgICAgICAgICBiZWZvcmU6IFwic3RvcFwiLFxuICAgICAgICAgIGFmdGVyOiBcInBsYXlcIlxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLmNsaXAucmVzdW1lKCk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnNldHRpbmdzLnBsYXlBZnRlclJlc2l6ZSA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZURvd25Mb29wRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICBfdGhpcy5lbGVtZW50cy5saXN0ZW5lckhlbHBlci5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJhdXRvXCI7IC8vIGlmICghX3RoaXMub3B0aW9ucy5wb2ludGVyRXZlbnRzKSB7XG4gICAgLy8gICBwZSA9IHRydWU7XG4gICAgLy8gICBfdGhpcy5lbGVtZW50cy5zZXR0aW5nc1BvaW50ZXJFdmVudHMuY2xpY2soKTtcbiAgICAvLyB9XG5cbiAgICBfdGhpcy5zZXR0aW5ncy5yZXNpemVMb29wID0gdHJ1ZTtcbiAgICBfdGhpcy5zZXR0aW5ncy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICBpZiAoX3RoaXMuY2xpcC5zdGF0ZSA9PT0gXCJwbGF5aW5nXCIpIHtcbiAgICAgIF90aGlzLmNsaXAud2FpdCgpO1xuXG4gICAgICBfdGhpcy5zZXR0aW5ncy5wbGF5QWZ0ZXJSZXNpemUgPSB0cnVlO1xuICAgIH1cblxuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBfdGhpcy5lbGVtZW50cy5ydW5uaW5nQmFyLnN0eWxlLndpZHRoID0gX3RoaXMuZWxlbWVudHMucnVubmluZ0Jhci5vZmZzZXRXaWR0aCArIFwicHhcIjtcbiAgICBfdGhpcy5lbGVtZW50cy5sb29wQmFyLnN0eWxlLmxlZnQgPSBfdGhpcy5lbGVtZW50cy5sb29wQmFyLm9mZnNldExlZnQgKyBcInB4XCI7XG4gICAgX3RoaXMuZWxlbWVudHMubG9vcEJhci5zdHlsZS53aWR0aCA9IF90aGlzLmVsZW1lbnRzLmxvb3BCYXIub2Zmc2V0V2lkdGggKyBcInB4XCI7XG5cbiAgICBfdGhpcy5lbGVtZW50cy5sb29wQmFyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgX3RoaXMubGlzdGVuZXJzLm9uTW91c2VEb3duLCBmYWxzZSk7XG5cbiAgICBfdGhpcy5lbGVtZW50cy5sb29wQmFyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIF90aGlzLmxpc3RlbmVycy5vbk1vdXNlRG93biwgZmFsc2UpO1xuXG4gICAgX3RoaXMubGlzdGVuZXJzLm9uQ3Vyc29yTW92ZUxvb3BFbmQoZSk7XG5cbiAgICBhZGRMaXN0ZW5lcihcIm1vdXNldXBcIiwgX3RoaXMubGlzdGVuZXJzLm9uTW91c2VVcExvb3BFbmQsIGZhbHNlKTtcbiAgICBhZGRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIF90aGlzLmxpc3RlbmVycy5vbk1vdXNlVXBMb29wRW5kLCBmYWxzZSk7XG4gICAgYWRkTGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgX3RoaXMubGlzdGVuZXJzLm9uQ3Vyc29yTW92ZUxvb3BFbmQsIGZhbHNlKTtcbiAgICBhZGRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBfdGhpcy5saXN0ZW5lcnMub25DdXJzb3JNb3ZlTG9vcEVuZCwgZmFsc2UpO1xuICB9O1xuXG4gIF90aGlzLmVsZW1lbnRzLmxvb3BCYXJFbmQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZURvd25Mb29wRW5kLCBmYWxzZSk7XG5cbiAgX3RoaXMuZWxlbWVudHMubG9vcEJhckVuZC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZURvd25Mb29wRW5kLCB7XG4gICAgcGFzc2l2ZTogZmFsc2VcbiAgfSwgZmFsc2UpO1xufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex-player/dist/listeners/loopBarEnd.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex-player/dist/listeners/loopBarStart.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex-player/dist/listeners/loopBarStart.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _require = __webpack_require__(/*! ../helpers */ \"./node_modules/@kissmybutton/motorcortex-player/dist/helpers.js\"),\n    addListener = _require.addListener,\n    removeListener = _require.removeListener;\n\nmodule.exports = function (_this) {\n  // let pe = false;\n  _this.listeners.onCursorMoveLoopStart = function (e) {\n    e.preventDefault();\n    var clientX = e.clientX || ((e.touches || [])[0] || {}).clientX;\n\n    var viewportOffset = _this.elements.totalBar.getBoundingClientRect();\n\n    var positionX = clientX - viewportOffset.left;\n    var endPosition = _this.elements.loopBar.offsetWidth + _this.elements.loopBar.offsetLeft;\n\n    if (positionX < 0) {\n      positionX = 0;\n    } else if (positionX > _this.elements.totalBar.offsetWidth) {\n      positionX = _this.elements.totalBar.offsetWidth;\n    }\n\n    var loopBarDeltaX = positionX - _this.settings.loopLastPositionXPxls || 0;\n    var runningBarWidthInPxls = _this.elements.runningBar.offsetWidth - loopBarDeltaX;\n    _this.elements.loopBar.style.left = positionX + \"px\";\n    var diff = endPosition - _this.elements.loopBar.offsetLeft;\n    _this.elements.loopBar.style.width = diff + \"px\";\n    _this.elements.runningBar.style.width = runningBarWidthInPxls + \"px\";\n    _this.settings.loopLastPositionXPxls = positionX;\n    _this.settings.loopStartMillisecond = Math.round(_this.clip.duration * _this.elements.loopBar.offsetLeft / _this.elements.totalBar.offsetWidth);\n\n    if (_this.settings.loopEndMillisecond < _this.settings.loopStartMillisecond) {\n      _this.settings.loopEndMillisecond = _this.settings.loopStartMillisecond;\n      _this.elements.loopBar.style.width = \"0px\";\n      _this.elements.runningBar.style.width = \"0px\";\n    }\n\n    _this.elements.loopEndTime.innerHTML = _this.settings.loopEndMillisecond;\n    _this.elements.loopStartTime.innerHTML = _this.settings.loopStartMillisecond;\n\n    if (_this.settings.loopStartMillisecond > _this.clip.runTimeInfo.currentMillisecond) {\n      _this.settings.loopJourney = true;\n    }\n  };\n\n  _this.listeners.onMouseUpLoopStart = function (e) {\n    _this.elements.listenerHelper.style.pointerEvents = \"none\"; // if (pe) {\n    //   _this.elements.settingsPointerEvents.click();\n    // }\n\n    _this.settings.resizeLoop = false;\n    e.preventDefault();\n\n    if (_this.settings.loopJourney) {\n      _this.createProgressDrag(_this.elements.runningBar.offsetWidth);\n\n      _this.settings.loopJourney = false;\n    }\n\n    _this.elements.loopBar.style.left = _this.elements.loopBar.offsetLeft / _this.elements.totalBar.offsetWidth * 100 + \"%\";\n    _this.elements.loopBar.style.width = _this.elements.loopBar.offsetWidth / _this.elements.totalBar.offsetWidth * 100 + \"%\";\n    _this.settings.loopStartMillisecond = Math.round(_this.clip.duration * _this.elements.loopBar.offsetLeft / _this.elements.totalBar.offsetWidth);\n    _this.elements.runningBar.style.width = _this.elements.runningBar.offsetWidth / _this.elements.loopBar.offsetWidth * 100 + \"%\";\n    removeListener(\"mouseup\", _this.listeners.onMouseUpLoopStart, false);\n    removeListener(\"touchend\", _this.listeners.onMouseUpLoopStart, false);\n    removeListener(\"mousemove\", _this.listeners.onCursorMoveLoopStart, false);\n    removeListener(\"touchmove\", _this.listeners.onCursorMoveLoopStart, false);\n\n    _this.elements.loopBar.addEventListener(\"mousedown\", _this.listeners.onMouseDown, false);\n\n    _this.elements.loopBar.addEventListener(\"touchstart\", _this.listeners.onMouseDown, {\n      passive: true\n    }, false);\n\n    if (_this.settings.playAfterResize) {\n      if (_this.clip.state === \"idle\") {\n        var loopms;\n\n        if (_this.clip.speed >= 0) {\n          loopms = _this.settings.loopStartMillisecond + 1;\n        } else {\n          loopms = _this.settings.loopEndMillisecond - 1;\n        }\n\n        _this.settings.needsUpdate = true;\n\n        _this.createJourney(_this.clip, loopms, {\n          before: \"stop\",\n          after: \"play\"\n        });\n      } else if (_this.clip.state === \"completed\") {\n        var _loopms;\n\n        if (_this.clip.speed >= 0) {\n          _loopms = _this.settings.loopStartMillisecond + 1;\n        } else {\n          _loopms = _this.settings.loopEndMillisecond - 1;\n        }\n\n        _this.settings.needsUpdate = true;\n\n        _this.createJourney(_this.clip, _loopms, {\n          before: \"stop\",\n          after: \"play\"\n        });\n      } else {\n        _this.clip.resume();\n      }\n\n      _this.settings.playAfterResize = false;\n    }\n  };\n\n  _this.listeners.onMouseDownLoopStart = function (e) {\n    _this.elements.listenerHelper.style.pointerEvents = \"auto\"; // if (!_this.options.pointerEvents) {\n    //   pe = true;\n    //   _this.elements.settingsPointerEvents.click();\n    // }\n\n    _this.settings.resizeLoop = true;\n    e.preventDefault();\n    _this.settings.needsUpdate = true;\n\n    if (_this.clip.state === \"playing\") {\n      _this.clip.wait();\n\n      _this.settings.playAfterResize = true;\n    }\n\n    _this.elements.loopBar.removeEventListener(\"mousedown\", _this.listeners.onMouseDown, false);\n\n    _this.elements.loopBar.removeEventListener(\"touchstart\", _this.listeners.onMouseDown, false);\n\n    _this.listeners.onCursorMoveLoopStart(e);\n\n    addListener(\"mouseup\", _this.listeners.onMouseUpLoopStart, false);\n    addListener(\"touchend\", _this.listeners.onMouseUpLoopStart, false);\n    addListener(\"mousemove\", _this.listeners.onCursorMoveLoopStart, false);\n    addListener(\"touchmove\", _this.listeners.onCursorMoveLoopStart, false);\n  };\n\n  _this.elements.loopBarStart.addEventListener(\"mousedown\", _this.listeners.onMouseDownLoopStart, false);\n\n  _this.elements.loopBarStart.addEventListener(\"touchstart\", _this.listeners.onMouseDownLoopStart, {\n    passive: false\n  }, false);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC1wbGF5ZXIvZGlzdC9saXN0ZW5lcnMvbG9vcEJhclN0YXJ0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyL2Rpc3QvbGlzdGVuZXJzL2xvb3BCYXJTdGFydC5qcz8zYjNiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi4vaGVscGVyc1wiKSxcbiAgICBhZGRMaXN0ZW5lciA9IF9yZXF1aXJlLmFkZExpc3RlbmVyLFxuICAgIHJlbW92ZUxpc3RlbmVyID0gX3JlcXVpcmUucmVtb3ZlTGlzdGVuZXI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF90aGlzKSB7XG4gIC8vIGxldCBwZSA9IGZhbHNlO1xuICBfdGhpcy5saXN0ZW5lcnMub25DdXJzb3JNb3ZlTG9vcFN0YXJ0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyIGNsaWVudFggPSBlLmNsaWVudFggfHwgKChlLnRvdWNoZXMgfHwgW10pWzBdIHx8IHt9KS5jbGllbnRYO1xuXG4gICAgdmFyIHZpZXdwb3J0T2Zmc2V0ID0gX3RoaXMuZWxlbWVudHMudG90YWxCYXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICB2YXIgcG9zaXRpb25YID0gY2xpZW50WCAtIHZpZXdwb3J0T2Zmc2V0LmxlZnQ7XG4gICAgdmFyIGVuZFBvc2l0aW9uID0gX3RoaXMuZWxlbWVudHMubG9vcEJhci5vZmZzZXRXaWR0aCArIF90aGlzLmVsZW1lbnRzLmxvb3BCYXIub2Zmc2V0TGVmdDtcblxuICAgIGlmIChwb3NpdGlvblggPCAwKSB7XG4gICAgICBwb3NpdGlvblggPSAwO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb25YID4gX3RoaXMuZWxlbWVudHMudG90YWxCYXIub2Zmc2V0V2lkdGgpIHtcbiAgICAgIHBvc2l0aW9uWCA9IF90aGlzLmVsZW1lbnRzLnRvdGFsQmFyLm9mZnNldFdpZHRoO1xuICAgIH1cblxuICAgIHZhciBsb29wQmFyRGVsdGFYID0gcG9zaXRpb25YIC0gX3RoaXMuc2V0dGluZ3MubG9vcExhc3RQb3NpdGlvblhQeGxzIHx8IDA7XG4gICAgdmFyIHJ1bm5pbmdCYXJXaWR0aEluUHhscyA9IF90aGlzLmVsZW1lbnRzLnJ1bm5pbmdCYXIub2Zmc2V0V2lkdGggLSBsb29wQmFyRGVsdGFYO1xuICAgIF90aGlzLmVsZW1lbnRzLmxvb3BCYXIuc3R5bGUubGVmdCA9IHBvc2l0aW9uWCArIFwicHhcIjtcbiAgICB2YXIgZGlmZiA9IGVuZFBvc2l0aW9uIC0gX3RoaXMuZWxlbWVudHMubG9vcEJhci5vZmZzZXRMZWZ0O1xuICAgIF90aGlzLmVsZW1lbnRzLmxvb3BCYXIuc3R5bGUud2lkdGggPSBkaWZmICsgXCJweFwiO1xuICAgIF90aGlzLmVsZW1lbnRzLnJ1bm5pbmdCYXIuc3R5bGUud2lkdGggPSBydW5uaW5nQmFyV2lkdGhJblB4bHMgKyBcInB4XCI7XG4gICAgX3RoaXMuc2V0dGluZ3MubG9vcExhc3RQb3NpdGlvblhQeGxzID0gcG9zaXRpb25YO1xuICAgIF90aGlzLnNldHRpbmdzLmxvb3BTdGFydE1pbGxpc2Vjb25kID0gTWF0aC5yb3VuZChfdGhpcy5jbGlwLmR1cmF0aW9uICogX3RoaXMuZWxlbWVudHMubG9vcEJhci5vZmZzZXRMZWZ0IC8gX3RoaXMuZWxlbWVudHMudG90YWxCYXIub2Zmc2V0V2lkdGgpO1xuXG4gICAgaWYgKF90aGlzLnNldHRpbmdzLmxvb3BFbmRNaWxsaXNlY29uZCA8IF90aGlzLnNldHRpbmdzLmxvb3BTdGFydE1pbGxpc2Vjb25kKSB7XG4gICAgICBfdGhpcy5zZXR0aW5ncy5sb29wRW5kTWlsbGlzZWNvbmQgPSBfdGhpcy5zZXR0aW5ncy5sb29wU3RhcnRNaWxsaXNlY29uZDtcbiAgICAgIF90aGlzLmVsZW1lbnRzLmxvb3BCYXIuc3R5bGUud2lkdGggPSBcIjBweFwiO1xuICAgICAgX3RoaXMuZWxlbWVudHMucnVubmluZ0Jhci5zdHlsZS53aWR0aCA9IFwiMHB4XCI7XG4gICAgfVxuXG4gICAgX3RoaXMuZWxlbWVudHMubG9vcEVuZFRpbWUuaW5uZXJIVE1MID0gX3RoaXMuc2V0dGluZ3MubG9vcEVuZE1pbGxpc2Vjb25kO1xuICAgIF90aGlzLmVsZW1lbnRzLmxvb3BTdGFydFRpbWUuaW5uZXJIVE1MID0gX3RoaXMuc2V0dGluZ3MubG9vcFN0YXJ0TWlsbGlzZWNvbmQ7XG5cbiAgICBpZiAoX3RoaXMuc2V0dGluZ3MubG9vcFN0YXJ0TWlsbGlzZWNvbmQgPiBfdGhpcy5jbGlwLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCkge1xuICAgICAgX3RoaXMuc2V0dGluZ3MubG9vcEpvdXJuZXkgPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZVVwTG9vcFN0YXJ0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICBfdGhpcy5lbGVtZW50cy5saXN0ZW5lckhlbHBlci5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7IC8vIGlmIChwZSkge1xuICAgIC8vICAgX3RoaXMuZWxlbWVudHMuc2V0dGluZ3NQb2ludGVyRXZlbnRzLmNsaWNrKCk7XG4gICAgLy8gfVxuXG4gICAgX3RoaXMuc2V0dGluZ3MucmVzaXplTG9vcCA9IGZhbHNlO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIGlmIChfdGhpcy5zZXR0aW5ncy5sb29wSm91cm5leSkge1xuICAgICAgX3RoaXMuY3JlYXRlUHJvZ3Jlc3NEcmFnKF90aGlzLmVsZW1lbnRzLnJ1bm5pbmdCYXIub2Zmc2V0V2lkdGgpO1xuXG4gICAgICBfdGhpcy5zZXR0aW5ncy5sb29wSm91cm5leSA9IGZhbHNlO1xuICAgIH1cblxuICAgIF90aGlzLmVsZW1lbnRzLmxvb3BCYXIuc3R5bGUubGVmdCA9IF90aGlzLmVsZW1lbnRzLmxvb3BCYXIub2Zmc2V0TGVmdCAvIF90aGlzLmVsZW1lbnRzLnRvdGFsQmFyLm9mZnNldFdpZHRoICogMTAwICsgXCIlXCI7XG4gICAgX3RoaXMuZWxlbWVudHMubG9vcEJhci5zdHlsZS53aWR0aCA9IF90aGlzLmVsZW1lbnRzLmxvb3BCYXIub2Zmc2V0V2lkdGggLyBfdGhpcy5lbGVtZW50cy50b3RhbEJhci5vZmZzZXRXaWR0aCAqIDEwMCArIFwiJVwiO1xuICAgIF90aGlzLnNldHRpbmdzLmxvb3BTdGFydE1pbGxpc2Vjb25kID0gTWF0aC5yb3VuZChfdGhpcy5jbGlwLmR1cmF0aW9uICogX3RoaXMuZWxlbWVudHMubG9vcEJhci5vZmZzZXRMZWZ0IC8gX3RoaXMuZWxlbWVudHMudG90YWxCYXIub2Zmc2V0V2lkdGgpO1xuICAgIF90aGlzLmVsZW1lbnRzLnJ1bm5pbmdCYXIuc3R5bGUud2lkdGggPSBfdGhpcy5lbGVtZW50cy5ydW5uaW5nQmFyLm9mZnNldFdpZHRoIC8gX3RoaXMuZWxlbWVudHMubG9vcEJhci5vZmZzZXRXaWR0aCAqIDEwMCArIFwiJVwiO1xuICAgIHJlbW92ZUxpc3RlbmVyKFwibW91c2V1cFwiLCBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZVVwTG9vcFN0YXJ0LCBmYWxzZSk7XG4gICAgcmVtb3ZlTGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZVVwTG9vcFN0YXJ0LCBmYWxzZSk7XG4gICAgcmVtb3ZlTGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgX3RoaXMubGlzdGVuZXJzLm9uQ3Vyc29yTW92ZUxvb3BTdGFydCwgZmFsc2UpO1xuICAgIHJlbW92ZUxpc3RlbmVyKFwidG91Y2htb3ZlXCIsIF90aGlzLmxpc3RlbmVycy5vbkN1cnNvck1vdmVMb29wU3RhcnQsIGZhbHNlKTtcblxuICAgIF90aGlzLmVsZW1lbnRzLmxvb3BCYXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZURvd24sIGZhbHNlKTtcblxuICAgIF90aGlzLmVsZW1lbnRzLmxvb3BCYXIuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgX3RoaXMubGlzdGVuZXJzLm9uTW91c2VEb3duLCB7XG4gICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfSwgZmFsc2UpO1xuXG4gICAgaWYgKF90aGlzLnNldHRpbmdzLnBsYXlBZnRlclJlc2l6ZSkge1xuICAgICAgaWYgKF90aGlzLmNsaXAuc3RhdGUgPT09IFwiaWRsZVwiKSB7XG4gICAgICAgIHZhciBsb29wbXM7XG5cbiAgICAgICAgaWYgKF90aGlzLmNsaXAuc3BlZWQgPj0gMCkge1xuICAgICAgICAgIGxvb3BtcyA9IF90aGlzLnNldHRpbmdzLmxvb3BTdGFydE1pbGxpc2Vjb25kICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb29wbXMgPSBfdGhpcy5zZXR0aW5ncy5sb29wRW5kTWlsbGlzZWNvbmQgLSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuc2V0dGluZ3MubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgIF90aGlzLmNyZWF0ZUpvdXJuZXkoX3RoaXMuY2xpcCwgbG9vcG1zLCB7XG4gICAgICAgICAgYmVmb3JlOiBcInN0b3BcIixcbiAgICAgICAgICBhZnRlcjogXCJwbGF5XCJcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKF90aGlzLmNsaXAuc3RhdGUgPT09IFwiY29tcGxldGVkXCIpIHtcbiAgICAgICAgdmFyIF9sb29wbXM7XG5cbiAgICAgICAgaWYgKF90aGlzLmNsaXAuc3BlZWQgPj0gMCkge1xuICAgICAgICAgIF9sb29wbXMgPSBfdGhpcy5zZXR0aW5ncy5sb29wU3RhcnRNaWxsaXNlY29uZCArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX2xvb3BtcyA9IF90aGlzLnNldHRpbmdzLmxvb3BFbmRNaWxsaXNlY29uZCAtIDE7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5zZXR0aW5ncy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgX3RoaXMuY3JlYXRlSm91cm5leShfdGhpcy5jbGlwLCBfbG9vcG1zLCB7XG4gICAgICAgICAgYmVmb3JlOiBcInN0b3BcIixcbiAgICAgICAgICBhZnRlcjogXCJwbGF5XCJcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5jbGlwLnJlc3VtZSgpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5zZXR0aW5ncy5wbGF5QWZ0ZXJSZXNpemUgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgX3RoaXMubGlzdGVuZXJzLm9uTW91c2VEb3duTG9vcFN0YXJ0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICBfdGhpcy5lbGVtZW50cy5saXN0ZW5lckhlbHBlci5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJhdXRvXCI7IC8vIGlmICghX3RoaXMub3B0aW9ucy5wb2ludGVyRXZlbnRzKSB7XG4gICAgLy8gICBwZSA9IHRydWU7XG4gICAgLy8gICBfdGhpcy5lbGVtZW50cy5zZXR0aW5nc1BvaW50ZXJFdmVudHMuY2xpY2soKTtcbiAgICAvLyB9XG5cbiAgICBfdGhpcy5zZXR0aW5ncy5yZXNpemVMb29wID0gdHJ1ZTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgX3RoaXMuc2V0dGluZ3MubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgaWYgKF90aGlzLmNsaXAuc3RhdGUgPT09IFwicGxheWluZ1wiKSB7XG4gICAgICBfdGhpcy5jbGlwLndhaXQoKTtcblxuICAgICAgX3RoaXMuc2V0dGluZ3MucGxheUFmdGVyUmVzaXplID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBfdGhpcy5lbGVtZW50cy5sb29wQmFyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgX3RoaXMubGlzdGVuZXJzLm9uTW91c2VEb3duLCBmYWxzZSk7XG5cbiAgICBfdGhpcy5lbGVtZW50cy5sb29wQmFyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIF90aGlzLmxpc3RlbmVycy5vbk1vdXNlRG93biwgZmFsc2UpO1xuXG4gICAgX3RoaXMubGlzdGVuZXJzLm9uQ3Vyc29yTW92ZUxvb3BTdGFydChlKTtcblxuICAgIGFkZExpc3RlbmVyKFwibW91c2V1cFwiLCBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZVVwTG9vcFN0YXJ0LCBmYWxzZSk7XG4gICAgYWRkTGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZVVwTG9vcFN0YXJ0LCBmYWxzZSk7XG4gICAgYWRkTGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgX3RoaXMubGlzdGVuZXJzLm9uQ3Vyc29yTW92ZUxvb3BTdGFydCwgZmFsc2UpO1xuICAgIGFkZExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIF90aGlzLmxpc3RlbmVycy5vbkN1cnNvck1vdmVMb29wU3RhcnQsIGZhbHNlKTtcbiAgfTtcblxuICBfdGhpcy5lbGVtZW50cy5sb29wQmFyU3RhcnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZURvd25Mb29wU3RhcnQsIGZhbHNlKTtcblxuICBfdGhpcy5lbGVtZW50cy5sb29wQmFyU3RhcnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgX3RoaXMubGlzdGVuZXJzLm9uTW91c2VEb3duTG9vcFN0YXJ0LCB7XG4gICAgcGFzc2l2ZTogZmFsc2VcbiAgfSwgZmFsc2UpO1xufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex-player/dist/listeners/loopBarStart.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex-player/dist/listeners/loopBtn.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex-player/dist/listeners/loopBtn.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _require = __webpack_require__(/*! ../helpers */ \"./node_modules/@kissmybutton/motorcortex-player/dist/helpers.js\"),\n    elid = _require.elid;\n\nmodule.exports = function (_this) {\n  _this.elements.loopButton.onclick = function () {\n    _this.settings.loopActivated = !_this.settings.loopActivated;\n\n    _this.elements.loopButton.classList.toggle(\"svg-selected\");\n\n    _this.elements.loopBarStart.classList.toggle(\"m-fadeOut\");\n\n    _this.elements.loopBarEnd.classList.toggle(\"m-fadeOut\");\n\n    _this.elements.loopBarStart.classList.toggle(\"m-fadeIn\");\n\n    _this.elements.loopBarStart.classList.toggle(\"\".concat(_this.name, \"-hide\"));\n\n    _this.elements.loopBarEnd.classList.toggle(\"m-fadeIn\");\n\n    _this.elements.loopBarEnd.classList.toggle(\"\".concat(_this.name, \"-hide\"));\n\n    elid(\"\".concat(_this.name, \"-loop-time\")).classList.toggle(\"m-fadeOut\");\n    elid(\"\".concat(_this.name, \"-loop-time\")).classList.toggle(\"m-fadeIn\");\n    elid(\"\".concat(_this.name, \"-loop-time\")).classList.toggle(\"\".concat(_this.name, \"-hide\"));\n    _this.elements.loopEndTime.innerHTML = _this.settings.loopEndMillisecond;\n    _this.elements.loopStartTime.innerHTML = _this.settings.loopStartMillisecond;\n    _this.settings.needsUpdate = true;\n\n    if (!_this.settings.loopActivated) {\n      _this.elements.loopBar.style.left = \"0%\";\n      _this.elements.loopBar.style.width = \"100%\";\n      _this.settings.loopStartMillisecond = 0;\n      _this.settings.loopEndMillisecond = _this.clip.duration;\n      _this.settings.loopLastPositionXPxls = 0;\n      _this.settings.loopLastPositionXPercentage = 0;\n      _this.elements.runningBar.style.width = _this.clip.runTimeInfo.currentMillisecond / _this.clip.duration * 100 + \"%\";\n    }\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC1wbGF5ZXIvZGlzdC9saXN0ZW5lcnMvbG9vcEJ0bi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4LXBsYXllci9kaXN0L2xpc3RlbmVycy9sb29wQnRuLmpzPzkyY2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzXCIpLFxuICAgIGVsaWQgPSBfcmVxdWlyZS5lbGlkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfdGhpcykge1xuICBfdGhpcy5lbGVtZW50cy5sb29wQnV0dG9uLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMuc2V0dGluZ3MubG9vcEFjdGl2YXRlZCA9ICFfdGhpcy5zZXR0aW5ncy5sb29wQWN0aXZhdGVkO1xuXG4gICAgX3RoaXMuZWxlbWVudHMubG9vcEJ1dHRvbi5jbGFzc0xpc3QudG9nZ2xlKFwic3ZnLXNlbGVjdGVkXCIpO1xuXG4gICAgX3RoaXMuZWxlbWVudHMubG9vcEJhclN0YXJ0LmNsYXNzTGlzdC50b2dnbGUoXCJtLWZhZGVPdXRcIik7XG5cbiAgICBfdGhpcy5lbGVtZW50cy5sb29wQmFyRW5kLmNsYXNzTGlzdC50b2dnbGUoXCJtLWZhZGVPdXRcIik7XG5cbiAgICBfdGhpcy5lbGVtZW50cy5sb29wQmFyU3RhcnQuY2xhc3NMaXN0LnRvZ2dsZShcIm0tZmFkZUluXCIpO1xuXG4gICAgX3RoaXMuZWxlbWVudHMubG9vcEJhclN0YXJ0LmNsYXNzTGlzdC50b2dnbGUoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItaGlkZVwiKSk7XG5cbiAgICBfdGhpcy5lbGVtZW50cy5sb29wQmFyRW5kLmNsYXNzTGlzdC50b2dnbGUoXCJtLWZhZGVJblwiKTtcblxuICAgIF90aGlzLmVsZW1lbnRzLmxvb3BCYXJFbmQuY2xhc3NMaXN0LnRvZ2dsZShcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1oaWRlXCIpKTtcblxuICAgIGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItbG9vcC10aW1lXCIpKS5jbGFzc0xpc3QudG9nZ2xlKFwibS1mYWRlT3V0XCIpO1xuICAgIGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItbG9vcC10aW1lXCIpKS5jbGFzc0xpc3QudG9nZ2xlKFwibS1mYWRlSW5cIik7XG4gICAgZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1sb29wLXRpbWVcIikpLmNsYXNzTGlzdC50b2dnbGUoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItaGlkZVwiKSk7XG4gICAgX3RoaXMuZWxlbWVudHMubG9vcEVuZFRpbWUuaW5uZXJIVE1MID0gX3RoaXMuc2V0dGluZ3MubG9vcEVuZE1pbGxpc2Vjb25kO1xuICAgIF90aGlzLmVsZW1lbnRzLmxvb3BTdGFydFRpbWUuaW5uZXJIVE1MID0gX3RoaXMuc2V0dGluZ3MubG9vcFN0YXJ0TWlsbGlzZWNvbmQ7XG4gICAgX3RoaXMuc2V0dGluZ3MubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgaWYgKCFfdGhpcy5zZXR0aW5ncy5sb29wQWN0aXZhdGVkKSB7XG4gICAgICBfdGhpcy5lbGVtZW50cy5sb29wQmFyLnN0eWxlLmxlZnQgPSBcIjAlXCI7XG4gICAgICBfdGhpcy5lbGVtZW50cy5sb29wQmFyLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgICBfdGhpcy5zZXR0aW5ncy5sb29wU3RhcnRNaWxsaXNlY29uZCA9IDA7XG4gICAgICBfdGhpcy5zZXR0aW5ncy5sb29wRW5kTWlsbGlzZWNvbmQgPSBfdGhpcy5jbGlwLmR1cmF0aW9uO1xuICAgICAgX3RoaXMuc2V0dGluZ3MubG9vcExhc3RQb3NpdGlvblhQeGxzID0gMDtcbiAgICAgIF90aGlzLnNldHRpbmdzLmxvb3BMYXN0UG9zaXRpb25YUGVyY2VudGFnZSA9IDA7XG4gICAgICBfdGhpcy5lbGVtZW50cy5ydW5uaW5nQmFyLnN0eWxlLndpZHRoID0gX3RoaXMuY2xpcC5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQgLyBfdGhpcy5jbGlwLmR1cmF0aW9uICogMTAwICsgXCIlXCI7XG4gICAgfVxuICB9O1xufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex-player/dist/listeners/loopBtn.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex-player/dist/listeners/loopStartEnd.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex-player/dist/listeners/loopStartEnd.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function (_this) {\n  _this.listeners.editableLoopStartTime = function () {\n    _this.elements.editableLoopStartTime.value = _this.elements.loopStartTime.innerHTML;\n\n    _this.elements.loopStartTime.replaceWith(_this.elements.editableLoopStartTime);\n\n    _this.elements.editableLoopStartTime.focus();\n  };\n\n  _this.listeners.editableLoopEndTime = function () {\n    _this.elements.editableLoopEndTime.value = _this.elements.loopEndTime.innerHTML;\n\n    _this.elements.loopEndTime.replaceWith(_this.elements.editableLoopEndTime);\n\n    _this.elements.editableLoopEndTime.focus();\n  };\n\n  _this.elements.editableLoopEndTime.onkeydown = _this.elements.editableLoopStartTime.onkeydown = function (e) {\n    e.preventDefault();\n\n    if (e.keyCode === 8) {\n      e.target.value = e.target.value.toString().substring(0, e.target.value.toString().length - 1);\n    }\n\n    if (e.keyCode === 13) {\n      e.target.blur();\n    }\n\n    var newValue = parseFloat((e.target.value || 0).toString() + e.key);\n\n    if (newValue > _this.clip.duration) {\n      return;\n    }\n\n    e.target.value = newValue;\n\n    if (e.target === _this.elements.editableLoopStartTime) {\n      var viewportOffset = _this.elements.totalBar.getBoundingClientRect();\n\n      var event = {\n        preventDefault: function preventDefault() {},\n        clientX: _this.elements.totalBar.offsetWidth / _this.clip.duration * e.target.value + viewportOffset.left\n      };\n\n      _this.listeners.onMouseDownLoopStart(event);\n\n      _this.listeners.onCursorMoveLoopStart(event);\n\n      _this.listeners.onMouseUpLoopStart(event);\n    } else if (e.target === _this.elements.editableLoopEndTime) {\n      var _viewportOffset = _this.elements.totalBar.getBoundingClientRect();\n\n      var _event = {\n        preventDefault: function preventDefault() {},\n        clientX: _this.elements.totalBar.offsetWidth / _this.clip.duration * e.target.value + _viewportOffset.left\n      };\n\n      _this.listeners.onMouseDownLoopEnd(_event);\n\n      _this.listeners.onCursorMoveLoopEnd(_event);\n\n      _this.listeners.onMouseUpLoopEnd(_event);\n    }\n  };\n\n  _this.elements.loopStartTime.onclick = _this.listeners.editableLoopStartTime;\n  _this.elements.loopEndTime.onclick = _this.listeners.editableLoopEndTime;\n\n  _this.elements.editableLoopStartTime.onfocusout = function () {\n    _this.elements.editableLoopStartTime.replaceWith(_this.elements.loopStartTime);\n  };\n\n  _this.elements.editableLoopEndTime.onfocusout = function () {\n    _this.elements.editableLoopEndTime.replaceWith(_this.elements.loopEndTime);\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC1wbGF5ZXIvZGlzdC9saXN0ZW5lcnMvbG9vcFN0YXJ0RW5kLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyL2Rpc3QvbGlzdGVuZXJzL2xvb3BTdGFydEVuZC5qcz9kMDBkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfdGhpcykge1xuICBfdGhpcy5saXN0ZW5lcnMuZWRpdGFibGVMb29wU3RhcnRUaW1lID0gZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLmVsZW1lbnRzLmVkaXRhYmxlTG9vcFN0YXJ0VGltZS52YWx1ZSA9IF90aGlzLmVsZW1lbnRzLmxvb3BTdGFydFRpbWUuaW5uZXJIVE1MO1xuXG4gICAgX3RoaXMuZWxlbWVudHMubG9vcFN0YXJ0VGltZS5yZXBsYWNlV2l0aChfdGhpcy5lbGVtZW50cy5lZGl0YWJsZUxvb3BTdGFydFRpbWUpO1xuXG4gICAgX3RoaXMuZWxlbWVudHMuZWRpdGFibGVMb29wU3RhcnRUaW1lLmZvY3VzKCk7XG4gIH07XG5cbiAgX3RoaXMubGlzdGVuZXJzLmVkaXRhYmxlTG9vcEVuZFRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMuZWxlbWVudHMuZWRpdGFibGVMb29wRW5kVGltZS52YWx1ZSA9IF90aGlzLmVsZW1lbnRzLmxvb3BFbmRUaW1lLmlubmVySFRNTDtcblxuICAgIF90aGlzLmVsZW1lbnRzLmxvb3BFbmRUaW1lLnJlcGxhY2VXaXRoKF90aGlzLmVsZW1lbnRzLmVkaXRhYmxlTG9vcEVuZFRpbWUpO1xuXG4gICAgX3RoaXMuZWxlbWVudHMuZWRpdGFibGVMb29wRW5kVGltZS5mb2N1cygpO1xuICB9O1xuXG4gIF90aGlzLmVsZW1lbnRzLmVkaXRhYmxlTG9vcEVuZFRpbWUub25rZXlkb3duID0gX3RoaXMuZWxlbWVudHMuZWRpdGFibGVMb29wU3RhcnRUaW1lLm9ua2V5ZG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgaWYgKGUua2V5Q29kZSA9PT0gOCkge1xuICAgICAgZS50YXJnZXQudmFsdWUgPSBlLnRhcmdldC52YWx1ZS50b1N0cmluZygpLnN1YnN0cmluZygwLCBlLnRhcmdldC52YWx1ZS50b1N0cmluZygpLmxlbmd0aCAtIDEpO1xuICAgIH1cblxuICAgIGlmIChlLmtleUNvZGUgPT09IDEzKSB7XG4gICAgICBlLnRhcmdldC5ibHVyKCk7XG4gICAgfVxuXG4gICAgdmFyIG5ld1ZhbHVlID0gcGFyc2VGbG9hdCgoZS50YXJnZXQudmFsdWUgfHwgMCkudG9TdHJpbmcoKSArIGUua2V5KTtcblxuICAgIGlmIChuZXdWYWx1ZSA+IF90aGlzLmNsaXAuZHVyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlLnRhcmdldC52YWx1ZSA9IG5ld1ZhbHVlO1xuXG4gICAgaWYgKGUudGFyZ2V0ID09PSBfdGhpcy5lbGVtZW50cy5lZGl0YWJsZUxvb3BTdGFydFRpbWUpIHtcbiAgICAgIHZhciB2aWV3cG9ydE9mZnNldCA9IF90aGlzLmVsZW1lbnRzLnRvdGFsQmFyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdCgpIHt9LFxuICAgICAgICBjbGllbnRYOiBfdGhpcy5lbGVtZW50cy50b3RhbEJhci5vZmZzZXRXaWR0aCAvIF90aGlzLmNsaXAuZHVyYXRpb24gKiBlLnRhcmdldC52YWx1ZSArIHZpZXdwb3J0T2Zmc2V0LmxlZnRcbiAgICAgIH07XG5cbiAgICAgIF90aGlzLmxpc3RlbmVycy5vbk1vdXNlRG93bkxvb3BTdGFydChldmVudCk7XG5cbiAgICAgIF90aGlzLmxpc3RlbmVycy5vbkN1cnNvck1vdmVMb29wU3RhcnQoZXZlbnQpO1xuXG4gICAgICBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZVVwTG9vcFN0YXJ0KGV2ZW50KTtcbiAgICB9IGVsc2UgaWYgKGUudGFyZ2V0ID09PSBfdGhpcy5lbGVtZW50cy5lZGl0YWJsZUxvb3BFbmRUaW1lKSB7XG4gICAgICB2YXIgX3ZpZXdwb3J0T2Zmc2V0ID0gX3RoaXMuZWxlbWVudHMudG90YWxCYXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgIHZhciBfZXZlbnQgPSB7XG4gICAgICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdCgpIHt9LFxuICAgICAgICBjbGllbnRYOiBfdGhpcy5lbGVtZW50cy50b3RhbEJhci5vZmZzZXRXaWR0aCAvIF90aGlzLmNsaXAuZHVyYXRpb24gKiBlLnRhcmdldC52YWx1ZSArIF92aWV3cG9ydE9mZnNldC5sZWZ0XG4gICAgICB9O1xuXG4gICAgICBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZURvd25Mb29wRW5kKF9ldmVudCk7XG5cbiAgICAgIF90aGlzLmxpc3RlbmVycy5vbkN1cnNvck1vdmVMb29wRW5kKF9ldmVudCk7XG5cbiAgICAgIF90aGlzLmxpc3RlbmVycy5vbk1vdXNlVXBMb29wRW5kKF9ldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIF90aGlzLmVsZW1lbnRzLmxvb3BTdGFydFRpbWUub25jbGljayA9IF90aGlzLmxpc3RlbmVycy5lZGl0YWJsZUxvb3BTdGFydFRpbWU7XG4gIF90aGlzLmVsZW1lbnRzLmxvb3BFbmRUaW1lLm9uY2xpY2sgPSBfdGhpcy5saXN0ZW5lcnMuZWRpdGFibGVMb29wRW5kVGltZTtcblxuICBfdGhpcy5lbGVtZW50cy5lZGl0YWJsZUxvb3BTdGFydFRpbWUub25mb2N1c291dCA9IGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpcy5lbGVtZW50cy5lZGl0YWJsZUxvb3BTdGFydFRpbWUucmVwbGFjZVdpdGgoX3RoaXMuZWxlbWVudHMubG9vcFN0YXJ0VGltZSk7XG4gIH07XG5cbiAgX3RoaXMuZWxlbWVudHMuZWRpdGFibGVMb29wRW5kVGltZS5vbmZvY3Vzb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLmVsZW1lbnRzLmVkaXRhYmxlTG9vcEVuZFRpbWUucmVwbGFjZVdpdGgoX3RoaXMuZWxlbWVudHMubG9vcEVuZFRpbWUpO1xuICB9O1xufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex-player/dist/listeners/loopStartEnd.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex-player/dist/listeners/preview.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex-player/dist/listeners/preview.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _require = __webpack_require__(/*! ../helpers */ \"./node_modules/@kissmybutton/motorcortex-player/dist/helpers.js\"),\n    elid = _require.elid,\n    addListener = _require.addListener,\n    removeListener = _require.removeListener;\n\nvar MC = __webpack_require__(/*! @kissmybutton/motorcortex */ \"./node_modules/@kissmybutton/motorcortex/dist/main.js\");\n\nvar hoverTimeCapsule = new MC.TimeCapsule();\n\nmodule.exports = function (_this) {\n  // only on desctop devices\n  if (!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {\n    var loopBarMouseInOut = function loopBarMouseInOut() {\n      if (!_this.options.preview) {\n        return;\n      }\n\n      elid(\"\".concat(_this.name, \"-hover-display\")).classList.toggle(\"m-fadeOut\");\n      elid(\"\".concat(_this.name, \"-hover-display\")).classList.toggle(\"m-fadeIn\");\n      elid(\"\".concat(_this.name, \"-hover-display\")).classList.toggle(\"\".concat(_this.name, \"-hide\"));\n\n      if (elid(\"\".concat(_this.name, \"-hover-display\")).className.includes(\"m-fadeIn\")) {\n        _this.previewJourney = hoverTimeCapsule.startJourney(_this.previewClip);\n      } else {\n        _this.previewJourney.destination();\n      }\n\n      _this.elements.loopBar.onmousemove = loopBarMouseMove;\n    };\n\n    var loopBarAddListeners = function loopBarAddListeners() {\n      if (!_this.options.preview) {\n        return;\n      }\n\n      loopBarMouseInOut();\n      _this.elements.loopBar.onmouseover = _this.elements.loopBar.onmouseout = loopBarMouseInOut;\n      _this.elements.loopBar.onmousemove = loopBarMouseMove;\n      removeListener(\"mouseup\", loopBarAddListeners, false);\n      removeListener(\"touchend\", loopBarAddListeners, false);\n      removeListener(\"mousemove\", loopBarMouseMove, false);\n      removeListener(\"touchmove\", loopBarMouseMove, false);\n    };\n\n    _this.elements.loopBar.onmouseover = _this.elements.loopBar.onmouseout = loopBarMouseInOut;\n\n    _this.elements.loopBar.onmousedown = function () {\n      if (!_this.options.preview) {\n        return;\n      }\n\n      _this.elements.loopBar.onmouseover = _this.elements.loopBar.onmouseout = null;\n      _this.elements.loopBar.onmousemove = null;\n      addListener(\"mouseup\", loopBarAddListeners, false);\n      addListener(\"touchend\", loopBarAddListeners, false);\n      addListener(\"mousemove\", loopBarMouseMove, false);\n      addListener(\"touchmove\", loopBarMouseMove, false);\n    };\n\n    _this.elements.loopBar.onmouseup = function () {\n      if (!_this.options.preview) {\n        return;\n      }\n\n      removeListener(\"mouseup\", loopBarAddListeners, false);\n      removeListener(\"touchend\", loopBarAddListeners, false);\n      removeListener(\"mousemove\", loopBarMouseMove, false);\n      removeListener(\"touchmove\", loopBarMouseMove, false);\n      _this.elements.loopBar.onmouseover = _this.elements.loopBar.onmouseout = loopBarMouseInOut;\n      _this.elements.loopBar.onmousemove = loopBarMouseMove;\n    };\n\n    var loopBarMouseMove = function loopBarMouseMove(e) {\n      var clientX = e.clientX;\n\n      var viewportOffset = _this.elements.loopBar.getBoundingClientRect();\n\n      if (clientX - viewportOffset.left + _this.settings.loopLastPositionXPxls > _this.settings.loopLastPositionXPxls + _this.elements.loopBar.offsetWidth && !_this.settings.resizeLoop) {\n        elid(\"\".concat(_this.name, \"-hover-millisecond\")).innerHTML = _this.settings.loopEndMillisecond;\n        return;\n      } else if (clientX - viewportOffset.left < 0 && !_this.settings.resizeLoop) {\n        elid(\"\".concat(_this.name, \"-hover-millisecond\")).innerHTML = _this.settings.loopStartMillisecond;\n        return;\n      }\n\n      var positionX = clientX - viewportOffset.left + _this.settings.loopLastPositionXPxls;\n\n      if (positionX < 0) {\n        positionX = 0;\n      }\n\n      var left = positionX - elid(\"\".concat(_this.name, \"-hover-display\")).offsetWidth / 2;\n\n      if (left < 0) {\n        left = 0;\n      } else if (left + elid(\"\".concat(_this.name, \"-hover-display\")).offsetWidth > _this.elements.totalBar.offsetWidth) {\n        left = _this.elements.totalBar.offsetWidth - elid(\"\".concat(_this.name, \"-hover-display\")).offsetWidth;\n      }\n\n      var ms = Math.round(positionX / _this.elements.totalBar.offsetWidth * _this.clip.duration);\n\n      if (_this.options.preview) {\n        _this.previewJourney.station(ms);\n      }\n\n      elid(\"\".concat(_this.name, \"-hover-millisecond\")).innerHTML = ms;\n      elid(\"\".concat(_this.name, \"-hover-display\")).style.left = left + \"px\";\n    };\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC1wbGF5ZXIvZGlzdC9saXN0ZW5lcnMvcHJldmlldy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4LXBsYXllci9kaXN0L2xpc3RlbmVycy9wcmV2aWV3LmpzPzI0YzIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzXCIpLFxuICAgIGVsaWQgPSBfcmVxdWlyZS5lbGlkLFxuICAgIGFkZExpc3RlbmVyID0gX3JlcXVpcmUuYWRkTGlzdGVuZXIsXG4gICAgcmVtb3ZlTGlzdGVuZXIgPSBfcmVxdWlyZS5yZW1vdmVMaXN0ZW5lcjtcblxudmFyIE1DID0gcmVxdWlyZShcIkBraXNzbXlidXR0b24vbW90b3Jjb3J0ZXhcIik7XG5cbnZhciBob3ZlclRpbWVDYXBzdWxlID0gbmV3IE1DLlRpbWVDYXBzdWxlKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF90aGlzKSB7XG4gIC8vIG9ubHkgb24gZGVzY3RvcCBkZXZpY2VzXG4gIGlmICghL0FuZHJvaWR8d2ViT1N8aVBob25lfGlQYWR8aVBvZHxCbGFja0JlcnJ5fElFTW9iaWxlfE9wZXJhIE1pbmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgdmFyIGxvb3BCYXJNb3VzZUluT3V0ID0gZnVuY3Rpb24gbG9vcEJhck1vdXNlSW5PdXQoKSB7XG4gICAgICBpZiAoIV90aGlzLm9wdGlvbnMucHJldmlldykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItaG92ZXItZGlzcGxheVwiKSkuY2xhc3NMaXN0LnRvZ2dsZShcIm0tZmFkZU91dFwiKTtcbiAgICAgIGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItaG92ZXItZGlzcGxheVwiKSkuY2xhc3NMaXN0LnRvZ2dsZShcIm0tZmFkZUluXCIpO1xuICAgICAgZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1ob3Zlci1kaXNwbGF5XCIpKS5jbGFzc0xpc3QudG9nZ2xlKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLWhpZGVcIikpO1xuXG4gICAgICBpZiAoZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1ob3Zlci1kaXNwbGF5XCIpKS5jbGFzc05hbWUuaW5jbHVkZXMoXCJtLWZhZGVJblwiKSkge1xuICAgICAgICBfdGhpcy5wcmV2aWV3Sm91cm5leSA9IGhvdmVyVGltZUNhcHN1bGUuc3RhcnRKb3VybmV5KF90aGlzLnByZXZpZXdDbGlwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLnByZXZpZXdKb3VybmV5LmRlc3RpbmF0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmVsZW1lbnRzLmxvb3BCYXIub25tb3VzZW1vdmUgPSBsb29wQmFyTW91c2VNb3ZlO1xuICAgIH07XG5cbiAgICB2YXIgbG9vcEJhckFkZExpc3RlbmVycyA9IGZ1bmN0aW9uIGxvb3BCYXJBZGRMaXN0ZW5lcnMoKSB7XG4gICAgICBpZiAoIV90aGlzLm9wdGlvbnMucHJldmlldykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxvb3BCYXJNb3VzZUluT3V0KCk7XG4gICAgICBfdGhpcy5lbGVtZW50cy5sb29wQmFyLm9ubW91c2VvdmVyID0gX3RoaXMuZWxlbWVudHMubG9vcEJhci5vbm1vdXNlb3V0ID0gbG9vcEJhck1vdXNlSW5PdXQ7XG4gICAgICBfdGhpcy5lbGVtZW50cy5sb29wQmFyLm9ubW91c2Vtb3ZlID0gbG9vcEJhck1vdXNlTW92ZTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKFwibW91c2V1cFwiLCBsb29wQmFyQWRkTGlzdGVuZXJzLCBmYWxzZSk7XG4gICAgICByZW1vdmVMaXN0ZW5lcihcInRvdWNoZW5kXCIsIGxvb3BCYXJBZGRMaXN0ZW5lcnMsIGZhbHNlKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIGxvb3BCYXJNb3VzZU1vdmUsIGZhbHNlKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKFwidG91Y2htb3ZlXCIsIGxvb3BCYXJNb3VzZU1vdmUsIGZhbHNlKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuZWxlbWVudHMubG9vcEJhci5vbm1vdXNlb3ZlciA9IF90aGlzLmVsZW1lbnRzLmxvb3BCYXIub25tb3VzZW91dCA9IGxvb3BCYXJNb3VzZUluT3V0O1xuXG4gICAgX3RoaXMuZWxlbWVudHMubG9vcEJhci5vbm1vdXNlZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghX3RoaXMub3B0aW9ucy5wcmV2aWV3KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuZWxlbWVudHMubG9vcEJhci5vbm1vdXNlb3ZlciA9IF90aGlzLmVsZW1lbnRzLmxvb3BCYXIub25tb3VzZW91dCA9IG51bGw7XG4gICAgICBfdGhpcy5lbGVtZW50cy5sb29wQmFyLm9ubW91c2Vtb3ZlID0gbnVsbDtcbiAgICAgIGFkZExpc3RlbmVyKFwibW91c2V1cFwiLCBsb29wQmFyQWRkTGlzdGVuZXJzLCBmYWxzZSk7XG4gICAgICBhZGRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIGxvb3BCYXJBZGRMaXN0ZW5lcnMsIGZhbHNlKTtcbiAgICAgIGFkZExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIGxvb3BCYXJNb3VzZU1vdmUsIGZhbHNlKTtcbiAgICAgIGFkZExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIGxvb3BCYXJNb3VzZU1vdmUsIGZhbHNlKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuZWxlbWVudHMubG9vcEJhci5vbm1vdXNldXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIV90aGlzLm9wdGlvbnMucHJldmlldykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlbW92ZUxpc3RlbmVyKFwibW91c2V1cFwiLCBsb29wQmFyQWRkTGlzdGVuZXJzLCBmYWxzZSk7XG4gICAgICByZW1vdmVMaXN0ZW5lcihcInRvdWNoZW5kXCIsIGxvb3BCYXJBZGRMaXN0ZW5lcnMsIGZhbHNlKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIGxvb3BCYXJNb3VzZU1vdmUsIGZhbHNlKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKFwidG91Y2htb3ZlXCIsIGxvb3BCYXJNb3VzZU1vdmUsIGZhbHNlKTtcbiAgICAgIF90aGlzLmVsZW1lbnRzLmxvb3BCYXIub25tb3VzZW92ZXIgPSBfdGhpcy5lbGVtZW50cy5sb29wQmFyLm9ubW91c2VvdXQgPSBsb29wQmFyTW91c2VJbk91dDtcbiAgICAgIF90aGlzLmVsZW1lbnRzLmxvb3BCYXIub25tb3VzZW1vdmUgPSBsb29wQmFyTW91c2VNb3ZlO1xuICAgIH07XG5cbiAgICB2YXIgbG9vcEJhck1vdXNlTW92ZSA9IGZ1bmN0aW9uIGxvb3BCYXJNb3VzZU1vdmUoZSkge1xuICAgICAgdmFyIGNsaWVudFggPSBlLmNsaWVudFg7XG5cbiAgICAgIHZhciB2aWV3cG9ydE9mZnNldCA9IF90aGlzLmVsZW1lbnRzLmxvb3BCYXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgIGlmIChjbGllbnRYIC0gdmlld3BvcnRPZmZzZXQubGVmdCArIF90aGlzLnNldHRpbmdzLmxvb3BMYXN0UG9zaXRpb25YUHhscyA+IF90aGlzLnNldHRpbmdzLmxvb3BMYXN0UG9zaXRpb25YUHhscyArIF90aGlzLmVsZW1lbnRzLmxvb3BCYXIub2Zmc2V0V2lkdGggJiYgIV90aGlzLnNldHRpbmdzLnJlc2l6ZUxvb3ApIHtcbiAgICAgICAgZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1ob3Zlci1taWxsaXNlY29uZFwiKSkuaW5uZXJIVE1MID0gX3RoaXMuc2V0dGluZ3MubG9vcEVuZE1pbGxpc2Vjb25kO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKGNsaWVudFggLSB2aWV3cG9ydE9mZnNldC5sZWZ0IDwgMCAmJiAhX3RoaXMuc2V0dGluZ3MucmVzaXplTG9vcCkge1xuICAgICAgICBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLWhvdmVyLW1pbGxpc2Vjb25kXCIpKS5pbm5lckhUTUwgPSBfdGhpcy5zZXR0aW5ncy5sb29wU3RhcnRNaWxsaXNlY29uZDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9zaXRpb25YID0gY2xpZW50WCAtIHZpZXdwb3J0T2Zmc2V0LmxlZnQgKyBfdGhpcy5zZXR0aW5ncy5sb29wTGFzdFBvc2l0aW9uWFB4bHM7XG5cbiAgICAgIGlmIChwb3NpdGlvblggPCAwKSB7XG4gICAgICAgIHBvc2l0aW9uWCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZWZ0ID0gcG9zaXRpb25YIC0gZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1ob3Zlci1kaXNwbGF5XCIpKS5vZmZzZXRXaWR0aCAvIDI7XG5cbiAgICAgIGlmIChsZWZ0IDwgMCkge1xuICAgICAgICBsZWZ0ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAobGVmdCArIGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItaG92ZXItZGlzcGxheVwiKSkub2Zmc2V0V2lkdGggPiBfdGhpcy5lbGVtZW50cy50b3RhbEJhci5vZmZzZXRXaWR0aCkge1xuICAgICAgICBsZWZ0ID0gX3RoaXMuZWxlbWVudHMudG90YWxCYXIub2Zmc2V0V2lkdGggLSBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLWhvdmVyLWRpc3BsYXlcIikpLm9mZnNldFdpZHRoO1xuICAgICAgfVxuXG4gICAgICB2YXIgbXMgPSBNYXRoLnJvdW5kKHBvc2l0aW9uWCAvIF90aGlzLmVsZW1lbnRzLnRvdGFsQmFyLm9mZnNldFdpZHRoICogX3RoaXMuY2xpcC5kdXJhdGlvbik7XG5cbiAgICAgIGlmIChfdGhpcy5vcHRpb25zLnByZXZpZXcpIHtcbiAgICAgICAgX3RoaXMucHJldmlld0pvdXJuZXkuc3RhdGlvbihtcyk7XG4gICAgICB9XG5cbiAgICAgIGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItaG92ZXItbWlsbGlzZWNvbmRcIikpLmlubmVySFRNTCA9IG1zO1xuICAgICAgZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1ob3Zlci1kaXNwbGF5XCIpKS5zdHlsZS5sZWZ0ID0gbGVmdCArIFwicHhcIjtcbiAgICB9O1xuICB9XG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex-player/dist/listeners/preview.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex-player/dist/listeners/progressBar.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex-player/dist/listeners/progressBar.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _require = __webpack_require__(/*! ../helpers */ \"./node_modules/@kissmybutton/motorcortex-player/dist/helpers.js\"),\n    addListener = _require.addListener,\n    removeListener = _require.removeListener;\n\nmodule.exports = function (_this) {\n  // let pe = false;\n  _this.listeners.onCursorMove = function (e) {\n    e.preventDefault();\n    var clientX = e.clientX || ((e.touches || [])[0] || {}).clientX;\n\n    var viewportOffset = _this.elements.loopBar.getBoundingClientRect();\n\n    var positionX = clientX - viewportOffset.left;\n\n    if (positionX < 0) {\n      positionX = 0;\n    } else if (positionX > _this.elements.loopBar.offsetWidth) {\n      positionX = _this.elements.loopBar.offsetWidth;\n    }\n\n    _this.handleDrag(positionX);\n  };\n\n  _this.listeners.onMouseUp = function () {\n    _this.elements.listenerHelper.style.pointerEvents = \"none\"; // if (pe) {\n    //   _this.elements.settingsPointerEvents.click();\n    // }\n    // e.preventDefault();\n\n    removeListener(\"mouseup\", _this.listeners.onMouseUp, false);\n    removeListener(\"touchend\", _this.listeners.onMouseUp, false);\n    removeListener(\"mousemove\", _this.listeners.onCursorMove, false);\n    removeListener(\"touchmove\", _this.listeners.onCursorMove, false);\n\n    _this.handleDragEnd(_this.settings);\n\n    if (_this.settings.playAfterResize) {\n      if (_this.clip.state === \"idle\" && !_this.settings.loopActivated) {\n        _this.clip.play();\n      } else if (_this.clip.state === \"completed\" && !_this.settings.loopActivated) {\n        _this.createJourney(_this.clip, _this.settings.loopBarMillisecond - 1, {\n          before: \"stop\",\n          after: \"play\"\n        });\n      } else if ((_this.clip.state === \"completed\" || _this.clip.state === \"idle\") && _this.settings.loopActivated) {\n        _this.clip.speed >= 0 ? _this.createJourney(_this.clip, _this.settings.loopBarStartMillisecond + 1, {\n          before: \"stop\",\n          after: \"play\"\n        }) : _this.createJourney(_this.clip, _this.settings.loopBarEndMillisecond - 1, {\n          before: \"stop\",\n          after: \"play\"\n        });\n      } else {\n        _this.clip.resume();\n      }\n\n      _this.settings.playAfterResize = false;\n    }\n  };\n\n  _this.listeners.onMouseDown = function (e) {\n    _this.elements.listenerHelper.style.pointerEvents = \"auto\"; // e.preventDefault();\n    // if (!_this.options.pointerEvents) {\n    //   pe = true;\n    //   _this.elements.settingsPointerEvents.click();\n    // }\n\n    if (_this.clip.state === \"playing\") {\n      _this.settings.playAfterResize = true;\n    }\n\n    _this.handleDragStart(_this.clip);\n\n    _this.listeners.onCursorMove(e);\n\n    addListener(\"mouseup\", _this.listeners.onMouseUp, false);\n    addListener(\"touchend\", _this.listeners.onMouseUp, false);\n    addListener(\"mousemove\", _this.listeners.onCursorMove, false);\n    addListener(\"touchmove\", _this.listeners.onCursorMove, false);\n  };\n\n  _this.elements.loopBar.addEventListener(\"mousedown\", _this.listeners.onMouseDown, false);\n\n  _this.elements.loopBar.addEventListener(\"touchstart\", _this.listeners.onMouseDown, {\n    passive: false\n  }, false);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC1wbGF5ZXIvZGlzdC9saXN0ZW5lcnMvcHJvZ3Jlc3NCYXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC1wbGF5ZXIvZGlzdC9saXN0ZW5lcnMvcHJvZ3Jlc3NCYXIuanM/ZGUyNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4uL2hlbHBlcnNcIiksXG4gICAgYWRkTGlzdGVuZXIgPSBfcmVxdWlyZS5hZGRMaXN0ZW5lcixcbiAgICByZW1vdmVMaXN0ZW5lciA9IF9yZXF1aXJlLnJlbW92ZUxpc3RlbmVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfdGhpcykge1xuICAvLyBsZXQgcGUgPSBmYWxzZTtcbiAgX3RoaXMubGlzdGVuZXJzLm9uQ3Vyc29yTW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHZhciBjbGllbnRYID0gZS5jbGllbnRYIHx8ICgoZS50b3VjaGVzIHx8IFtdKVswXSB8fCB7fSkuY2xpZW50WDtcblxuICAgIHZhciB2aWV3cG9ydE9mZnNldCA9IF90aGlzLmVsZW1lbnRzLmxvb3BCYXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICB2YXIgcG9zaXRpb25YID0gY2xpZW50WCAtIHZpZXdwb3J0T2Zmc2V0LmxlZnQ7XG5cbiAgICBpZiAocG9zaXRpb25YIDwgMCkge1xuICAgICAgcG9zaXRpb25YID0gMDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uWCA+IF90aGlzLmVsZW1lbnRzLmxvb3BCYXIub2Zmc2V0V2lkdGgpIHtcbiAgICAgIHBvc2l0aW9uWCA9IF90aGlzLmVsZW1lbnRzLmxvb3BCYXIub2Zmc2V0V2lkdGg7XG4gICAgfVxuXG4gICAgX3RoaXMuaGFuZGxlRHJhZyhwb3NpdGlvblgpO1xuICB9O1xuXG4gIF90aGlzLmxpc3RlbmVycy5vbk1vdXNlVXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMuZWxlbWVudHMubGlzdGVuZXJIZWxwZXIuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiOyAvLyBpZiAocGUpIHtcbiAgICAvLyAgIF90aGlzLmVsZW1lbnRzLnNldHRpbmdzUG9pbnRlckV2ZW50cy5jbGljaygpO1xuICAgIC8vIH1cbiAgICAvLyBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICByZW1vdmVMaXN0ZW5lcihcIm1vdXNldXBcIiwgX3RoaXMubGlzdGVuZXJzLm9uTW91c2VVcCwgZmFsc2UpO1xuICAgIHJlbW92ZUxpc3RlbmVyKFwidG91Y2hlbmRcIiwgX3RoaXMubGlzdGVuZXJzLm9uTW91c2VVcCwgZmFsc2UpO1xuICAgIHJlbW92ZUxpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIF90aGlzLmxpc3RlbmVycy5vbkN1cnNvck1vdmUsIGZhbHNlKTtcbiAgICByZW1vdmVMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBfdGhpcy5saXN0ZW5lcnMub25DdXJzb3JNb3ZlLCBmYWxzZSk7XG5cbiAgICBfdGhpcy5oYW5kbGVEcmFnRW5kKF90aGlzLnNldHRpbmdzKTtcblxuICAgIGlmIChfdGhpcy5zZXR0aW5ncy5wbGF5QWZ0ZXJSZXNpemUpIHtcbiAgICAgIGlmIChfdGhpcy5jbGlwLnN0YXRlID09PSBcImlkbGVcIiAmJiAhX3RoaXMuc2V0dGluZ3MubG9vcEFjdGl2YXRlZCkge1xuICAgICAgICBfdGhpcy5jbGlwLnBsYXkoKTtcbiAgICAgIH0gZWxzZSBpZiAoX3RoaXMuY2xpcC5zdGF0ZSA9PT0gXCJjb21wbGV0ZWRcIiAmJiAhX3RoaXMuc2V0dGluZ3MubG9vcEFjdGl2YXRlZCkge1xuICAgICAgICBfdGhpcy5jcmVhdGVKb3VybmV5KF90aGlzLmNsaXAsIF90aGlzLnNldHRpbmdzLmxvb3BCYXJNaWxsaXNlY29uZCAtIDEsIHtcbiAgICAgICAgICBiZWZvcmU6IFwic3RvcFwiLFxuICAgICAgICAgIGFmdGVyOiBcInBsYXlcIlxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoKF90aGlzLmNsaXAuc3RhdGUgPT09IFwiY29tcGxldGVkXCIgfHwgX3RoaXMuY2xpcC5zdGF0ZSA9PT0gXCJpZGxlXCIpICYmIF90aGlzLnNldHRpbmdzLmxvb3BBY3RpdmF0ZWQpIHtcbiAgICAgICAgX3RoaXMuY2xpcC5zcGVlZCA+PSAwID8gX3RoaXMuY3JlYXRlSm91cm5leShfdGhpcy5jbGlwLCBfdGhpcy5zZXR0aW5ncy5sb29wQmFyU3RhcnRNaWxsaXNlY29uZCArIDEsIHtcbiAgICAgICAgICBiZWZvcmU6IFwic3RvcFwiLFxuICAgICAgICAgIGFmdGVyOiBcInBsYXlcIlxuICAgICAgICB9KSA6IF90aGlzLmNyZWF0ZUpvdXJuZXkoX3RoaXMuY2xpcCwgX3RoaXMuc2V0dGluZ3MubG9vcEJhckVuZE1pbGxpc2Vjb25kIC0gMSwge1xuICAgICAgICAgIGJlZm9yZTogXCJzdG9wXCIsXG4gICAgICAgICAgYWZ0ZXI6IFwicGxheVwiXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMuY2xpcC5yZXN1bWUoKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuc2V0dGluZ3MucGxheUFmdGVyUmVzaXplID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIF90aGlzLmxpc3RlbmVycy5vbk1vdXNlRG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgX3RoaXMuZWxlbWVudHMubGlzdGVuZXJIZWxwZXIuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwiYXV0b1wiOyAvLyBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgLy8gaWYgKCFfdGhpcy5vcHRpb25zLnBvaW50ZXJFdmVudHMpIHtcbiAgICAvLyAgIHBlID0gdHJ1ZTtcbiAgICAvLyAgIF90aGlzLmVsZW1lbnRzLnNldHRpbmdzUG9pbnRlckV2ZW50cy5jbGljaygpO1xuICAgIC8vIH1cblxuICAgIGlmIChfdGhpcy5jbGlwLnN0YXRlID09PSBcInBsYXlpbmdcIikge1xuICAgICAgX3RoaXMuc2V0dGluZ3MucGxheUFmdGVyUmVzaXplID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBfdGhpcy5oYW5kbGVEcmFnU3RhcnQoX3RoaXMuY2xpcCk7XG5cbiAgICBfdGhpcy5saXN0ZW5lcnMub25DdXJzb3JNb3ZlKGUpO1xuXG4gICAgYWRkTGlzdGVuZXIoXCJtb3VzZXVwXCIsIF90aGlzLmxpc3RlbmVycy5vbk1vdXNlVXAsIGZhbHNlKTtcbiAgICBhZGRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIF90aGlzLmxpc3RlbmVycy5vbk1vdXNlVXAsIGZhbHNlKTtcbiAgICBhZGRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBfdGhpcy5saXN0ZW5lcnMub25DdXJzb3JNb3ZlLCBmYWxzZSk7XG4gICAgYWRkTGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgX3RoaXMubGlzdGVuZXJzLm9uQ3Vyc29yTW92ZSwgZmFsc2UpO1xuICB9O1xuXG4gIF90aGlzLmVsZW1lbnRzLmxvb3BCYXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZURvd24sIGZhbHNlKTtcblxuICBfdGhpcy5lbGVtZW50cy5sb29wQmFyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIF90aGlzLmxpc3RlbmVycy5vbk1vdXNlRG93biwge1xuICAgIHBhc3NpdmU6IGZhbHNlXG4gIH0sIGZhbHNlKTtcbn07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex-player/dist/listeners/progressBar.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex-player/dist/listeners/settings.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex-player/dist/listeners/settings.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _require = __webpack_require__(/*! ../helpers */ \"./node_modules/@kissmybutton/motorcortex-player/dist/helpers.js\"),\n    elid = _require.elid,\n    addListener = _require.addListener,\n    removeListener = _require.removeListener;\n\nmodule.exports = function (_this) {\n  _this.elements.settingsShowIndicator.onclick = function (e) {\n    e.preventDefault();\n    var checkbox = elid(\"\".concat(_this.name, \"-show-indicator-checkbox\"));\n\n    if (checkbox.checked) {\n      checkbox.checked = false;\n      _this.elements.indicator.style.visibility = \"hidden\";\n      _this.elements.statusButton.style.width = \"40px\";\n      _this.elements.statusButton.style.height = \"25px\";\n      _this.elements.statusButton.style.bottom = \"0px\";\n    } else {\n      checkbox.checked = true;\n      _this.elements.indicator.style.visibility = \"visible\";\n      _this.elements.statusButton.style.width = \"35px\";\n      _this.elements.statusButton.style.height = \"20px\";\n      _this.elements.statusButton.style.bottom = \"5px\";\n    }\n  };\n\n  _this.elements.settingsPointerEvents.onclick = function (e) {\n    e.preventDefault();\n    var checkbox = elid(\"\".concat(_this.name, \"-pointer-events-checkbox\"));\n\n    if (checkbox.checked) {\n      checkbox.checked = false;\n      _this.options.pointerEvents = false;\n      _this.elements.mcPlayer.style.pointerEvents = \"none\";\n      _this.elements.pointerEventPanel.style.pointerEvents = \"none\";\n      elid(\"\".concat(_this.name, \"-controls\")).style.pointerEvents = \"auto\";\n      _this.elements.settingsPanel.style.pointerEvents = \"auto\";\n    } else {\n      checkbox.checked = true;\n      _this.elements.mcPlayer.style.pointerEvents = \"none\";\n      _this.elements.pointerEventPanel.style.pointerEvents = \"auto\";\n      elid(\"\".concat(_this.name, \"-controls\")).style.pointerEvents = \"auto\";\n      _this.elements.settingsPanel.style.pointerEvents = \"auto\";\n    }\n  };\n\n  _this.elements.settingsShowVolume.onclick = function (e) {\n    e.preventDefault();\n\n    _this.elements.volumeControl.classList.toggle(\"\".concat(_this.name, \"-volume-width-transition\"));\n\n    _this.elements.volumeBar.classList.toggle(\"\".concat(_this.name, \"-volume-width-transition\"));\n\n    _this.elements.volumeBar.classList.toggle(\"\".concat(_this.name, \"-hide\"));\n\n    _this.elements.volumeBarHelper.classList.toggle(\"\".concat(_this.name, \"-volume-width-transition\")); // _this.elements.timeDisplay.classList.toggle(\n    //   `${_this.name}-time-width-transition`\n    // );\n\n\n    var checkbox = elid(\"\".concat(_this.name, \"-show-volume-checkbox\"));\n\n    if (checkbox.checked) {\n      checkbox.checked = false;\n      _this.elements.volumeControl.style.visibility = \"hidden\";\n      _this.elements.timeDisplay.style.left = \"45px\";\n    } else {\n      checkbox.checked = true;\n      _this.elements.volumeControl.style.visibility = \"visible\";\n      _this.elements.timeDisplay.style.left = \"\";\n    }\n  };\n\n  _this.elements.settingsShowPreview.onclick = function (e) {\n    e.preventDefault();\n    var checkbox = elid(\"\".concat(_this.name, \"-show-preview-checkbox\"));\n\n    if (checkbox.checked) {\n      checkbox.checked = false;\n      elid(\"\".concat(_this.name, \"-hover-display\")).style.visibility = \"hidden\";\n      elid(\"\".concat(_this.name, \"-hover-display\")).style.display = \"none\";\n      _this.options.preview = false;\n    } else {\n      if (!_this.previewClip) {\n        _this.createPreviewDisplay();\n      }\n\n      checkbox.checked = true;\n      elid(\"\".concat(_this.name, \"-hover-display\")).style.visibility = \"visible\";\n      elid(\"\".concat(_this.name, \"-hover-display\")).style.display = \"flex\";\n      _this.options.preview = true;\n    }\n  };\n\n  _this.elements.settingsButton.onclick = function (e) {\n    e.preventDefault();\n\n    var showHideSettings = function showHideSettings(e) {\n      if (_this.elements.settingsPanel.contains(e.target)) {\n        return true;\n      }\n\n      _this.elements.settingsPanel.classList.toggle(\"\".concat(_this.name, \"-hide\"));\n\n      _this.elements.settingsPanel.classList.toggle(\"m-fadeOut\");\n\n      _this.elements.settingsPanel.classList.toggle(\"m-fadeIn\");\n\n      if (_this.elements.settingsPanel.className.includes(\"m-fadeOut\")) {\n        removeListener(\"click\", showHideSettings, false);\n      }\n    };\n\n    if (_this.elements.settingsPanel.className.includes(\"m-fadeOut\")) {\n      addListener(\"click\", showHideSettings, false);\n    } else {\n      removeListener(\"click\", showHideSettings, false);\n    }\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC1wbGF5ZXIvZGlzdC9saXN0ZW5lcnMvc2V0dGluZ3MuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC1wbGF5ZXIvZGlzdC9saXN0ZW5lcnMvc2V0dGluZ3MuanM/MjljMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4uL2hlbHBlcnNcIiksXG4gICAgZWxpZCA9IF9yZXF1aXJlLmVsaWQsXG4gICAgYWRkTGlzdGVuZXIgPSBfcmVxdWlyZS5hZGRMaXN0ZW5lcixcbiAgICByZW1vdmVMaXN0ZW5lciA9IF9yZXF1aXJlLnJlbW92ZUxpc3RlbmVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfdGhpcykge1xuICBfdGhpcy5lbGVtZW50cy5zZXR0aW5nc1Nob3dJbmRpY2F0b3Iub25jbGljayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHZhciBjaGVja2JveCA9IGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItc2hvdy1pbmRpY2F0b3ItY2hlY2tib3hcIikpO1xuXG4gICAgaWYgKGNoZWNrYm94LmNoZWNrZWQpIHtcbiAgICAgIGNoZWNrYm94LmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgIF90aGlzLmVsZW1lbnRzLmluZGljYXRvci5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgIF90aGlzLmVsZW1lbnRzLnN0YXR1c0J1dHRvbi5zdHlsZS53aWR0aCA9IFwiNDBweFwiO1xuICAgICAgX3RoaXMuZWxlbWVudHMuc3RhdHVzQnV0dG9uLnN0eWxlLmhlaWdodCA9IFwiMjVweFwiO1xuICAgICAgX3RoaXMuZWxlbWVudHMuc3RhdHVzQnV0dG9uLnN0eWxlLmJvdHRvbSA9IFwiMHB4XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoZWNrYm94LmNoZWNrZWQgPSB0cnVlO1xuICAgICAgX3RoaXMuZWxlbWVudHMuaW5kaWNhdG9yLnN0eWxlLnZpc2liaWxpdHkgPSBcInZpc2libGVcIjtcbiAgICAgIF90aGlzLmVsZW1lbnRzLnN0YXR1c0J1dHRvbi5zdHlsZS53aWR0aCA9IFwiMzVweFwiO1xuICAgICAgX3RoaXMuZWxlbWVudHMuc3RhdHVzQnV0dG9uLnN0eWxlLmhlaWdodCA9IFwiMjBweFwiO1xuICAgICAgX3RoaXMuZWxlbWVudHMuc3RhdHVzQnV0dG9uLnN0eWxlLmJvdHRvbSA9IFwiNXB4XCI7XG4gICAgfVxuICB9O1xuXG4gIF90aGlzLmVsZW1lbnRzLnNldHRpbmdzUG9pbnRlckV2ZW50cy5vbmNsaWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyIGNoZWNrYm94ID0gZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1wb2ludGVyLWV2ZW50cy1jaGVja2JveFwiKSk7XG5cbiAgICBpZiAoY2hlY2tib3guY2hlY2tlZCkge1xuICAgICAgY2hlY2tib3guY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgX3RoaXMub3B0aW9ucy5wb2ludGVyRXZlbnRzID0gZmFsc2U7XG4gICAgICBfdGhpcy5lbGVtZW50cy5tY1BsYXllci5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gICAgICBfdGhpcy5lbGVtZW50cy5wb2ludGVyRXZlbnRQYW5lbC5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gICAgICBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLWNvbnRyb2xzXCIpKS5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJhdXRvXCI7XG4gICAgICBfdGhpcy5lbGVtZW50cy5zZXR0aW5nc1BhbmVsLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcImF1dG9cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hlY2tib3guY2hlY2tlZCA9IHRydWU7XG4gICAgICBfdGhpcy5lbGVtZW50cy5tY1BsYXllci5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gICAgICBfdGhpcy5lbGVtZW50cy5wb2ludGVyRXZlbnRQYW5lbC5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJhdXRvXCI7XG4gICAgICBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLWNvbnRyb2xzXCIpKS5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJhdXRvXCI7XG4gICAgICBfdGhpcy5lbGVtZW50cy5zZXR0aW5nc1BhbmVsLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcImF1dG9cIjtcbiAgICB9XG4gIH07XG5cbiAgX3RoaXMuZWxlbWVudHMuc2V0dGluZ3NTaG93Vm9sdW1lLm9uY2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIF90aGlzLmVsZW1lbnRzLnZvbHVtZUNvbnRyb2wuY2xhc3NMaXN0LnRvZ2dsZShcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi12b2x1bWUtd2lkdGgtdHJhbnNpdGlvblwiKSk7XG5cbiAgICBfdGhpcy5lbGVtZW50cy52b2x1bWVCYXIuY2xhc3NMaXN0LnRvZ2dsZShcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi12b2x1bWUtd2lkdGgtdHJhbnNpdGlvblwiKSk7XG5cbiAgICBfdGhpcy5lbGVtZW50cy52b2x1bWVCYXIuY2xhc3NMaXN0LnRvZ2dsZShcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1oaWRlXCIpKTtcblxuICAgIF90aGlzLmVsZW1lbnRzLnZvbHVtZUJhckhlbHBlci5jbGFzc0xpc3QudG9nZ2xlKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXZvbHVtZS13aWR0aC10cmFuc2l0aW9uXCIpKTsgLy8gX3RoaXMuZWxlbWVudHMudGltZURpc3BsYXkuY2xhc3NMaXN0LnRvZ2dsZShcbiAgICAvLyAgIGAke190aGlzLm5hbWV9LXRpbWUtd2lkdGgtdHJhbnNpdGlvbmBcbiAgICAvLyApO1xuXG5cbiAgICB2YXIgY2hlY2tib3ggPSBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXNob3ctdm9sdW1lLWNoZWNrYm94XCIpKTtcblxuICAgIGlmIChjaGVja2JveC5jaGVja2VkKSB7XG4gICAgICBjaGVja2JveC5jaGVja2VkID0gZmFsc2U7XG4gICAgICBfdGhpcy5lbGVtZW50cy52b2x1bWVDb250cm9sLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgX3RoaXMuZWxlbWVudHMudGltZURpc3BsYXkuc3R5bGUubGVmdCA9IFwiNDVweFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGVja2JveC5jaGVja2VkID0gdHJ1ZTtcbiAgICAgIF90aGlzLmVsZW1lbnRzLnZvbHVtZUNvbnRyb2wuc3R5bGUudmlzaWJpbGl0eSA9IFwidmlzaWJsZVwiO1xuICAgICAgX3RoaXMuZWxlbWVudHMudGltZURpc3BsYXkuc3R5bGUubGVmdCA9IFwiXCI7XG4gICAgfVxuICB9O1xuXG4gIF90aGlzLmVsZW1lbnRzLnNldHRpbmdzU2hvd1ByZXZpZXcub25jbGljayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHZhciBjaGVja2JveCA9IGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItc2hvdy1wcmV2aWV3LWNoZWNrYm94XCIpKTtcblxuICAgIGlmIChjaGVja2JveC5jaGVja2VkKSB7XG4gICAgICBjaGVja2JveC5jaGVja2VkID0gZmFsc2U7XG4gICAgICBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLWhvdmVyLWRpc3BsYXlcIikpLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1ob3Zlci1kaXNwbGF5XCIpKS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICBfdGhpcy5vcHRpb25zLnByZXZpZXcgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFfdGhpcy5wcmV2aWV3Q2xpcCkge1xuICAgICAgICBfdGhpcy5jcmVhdGVQcmV2aWV3RGlzcGxheSgpO1xuICAgICAgfVxuXG4gICAgICBjaGVja2JveC5jaGVja2VkID0gdHJ1ZTtcbiAgICAgIGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItaG92ZXItZGlzcGxheVwiKSkuc3R5bGUudmlzaWJpbGl0eSA9IFwidmlzaWJsZVwiO1xuICAgICAgZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1ob3Zlci1kaXNwbGF5XCIpKS5zdHlsZS5kaXNwbGF5ID0gXCJmbGV4XCI7XG4gICAgICBfdGhpcy5vcHRpb25zLnByZXZpZXcgPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICBfdGhpcy5lbGVtZW50cy5zZXR0aW5nc0J1dHRvbi5vbmNsaWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICB2YXIgc2hvd0hpZGVTZXR0aW5ncyA9IGZ1bmN0aW9uIHNob3dIaWRlU2V0dGluZ3MoZSkge1xuICAgICAgaWYgKF90aGlzLmVsZW1lbnRzLnNldHRpbmdzUGFuZWwuY29udGFpbnMoZS50YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5lbGVtZW50cy5zZXR0aW5nc1BhbmVsLmNsYXNzTGlzdC50b2dnbGUoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItaGlkZVwiKSk7XG5cbiAgICAgIF90aGlzLmVsZW1lbnRzLnNldHRpbmdzUGFuZWwuY2xhc3NMaXN0LnRvZ2dsZShcIm0tZmFkZU91dFwiKTtcblxuICAgICAgX3RoaXMuZWxlbWVudHMuc2V0dGluZ3NQYW5lbC5jbGFzc0xpc3QudG9nZ2xlKFwibS1mYWRlSW5cIik7XG5cbiAgICAgIGlmIChfdGhpcy5lbGVtZW50cy5zZXR0aW5nc1BhbmVsLmNsYXNzTmFtZS5pbmNsdWRlcyhcIm0tZmFkZU91dFwiKSkge1xuICAgICAgICByZW1vdmVMaXN0ZW5lcihcImNsaWNrXCIsIHNob3dIaWRlU2V0dGluZ3MsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKF90aGlzLmVsZW1lbnRzLnNldHRpbmdzUGFuZWwuY2xhc3NOYW1lLmluY2x1ZGVzKFwibS1mYWRlT3V0XCIpKSB7XG4gICAgICBhZGRMaXN0ZW5lcihcImNsaWNrXCIsIHNob3dIaWRlU2V0dGluZ3MsIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoXCJjbGlja1wiLCBzaG93SGlkZVNldHRpbmdzLCBmYWxzZSk7XG4gICAgfVxuICB9O1xufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex-player/dist/listeners/settings.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex-player/dist/listeners/speed.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex-player/dist/listeners/speed.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _require = __webpack_require__(/*! ../helpers */ \"./node_modules/@kissmybutton/motorcortex-player/dist/helpers.js\"),\n    elid = _require.elid,\n    addListener = _require.addListener,\n    removeListener = _require.removeListener;\n\nmodule.exports = function (_this) {\n  // const pe = false;\n  _this.elements.settingsSpeedButtonShow.onclick = _this.elements.settingsSpeedButtonHide.onclick = function (e) {\n    e.preventDefault();\n\n    _this.elements.settingsPanel.classList.toggle(\"\".concat(_this.name, \"-settings-speed-panel\"));\n\n    var includesClass = _this.elements.settingsPanel.className.includes(\"\".concat(_this.name, \"-settings-speed-panel\"));\n\n    if (includesClass) {\n      _this.elements.settingsMainPanel.style.display = \"none\";\n      _this.elements.settingsSpeedPanel.style.display = \"block\";\n    } else {\n      _this.elements.settingsSpeedPanel.style.display = \"none\";\n      _this.elements.settingsMainPanel.style.display = \"block\";\n    }\n  };\n\n  var onCursorMoveSpeedBar = function onCursorMoveSpeedBar(e) {\n    e.preventDefault();\n\n    var viewportOffset = _this.elements.speedBar.getBoundingClientRect();\n\n    var clientY = e.clientY || ((e.touches || [])[0] || {}).clientY;\n    var positionY = clientY - viewportOffset.top;\n    positionY -= 8;\n\n    if (positionY < 0) {\n      positionY = 0;\n    } else if (positionY > _this.elements.speedBar.offsetHeight - 16) {\n      positionY = _this.elements.speedBar.offsetHeight - 16;\n    }\n\n    positionY = Math.floor(positionY); // show speed\n\n    var percentage = (positionY / ((_this.options.speedValues.length - 1) * 16) - 1) * -1;\n    var step = 1 / (_this.options.speedValues.length - 1);\n\n    var speed = _this.calculateSpeed(step, _this.options.speedValues, percentage);\n\n    elid(\"\".concat(_this.name, \"-speed-runtime\")).innerHTML = speed + \"0\";\n    elid(\"\".concat(_this.name, \"-speed-cursor\")).style.top = positionY + \"px\";\n    _this.clip.executionSpeed = speed;\n  };\n\n  var onMouseUpSpeedBar = function onMouseUpSpeedBar(e) {\n    // if (pe) {\n    //   _this.elements.settingsPointerEvents.click();\n    // }\n    _this.elements.listenerHelper.style.pointerEvents = \"none\";\n    e.preventDefault();\n    removeListener(\"mouseup\", onMouseUpSpeedBar, false);\n    removeListener(\"touchend\", onMouseUpSpeedBar, false);\n    removeListener(\"mousemove\", onCursorMoveSpeedBar, false);\n    removeListener(\"touchmove\", onCursorMoveSpeedBar, false);\n    elid(\"\".concat(_this.name, \"-speed-runtime\")).innerHTML = \"Speed\";\n    var speedDisplay;\n    _this.clip.speed == 1 ? speedDisplay = \"Normal\" : speedDisplay = _this.clip.speed;\n    _this.elements.speedCurrent.innerHTML = speedDisplay;\n  };\n\n  var onMouseDownSpeedBar = function onMouseDownSpeedBar(e) {\n    // if (!_this.options.pointerEvents) {\n    //   pe = true;\n    //   _this.elements.settingsPointerEvents.click();\n    // }\n    _this.elements.listenerHelper.style.pointerEvents = \"auto\";\n    e.preventDefault();\n    onCursorMoveSpeedBar(e);\n    addListener(\"mouseup\", onMouseUpSpeedBar, false);\n    addListener(\"touchend\", onMouseUpSpeedBar, false);\n    addListener(\"mousemove\", onCursorMoveSpeedBar, false);\n    addListener(\"touchmove\", onCursorMoveSpeedBar, false);\n  };\n\n  _this.elements.speedBarHelper.addEventListener(\"mousedown\", onMouseDownSpeedBar, false);\n\n  _this.elements.speedBarHelper.addEventListener(\"touchstart\", onMouseDownSpeedBar, {\n    passive: false\n  }, false);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC1wbGF5ZXIvZGlzdC9saXN0ZW5lcnMvc3BlZWQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC1wbGF5ZXIvZGlzdC9saXN0ZW5lcnMvc3BlZWQuanM/NDgyNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4uL2hlbHBlcnNcIiksXG4gICAgZWxpZCA9IF9yZXF1aXJlLmVsaWQsXG4gICAgYWRkTGlzdGVuZXIgPSBfcmVxdWlyZS5hZGRMaXN0ZW5lcixcbiAgICByZW1vdmVMaXN0ZW5lciA9IF9yZXF1aXJlLnJlbW92ZUxpc3RlbmVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfdGhpcykge1xuICAvLyBjb25zdCBwZSA9IGZhbHNlO1xuICBfdGhpcy5lbGVtZW50cy5zZXR0aW5nc1NwZWVkQnV0dG9uU2hvdy5vbmNsaWNrID0gX3RoaXMuZWxlbWVudHMuc2V0dGluZ3NTcGVlZEJ1dHRvbkhpZGUub25jbGljayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgX3RoaXMuZWxlbWVudHMuc2V0dGluZ3NQYW5lbC5jbGFzc0xpc3QudG9nZ2xlKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXNldHRpbmdzLXNwZWVkLXBhbmVsXCIpKTtcblxuICAgIHZhciBpbmNsdWRlc0NsYXNzID0gX3RoaXMuZWxlbWVudHMuc2V0dGluZ3NQYW5lbC5jbGFzc05hbWUuaW5jbHVkZXMoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItc2V0dGluZ3Mtc3BlZWQtcGFuZWxcIikpO1xuXG4gICAgaWYgKGluY2x1ZGVzQ2xhc3MpIHtcbiAgICAgIF90aGlzLmVsZW1lbnRzLnNldHRpbmdzTWFpblBhbmVsLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgIF90aGlzLmVsZW1lbnRzLnNldHRpbmdzU3BlZWRQYW5lbC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpcy5lbGVtZW50cy5zZXR0aW5nc1NwZWVkUGFuZWwuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgX3RoaXMuZWxlbWVudHMuc2V0dGluZ3NNYWluUGFuZWwuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICB9XG4gIH07XG5cbiAgdmFyIG9uQ3Vyc29yTW92ZVNwZWVkQmFyID0gZnVuY3Rpb24gb25DdXJzb3JNb3ZlU3BlZWRCYXIoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIHZhciB2aWV3cG9ydE9mZnNldCA9IF90aGlzLmVsZW1lbnRzLnNwZWVkQmFyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgdmFyIGNsaWVudFkgPSBlLmNsaWVudFkgfHwgKChlLnRvdWNoZXMgfHwgW10pWzBdIHx8IHt9KS5jbGllbnRZO1xuICAgIHZhciBwb3NpdGlvblkgPSBjbGllbnRZIC0gdmlld3BvcnRPZmZzZXQudG9wO1xuICAgIHBvc2l0aW9uWSAtPSA4O1xuXG4gICAgaWYgKHBvc2l0aW9uWSA8IDApIHtcbiAgICAgIHBvc2l0aW9uWSA9IDA7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvblkgPiBfdGhpcy5lbGVtZW50cy5zcGVlZEJhci5vZmZzZXRIZWlnaHQgLSAxNikge1xuICAgICAgcG9zaXRpb25ZID0gX3RoaXMuZWxlbWVudHMuc3BlZWRCYXIub2Zmc2V0SGVpZ2h0IC0gMTY7XG4gICAgfVxuXG4gICAgcG9zaXRpb25ZID0gTWF0aC5mbG9vcihwb3NpdGlvblkpOyAvLyBzaG93IHNwZWVkXG5cbiAgICB2YXIgcGVyY2VudGFnZSA9IChwb3NpdGlvblkgLyAoKF90aGlzLm9wdGlvbnMuc3BlZWRWYWx1ZXMubGVuZ3RoIC0gMSkgKiAxNikgLSAxKSAqIC0xO1xuICAgIHZhciBzdGVwID0gMSAvIChfdGhpcy5vcHRpb25zLnNwZWVkVmFsdWVzLmxlbmd0aCAtIDEpO1xuXG4gICAgdmFyIHNwZWVkID0gX3RoaXMuY2FsY3VsYXRlU3BlZWQoc3RlcCwgX3RoaXMub3B0aW9ucy5zcGVlZFZhbHVlcywgcGVyY2VudGFnZSk7XG5cbiAgICBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXNwZWVkLXJ1bnRpbWVcIikpLmlubmVySFRNTCA9IHNwZWVkICsgXCIwXCI7XG4gICAgZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1zcGVlZC1jdXJzb3JcIikpLnN0eWxlLnRvcCA9IHBvc2l0aW9uWSArIFwicHhcIjtcbiAgICBfdGhpcy5jbGlwLmV4ZWN1dGlvblNwZWVkID0gc3BlZWQ7XG4gIH07XG5cbiAgdmFyIG9uTW91c2VVcFNwZWVkQmFyID0gZnVuY3Rpb24gb25Nb3VzZVVwU3BlZWRCYXIoZSkge1xuICAgIC8vIGlmIChwZSkge1xuICAgIC8vICAgX3RoaXMuZWxlbWVudHMuc2V0dGluZ3NQb2ludGVyRXZlbnRzLmNsaWNrKCk7XG4gICAgLy8gfVxuICAgIF90aGlzLmVsZW1lbnRzLmxpc3RlbmVySGVscGVyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgcmVtb3ZlTGlzdGVuZXIoXCJtb3VzZXVwXCIsIG9uTW91c2VVcFNwZWVkQmFyLCBmYWxzZSk7XG4gICAgcmVtb3ZlTGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBvbk1vdXNlVXBTcGVlZEJhciwgZmFsc2UpO1xuICAgIHJlbW92ZUxpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG9uQ3Vyc29yTW92ZVNwZWVkQmFyLCBmYWxzZSk7XG4gICAgcmVtb3ZlTGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgb25DdXJzb3JNb3ZlU3BlZWRCYXIsIGZhbHNlKTtcbiAgICBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXNwZWVkLXJ1bnRpbWVcIikpLmlubmVySFRNTCA9IFwiU3BlZWRcIjtcbiAgICB2YXIgc3BlZWREaXNwbGF5O1xuICAgIF90aGlzLmNsaXAuc3BlZWQgPT0gMSA/IHNwZWVkRGlzcGxheSA9IFwiTm9ybWFsXCIgOiBzcGVlZERpc3BsYXkgPSBfdGhpcy5jbGlwLnNwZWVkO1xuICAgIF90aGlzLmVsZW1lbnRzLnNwZWVkQ3VycmVudC5pbm5lckhUTUwgPSBzcGVlZERpc3BsYXk7XG4gIH07XG5cbiAgdmFyIG9uTW91c2VEb3duU3BlZWRCYXIgPSBmdW5jdGlvbiBvbk1vdXNlRG93blNwZWVkQmFyKGUpIHtcbiAgICAvLyBpZiAoIV90aGlzLm9wdGlvbnMucG9pbnRlckV2ZW50cykge1xuICAgIC8vICAgcGUgPSB0cnVlO1xuICAgIC8vICAgX3RoaXMuZWxlbWVudHMuc2V0dGluZ3NQb2ludGVyRXZlbnRzLmNsaWNrKCk7XG4gICAgLy8gfVxuICAgIF90aGlzLmVsZW1lbnRzLmxpc3RlbmVySGVscGVyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcImF1dG9cIjtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgb25DdXJzb3JNb3ZlU3BlZWRCYXIoZSk7XG4gICAgYWRkTGlzdGVuZXIoXCJtb3VzZXVwXCIsIG9uTW91c2VVcFNwZWVkQmFyLCBmYWxzZSk7XG4gICAgYWRkTGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBvbk1vdXNlVXBTcGVlZEJhciwgZmFsc2UpO1xuICAgIGFkZExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG9uQ3Vyc29yTW92ZVNwZWVkQmFyLCBmYWxzZSk7XG4gICAgYWRkTGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgb25DdXJzb3JNb3ZlU3BlZWRCYXIsIGZhbHNlKTtcbiAgfTtcblxuICBfdGhpcy5lbGVtZW50cy5zcGVlZEJhckhlbHBlci5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIG9uTW91c2VEb3duU3BlZWRCYXIsIGZhbHNlKTtcblxuICBfdGhpcy5lbGVtZW50cy5zcGVlZEJhckhlbHBlci5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBvbk1vdXNlRG93blNwZWVkQmFyLCB7XG4gICAgcGFzc2l2ZTogZmFsc2VcbiAgfSwgZmFsc2UpO1xufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex-player/dist/listeners/speed.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex-player/dist/listeners/statusBtn.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex-player/dist/listeners/statusBtn.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function (_this) {\n  _this.elements.statusButton.onclick = function (e) {\n    e.preventDefault();\n\n    if (_this.clip.state === \"playing\") {\n      _this.clip.wait();\n    } else if (_this.clip.state === \"waiting\") {\n      _this.clip.resume();\n    } else if (_this.clip.state === \"idle\") {\n      if (_this.clip.speed >= 0) {\n        _this.clip.play();\n\n        _this.settings.needsUpdate = true;\n      } else {\n        _this.createJourney(_this.clip, _this.settings.loopEndMillisecond - 1, {\n          before: \"stop\",\n          after: \"play\"\n        });\n\n        _this.settings.needsUpdate = true;\n      }\n    } else if (_this.clip.state === \"completed\") {\n      if (_this.clip.speed >= 0) {\n        _this.createJourney(_this.clip, 0, {\n          before: \"stop\",\n          after: \"play\"\n        });\n\n        _this.settings.needsUpdate = true;\n      } else {\n        _this.createJourney(_this.clip, _this.settings.loopEndMillisecond - 1, {\n          before: \"stop\",\n          after: \"play\"\n        });\n\n        _this.settings.needsUpdate = true;\n      }\n    }\n\n    return false;\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC1wbGF5ZXIvZGlzdC9saXN0ZW5lcnMvc3RhdHVzQnRuLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyL2Rpc3QvbGlzdGVuZXJzL3N0YXR1c0J0bi5qcz9mODVkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfdGhpcykge1xuICBfdGhpcy5lbGVtZW50cy5zdGF0dXNCdXR0b24ub25jbGljayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgaWYgKF90aGlzLmNsaXAuc3RhdGUgPT09IFwicGxheWluZ1wiKSB7XG4gICAgICBfdGhpcy5jbGlwLndhaXQoKTtcbiAgICB9IGVsc2UgaWYgKF90aGlzLmNsaXAuc3RhdGUgPT09IFwid2FpdGluZ1wiKSB7XG4gICAgICBfdGhpcy5jbGlwLnJlc3VtZSgpO1xuICAgIH0gZWxzZSBpZiAoX3RoaXMuY2xpcC5zdGF0ZSA9PT0gXCJpZGxlXCIpIHtcbiAgICAgIGlmIChfdGhpcy5jbGlwLnNwZWVkID49IDApIHtcbiAgICAgICAgX3RoaXMuY2xpcC5wbGF5KCk7XG5cbiAgICAgICAgX3RoaXMuc2V0dGluZ3MubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMuY3JlYXRlSm91cm5leShfdGhpcy5jbGlwLCBfdGhpcy5zZXR0aW5ncy5sb29wRW5kTWlsbGlzZWNvbmQgLSAxLCB7XG4gICAgICAgICAgYmVmb3JlOiBcInN0b3BcIixcbiAgICAgICAgICBhZnRlcjogXCJwbGF5XCJcbiAgICAgICAgfSk7XG5cbiAgICAgICAgX3RoaXMuc2V0dGluZ3MubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoX3RoaXMuY2xpcC5zdGF0ZSA9PT0gXCJjb21wbGV0ZWRcIikge1xuICAgICAgaWYgKF90aGlzLmNsaXAuc3BlZWQgPj0gMCkge1xuICAgICAgICBfdGhpcy5jcmVhdGVKb3VybmV5KF90aGlzLmNsaXAsIDAsIHtcbiAgICAgICAgICBiZWZvcmU6IFwic3RvcFwiLFxuICAgICAgICAgIGFmdGVyOiBcInBsYXlcIlxuICAgICAgICB9KTtcblxuICAgICAgICBfdGhpcy5zZXR0aW5ncy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5jcmVhdGVKb3VybmV5KF90aGlzLmNsaXAsIF90aGlzLnNldHRpbmdzLmxvb3BFbmRNaWxsaXNlY29uZCAtIDEsIHtcbiAgICAgICAgICBiZWZvcmU6IFwic3RvcFwiLFxuICAgICAgICAgIGFmdGVyOiBcInBsYXlcIlxuICAgICAgICB9KTtcblxuICAgICAgICBfdGhpcy5zZXR0aW5ncy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex-player/dist/listeners/statusBtn.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex-player/dist/listeners/volume.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex-player/dist/listeners/volume.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _require = __webpack_require__(/*! ../helpers */ \"./node_modules/@kissmybutton/motorcortex-player/dist/helpers.js\"),\n    addListener = _require.addListener,\n    removeListener = _require.removeListener,\n    elid = _require.elid;\n\nvar svg = __webpack_require__(/*! ../html/svg */ \"./node_modules/@kissmybutton/motorcortex-player/dist/html/svg.js\");\n\nmodule.exports = function (_this) {\n  // let pe = false;\n  var volumeDrag = false;\n\n  _this.elements.volumeBtn.onclick = function () {\n    if (_this.settings.volumeMute) {\n      _this.elements.volumeBarActive.style.width = _this.settings.previousVolume * 100 + \"%\";\n\n      _this.clip.setVolume(_this.settings.previousVolume);\n\n      _this.settings.volumeMute = false;\n      var SVG = document.createElement(\"span\");\n      SVG.innerHTML = svg.volumeSVG;\n\n      _this.elements.volumeBtn.getElementsByTagName(\"svg\")[0].replaceWith(SVG);\n    } else {\n      _this.settings.volumeMute = true;\n      _this.elements.volumeBarActive.style.width = \"0%\";\n\n      _this.clip.setVolume(0);\n\n      var _SVG = document.createElement(\"span\");\n\n      _SVG.innerHTML = svg.volumeMuteSVG;\n\n      _this.elements.volumeBtn.getElementsByTagName(\"svg\")[0].replaceWith(_SVG);\n    }\n  };\n\n  var volumeOpen = false;\n\n  _this.elements.volumeBtn.onmouseover = function () {\n    volumeOpen = true;\n\n    _this.elements.volumeCursor.classList.add(\"\".concat(_this.name, \"-volume-cursor-transition\"));\n\n    _this.elements.volumeBar.classList.add(\"\".concat(_this.name, \"-volume-width-transition\"));\n\n    _this.elements.volumeBarHelper.classList.add(\"\".concat(_this.name, \"-volume-width-transition\"));\n\n    _this.elements.timeDisplay.classList.add(\"\".concat(_this.name, \"-time-width-transition\"));\n  };\n\n  elid(\"\".concat(_this.name, \"-left-controls\")).onmouseout = function () {\n    if (!volumeOpen || volumeDrag) {\n      return;\n    }\n\n    var e = event.toElement || event.relatedTarget || event.target;\n\n    if (isDescendant(elid(\"\".concat(_this.name, \"-left-controls\")), e) || e === elid(\"\".concat(_this.name, \"-left-controls\"))) {\n      return;\n    }\n\n    volumeOpen = false;\n\n    _this.elements.volumeCursor.classList.remove(\"\".concat(_this.name, \"-volume-cursor-transition\"));\n\n    _this.elements.volumeBar.classList.remove(\"\".concat(_this.name, \"-volume-width-transition\"));\n\n    _this.elements.volumeBarHelper.classList.remove(\"\".concat(_this.name, \"-volume-width-transition\"));\n\n    _this.elements.timeDisplay.classList.remove(\"\".concat(_this.name, \"-time-width-transition\"));\n  };\n\n  _this.listeners.onCursorMoveVolumeBar = function (e) {\n    e.preventDefault();\n    var clientX = e.clientX || ((e.touches || [])[0] || {}).clientX;\n\n    var viewportOffset = _this.elements.volumeBarHelper.getBoundingClientRect();\n\n    var positionX = clientX - viewportOffset.left;\n\n    if (positionX < 0) {\n      positionX = 0;\n    } else if (positionX > _this.elements.volumeBarHelper.offsetWidth) {\n      positionX = _this.elements.volumeBarHelper.offsetWidth;\n    }\n\n    _this.settings.volume = Number((positionX / _this.elements.volumeBarHelper.offsetWidth).toFixed(2));\n    _this.elements.volumeBarActive.style.width = _this.settings.volume * 100 + \"%\";\n\n    _this.clip.setVolume(_this.settings.volume);\n\n    if (_this.settings.volume > 0) {\n      _this.settings.volumeMute = false;\n      var SVG = document.createElement(\"span\");\n      SVG.innerHTML = svg.volumeSVG;\n\n      _this.elements.volumeBtn.getElementsByTagName(\"svg\")[0].replaceWith(SVG);\n    } else if (_this.settings.volume === 0) {\n      _this.settings.volumeMute = true;\n\n      var _SVG2 = document.createElement(\"span\");\n\n      _SVG2.innerHTML = svg.volumeMuteSVG;\n\n      _this.elements.volumeBtn.getElementsByTagName(\"svg\")[0].replaceWith(_SVG2);\n    }\n  };\n\n  _this.listeners.onMouseUpVolumeBar = function (e) {\n    volumeDrag = false; // if (pe) {\n    //   _this.elements.settingsPointerEvents.click();\n    // }\n\n    _this.elements.listenerHelper.style.pointerEvents = \"none\";\n    e.preventDefault();\n\n    if (_this.settings.volume > 0) {\n      _this.settings.previousVolume = _this.settings.volume;\n    }\n\n    removeListener(\"mouseup\", _this.listeners.onMouseUpVolumeBar, false);\n    removeListener(\"touchend\", _this.listeners.onMouseUpVolumeBar, false);\n    removeListener(\"mousemove\", _this.listeners.onCursorMoveVolumeBar, false);\n    removeListener(\"touchmove\", _this.listeners.onCursorMoveVolumeBar, false);\n  };\n\n  _this.listeners.onMouseDownVolumeBar = function (e) {\n    volumeDrag = true; // if (!_this.options.pointerEvents) {\n    //   pe = true;\n    //   _this.elements.settingsPointerEvents.click();\n    // }\n\n    _this.elements.listenerHelper.style.pointerEvents = \"auto\";\n    e.preventDefault();\n\n    _this.listeners.onCursorMoveVolumeBar(e);\n\n    addListener(\"mouseup\", _this.listeners.onMouseUpVolumeBar, false);\n    addListener(\"touchend\", _this.listeners.onMouseUpVolumeBar, false);\n    addListener(\"mousemove\", _this.listeners.onCursorMoveVolumeBar, false);\n    addListener(\"touchmove\", _this.listeners.onCursorMoveVolumeBar, false);\n  };\n\n  _this.elements.volumeBarHelper.addEventListener(\"mousedown\", _this.listeners.onMouseDownVolumeBar, false);\n\n  _this.elements.volumeCursor.addEventListener(\"mousedown\", _this.listeners.onMouseDownVolumeBar, false);\n\n  _this.elements.volumeBarHelper.addEventListener(\"touchstart\", _this.listeners.onMouseDownVolumeBar, {\n    passive: false\n  }, false);\n\n  _this.elements.volumeCursor.addEventListener(\"touchstart\", _this.listeners.onMouseDownVolumeBar, {\n    passive: false\n  }, false);\n};\n\nfunction isDescendant(parent, child) {\n  var node = child.parentNode;\n\n  while (node != null) {\n    if (node == parent) {\n      return true;\n    }\n\n    node = node.parentNode;\n  }\n\n  return false;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC1wbGF5ZXIvZGlzdC9saXN0ZW5lcnMvdm9sdW1lLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyL2Rpc3QvbGlzdGVuZXJzL3ZvbHVtZS5qcz9jNDg2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi4vaGVscGVyc1wiKSxcbiAgICBhZGRMaXN0ZW5lciA9IF9yZXF1aXJlLmFkZExpc3RlbmVyLFxuICAgIHJlbW92ZUxpc3RlbmVyID0gX3JlcXVpcmUucmVtb3ZlTGlzdGVuZXIsXG4gICAgZWxpZCA9IF9yZXF1aXJlLmVsaWQ7XG5cbnZhciBzdmcgPSByZXF1aXJlKFwiLi4vaHRtbC9zdmdcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF90aGlzKSB7XG4gIC8vIGxldCBwZSA9IGZhbHNlO1xuICB2YXIgdm9sdW1lRHJhZyA9IGZhbHNlO1xuXG4gIF90aGlzLmVsZW1lbnRzLnZvbHVtZUJ0bi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChfdGhpcy5zZXR0aW5ncy52b2x1bWVNdXRlKSB7XG4gICAgICBfdGhpcy5lbGVtZW50cy52b2x1bWVCYXJBY3RpdmUuc3R5bGUud2lkdGggPSBfdGhpcy5zZXR0aW5ncy5wcmV2aW91c1ZvbHVtZSAqIDEwMCArIFwiJVwiO1xuXG4gICAgICBfdGhpcy5jbGlwLnNldFZvbHVtZShfdGhpcy5zZXR0aW5ncy5wcmV2aW91c1ZvbHVtZSk7XG5cbiAgICAgIF90aGlzLnNldHRpbmdzLnZvbHVtZU11dGUgPSBmYWxzZTtcbiAgICAgIHZhciBTVkcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIFNWRy5pbm5lckhUTUwgPSBzdmcudm9sdW1lU1ZHO1xuXG4gICAgICBfdGhpcy5lbGVtZW50cy52b2x1bWVCdG4uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzdmdcIilbMF0ucmVwbGFjZVdpdGgoU1ZHKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMuc2V0dGluZ3Mudm9sdW1lTXV0ZSA9IHRydWU7XG4gICAgICBfdGhpcy5lbGVtZW50cy52b2x1bWVCYXJBY3RpdmUuc3R5bGUud2lkdGggPSBcIjAlXCI7XG5cbiAgICAgIF90aGlzLmNsaXAuc2V0Vm9sdW1lKDApO1xuXG4gICAgICB2YXIgX1NWRyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuXG4gICAgICBfU1ZHLmlubmVySFRNTCA9IHN2Zy52b2x1bWVNdXRlU1ZHO1xuXG4gICAgICBfdGhpcy5lbGVtZW50cy52b2x1bWVCdG4uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzdmdcIilbMF0ucmVwbGFjZVdpdGgoX1NWRyk7XG4gICAgfVxuICB9O1xuXG4gIHZhciB2b2x1bWVPcGVuID0gZmFsc2U7XG5cbiAgX3RoaXMuZWxlbWVudHMudm9sdW1lQnRuLm9ubW91c2VvdmVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZvbHVtZU9wZW4gPSB0cnVlO1xuXG4gICAgX3RoaXMuZWxlbWVudHMudm9sdW1lQ3Vyc29yLmNsYXNzTGlzdC5hZGQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItdm9sdW1lLWN1cnNvci10cmFuc2l0aW9uXCIpKTtcblxuICAgIF90aGlzLmVsZW1lbnRzLnZvbHVtZUJhci5jbGFzc0xpc3QuYWRkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXZvbHVtZS13aWR0aC10cmFuc2l0aW9uXCIpKTtcblxuICAgIF90aGlzLmVsZW1lbnRzLnZvbHVtZUJhckhlbHBlci5jbGFzc0xpc3QuYWRkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXZvbHVtZS13aWR0aC10cmFuc2l0aW9uXCIpKTtcblxuICAgIF90aGlzLmVsZW1lbnRzLnRpbWVEaXNwbGF5LmNsYXNzTGlzdC5hZGQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItdGltZS13aWR0aC10cmFuc2l0aW9uXCIpKTtcbiAgfTtcblxuICBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLWxlZnQtY29udHJvbHNcIikpLm9ubW91c2VvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF2b2x1bWVPcGVuIHx8IHZvbHVtZURyYWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZSA9IGV2ZW50LnRvRWxlbWVudCB8fCBldmVudC5yZWxhdGVkVGFyZ2V0IHx8IGV2ZW50LnRhcmdldDtcblxuICAgIGlmIChpc0Rlc2NlbmRhbnQoZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1sZWZ0LWNvbnRyb2xzXCIpKSwgZSkgfHwgZSA9PT0gZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1sZWZ0LWNvbnRyb2xzXCIpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZvbHVtZU9wZW4gPSBmYWxzZTtcblxuICAgIF90aGlzLmVsZW1lbnRzLnZvbHVtZUN1cnNvci5jbGFzc0xpc3QucmVtb3ZlKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXZvbHVtZS1jdXJzb3ItdHJhbnNpdGlvblwiKSk7XG5cbiAgICBfdGhpcy5lbGVtZW50cy52b2x1bWVCYXIuY2xhc3NMaXN0LnJlbW92ZShcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi12b2x1bWUtd2lkdGgtdHJhbnNpdGlvblwiKSk7XG5cbiAgICBfdGhpcy5lbGVtZW50cy52b2x1bWVCYXJIZWxwZXIuY2xhc3NMaXN0LnJlbW92ZShcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi12b2x1bWUtd2lkdGgtdHJhbnNpdGlvblwiKSk7XG5cbiAgICBfdGhpcy5lbGVtZW50cy50aW1lRGlzcGxheS5jbGFzc0xpc3QucmVtb3ZlKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXRpbWUtd2lkdGgtdHJhbnNpdGlvblwiKSk7XG4gIH07XG5cbiAgX3RoaXMubGlzdGVuZXJzLm9uQ3Vyc29yTW92ZVZvbHVtZUJhciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHZhciBjbGllbnRYID0gZS5jbGllbnRYIHx8ICgoZS50b3VjaGVzIHx8IFtdKVswXSB8fCB7fSkuY2xpZW50WDtcblxuICAgIHZhciB2aWV3cG9ydE9mZnNldCA9IF90aGlzLmVsZW1lbnRzLnZvbHVtZUJhckhlbHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIHZhciBwb3NpdGlvblggPSBjbGllbnRYIC0gdmlld3BvcnRPZmZzZXQubGVmdDtcblxuICAgIGlmIChwb3NpdGlvblggPCAwKSB7XG4gICAgICBwb3NpdGlvblggPSAwO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb25YID4gX3RoaXMuZWxlbWVudHMudm9sdW1lQmFySGVscGVyLm9mZnNldFdpZHRoKSB7XG4gICAgICBwb3NpdGlvblggPSBfdGhpcy5lbGVtZW50cy52b2x1bWVCYXJIZWxwZXIub2Zmc2V0V2lkdGg7XG4gICAgfVxuXG4gICAgX3RoaXMuc2V0dGluZ3Mudm9sdW1lID0gTnVtYmVyKChwb3NpdGlvblggLyBfdGhpcy5lbGVtZW50cy52b2x1bWVCYXJIZWxwZXIub2Zmc2V0V2lkdGgpLnRvRml4ZWQoMikpO1xuICAgIF90aGlzLmVsZW1lbnRzLnZvbHVtZUJhckFjdGl2ZS5zdHlsZS53aWR0aCA9IF90aGlzLnNldHRpbmdzLnZvbHVtZSAqIDEwMCArIFwiJVwiO1xuXG4gICAgX3RoaXMuY2xpcC5zZXRWb2x1bWUoX3RoaXMuc2V0dGluZ3Mudm9sdW1lKTtcblxuICAgIGlmIChfdGhpcy5zZXR0aW5ncy52b2x1bWUgPiAwKSB7XG4gICAgICBfdGhpcy5zZXR0aW5ncy52b2x1bWVNdXRlID0gZmFsc2U7XG4gICAgICB2YXIgU1ZHID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICBTVkcuaW5uZXJIVE1MID0gc3ZnLnZvbHVtZVNWRztcblxuICAgICAgX3RoaXMuZWxlbWVudHMudm9sdW1lQnRuLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic3ZnXCIpWzBdLnJlcGxhY2VXaXRoKFNWRyk7XG4gICAgfSBlbHNlIGlmIChfdGhpcy5zZXR0aW5ncy52b2x1bWUgPT09IDApIHtcbiAgICAgIF90aGlzLnNldHRpbmdzLnZvbHVtZU11dGUgPSB0cnVlO1xuXG4gICAgICB2YXIgX1NWRzIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcblxuICAgICAgX1NWRzIuaW5uZXJIVE1MID0gc3ZnLnZvbHVtZU11dGVTVkc7XG5cbiAgICAgIF90aGlzLmVsZW1lbnRzLnZvbHVtZUJ0bi5nZXRFbGVtZW50c0J5VGFnTmFtZShcInN2Z1wiKVswXS5yZXBsYWNlV2l0aChfU1ZHMik7XG4gICAgfVxuICB9O1xuXG4gIF90aGlzLmxpc3RlbmVycy5vbk1vdXNlVXBWb2x1bWVCYXIgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZvbHVtZURyYWcgPSBmYWxzZTsgLy8gaWYgKHBlKSB7XG4gICAgLy8gICBfdGhpcy5lbGVtZW50cy5zZXR0aW5nc1BvaW50ZXJFdmVudHMuY2xpY2soKTtcbiAgICAvLyB9XG5cbiAgICBfdGhpcy5lbGVtZW50cy5saXN0ZW5lckhlbHBlci5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgaWYgKF90aGlzLnNldHRpbmdzLnZvbHVtZSA+IDApIHtcbiAgICAgIF90aGlzLnNldHRpbmdzLnByZXZpb3VzVm9sdW1lID0gX3RoaXMuc2V0dGluZ3Mudm9sdW1lO1xuICAgIH1cblxuICAgIHJlbW92ZUxpc3RlbmVyKFwibW91c2V1cFwiLCBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZVVwVm9sdW1lQmFyLCBmYWxzZSk7XG4gICAgcmVtb3ZlTGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZVVwVm9sdW1lQmFyLCBmYWxzZSk7XG4gICAgcmVtb3ZlTGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgX3RoaXMubGlzdGVuZXJzLm9uQ3Vyc29yTW92ZVZvbHVtZUJhciwgZmFsc2UpO1xuICAgIHJlbW92ZUxpc3RlbmVyKFwidG91Y2htb3ZlXCIsIF90aGlzLmxpc3RlbmVycy5vbkN1cnNvck1vdmVWb2x1bWVCYXIsIGZhbHNlKTtcbiAgfTtcblxuICBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZURvd25Wb2x1bWVCYXIgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZvbHVtZURyYWcgPSB0cnVlOyAvLyBpZiAoIV90aGlzLm9wdGlvbnMucG9pbnRlckV2ZW50cykge1xuICAgIC8vICAgcGUgPSB0cnVlO1xuICAgIC8vICAgX3RoaXMuZWxlbWVudHMuc2V0dGluZ3NQb2ludGVyRXZlbnRzLmNsaWNrKCk7XG4gICAgLy8gfVxuXG4gICAgX3RoaXMuZWxlbWVudHMubGlzdGVuZXJIZWxwZXIuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwiYXV0b1wiO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIF90aGlzLmxpc3RlbmVycy5vbkN1cnNvck1vdmVWb2x1bWVCYXIoZSk7XG5cbiAgICBhZGRMaXN0ZW5lcihcIm1vdXNldXBcIiwgX3RoaXMubGlzdGVuZXJzLm9uTW91c2VVcFZvbHVtZUJhciwgZmFsc2UpO1xuICAgIGFkZExpc3RlbmVyKFwidG91Y2hlbmRcIiwgX3RoaXMubGlzdGVuZXJzLm9uTW91c2VVcFZvbHVtZUJhciwgZmFsc2UpO1xuICAgIGFkZExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIF90aGlzLmxpc3RlbmVycy5vbkN1cnNvck1vdmVWb2x1bWVCYXIsIGZhbHNlKTtcbiAgICBhZGRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBfdGhpcy5saXN0ZW5lcnMub25DdXJzb3JNb3ZlVm9sdW1lQmFyLCBmYWxzZSk7XG4gIH07XG5cbiAgX3RoaXMuZWxlbWVudHMudm9sdW1lQmFySGVscGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgX3RoaXMubGlzdGVuZXJzLm9uTW91c2VEb3duVm9sdW1lQmFyLCBmYWxzZSk7XG5cbiAgX3RoaXMuZWxlbWVudHMudm9sdW1lQ3Vyc29yLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgX3RoaXMubGlzdGVuZXJzLm9uTW91c2VEb3duVm9sdW1lQmFyLCBmYWxzZSk7XG5cbiAgX3RoaXMuZWxlbWVudHMudm9sdW1lQmFySGVscGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIF90aGlzLmxpc3RlbmVycy5vbk1vdXNlRG93blZvbHVtZUJhciwge1xuICAgIHBhc3NpdmU6IGZhbHNlXG4gIH0sIGZhbHNlKTtcblxuICBfdGhpcy5lbGVtZW50cy52b2x1bWVDdXJzb3IuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgX3RoaXMubGlzdGVuZXJzLm9uTW91c2VEb3duVm9sdW1lQmFyLCB7XG4gICAgcGFzc2l2ZTogZmFsc2VcbiAgfSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gaXNEZXNjZW5kYW50KHBhcmVudCwgY2hpbGQpIHtcbiAgdmFyIG5vZGUgPSBjaGlsZC5wYXJlbnROb2RlO1xuXG4gIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICBpZiAobm9kZSA9PSBwYXJlbnQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex-player/dist/listeners/volume.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Group.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Group.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar TimedIncident = __webpack_require__(/*! ./TimedIncident */ \"./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/TimedIncident.js\");\nvar Helper = __webpack_require__(/*! ../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar conf = __webpack_require__(/*! ../configuration/generalConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\nvar pipeMessges = __webpack_require__(/*! ../configuration/pipesConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/pipesConf.js\");\nvar checkTransition = __webpack_require__(/*! ../configuration/allowedStateChanges */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/allowedStateChanges.js\").checkTransition;\nvar _CONST = __webpack_require__(/*! ../configuration/_CONST */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/_CONST.js\");\n\n/** @classdesc\n * A Scene is a TimeIncident that can have other Incidents (any kind of) on its timeline and its state mainly derives\n * from the state of its incidents rather than itself.\n */\n\nvar Group = function (_TimedIncident) {\n    _inherits(Group, _TimedIncident);\n\n    function Group() {\n        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var oldProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n        _classCallCheck(this, Group);\n\n        var attrsToPass = void 0,\n            propsToPass = void 0;\n\n        /*\n        backwards compatibility. If the user doesn't pass a second argument on the constructor then this is \n        the new way of initialising a Group (only props).\n        */\n        if (oldProps === null) {\n            attrsToPass = {};\n            propsToPass = props;\n        } else {\n            // else, in case the user has passed two arguments then both should be used\n            attrsToPass = props;\n            propsToPass = oldProps;\n        }\n\n        var _this = _possibleConstructorReturn(this, (Group.__proto__ || Object.getPrototypeOf(Group)).call(this, attrsToPass, propsToPass));\n\n        _this.hasIncidents = true;\n        _this.isChannel = false;\n\n        /**\n          keyframes are special points on the Scene's time where Incidents should be executed\n          The keys of the keyframes array are the millisecond on which the keyframes should get executed:\n          e.g.:\n          keyframes = {\n                sec_2000: {\n                    incident_id: IncidentObject,\n                    incident_id: IncidentObject,\n                    ...\n                },\n                ...\n          }\n          */\n        _this.keyframes = {};\n\n        /**\n          An object holding the mapping incidentid / keyframekey, from which we can get the keyframe id as defined on\n          the this.keyframes object where the incident belongs to\n          e.g.:\n          incidentsKeyframeKeys = {\n                incidentid: sec_2000,\n                ...\n          }\n           */\n        _this.incidentsKeyframeKeys = {};\n\n        /**\n          The array holds the Incidents of the Scene on the format:\n          {\n                id // the id of the Incident object\n                incident // the incident object\n                millisecond // the millisecond the incident should be executed\n          }\n           */\n        _this.incidents = [];\n\n        /*\n        an object / associative array holding all Incidents in the form:\n        <incident_id>: Incident object\n         */\n        _this.incidentsById = {};\n\n        _this.calculatedDuration = 0;\n\n        /**\n         * The cnannels attribute holds a list of all intantiated Channels of the Incidents belonging to the clip\n         * this attribute is only valuable when the Group becomes the Clip\n         * The format of the attribute is:\n         *  key-value pairs in the manner:\n         * <mc_plugin_npm_name>: Channel object\n        */\n        _this.instantiatedChannels = {};\n\n        _this.isTheClip = false;\n\n        _this.onGroupInitialise();\n        return _this;\n    }\n\n    _createClass(Group, [{\n        key: 'onGroupInitialise',\n        value: function onGroupInitialise() {\n            // called when group gets initialised\n        }\n    }, {\n        key: '_getChannel',\n\n\n        /*\n        returns the initialised channel by the Clip the Incident belongs to\n        */\n        value: function _getChannel(mc_plugin_npm_name) {\n            if (this.checkParentScene()) {\n                return this.parentSceneObject._getChannel(mc_plugin_npm_name);\n            } else {\n                return null;\n            }\n        }\n\n        /*\n        removes all emtpy groups that belong to the group as incident\n        */\n\n    }, {\n        key: 'removeEmtpyGroups',\n        value: function removeEmtpyGroups() {\n            var incidentsToRemove = [];\n            for (var i = 0; i < this.incidents.length; i++) {\n                if (this.incidents[i].incident.hasIncidents && this.incidents[i].incident.incidents.length === 0) {\n                    incidentsToRemove.push(this.incidents[i].id);\n                }\n            }\n            for (var _i = 0; _i < incidentsToRemove.length; _i++) {\n                this.removeIncident(incidentsToRemove[_i]);\n            }\n        }\n\n        /*\n        return the direct parent of a specific Incident\n        */\n\n    }, {\n        key: '_getDirectParent',\n        value: function _getDirectParent(incidentId) {\n            if (this.incidentsById.hasOwnProperty(incidentId)) {\n                return this;\n            } else {\n                for (var i = 0; i < this.incidents.length; i++) {\n                    if (this.incidents[i].incident.hasIncidents) {\n                        var directParent = this.incidents[i].incident._getDirectParent(incidentId);\n                        if (directParent != null) {\n                            return directParent;\n                        }\n                    }\n                }\n            }\n\n            return null;\n        }\n\n        /**\n         * Returns all of its Incidents (not groups) in a collection of the form:\n         * {\n                id,\n                millisecond\n                incident\n            }\n        */\n\n    }, {\n        key: 'getIncidentsByChannel',\n\n\n        /**\n         * Returns an object that has the key of the npm plugin name the Channel of which manages the specific Incident\n         * With the same logic all Incidents that belong to this Group as categorised by plugin / channel on the same object\n        */\n        value: function getIncidentsByChannel() {\n            var adjustMillisecond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n            // initially it only puts itself onthe incidentsByPlugin array, exactly as the plain Incidents do\n            var incidentsByPlugin = {};\n            var keyToUse = this.mc_plugin_npm_name;\n            if (this.bypassChannel === true) {\n                keyToUse = 'motor-cortex-js';\n            }\n            incidentsByPlugin[keyToUse] = [{\n                millisecond: adjustMillisecond,\n                incident: this,\n                id: this.id\n            }];\n\n            // proceed to gather the contained incidents as well\n            for (var i = 0; i < this.incidents.length; i++) {\n                var incidentsToAdd = this.incidents[i].incident.getIncidentsByChannel(adjustMillisecond + this.incidents[i].millisecond);\n                for (var key in incidentsToAdd) {\n                    if (incidentsByPlugin.hasOwnProperty(key)) {\n                        incidentsByPlugin[key] = incidentsByPlugin[key].concat(incidentsToAdd[key]);\n                    } else {\n                        incidentsByPlugin[key] = incidentsToAdd[key];\n                    }\n                }\n            }\n            return incidentsByPlugin;\n        }\n    }, {\n        key: 'checkStateTransition',\n        value: function checkStateTransition(targetState) {\n            if (checkTransition(this.runTimeInfo.state, targetState, this.direction)) {\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * This method returns the Incidents of each Incident in array format holding the incidents in the structure:\n            {\n                id,\n                millisecond\n                incident\n            }\n            Depending on who asks for the incidents, it might pass the adjustMillisecond argument. This argument is\n            used in case a parent Group wants to receive the Incidents of its child but by passing a correction millisecond\n            that represents the millisecond the Incident starts on its parent's timeline.\n            @param {int} adjustMillisecond\n        */\n\n    }, {\n        key: 'getProjectedIncidents',\n        value: function getProjectedIncidents() {\n            var adjustMillisecond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n            var projectedIncidents = [];\n            for (var i = 0; i < this.incidents.length; i++) {\n                var incidentsToAdd = this.incidents[i].incident.getProjectedIncidents(adjustMillisecond + this.incidents[i].millisecond);\n                projectedIncidents = projectedIncidents.concat(incidentsToAdd);\n            }\n            return projectedIncidents;\n        }\n\n        // ******** METHODS TO CALCULATE OVERALL DURATION OF SCENE\n        // *******************************************************\n\n        /**\n         * called when an Incident of the Scene gets affected by an edit or a deletion. The command targets the\n         * root of the scenes tree where a recalc state and a set current millisecond should take place\n         */\n\n    }, {\n        key: 'getDurationAfterIncidentAffected',\n        value: function getDurationAfterIncidentAffected() {\n            var durationBeforeChange = this.duration * 1;\n            var currentMillisecondBeforeChange = this.runTimeInfo.currentMillisecond * 1;\n            var stateBeforeChage = this.state + '';\n\n            var newDuration = 0;\n            for (var i = 0; i < this.incidents.length; i++) {\n                var incident = this.incidents[i];\n                if (incident.incident.duration + incident.millisecond > newDuration) {\n                    newDuration = incident.incident.duration + incident.millisecond;\n                }\n            }\n            this.duration = newDuration;\n            // helper.log('duration changed on incident: ' + this.id + '. New duration: ' + newDuration);\n            if (this.duration != durationBeforeChange) {\n                this.broadcastEvent('duration-change', { newDuration: newDuration });\n            }\n\n            if (this.checkParentScene()) {\n                this.parentSceneObject.getDurationAfterIncidentAffected();\n            } else {\n                // return ;\n                if (this.putMessageOnPipe(pipeMessges._CLIP_EDITING_STATUS, {}, true, \"up\", { type: 'rootClip' }) === \"normal\") {\n                    this.stop();\n                    this.setCurrentMillisecond(currentMillisecondBeforeChange);\n                    this.recalcState(currentMillisecondBeforeChange);\n                    this.restore();\n                }\n            }\n        }\n\n        /**\n         * called when an Incident gets added on the Scene\n         * @param {int} startMillisecond\n         * @param {int} incidentDuration\n         */\n\n    }, {\n        key: 'getDurationAfterIncidentAdded',\n        value: function getDurationAfterIncidentAdded(startMillisecond, incidentDuration) {\n            var durationBeforeChange = this.duration * 1;\n            var currentMillisecondBeforeChange = this.runTimeInfo.currentMillisecond * 1;\n            // const stateBeforeRecal = this.state + \"\";\n\n            if (startMillisecond + incidentDuration > this.calculatedDuration) {\n                this.calculatedDuration = startMillisecond + incidentDuration;\n            }\n\n            if (this.duration != durationBeforeChange) {\n                this.broadcastEvent('duration-change', { newDuration: this.duration });\n            }\n\n            if (this.checkParentScene()) {\n                this.parentSceneObject.getDurationAfterIncidentAffected();\n            } else {\n                // return ;\n                if (this.putMessageOnPipe(pipeMessges._CLIP_EDITING_STATUS, {}, true, \"up\", { type: 'rootClip' }) === \"normal\") {\n                    this.stop();\n                    this.setCurrentMillisecond(currentMillisecondBeforeChange);\n                    this.recalcState(currentMillisecondBeforeChange);\n                    this.restore();\n                }\n            }\n        }\n\n        // ******** INCIDENT METHODS IMPLEMENTATION **************\n        // *******************************************************\n\n    }, {\n        key: 'play',\n        value: function play() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            if (this.isHeadlessClip) {\n                return false;\n            }\n            _get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'play', this).call(this, props);\n        }\n\n        /** timer blocking */\n\n    }, {\n        key: 'wait',\n        value: function wait() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            if (_get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'wait', this).call(this, props)) {\n                for (var i = 0; i < this.incidents.length; i++) {\n                    if (props.callerId === this.incidents[i].id) continue;\n                    this.incidents[i].incident.block(props);\n                }\n                return true;\n            }\n            return false;\n        }\n\n        /** timer blocking */\n\n    }, {\n        key: 'block',\n        value: function block(props) {\n            if (_get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'block', this).call(this, props)) {\n                for (var i = 0; i < this.incidents.length; i++) {\n                    this.incidents[i].incident.block();\n                }\n                return true;\n            }\n            return false;\n        }\n\n        /** timer unblocking */\n\n    }, {\n        key: 'resume',\n        value: function resume(props) {\n            if (_get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'resume', this).call(this, props)) {\n                for (var i = 0; i < this.incidents.length; i++) {\n                    this.incidents[i].incident.resume();\n                }\n                return true;\n            }\n            return false;\n        }\n    }, {\n        key: 'reset',\n        value: function reset(props) {\n            if (_get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'reset', this).call(this, props)) {\n                for (var i = 0; i < this.incidents.length; i++) {\n                    this.incidents[i].incident.reset();\n                }\n            }\n            return false;\n        }\n    }, {\n        key: 'stop',\n        value: function stop(props) {\n            if (_get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'stop', this).call(this, props)) {\n                for (var i = 0; i < this.incidents.length; i++) {\n                    this.incidents[i].incident.stop();\n                }\n                return true;\n            }\n            return false;\n        }\n\n        /**\n         * The parameter it takes is relative to the beginning of the Incident itself and it might be negative\n         * Negative targetMillisecond means the target millisecond is N milliseconds BEFORE the start of the Incident\n         * @param {int} targetMillisecondDeltaFromStart - the delta of the target millisecond compared to the Incident start\n        */\n\n    }, {\n        key: 'recalcState',\n        value: function recalcState(targetMillisecondDeltaFromStart) {\n            _get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'recalcState', this).call(this, targetMillisecondDeltaFromStart);\n            for (var i = 0; i < this.incidents.length; i++) {\n                var incident = this.incidents[i].incident;\n                var startMillisecond = this.incidents[i].millisecond;\n                incident.recalcState(targetMillisecondDeltaFromStart - startMillisecond);\n            }\n        }\n    }, {\n        key: 'lastWish',\n        value: function lastWish() {\n            for (var i = 0; i < this.incidents.length; i++) {\n                this.incidents[i].incident.lastWish();\n            }\n            this.stop();\n        }\n\n        // *******************************************************\n        // SCENE SPECIFIC FUNCTIONS / HELPER FUNCTIONS\n\n    }, {\n        key: 'reverse',\n        value: function reverse(_reverse) {\n            this.reversed = _reverse;\n        }\n    }, {\n        key: 'getIncidentMillisecond',\n        value: function getIncidentMillisecond(incidentId) {\n            return conf.getMillisecondFromKeyframeKey(this.incidentsKeyframeKeys[incidentId]);\n        }\n    }, {\n        key: 'exportState',\n        value: function exportState() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            var incidents = [];\n\n            for (var i = 0; i < this.incidents.length; i++) {\n                if (this.incidents[i].incident.autoGenerated === true && props.unprocessed === true) {\n                    continue;\n                }\n                var incident = {};\n                incident.millisecond = this.incidents[i].millisecond;\n                incident.incident = this.incidents[i].incident.exportState(props);\n                incident.id = this.incidents[i].id;\n                incidents.push(incident);\n            }\n\n            var state = _get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'exportState', this).call(this, props);\n            state.incidents = incidents;\n\n            return state;\n        }\n    }, {\n        key: 'setCurrentMillisecond',\n        value: function setCurrentMillisecond(millisecond) {\n            // helper.log(`setting currentUser of ${this.id} to ${millisecond}`);\n            this.runTimeInfo.currentMillisecond = millisecond;\n\n            for (var i = 0; i < this.incidents.length; i++) {\n                var childIncident = this.incidents[i];\n\n                // if the child incident starts before the millisecond and has not ended yet\n                if (childIncident.millisecond < millisecond && childIncident.incident.duration + childIncident.millisecond > millisecond) {\n                    childIncident.incident.setCurrentMillisecond(millisecond - childIncident.millisecond);\n                } else {\n                    childIncident.incident.setCurrentMillisecond(0);\n                }\n            }\n        }\n\n        /**\n         * Returns the Incident by ID no matter if the Incident balongs directly to the Scene of to a child Scene\n         * @param {string} id - the id of the Incident to get\n        */\n\n    }, {\n        key: 'getIncidentById',\n        value: function getIncidentById(id) {\n            if (this.incidentsById.hasOwnProperty(id)) {\n                return this.incidentsById[id];\n            } else {\n                for (var i = 0; i < this.incidents.length; i++) {\n                    if (this.incidents[i].incident.hasIncidents) {\n                        var incident = this.incidents[i].incident.getIncidentById(id);\n                        if (incident != null) {\n                            return incident;\n                        }\n                    }\n                }\n            }\n\n            return null;\n        }\n\n        // *******************************************************\n        // INCIDENTS MANAGEMENT METHODS\n        // POLYMORPHISM APPLIED. IF THE GROUP HAS NO PARENT IT ACTS AS A SCENE. IF THE GROUP HAS PARENT IT ACTS AS\n        // A \"TRANSPARENT GROUP\"\n\n        /**\n         * The checkAddition method serves exactly what its name implies. To check if the addition of an Incident\n         * is valid and accepted, according to the rules defined on the channels.\n         * The method boobles up until it reaches the Clip by carrying adjusting the millisecond.\n         * The method takes as input the management type. On error / conflict:\n         *  - on type === 'all-or-nothing' completely discard addition of all incidents\n         *  - on type === 'keep-passing' it will only add the passing incidents no matter if some other incidents of the addition failed\n         * @param {object} incident - the incident to add\n         * @param {int} millisecond - the millisecond to add the Incident to\n         * @param {string} type - as explained above\n         * The method returns either:\n            {\n                result:true,\n                execute: // an array of functions that when executed it will add the Incidents on the Channels\n            }\n            or\n            {\n                result: false,\n                errors\n            }\n        */\n\n    }, {\n        key: 'checkAddition',\n        value: function checkAddition(incident, millisecond) {\n            var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"all-or-nothing\";\n\n            if (this.isHeadlessClip) {\n                return { result: true, execute: function execute() {} };\n            } else {\n                // IF THE GROUP HAS NO PARENT (ACT AS THE CLIP)\n                return this.parentSceneObject.checkAddition(incident, millisecond + this.parentSceneObject.getIncidentMillisecond(this.id), type);\n            }\n        }\n\n        /**\n         * The checkEdit method serves exactly what its name implies. To check if the edit of an Incident (edit of Incident's position given in milliseconds delta)\n         * is valid and accepted, according to the rules defined on the channels.\n         * The method boobles up until it reaches the Clip.\n         * @param {object} incident - the incident to edit\n         * @param {int} millisecondsDelta - the milliseconds delta of the Incident's start time\n         The method should return either:\n            {\n                result:true,\n                execute: // an array of functions that when executed it will edit the Incidents on the Channels\n            }\n            or\n            {\n                result: false,\n                errors\n            }\n        */\n\n    }, {\n        key: 'checkEdit',\n        value: function checkEdit(incident, millisecondsDelta) {\n            if (this.isHeadlessClip) {\n                return { result: true, execute: function execute() {} };\n            } else {\n                // IF THE GROUP HAS NO PARENT (ACT AS THE CLIP)\n                return this.parentSceneObject.checkEdit(incident, millisecondsDelta);\n            }\n        }\n\n        /**\n         * The checkDelete method serves exactly what its name implies. To check if the deletion of an Incident\n         * is valid and accepted, according to the rules defined on the channels.\n         * The method boobles up until it reaches the Clip.\n         * @param {object} incident - the incident to edit\n         * @param {object} props - if passed it supports the preventSlip key which if false the channel should not slip. This case is for \n            flashDOM of DOMAwareIncidents where we have elements deleted so slipping on their lanes is not valid nor necessary\n          The result might be either:\n            {\n                result:true,\n                execute: // an array of functions that when executed it will remove the Incident on the Channels\n            }\n            or\n            {\n                result: false,\n                errors\n            }\n        */\n\n    }, {\n        key: 'checkDelete',\n        value: function checkDelete(incidentId) {\n            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n            if (this.isHeadlessClip) {\n                return { result: true, execute: function execute() {} };\n            } else {\n                // IF THE GROUP HAS NO PARENT (ACT AS THE CLIP)\n                return this.parentSceneObject.checkDelete(incidentId, props);\n            }\n        }\n\n        /**\n         * It's called always by a child to Scene that wants to expand to the left to its parent.\n         * Expanding a Scene to the left means it tries to add extra (initially unsued) space (in milliseconds) before its\n         * current starting point.\n         * In order for this action to be allowed the Scene's context should allow such an expansion. This means:\n         *  - that if the Scene has no parents this expansion is not legal\n         *  - that if the root Scene of the Scene's parents tree needs to expand on the left in order to apply the expansion\n         *      then the expansion is not acceptable\n         * @param {int} howManyMilliseconds - the milliseconds to expand the Scene to the left\n         * @param {string} sceneId - the child scene id that wants to gain extra space to the left\n         * @returns {object} - the result is an object with two keys:\n         *  - the first key is the \"result\" which might either be true or false\n         *  - the second key is the \"undo\" which is a function that can undo the (approved) expansion\n        */\n\n    }, {\n        key: 'expandSceneToTheLeft',\n        value: function expandSceneToTheLeft(howManyMilliseconds, sceneId) {\n            var _this2 = this;\n\n            // First we identify the expansion within the context of the parent (this) Scene\n            var currentStartMillisecondOfTheChildScene = this.getIncidentMillisecond(sceneId);\n            var newStartMillisecondOfTheChildScene = howManyMilliseconds - currentStartMillisecondOfTheChildScene;\n\n            // Check if the expansion is allowed\n            // if the millisecons to expand are zero or less (meaning the current Scene is actually not affected by the expansion)\n            if (newStartMillisecondOfTheChildScene <= 0) {\n                var rootScene = this;\n                var changeResult = this.changeIncidentsStartMillisecond(-newStartMillisecondOfTheChildScene, sceneId);\n                var undo = function undo() {\n                    _this2.changeIncidentsStartMillisecond(changeResult.oldMillisecond, sceneId);\n                };\n                return {\n                    result: true,\n                    undo: undo,\n                    rootScene: rootScene\n                };\n            }\n\n            // if it reaches to that point that means the expansion afects the left borders of this (parent) Scene as well\n            // If it doesn't have a parent scene that means the expansion is illegal\n            if (!this.checkParentScene()) {\n                return {\n                    result: false\n                };\n            }\n\n            // if it has a parent scene and the this Scene needs to expand to the left as well then this Scene\n            // assigns the obligation to evaluate the expansion to its parent\n            var parentDecision = this.parentSceneObject.expandSceneToTheLeft(newStartMillisecondOfTheChildScene, this.id);\n            // if the parent approves the expansion\n            if (parentDecision.result === true) {\n                // TODO apply the expansion itself and bundle its undo along with the undo coming from the parent\n                this.expandStartPoint(-newStartMillisecondOfTheChildScene);\n                var overallUndo = function overallUndo() {\n                    parentDecision.undo();\n                    _this2.expandStartPoint(newStartMillisecondOfTheChildScene);\n                };\n                return {\n                    result: true,\n                    undo: overallUndo,\n                    rootScene: parentDecision.rootScene\n                };\n            } else {\n                // otherwise\n                return {\n                    result: false\n                };\n            }\n        }\n\n        /**\n         * expands or collapses the Scene's start millisecond by the given milliseconds\n         * e.g. expandStartPoint(200) will expand the Scene by 200 milliseconds to the left keeping all\n         *      of its incidents to the exact same place they were before on the overall timeline\n         * e.g. expandStartPoint(-200) will collapse the Scene, moving its start point by 200 milliseconds\n         *      to the right, again without affecting at all its Incidents' start point on the overall timeline\n         * @param {int} byMilliseconds - the number of milliseconds to expand (positive number) or collapse (minus number) number of milliseconds\n        */\n\n    }, {\n        key: 'expandStartPoint',\n        value: function expandStartPoint(byMilliseconds) {\n            for (var i = 0; i < this.incidents.length; i++) {\n                var incident = this.incidents[i];\n                this.changeIncidentsStartMillisecond(incident.millisecond + byMilliseconds, incident.id);\n            }\n        }\n\n        /**\n         * it alters the start millisecond of any already existing Incident of the Scene\n         * @param {int} newmillisecond - the new millisecond to place the Incident\n         * @param {string} incidentId - the incident id\n         * @returns {function} - the undo function of the change\n        */\n\n    }, {\n        key: 'changeIncidentsStartMillisecond',\n        value: function changeIncidentsStartMillisecond(newmillisecond, id) {\n            var keyframe_sec_key = this.incidentsKeyframeKeys[id];\n            //OPTIMIZE delete is slow on v8 engine we should check if we can achieve the same result by setting the value of the key to undefined\n            delete this.keyframes[keyframe_sec_key][id];\n\n            if (Object.keys(this.keyframes[keyframe_sec_key]).length === 0) {\n                delete this.keyframes[keyframe_sec_key];\n            }\n\n            delete this.listeners[id]; // delete the listener that currently manages the Incident's execution\n\n\n            var oldMillisecond = void 0; // the previous millisecond of the edited incident before the edit\n            for (var i = 0; i < this.incidents.length; i++) {\n                if (this.incidents[i].id === id) {\n                    oldMillisecond = this.incidents[i].millisecond * 1; // *1 to avoid reference, keep value\n                    this.incidents[i].millisecond = newmillisecond;\n                    break;\n                }\n            }\n\n            var incident = this.incidentsById[id];\n            var new_keyframe_sec_key = conf.keyframe_sec_key + newmillisecond;\n            if (!this.keyframes.hasOwnProperty(new_keyframe_sec_key)) {\n                this.keyframes[new_keyframe_sec_key] = {};\n            }\n            this.keyframes[new_keyframe_sec_key][incident.id] = incident;\n            this.incidentsKeyframeKeys[incident.id] = new_keyframe_sec_key;\n\n            // subscribe Incident start on the listeners\n            var funct = function funct(sceneMillisecond, previousTimeStamp, sceneState) {\n                if (sceneMillisecond >= newmillisecond && sceneMillisecond <= newmillisecond + incident.duration) {\n                    incident.play({ startFrom: sceneMillisecond - newmillisecond, previousTimeStamp: previousTimeStamp });\n                }\n            };\n\n            this.subscribe(incident.id, funct);\n\n            return {\n                oldMillisecond: oldMillisecond,\n                incident: incident\n            };\n        }\n\n        /**\n         * Plain groups\n            Can have on their timeline:\n            - Another plain group\n            - An incident with no selector\n            - A dom group (this method should actually turn any incident with selector to one)\n            Cant have on their timeline:\n            - An attribute group\n         */\n\n    }, {\n        key: '_prepareInicdentForAddition',\n        value: function _prepareInicdentForAddition(incident) {\n            if (!incident.props.hasOwnProperty('selector') && !incident.hasIncidents) {\n                // if the incident is not a group and it has no selector proceed normally\n                return incident;\n            } else if (incident.groupType === \"plain\") {\n                // if the Incident is a plain group proceed normally\n                return incident;\n            } else if (incident.groupType === \"attribute\") {\n                helper.error(\"Plain groups can not accept attribute groups on their timeline\");\n                return null;\n            }\n\n            // We need to turn the Incident to a DOMAwareIncident\n            // before adding it to the group\n            var DOMAwareIncident = __webpack_require__(/*! ../_responsiveness/DOMAwareIncident */ \"./node_modules/@kissmybutton/motorcortex/dist/_responsiveness/DOMAwareIncident.js\");\n            var theDOMAwareIncident = new DOMAwareIncident(incident);\n            return theDOMAwareIncident;\n        }\n    }, {\n        key: 'flashDOM',\n        value: function flashDOM() {\n            var result = {\n                failedAdditions: []\n            };\n            for (var i = 0; i < this.incidents.length; i++) {\n                var flashResult = this.incidents[i].incident.flashDOM();\n                result.failedAdditions = result.failedAdditions.concat(flashResult.failedAdditions);\n            }\n            return result;\n        }\n    }, {\n        key: 'addPassiveIncident',\n        value: function addPassiveIncident(incident, millisecond, sceneId) {\n            var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"all-or-nothing\";\n\n            return this.addIncident(incident, millisecond, sceneId, type, true);\n        }\n\n        /**\n        Any Scene can receive the addIncdent command either for adding an Incident on its own Incidents list or in order\n        to pass deeper the command to the parent Scene of the Incident (sceneId).\n        No matter which Scene took the command, all parent Scenes get informed\n         addIncident takes 3 arguments:\n        @param {Incident} incident - the Incident object to get added\n        @param {int} millisecond - the millisecond to which we want the Incident to get added, starting from the zero point of the\n            target Scene. It can't be negative. Millisecond can also take the string value \"end\" which means the new Incident should be added at the end of the Group\n        @param {string} sceneId - the sceneId to which we want to put the new Incident. It is optional and if it is not specified the\n            target Scene is the current one\n        @param {string} type - one of \"all-or-nothing\" / \"keep-passing\"\n        @param {boolean} autoGenerated - if set to true, it means the Incident was auto generated by another incident and it should not export itself on exportState with unprocessed = true\n         */\n\n    }, {\n        key: 'addIncident',\n        value: function addIncident(incident, millisecond, sceneId) {\n            var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"all-or-nothing\";\n            var autoGenerated = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n            if (millisecond < 0) {\n                return {\n                    result: false,\n                    conflicts: [{\n                        type: 'minus millisecond violation'\n                    }]\n                };\n            }\n\n            if (millisecond === _CONST.atTheEndOfTheGroup.value) {\n                millisecond = this.duration;\n            }\n\n            var originalMillisecond = millisecond * 1; // a backup variable holding the original millisecond passed as\n            // this might change during potential left expansion manipulation\n\n            if (!sceneId || sceneId === this.id) {\n                var that = this;\n                incident = this._prepareInicdentForAddition(incident);\n                if (autoGenerated === true) {\n                    incident.autoGenerated = true;\n                }\n\n                // when adding headless Clips to a group that has context (either because it's the clip itself or because\n                // it belongs to a clip that has context) we need to run flash the newly entered group's dom so it creates\n                // its elementIncidents\n                var flashIncidentsDOMAfterEnter = false;\n\n                if (incident.hasIncidents && incident.isHeadlessClip && this.context != null) {\n                    flashIncidentsDOMAfterEnter = true;\n                }\n\n                incident.setParentScene(that);\n\n                // check if the Incident is eligible for addition\n                var additionCheck = this.checkAddition(incident, millisecond, type);\n                if (additionCheck.result === false) {\n                    return additionCheck;\n                }\n                additionCheck.execute();\n\n                // indexing start\n                this.incidents.push({\n                    id: incident.id,\n                    incident: incident,\n                    millisecond: millisecond\n                });\n                this.incidentsById[incident.id] = incident;\n                var keyframe_sec_key = conf.keyframe_sec_key + millisecond;\n                if (!this.keyframes.hasOwnProperty(keyframe_sec_key)) {\n                    this.keyframes[keyframe_sec_key] = {};\n                }\n                this.keyframes[keyframe_sec_key][incident.id] = incident;\n                this.incidentsKeyframeKeys[incident.id] = keyframe_sec_key;\n                // indexing end\n\n                incident.executionSpeed = this.speed;\n\n                // subscribe Incident start on the listeners\n                // currentMillisecond: the millisecond the Group is on\n                // millisecond: the millisecond we set our Incident to get executed on the Group's timeline\n                var funct = function funct(currentMillisecond, previousTimeStamp, sceneState) {\n                    if (incident.speed > 0) {\n                        if (currentMillisecond >= millisecond && currentMillisecond <= millisecond + incident.duration || incident.state === 'idle' && currentMillisecond > millisecond) {\n                            // helper.log('greater');\n                            incident.play({ startFrom: currentMillisecond - millisecond, previousTimeStamp: previousTimeStamp });\n                        }\n                    } else {\n                        if (currentMillisecond >= millisecond && currentMillisecond <= millisecond + incident.duration || incident.state === 'completed' && currentMillisecond < millisecond) {\n                            // helper.log('greater');\n                            incident.play({ startFrom: currentMillisecond - millisecond, previousTimeStamp: previousTimeStamp });\n                        }\n                    }\n                };\n\n                this.subscribe(incident.id, funct);\n                this.getDurationAfterIncidentAdded(millisecond, incident.duration);\n\n                if (flashIncidentsDOMAfterEnter) {\n                    var result = incident.flashDOM();\n                    if (result.failedAdditions.length > 0 && type === \"all-or-nothing\") {\n                        this.removeIncident(incident.id);\n                        incident.parentSceneObject = null;\n                        return {\n                            result: false,\n                            conflicts: result.failedAdditions\n                        };\n                    } else {\n                        // if flashing incident's DOM passes let the Incident know that\n                        // it now has context\n                        incident._onGetContextOnce();\n                        this.onAddIncident(incident, millisecond);\n                        this.recalcState(this.runTimeInfo.currentMillisecond);\n                        if (result.failedAdditions.length > 0 && type === 'keep-passing') {\n                            incident.removeEmtpyGroups();\n                        }\n                        helper.notice('incident added');\n\n                        return {\n                            result: true,\n                            meta: {\n                                conflicts: result.failedAdditions\n                            }\n                        };\n                    }\n                } else {\n                    if (this.context != null) {\n                        incident._onGetContextOnce();\n                    }\n                    this.onAddIncident(incident, millisecond);\n                    helper.notice('incident added');\n                    return {\n                        result: true,\n                        meta: {\n                            incidentId: incident.id\n                        }\n                    };\n                }\n            } else {\n                for (var i = 0; i < this.incidents.length; i++) {\n                    if (this.incidents[i].incident.hasIncidents) {\n                        if (this.incidents[i].incident.addIncident(incident, millisecond - this.incidents[i].millisecond, sceneId).result === true) {\n                            return {\n                                result: true,\n                                meta: {\n                                    incidentId: incident.id\n                                }\n                            };\n                        }\n                    }\n                } // if it reaches the end of the loop without having returned true\n                return { result: false };\n            }\n        }\n\n        /**\n        Any Scene can receive the editIncident command in order to set a new starting point for one of its own Incidents or to\n        pass the command deeper down to its children Scenes so the parent of it can take care of it.\n        The Incident object and id remain the same after the edit.\n        No matter which Scene takes the command, all Parents get infomed about the edit.\n         It takes two params:\n         @param {string} id - the id of the incident to be edited\n         @param {int} newmillisecond - the new position of the Incident compared to the target Scene start (and not to the Scene it belongs)\n         */\n\n    }, {\n        key: 'editIncident',\n        value: function editIncident(id, newmillisecond) {\n            var expansionValidation = null;\n            var originalMillisecond = newmillisecond * 1;\n\n            if (!helper.isString(id)) {\n                helper.error('editIncident method of Group expects as its first argument the id of the Incident to edit in string format. ' + (typeof id === 'undefined' ? 'undefined' : _typeof(id)) + ' passed');\n                return {\n                    result: false,\n                    conflicts: [{\n                        type: 'wrong parameter type'\n                    }]\n                };\n            }\n\n            if (this.incidentsById[id]) {\n                var existingMillisecond = this.getIncidentMillisecond(id);\n                var millisecondDelta = newmillisecond - existingMillisecond;\n                // first check for minus expansion\n                if (newmillisecond < 0) {\n                    // if the Scene doesn't have a parent then it is the root and thus it can't expand to the left\n                    if (!this.checkParentScene()) {\n                        return {\n                            result: false,\n                            conflicts: [{\n                                type: 'minus millisecond violation'\n                            }]\n                        };\n                    }\n\n                    expansionValidation = this.parentSceneObject.expandSceneToTheLeft(-newmillisecond, this.id);\n                    if (expansionValidation.result === false) {\n                        return {\n                            result: false,\n                            conflicts: [{\n                                type: 'minus millisecond violation'\n                            }]\n                        };\n                    } else {\n                        newmillisecond = 0;\n                    }\n                } // end of if millisecond < 0\n\n                // if the edit is allowed (thus we come to that point) and the originalMillisecond is lower than 0\n                if (originalMillisecond < 0) {\n                    this.expandStartPoint(-originalMillisecond);\n                }\n\n                this.incidentsById[id].stop();\n\n                var editCheck = this.checkEdit(this.incidentsById[id], millisecondDelta);\n                if (editCheck.result === false) {\n                    helper.error(editCheck);\n                    if (expansionValidation !== null) {\n                        expansionValidation.undo();\n                        this.expandStartPoint(originalMillisecond);\n                    }\n                    return editCheck;\n                }\n\n                editCheck.execute();\n\n                var editIncidentStartResult = this.changeIncidentsStartMillisecond(newmillisecond, id);\n\n                this.getDurationAfterIncidentAffected();\n\n                this.onEditIncident(this.incidentsById[id], editIncidentStartResult.oldMillisecond, newmillisecond);\n\n                return { result: true };\n            } else {\n                for (var i = 0; i < this.incidents.length; i++) {\n                    if (this.incidents[i].incident.hasIncidents) {\n                        var result = this.incidents[i].incident.editIncident(id, newmillisecond - this.incidents[i].millisecond);\n                        if (result.result === true) {\n                            return { result: true };\n                        } else if (result.hasOwnProperty('errors')) {\n                            // if the result.result is false but it contains no errors that means the Incident we're looking for just not belong to \n                            // to the Group we are iterating in. Though if result.result==false && result.hasOwnProperty('errors') that means the \n                            // Incident has been found but editing it results to errors.\n                            return result;\n                        }\n                    }\n                } // if it reaches the end of the loop without having returned true\n                return { result: false };\n            }\n        }\n\n        /**\n        Any Scene can receive the removeIncident command either for removing one of its own Incidents or for passing the command\n        deeper down to its Scenes tree and have the Incident deleted no matter to which child Scene it belongs\n        No matter which Scene took the command, all parent Scenes get informed\n         It takes just one argument:\n        @param {string} id - the id of the Incident to be deleted\n        @param {object} props - if passed it supports the preventSlip key which if false the channel should not slip. This case is for \n            flashDOM of DOMAwareIncidents where we have elements deleted so slipping on their lanes is not valid nor necessary\n         */\n\n    }, {\n        key: 'removeIncident',\n        value: function removeIncident(id) {\n            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n            if (this.incidentsById[id]) {\n                var deleteCheck = this.checkDelete(id, props);\n                if (deleteCheck.result === false) {\n                    helper.error(deleteCheck);\n                    return deleteCheck;\n                }\n\n                deleteCheck.execute();\n\n                this.incidentsById[id].lastWish();\n                this.incidentsById[id].parentSceneObject = null;\n\n                var keyframe_sec_key = this.incidentsKeyframeKeys[id];\n                //OPTIMIZE delete is slow on v8 engine we should check if we can achieve the same result by setting the value of the key to undefined\n                delete this.incidentsKeyframeKeys[id];\n                delete this.keyframes[keyframe_sec_key][id];\n                delete this.incidentsById[id];\n                if (Object.keys(this.keyframes[keyframe_sec_key]).length === 0) {\n                    delete this.keyframes[keyframe_sec_key];\n                }\n                delete this.listeners[id]; // delete the listener that manages the Incident's execution\n\n                var deletedIncident = void 0;\n                for (var i = 0; i < this.incidents.length; i++) {\n                    if (this.incidents[i].id === id) {\n                        deletedIncident = this.incidents.splice(i, 1);\n                        break;\n                    }\n                }\n\n                this.getDurationAfterIncidentAffected();\n                this.onRemoveIncident(deletedIncident[0]);\n\n                return { result: true };\n            } else {\n                for (var _i2 = 0; _i2 < this.incidents.length; _i2++) {\n                    if (this.incidents[_i2].incident.hasIncidents) {\n                        if (this.incidents[_i2].incident.removeIncident(id).result === true) {\n                            return { result: true };\n                        }\n                    }\n                } // if it reaches the end of the loop without having returned true\n                return { result: false };\n            }\n        }\n\n        /**\n         * This method which is provided only by Groups accepts an incidentId and a new duration and \n         * edits the duration of the corresponding incident accordingly\n         * @param {string} incidentId - the id of the incident to resize\n         * @param {int} newDuration - the new duration of the incident in milliseconds\n        */\n\n    }, {\n        key: 'resizeIncident',\n        value: function resizeIncident(incidentId, newDuration) {\n            var existingIncident = this.getIncidentById(incidentId);\n            if (existingIncident === null) {\n                return { result: false, errors: [{ reason: 'The incident with id ' + incidentId + ' does not belong to the Group or any of its child Groups' }] };\n            }\n            return existingIncident.resize(newDuration);\n        }\n\n        /**\n         * This method which is provided only by Groups accepts an incidentId and a new attrs object \n         * and edits the attributes of the corresponding incident accordingly\n         * If the attribute editing ends up with conflicts the edit is discarded.\n         * @param {string} incidentId - the id of the incident to resize\n         * @param {int} attrs - the new attrs of the Incident\n        */\n\n    }, {\n        key: 'editIncidentAttributes',\n        value: function editIncidentAttributes(incidentId, attrs) {\n            var directParent = this._getDirectParent(incidentId);\n            if (directParent === null) {\n                return {\n                    result: false,\n                    errors: ['The Incident with id ' + incidentId + ' does not belong to the Group or any of its child Groups']\n                };\n            }\n            return directParent._editChildIncidentAttributes(incidentId, attrs);\n        }\n\n        /**\n         * By this method a Group tries to edit the attributes of one of its children. The process goes as follows:\n         * 1. The Group gets an export of the Incident's state\n         * 2. The Group deletes the Incident\n         * 3. The Group tries to create a new Incident with the same id as the old one and with type=\"all-or-nothing\"\n         * 4.a. If the new Incident gets added ok process finishes\n         * 4.b. If the new Incident doesn't get added because of conflicts the previous Incident gets back in\n         * @param {string} incidentId - the id of the Incident to edit its attrs\n         * @param {object} attrs - the new attributes of the Incident\n        */\n\n    }, {\n        key: '_editChildIncidentAttributes',\n        value: function _editChildIncidentAttributes(incidentId, attrs) {\n            var incidentToEdit = this.getIncidentById(incidentId);\n            var existingIncidentDefinition = incidentToEdit.exportState();\n            var millisecond = this.getIncidentMillisecond(incidentId);\n            this.removeIncident(incidentId);\n            var newIncidentProps = Object.assign({}, existingIncidentDefinition.props);\n            var newIncident = new existingIncidentDefinition.Incident(attrs, newIncidentProps);\n            var result = this.addIncident(newIncident, millisecond);\n            if (result.result === false) {\n                var myOldIncident = new existingIncidentDefinition.Incident(existingIncidentDefinition.attrs, newIncidentProps);\n                this.addIncident(myOldIncident, millisecond);\n                return result;\n            } else {\n                return {\n                    result: true\n                };\n            }\n        }\n\n        /**\n         * Starting from itself and going all the way down to each and every leaf of its tree it systols/diastoles the\n         * Incidents\n         * @param {float} durationFraction the fraction of the new duration to the existing duration\n        **/\n\n    }, {\n        key: 'systolDiastole',\n        value: function systolDiastole(durationFraction) {\n            this.calculatedDuration = durationFraction * this.duration;\n            for (var i = 0; i < this.incidents.length; i++) {\n                this.changeIncidentsStartMillisecond(this.incidents[i].millisecond * durationFraction, this.incidents[i].incident.id);\n                this.incidents[i].incident.systolDiastole(durationFraction);\n            }\n        }\n\n        // THE \"EARS\" OF THE SCENE TO ITS CHILD INCIDENTS\n        /**\n              NEW STATE CALCULATION RULES:\n              If a Scene has at least one clipBlockingWaiting (meaning the full Clip is halted at the moment) the Scenes state will be clipBlockingWaiting unless it is the Clip so its state will be waiting.\n              If a Scene has all children on the completed state, the Scene has the completed state as well.\n              If a Scene has at least one of its children on one of the following states:\n                    waiting     it has started playing and has been halted internally\n                    playing     it has started playing\n                    idle            it has not been executed yet\n              the Scene is on playing state\n               */\n\n    }, {\n        key: 'incidentStateChange',\n        value: function incidentStateChange(id, oldState, newState, props) {\n            if (newState === 'clipBlockingWaiting' || newState === 'sceneBlockingWaiting') {\n                var propsToPass = props;\n                propsToPass.callerId = id;\n                if (newState === 'sceneBlockingWaiting') {\n                    // stop propagation as this should only affect the Scene and not its parents\n                    props.waitingStateName = 'waiting';\n                }\n                this.wait(propsToPass);\n            } else if (newState === 'completed' && this.speed > 0) {\n                // helper.log('Incident ' + id + ' got into completed state');\n                // helper.log('Incident ' + this.id + ' takes care of it');\n                var allCompleted = true;\n                // helper.log('going to iterate on all Incidents');\n                for (var i = 0; i < this.incidents.length; i++) {\n                    // helper.log(\n                    //     this.incidents[i].incident.id + '.state = ' + this.incidents[i].incident.state\n                    // );\n                    if (this.incidents[i].incident.state != 'completed') {\n                        allCompleted = false;\n                        break;\n                    }\n                }\n                if (allCompleted) {\n                    this.complete();\n                }\n            } else if (newState === 'idle' && this.speed < 0) {\n                // helper.log('Incident ' + id + ' got into completed state');\n                // helper.log('Incident ' + this.id + ' takes care of it');\n                var _allCompleted = true;\n                // helper.log('going to iterate on all Incidents');\n                for (var _i3 = 0; _i3 < this.incidents.length; _i3++) {\n                    // helper.log(\n                    //     this.incidents[i].incident.id + '.state = ' + this.incidents[i].incident.state\n                    // );\n                    if (this.incidents[_i3].incident.state != 'idle') {\n                        _allCompleted = false;\n                        break;\n                    }\n                }\n                if (_allCompleted) {\n                    this.complete();\n                }\n            } else {\n                // in case the child was either on sceneBlockingWaiting or clipBlockingWaiting and now is changing\n                this.resume();\n            }\n        }\n\n        /**\n         * it checks if a block with the provided props exists on its blockingWaitings array\n         * if it exists it removes it.\n         * If the remaining blocking waitings are equal to 0 it returns true otherwise it returns false\n        */\n\n    }, {\n        key: 'removeBlock',\n        value: function removeBlock(props) {\n            var newBlockingWaitings = [];\n            var found = false;\n            for (var i = 0; i < this.blockingWaitings.length; i++) {\n                var bWaiting = this.blockingWaitings[i];\n                if (bWaiting.id === props.id) {\n                    found = true;\n                    continue;\n                }\n                newBlockingWaitings.push(this.blockingWaitings[i]);\n            }\n\n            this.blockingWaitings = newBlockingWaitings;\n            return found;\n        }\n\n        /**\n         * goTo method should always be handled by the Clip. No other Group nor Incident can handle goTo alone.\n         * Thus, if the Group is not the Clip it passes the command up. If the Group is the Clip then it handles goTo\n         * by passing the command to its Channels.\n        **/\n\n    }, {\n        key: 'goTo',\n        value: function goTo(millisecond) {\n            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n            // first decide the millisecond we want to goTo\n            if (millisecond === null || millisecond === undefined) {\n                millisecond = this.runTimeInfo.currentMillisecond;\n            }\n            if (props.hasOwnProperty('relativeTo')) {\n                millisecond += this.getIncidentMillisecond(props.relativeTo);\n            }\n\n            if (millisecond > this.duration) {\n                millisecond = this.duration;\n            } else if (millisecond < 0) {\n                millisecond = 0;\n            }\n\n            if (this.isHeadlessClip) {\n                return false;\n            } else {\n                props.relativeTo = this.id;\n                if (this.parentSceneObject.goTo(millisecond, props)) {\n                    return true;\n                }\n            }\n        }\n\n        /**\n         * when the Group is on test mode (this.isOnTestMode = true) the emulateStep method\n         * becomes functional.\n         * The method takes as input the millisecondsDelta from the previous timestamp and triggers\n         * the step function passing in a baked timestamp so the Incident behaves exactly as if the requestAnimationFrame run\n         * passing a timestamp that has exactly millisecondsDelta difference from the previous one\n         * @param {int} millisecondsDelta - the milliseconds difference between the previous timestamp and the new one\n        */\n\n    }, {\n        key: 'emulateStep',\n        value: function emulateStep(millisecondsDelta) {\n            if (!this.isOnTestMode) {\n                helper.error('emulateStep method can only be used on test mode');\n            } else {\n                this.step(this.runTimeInfo.previousTimeStamp + millisecondsDelta);\n                for (var i = 0; i < this.incidents.length; i++) {\n                    var childIncident = this.incidents[i];\n\n                    if (childIncident.incident.state === \"playing\") {\n                        childIncident.incident.emulateStep(Math.abs((this.runTimeInfo.currentMillisecond - childIncident.millisecond - childIncident.incident.runTimeInfo.currentMillisecond) / this.speed));\n                    }\n                }\n            }\n        }\n\n        // *******************************************************\n        // STEP FUNCTION\n\n    }, {\n        key: 'step',\n        value: function step(timestamp) {\n            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n            var that = this;\n\n            // start from is the number of milliseconds elapsed from the actual starting point of the Incident caused mainly\n            // by CPU performance. (each requestAnimationFrame cirlce doesn't happen every one millisecond\n            // so an Incident that was supposed to start on millisecond 100 of a Group might get fired 10 milliseconds later than\n            // its actual starting point, so tth startFrom will be 10)\n            if (props != null) {\n                var startFrom = props.startFrom;\n                if (!props.hasOwnProperty('startFrom')) {\n                    if (this.direction === \"forwards\") {\n                        startFrom = 0;\n                    } else {\n                        startFrom = this.duration;\n                    }\n                }\n\n                if (this.speed > 0) {\n                    this.runTimeInfo.previousTimeStamp = timestamp - startFrom / this.speed;\n                } else {\n                    this.runTimeInfo.previousTimeStamp = timestamp - (this.duration - startFrom) / Math.abs(this.speed);\n                }\n            }\n\n            var informListeners = function informListeners(progress) {\n                for (var key in that.listeners) {\n                    var listner = that.listeners[key];\n                    if (Math.abs(progress.milliseconds + listner.cavaDelta - that.runTimeInfo.currentMillisecond) > listner.threshold) {\n                        listner.funct(progress.milliseconds, timestamp, helper.roundNumberTo(listner.roundTo));\n                        listner.cavaDelta = 0;\n                    } else {\n                        listner.cavaDelta += Math.abs(progress.milliseconds - that.runTimeInfo.currentMillisecond);\n                    }\n                }\n            };\n\n            // helper.log('got into step on ' + this.id);\n            if (this.runTimeInfo.state !== 'playing') {\n                return;\n            }\n\n            // progressStep is the progress made from previousTimeStamp both in milliseconds and in fraction [0 to 1]\n            var progress = {\n                milliseconds: Math.round(this.runTimeInfo.currentMillisecond + (timestamp - this.runTimeInfo.previousTimeStamp) * this.speed),\n                fraction: (this.runTimeInfo.currentMillisecond + (timestamp - this.runTimeInfo.previousTimeStamp) * this.speed) / this.duration\n            };\n            // helper.notice(`calculation properties of progress for ${this.id}`);\n            // helper.log(`this.runTimeInfo.currentMillisecond: ${this.runTimeInfo.currentMillisecond}, timestamp: ${timestamp}, this.runTimeInfo.previousTimeStamp: ${this.runTimeInfo.previousTimeStamp}`)\n\n            // helper.log(this.id, progress);\n\n            if (progress.fraction < 0) {\n                this.onProgress(0, 0);\n                informListeners({ fraction: 0, milliseconds: 0 });\n                this._dontTellMamaStateChange('idle');\n                this.broadcastEvent('state-change', { oldState: \"playing\", newState: \"idle\" });\n                this.resetState();\n                return;\n            }\n\n            this.onProgress(progress.fraction, progress.milliseconds);\n\n            // helper.log(this.id);\n            // helper.log(this.runTimeInfo.currentMillisecond);\n            // helper.log(this.id + ' progress: ', progress);\n            // handle listeners\n            informListeners(progress);\n\n            this.runTimeInfo.currentMillisecond = progress.milliseconds;\n            this.runTimeInfo.previousTimeStamp = timestamp;\n\n            // helper.log(this.runTimeInfo.currentMillisecond);\n\n            // helper.log('this.runtimeInfo.state on ' + this.id + ' = ' + this.runTimeInfo.state);\n            this.requestAnimaFrame(that.step.bind(that));\n        }\n\n        /**\n         * The Scene receives this command from its chilren and the purpose of it is to help the caller\n         * identify the milliseconds delta of its start compared to the root Scene of it.\n         * In a multi-level situation with Scenes within scenes the Scene that receives this command might not own\n         * the Incident that triggered this thread directly. That's why we use the extraDelta helping parameter that\n         * actually delivers level by level the delta of the triggering Incident within the tree\n         * @param {string} incidentId = the id of the child incident of the scene that trigerred the method\n         * @param {int} extraDelta - the extra delta to add to the result\n        **/\n\n    }, {\n        key: 'getRootCurrentMillisecondDeltaFromIncidentsStart',\n        value: function getRootCurrentMillisecondDeltaFromIncidentsStart(incidentId) {\n            var extraDelta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n            // first step find the start millisecond of the incident\n            var incidentMillisecond = this.getIncidentMillisecond(incidentId);\n            if (!this.checkParentScene()) {\n                return this.runTimeInfo.currentMillisecond - incidentMillisecond - extraDelta;\n            } else {\n                return this.parentSceneObject.getRootCurrentMillisecondDeltaFromIncidentsStart(this.id, incidentMillisecond + extraDelta);\n            }\n        }\n\n        /*\n        CALLBACKS AFTER SUCCESSFUL ADDING / EDITING / DELETING AN INCIDENT\n         */\n\n    }, {\n        key: 'onAddIncident',\n        value: function onAddIncident(incident, millisecond) {}\n    }, {\n        key: 'onEditIncident',\n        value: function onEditIncident(incident, oldMillisecond, newMillisecond) {}\n    }, {\n        key: 'onRemoveIncident',\n        value: function onRemoveIncident(incident) {}\n\n        // on Groups there is no need to prevent re-invoking the onGetContext method\n\n    }, {\n        key: '_onGetContextOnce',\n        value: function _onGetContextOnce() {\n            this.onGetContext();\n            for (var i = 0; i < this.incidents.length; i++) {\n                this.incidents[i].incident._onGetContextOnce();\n            }\n        }\n    }, {\n        key: 'duration',\n        get: function get() {\n            return this.calculatedDuration;\n        },\n        set: function set(duration) {\n            this.calculatedDuration = duration;\n        }\n    }, {\n        key: 'groupType',\n        get: function get() {\n            return \"plain\";\n        }\n    }, {\n        key: 'projectedIncidents',\n        get: function get() {\n            return this.getProjectedIncidents();\n        }\n    }, {\n        key: 'executionSpeed',\n        set: function set(speed) {\n            helper.notice(this.id + ' is setting its execution speed to: ' + speed + ' while on millisecond: ' + this.runTimeInfo.currentMillisecond);\n            if (speed === 0) {\n                helper.error(\"Speed can't be 0\");\n                return false;\n            }\n\n            this.speed = speed;\n            this.onSpeedChange(speed);\n            for (var i = 0; i < this.incidents.length; i++) {\n                this.incidents[i].incident.executionSpeed = speed;\n            }\n        }\n    }]);\n\n    return Group;\n}(TimedIncident);\n\nmodule.exports = Group;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19CYXNlQ2xhc3Nlcy9Hcm91cC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2Rpc3QvX0Jhc2VDbGFzc2VzL0dyb3VwLmpzP2ZmZTEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgVGltZWRJbmNpZGVudCA9IHJlcXVpcmUoJy4vVGltZWRJbmNpZGVudCcpO1xudmFyIEhlbHBlciA9IHJlcXVpcmUoJy4uL19jb3JlVXRpbHMvSGVscGVyJyk7XG52YXIgaGVscGVyID0gbmV3IEhlbHBlcigpO1xudmFyIGNvbmYgPSByZXF1aXJlKCcuLi9jb25maWd1cmF0aW9uL2dlbmVyYWxDb25mJyk7XG52YXIgcGlwZU1lc3NnZXMgPSByZXF1aXJlKCcuLi9jb25maWd1cmF0aW9uL3BpcGVzQ29uZicpO1xudmFyIGNoZWNrVHJhbnNpdGlvbiA9IHJlcXVpcmUoJy4uL2NvbmZpZ3VyYXRpb24vYWxsb3dlZFN0YXRlQ2hhbmdlcycpLmNoZWNrVHJhbnNpdGlvbjtcbnZhciBfQ09OU1QgPSByZXF1aXJlKCcuLi9jb25maWd1cmF0aW9uL19DT05TVCcpO1xuXG4vKiogQGNsYXNzZGVzY1xuICogQSBTY2VuZSBpcyBhIFRpbWVJbmNpZGVudCB0aGF0IGNhbiBoYXZlIG90aGVyIEluY2lkZW50cyAoYW55IGtpbmQgb2YpIG9uIGl0cyB0aW1lbGluZSBhbmQgaXRzIHN0YXRlIG1haW5seSBkZXJpdmVzXG4gKiBmcm9tIHRoZSBzdGF0ZSBvZiBpdHMgaW5jaWRlbnRzIHJhdGhlciB0aGFuIGl0c2VsZi5cbiAqL1xuXG52YXIgR3JvdXAgPSBmdW5jdGlvbiAoX1RpbWVkSW5jaWRlbnQpIHtcbiAgICBfaW5oZXJpdHMoR3JvdXAsIF9UaW1lZEluY2lkZW50KTtcblxuICAgIGZ1bmN0aW9uIEdyb3VwKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgICB2YXIgb2xkUHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG5cbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEdyb3VwKTtcblxuICAgICAgICB2YXIgYXR0cnNUb1Bhc3MgPSB2b2lkIDAsXG4gICAgICAgICAgICBwcm9wc1RvUGFzcyA9IHZvaWQgMDtcblxuICAgICAgICAvKlxuICAgICAgICBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4gSWYgdGhlIHVzZXIgZG9lc24ndCBwYXNzIGEgc2Vjb25kIGFyZ3VtZW50IG9uIHRoZSBjb25zdHJ1Y3RvciB0aGVuIHRoaXMgaXMgXG4gICAgICAgIHRoZSBuZXcgd2F5IG9mIGluaXRpYWxpc2luZyBhIEdyb3VwIChvbmx5IHByb3BzKS5cbiAgICAgICAgKi9cbiAgICAgICAgaWYgKG9sZFByb3BzID09PSBudWxsKSB7XG4gICAgICAgICAgICBhdHRyc1RvUGFzcyA9IHt9O1xuICAgICAgICAgICAgcHJvcHNUb1Bhc3MgPSBwcm9wcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVsc2UsIGluIGNhc2UgdGhlIHVzZXIgaGFzIHBhc3NlZCB0d28gYXJndW1lbnRzIHRoZW4gYm90aCBzaG91bGQgYmUgdXNlZFxuICAgICAgICAgICAgYXR0cnNUb1Bhc3MgPSBwcm9wcztcbiAgICAgICAgICAgIHByb3BzVG9QYXNzID0gb2xkUHJvcHM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoR3JvdXAuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihHcm91cCkpLmNhbGwodGhpcywgYXR0cnNUb1Bhc3MsIHByb3BzVG9QYXNzKSk7XG5cbiAgICAgICAgX3RoaXMuaGFzSW5jaWRlbnRzID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMuaXNDaGFubmVsID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAga2V5ZnJhbWVzIGFyZSBzcGVjaWFsIHBvaW50cyBvbiB0aGUgU2NlbmUncyB0aW1lIHdoZXJlIEluY2lkZW50cyBzaG91bGQgYmUgZXhlY3V0ZWRcbiAgICAgICAgICBUaGUga2V5cyBvZiB0aGUga2V5ZnJhbWVzIGFycmF5IGFyZSB0aGUgbWlsbGlzZWNvbmQgb24gd2hpY2ggdGhlIGtleWZyYW1lcyBzaG91bGQgZ2V0IGV4ZWN1dGVkOlxuICAgICAgICAgIGUuZy46XG4gICAgICAgICAga2V5ZnJhbWVzID0ge1xuICAgICAgICAgICAgICAgIHNlY18yMDAwOiB7XG4gICAgICAgICAgICAgICAgICAgIGluY2lkZW50X2lkOiBJbmNpZGVudE9iamVjdCxcbiAgICAgICAgICAgICAgICAgICAgaW5jaWRlbnRfaWQ6IEluY2lkZW50T2JqZWN0LFxuICAgICAgICAgICAgICAgICAgICAuLi5cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC4uLlxuICAgICAgICAgIH1cbiAgICAgICAgICAqL1xuICAgICAgICBfdGhpcy5rZXlmcmFtZXMgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICBBbiBvYmplY3QgaG9sZGluZyB0aGUgbWFwcGluZyBpbmNpZGVudGlkIC8ga2V5ZnJhbWVrZXksIGZyb20gd2hpY2ggd2UgY2FuIGdldCB0aGUga2V5ZnJhbWUgaWQgYXMgZGVmaW5lZCBvblxuICAgICAgICAgIHRoZSB0aGlzLmtleWZyYW1lcyBvYmplY3Qgd2hlcmUgdGhlIGluY2lkZW50IGJlbG9uZ3MgdG9cbiAgICAgICAgICBlLmcuOlxuICAgICAgICAgIGluY2lkZW50c0tleWZyYW1lS2V5cyA9IHtcbiAgICAgICAgICAgICAgICBpbmNpZGVudGlkOiBzZWNfMjAwMCxcbiAgICAgICAgICAgICAgICAuLi5cbiAgICAgICAgICB9XG4gICAgICAgICAgICovXG4gICAgICAgIF90aGlzLmluY2lkZW50c0tleWZyYW1lS2V5cyA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgIFRoZSBhcnJheSBob2xkcyB0aGUgSW5jaWRlbnRzIG9mIHRoZSBTY2VuZSBvbiB0aGUgZm9ybWF0OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZCAvLyB0aGUgaWQgb2YgdGhlIEluY2lkZW50IG9iamVjdFxuICAgICAgICAgICAgICAgIGluY2lkZW50IC8vIHRoZSBpbmNpZGVudCBvYmplY3RcbiAgICAgICAgICAgICAgICBtaWxsaXNlY29uZCAvLyB0aGUgbWlsbGlzZWNvbmQgdGhlIGluY2lkZW50IHNob3VsZCBiZSBleGVjdXRlZFxuICAgICAgICAgIH1cbiAgICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuaW5jaWRlbnRzID0gW107XG5cbiAgICAgICAgLypcbiAgICAgICAgYW4gb2JqZWN0IC8gYXNzb2NpYXRpdmUgYXJyYXkgaG9sZGluZyBhbGwgSW5jaWRlbnRzIGluIHRoZSBmb3JtOlxuICAgICAgICA8aW5jaWRlbnRfaWQ+OiBJbmNpZGVudCBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmluY2lkZW50c0J5SWQgPSB7fTtcblxuICAgICAgICBfdGhpcy5jYWxjdWxhdGVkRHVyYXRpb24gPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY25hbm5lbHMgYXR0cmlidXRlIGhvbGRzIGEgbGlzdCBvZiBhbGwgaW50YW50aWF0ZWQgQ2hhbm5lbHMgb2YgdGhlIEluY2lkZW50cyBiZWxvbmdpbmcgdG8gdGhlIGNsaXBcbiAgICAgICAgICogdGhpcyBhdHRyaWJ1dGUgaXMgb25seSB2YWx1YWJsZSB3aGVuIHRoZSBHcm91cCBiZWNvbWVzIHRoZSBDbGlwXG4gICAgICAgICAqIFRoZSBmb3JtYXQgb2YgdGhlIGF0dHJpYnV0ZSBpczpcbiAgICAgICAgICogIGtleS12YWx1ZSBwYWlycyBpbiB0aGUgbWFubmVyOlxuICAgICAgICAgKiA8bWNfcGx1Z2luX25wbV9uYW1lPjogQ2hhbm5lbCBvYmplY3RcbiAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuaW5zdGFudGlhdGVkQ2hhbm5lbHMgPSB7fTtcblxuICAgICAgICBfdGhpcy5pc1RoZUNsaXAgPSBmYWxzZTtcblxuICAgICAgICBfdGhpcy5vbkdyb3VwSW5pdGlhbGlzZSgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEdyb3VwLCBbe1xuICAgICAgICBrZXk6ICdvbkdyb3VwSW5pdGlhbGlzZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkdyb3VwSW5pdGlhbGlzZSgpIHtcbiAgICAgICAgICAgIC8vIGNhbGxlZCB3aGVuIGdyb3VwIGdldHMgaW5pdGlhbGlzZWRcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2dldENoYW5uZWwnLFxuXG5cbiAgICAgICAgLypcbiAgICAgICAgcmV0dXJucyB0aGUgaW5pdGlhbGlzZWQgY2hhbm5lbCBieSB0aGUgQ2xpcCB0aGUgSW5jaWRlbnQgYmVsb25ncyB0b1xuICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENoYW5uZWwobWNfcGx1Z2luX25wbV9uYW1lKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGVja1BhcmVudFNjZW5lKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRTY2VuZU9iamVjdC5fZ2V0Q2hhbm5lbChtY19wbHVnaW5fbnBtX25hbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qXG4gICAgICAgIHJlbW92ZXMgYWxsIGVtdHB5IGdyb3VwcyB0aGF0IGJlbG9uZyB0byB0aGUgZ3JvdXAgYXMgaW5jaWRlbnRcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVtb3ZlRW10cHlHcm91cHMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlRW10cHlHcm91cHMoKSB7XG4gICAgICAgICAgICB2YXIgaW5jaWRlbnRzVG9SZW1vdmUgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmNpZGVudHNbaV0uaW5jaWRlbnQuaGFzSW5jaWRlbnRzICYmIHRoaXMuaW5jaWRlbnRzW2ldLmluY2lkZW50LmluY2lkZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaW5jaWRlbnRzVG9SZW1vdmUucHVzaCh0aGlzLmluY2lkZW50c1tpXS5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGluY2lkZW50c1RvUmVtb3ZlLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlSW5jaWRlbnQoaW5jaWRlbnRzVG9SZW1vdmVbX2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qXG4gICAgICAgIHJldHVybiB0aGUgZGlyZWN0IHBhcmVudCBvZiBhIHNwZWNpZmljIEluY2lkZW50XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19nZXREaXJlY3RQYXJlbnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERpcmVjdFBhcmVudChpbmNpZGVudElkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmNpZGVudHNCeUlkLmhhc093blByb3BlcnR5KGluY2lkZW50SWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5jaWRlbnRzW2ldLmluY2lkZW50Lmhhc0luY2lkZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpcmVjdFBhcmVudCA9IHRoaXMuaW5jaWRlbnRzW2ldLmluY2lkZW50Ll9nZXREaXJlY3RQYXJlbnQoaW5jaWRlbnRJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0UGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlyZWN0UGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGFsbCBvZiBpdHMgSW5jaWRlbnRzIChub3QgZ3JvdXBzKSBpbiBhIGNvbGxlY3Rpb24gb2YgdGhlIGZvcm06XG4gICAgICAgICAqIHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBtaWxsaXNlY29uZFxuICAgICAgICAgICAgICAgIGluY2lkZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldEluY2lkZW50c0J5Q2hhbm5lbCcsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBoYXMgdGhlIGtleSBvZiB0aGUgbnBtIHBsdWdpbiBuYW1lIHRoZSBDaGFubmVsIG9mIHdoaWNoIG1hbmFnZXMgdGhlIHNwZWNpZmljIEluY2lkZW50XG4gICAgICAgICAqIFdpdGggdGhlIHNhbWUgbG9naWMgYWxsIEluY2lkZW50cyB0aGF0IGJlbG9uZyB0byB0aGlzIEdyb3VwIGFzIGNhdGVnb3Jpc2VkIGJ5IHBsdWdpbiAvIGNoYW5uZWwgb24gdGhlIHNhbWUgb2JqZWN0XG4gICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbmNpZGVudHNCeUNoYW5uZWwoKSB7XG4gICAgICAgICAgICB2YXIgYWRqdXN0TWlsbGlzZWNvbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG5cbiAgICAgICAgICAgIC8vIGluaXRpYWxseSBpdCBvbmx5IHB1dHMgaXRzZWxmIG9udGhlIGluY2lkZW50c0J5UGx1Z2luIGFycmF5LCBleGFjdGx5IGFzIHRoZSBwbGFpbiBJbmNpZGVudHMgZG9cbiAgICAgICAgICAgIHZhciBpbmNpZGVudHNCeVBsdWdpbiA9IHt9O1xuICAgICAgICAgICAgdmFyIGtleVRvVXNlID0gdGhpcy5tY19wbHVnaW5fbnBtX25hbWU7XG4gICAgICAgICAgICBpZiAodGhpcy5ieXBhc3NDaGFubmVsID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAga2V5VG9Vc2UgPSAnbW90b3ItY29ydGV4LWpzJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluY2lkZW50c0J5UGx1Z2luW2tleVRvVXNlXSA9IFt7XG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmQ6IGFkanVzdE1pbGxpc2Vjb25kLFxuICAgICAgICAgICAgICAgIGluY2lkZW50OiB0aGlzLFxuICAgICAgICAgICAgICAgIGlkOiB0aGlzLmlkXG4gICAgICAgICAgICB9XTtcblxuICAgICAgICAgICAgLy8gcHJvY2VlZCB0byBnYXRoZXIgdGhlIGNvbnRhaW5lZCBpbmNpZGVudHMgYXMgd2VsbFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpbmNpZGVudHNUb0FkZCA9IHRoaXMuaW5jaWRlbnRzW2ldLmluY2lkZW50LmdldEluY2lkZW50c0J5Q2hhbm5lbChhZGp1c3RNaWxsaXNlY29uZCArIHRoaXMuaW5jaWRlbnRzW2ldLm1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gaW5jaWRlbnRzVG9BZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluY2lkZW50c0J5UGx1Z2luLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2lkZW50c0J5UGx1Z2luW2tleV0gPSBpbmNpZGVudHNCeVBsdWdpbltrZXldLmNvbmNhdChpbmNpZGVudHNUb0FkZFtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2lkZW50c0J5UGx1Z2luW2tleV0gPSBpbmNpZGVudHNUb0FkZFtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGluY2lkZW50c0J5UGx1Z2luO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjaGVja1N0YXRlVHJhbnNpdGlvbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja1N0YXRlVHJhbnNpdGlvbih0YXJnZXRTdGF0ZSkge1xuICAgICAgICAgICAgaWYgKGNoZWNrVHJhbnNpdGlvbih0aGlzLnJ1blRpbWVJbmZvLnN0YXRlLCB0YXJnZXRTdGF0ZSwgdGhpcy5kaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBJbmNpZGVudHMgb2YgZWFjaCBJbmNpZGVudCBpbiBhcnJheSBmb3JtYXQgaG9sZGluZyB0aGUgaW5jaWRlbnRzIGluIHRoZSBzdHJ1Y3R1cmU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgICBpbmNpZGVudFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgRGVwZW5kaW5nIG9uIHdobyBhc2tzIGZvciB0aGUgaW5jaWRlbnRzLCBpdCBtaWdodCBwYXNzIHRoZSBhZGp1c3RNaWxsaXNlY29uZCBhcmd1bWVudC4gVGhpcyBhcmd1bWVudCBpc1xuICAgICAgICAgICAgdXNlZCBpbiBjYXNlIGEgcGFyZW50IEdyb3VwIHdhbnRzIHRvIHJlY2VpdmUgdGhlIEluY2lkZW50cyBvZiBpdHMgY2hpbGQgYnV0IGJ5IHBhc3NpbmcgYSBjb3JyZWN0aW9uIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICB0aGF0IHJlcHJlc2VudHMgdGhlIG1pbGxpc2Vjb25kIHRoZSBJbmNpZGVudCBzdGFydHMgb24gaXRzIHBhcmVudCdzIHRpbWVsaW5lLlxuICAgICAgICAgICAgQHBhcmFtIHtpbnR9IGFkanVzdE1pbGxpc2Vjb25kXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldFByb2plY3RlZEluY2lkZW50cycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQcm9qZWN0ZWRJbmNpZGVudHMoKSB7XG4gICAgICAgICAgICB2YXIgYWRqdXN0TWlsbGlzZWNvbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG5cbiAgICAgICAgICAgIHZhciBwcm9qZWN0ZWRJbmNpZGVudHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5jaWRlbnRzVG9BZGQgPSB0aGlzLmluY2lkZW50c1tpXS5pbmNpZGVudC5nZXRQcm9qZWN0ZWRJbmNpZGVudHMoYWRqdXN0TWlsbGlzZWNvbmQgKyB0aGlzLmluY2lkZW50c1tpXS5taWxsaXNlY29uZCk7XG4gICAgICAgICAgICAgICAgcHJvamVjdGVkSW5jaWRlbnRzID0gcHJvamVjdGVkSW5jaWRlbnRzLmNvbmNhdChpbmNpZGVudHNUb0FkZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJvamVjdGVkSW5jaWRlbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gKioqKioqKiogTUVUSE9EUyBUTyBDQUxDVUxBVEUgT1ZFUkFMTCBEVVJBVElPTiBPRiBTQ0VORVxuICAgICAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNhbGxlZCB3aGVuIGFuIEluY2lkZW50IG9mIHRoZSBTY2VuZSBnZXRzIGFmZmVjdGVkIGJ5IGFuIGVkaXQgb3IgYSBkZWxldGlvbi4gVGhlIGNvbW1hbmQgdGFyZ2V0cyB0aGVcbiAgICAgICAgICogcm9vdCBvZiB0aGUgc2NlbmVzIHRyZWUgd2hlcmUgYSByZWNhbGMgc3RhdGUgYW5kIGEgc2V0IGN1cnJlbnQgbWlsbGlzZWNvbmQgc2hvdWxkIHRha2UgcGxhY2VcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldER1cmF0aW9uQWZ0ZXJJbmNpZGVudEFmZmVjdGVkJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldER1cmF0aW9uQWZ0ZXJJbmNpZGVudEFmZmVjdGVkKCkge1xuICAgICAgICAgICAgdmFyIGR1cmF0aW9uQmVmb3JlQ2hhbmdlID0gdGhpcy5kdXJhdGlvbiAqIDE7XG4gICAgICAgICAgICB2YXIgY3VycmVudE1pbGxpc2Vjb25kQmVmb3JlQ2hhbmdlID0gdGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQgKiAxO1xuICAgICAgICAgICAgdmFyIHN0YXRlQmVmb3JlQ2hhZ2UgPSB0aGlzLnN0YXRlICsgJyc7XG5cbiAgICAgICAgICAgIHZhciBuZXdEdXJhdGlvbiA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluY2lkZW50ID0gdGhpcy5pbmNpZGVudHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGluY2lkZW50LmluY2lkZW50LmR1cmF0aW9uICsgaW5jaWRlbnQubWlsbGlzZWNvbmQgPiBuZXdEdXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBuZXdEdXJhdGlvbiA9IGluY2lkZW50LmluY2lkZW50LmR1cmF0aW9uICsgaW5jaWRlbnQubWlsbGlzZWNvbmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kdXJhdGlvbiA9IG5ld0R1cmF0aW9uO1xuICAgICAgICAgICAgLy8gaGVscGVyLmxvZygnZHVyYXRpb24gY2hhbmdlZCBvbiBpbmNpZGVudDogJyArIHRoaXMuaWQgKyAnLiBOZXcgZHVyYXRpb246ICcgKyBuZXdEdXJhdGlvbik7XG4gICAgICAgICAgICBpZiAodGhpcy5kdXJhdGlvbiAhPSBkdXJhdGlvbkJlZm9yZUNoYW5nZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0RXZlbnQoJ2R1cmF0aW9uLWNoYW5nZScsIHsgbmV3RHVyYXRpb246IG5ld0R1cmF0aW9uIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5jaGVja1BhcmVudFNjZW5lKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudFNjZW5lT2JqZWN0LmdldER1cmF0aW9uQWZ0ZXJJbmNpZGVudEFmZmVjdGVkKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHJldHVybiA7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHV0TWVzc2FnZU9uUGlwZShwaXBlTWVzc2dlcy5fQ0xJUF9FRElUSU5HX1NUQVRVUywge30sIHRydWUsIFwidXBcIiwgeyB0eXBlOiAncm9vdENsaXAnIH0pID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRNaWxsaXNlY29uZChjdXJyZW50TWlsbGlzZWNvbmRCZWZvcmVDaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlY2FsY1N0YXRlKGN1cnJlbnRNaWxsaXNlY29uZEJlZm9yZUNoYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjYWxsZWQgd2hlbiBhbiBJbmNpZGVudCBnZXRzIGFkZGVkIG9uIHRoZSBTY2VuZVxuICAgICAgICAgKiBAcGFyYW0ge2ludH0gc3RhcnRNaWxsaXNlY29uZFxuICAgICAgICAgKiBAcGFyYW0ge2ludH0gaW5jaWRlbnREdXJhdGlvblxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0RHVyYXRpb25BZnRlckluY2lkZW50QWRkZWQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RHVyYXRpb25BZnRlckluY2lkZW50QWRkZWQoc3RhcnRNaWxsaXNlY29uZCwgaW5jaWRlbnREdXJhdGlvbikge1xuICAgICAgICAgICAgdmFyIGR1cmF0aW9uQmVmb3JlQ2hhbmdlID0gdGhpcy5kdXJhdGlvbiAqIDE7XG4gICAgICAgICAgICB2YXIgY3VycmVudE1pbGxpc2Vjb25kQmVmb3JlQ2hhbmdlID0gdGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQgKiAxO1xuICAgICAgICAgICAgLy8gY29uc3Qgc3RhdGVCZWZvcmVSZWNhbCA9IHRoaXMuc3RhdGUgKyBcIlwiO1xuXG4gICAgICAgICAgICBpZiAoc3RhcnRNaWxsaXNlY29uZCArIGluY2lkZW50RHVyYXRpb24gPiB0aGlzLmNhbGN1bGF0ZWREdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlZER1cmF0aW9uID0gc3RhcnRNaWxsaXNlY29uZCArIGluY2lkZW50RHVyYXRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmR1cmF0aW9uICE9IGR1cmF0aW9uQmVmb3JlQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RFdmVudCgnZHVyYXRpb24tY2hhbmdlJywgeyBuZXdEdXJhdGlvbjogdGhpcy5kdXJhdGlvbiB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tQYXJlbnRTY2VuZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRTY2VuZU9iamVjdC5nZXREdXJhdGlvbkFmdGVySW5jaWRlbnRBZmZlY3RlZCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnB1dE1lc3NhZ2VPblBpcGUocGlwZU1lc3NnZXMuX0NMSVBfRURJVElOR19TVEFUVVMsIHt9LCB0cnVlLCBcInVwXCIsIHsgdHlwZTogJ3Jvb3RDbGlwJyB9KSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50TWlsbGlzZWNvbmQoY3VycmVudE1pbGxpc2Vjb25kQmVmb3JlQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNhbGNTdGF0ZShjdXJyZW50TWlsbGlzZWNvbmRCZWZvcmVDaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyAqKioqKioqKiBJTkNJREVOVCBNRVRIT0RTIElNUExFTUVOVEFUSU9OICoqKioqKioqKioqKioqXG4gICAgICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncGxheScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwbGF5KCkge1xuICAgICAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaXNIZWFkbGVzc0NsaXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfZ2V0KEdyb3VwLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEdyb3VwLnByb3RvdHlwZSksICdwbGF5JywgdGhpcykuY2FsbCh0aGlzLCBwcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogdGltZXIgYmxvY2tpbmcgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnd2FpdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB3YWl0KCkge1xuICAgICAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgaWYgKF9nZXQoR3JvdXAucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoR3JvdXAucHJvdG90eXBlKSwgJ3dhaXQnLCB0aGlzKS5jYWxsKHRoaXMsIHByb3BzKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BzLmNhbGxlcklkID09PSB0aGlzLmluY2lkZW50c1tpXS5pZCkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5jaWRlbnRzW2ldLmluY2lkZW50LmJsb2NrKHByb3BzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogdGltZXIgYmxvY2tpbmcgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYmxvY2snLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYmxvY2socHJvcHMpIHtcbiAgICAgICAgICAgIGlmIChfZ2V0KEdyb3VwLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEdyb3VwLnByb3RvdHlwZSksICdibG9jaycsIHRoaXMpLmNhbGwodGhpcywgcHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluY2lkZW50c1tpXS5pbmNpZGVudC5ibG9jaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiB0aW1lciB1bmJsb2NraW5nICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3Jlc3VtZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXN1bWUocHJvcHMpIHtcbiAgICAgICAgICAgIGlmIChfZ2V0KEdyb3VwLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEdyb3VwLnByb3RvdHlwZSksICdyZXN1bWUnLCB0aGlzKS5jYWxsKHRoaXMsIHByb3BzKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmNpZGVudHNbaV0uaW5jaWRlbnQucmVzdW1lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZXNldCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldChwcm9wcykge1xuICAgICAgICAgICAgaWYgKF9nZXQoR3JvdXAucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoR3JvdXAucHJvdG90eXBlKSwgJ3Jlc2V0JywgdGhpcykuY2FsbCh0aGlzLCBwcm9wcykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5jaWRlbnRzW2ldLmluY2lkZW50LnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzdG9wJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3AocHJvcHMpIHtcbiAgICAgICAgICAgIGlmIChfZ2V0KEdyb3VwLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEdyb3VwLnByb3RvdHlwZSksICdzdG9wJywgdGhpcykuY2FsbCh0aGlzLCBwcm9wcykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5jaWRlbnRzW2ldLmluY2lkZW50LnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBhcmFtZXRlciBpdCB0YWtlcyBpcyByZWxhdGl2ZSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBJbmNpZGVudCBpdHNlbGYgYW5kIGl0IG1pZ2h0IGJlIG5lZ2F0aXZlXG4gICAgICAgICAqIE5lZ2F0aXZlIHRhcmdldE1pbGxpc2Vjb25kIG1lYW5zIHRoZSB0YXJnZXQgbWlsbGlzZWNvbmQgaXMgTiBtaWxsaXNlY29uZHMgQkVGT1JFIHRoZSBzdGFydCBvZiB0aGUgSW5jaWRlbnRcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IHRhcmdldE1pbGxpc2Vjb25kRGVsdGFGcm9tU3RhcnQgLSB0aGUgZGVsdGEgb2YgdGhlIHRhcmdldCBtaWxsaXNlY29uZCBjb21wYXJlZCB0byB0aGUgSW5jaWRlbnQgc3RhcnRcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVjYWxjU3RhdGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVjYWxjU3RhdGUodGFyZ2V0TWlsbGlzZWNvbmREZWx0YUZyb21TdGFydCkge1xuICAgICAgICAgICAgX2dldChHcm91cC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihHcm91cC5wcm90b3R5cGUpLCAncmVjYWxjU3RhdGUnLCB0aGlzKS5jYWxsKHRoaXMsIHRhcmdldE1pbGxpc2Vjb25kRGVsdGFGcm9tU3RhcnQpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpbmNpZGVudCA9IHRoaXMuaW5jaWRlbnRzW2ldLmluY2lkZW50O1xuICAgICAgICAgICAgICAgIHZhciBzdGFydE1pbGxpc2Vjb25kID0gdGhpcy5pbmNpZGVudHNbaV0ubWlsbGlzZWNvbmQ7XG4gICAgICAgICAgICAgICAgaW5jaWRlbnQucmVjYWxjU3RhdGUodGFyZ2V0TWlsbGlzZWNvbmREZWx0YUZyb21TdGFydCAtIHN0YXJ0TWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdsYXN0V2lzaCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBsYXN0V2lzaCgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluY2lkZW50c1tpXS5pbmNpZGVudC5sYXN0V2lzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIC8vIFNDRU5FIFNQRUNJRklDIEZVTkNUSU9OUyAvIEhFTFBFUiBGVU5DVElPTlNcblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmV2ZXJzZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXZlcnNlKF9yZXZlcnNlKSB7XG4gICAgICAgICAgICB0aGlzLnJldmVyc2VkID0gX3JldmVyc2U7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldEluY2lkZW50TWlsbGlzZWNvbmQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5jaWRlbnRNaWxsaXNlY29uZChpbmNpZGVudElkKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uZi5nZXRNaWxsaXNlY29uZEZyb21LZXlmcmFtZUtleSh0aGlzLmluY2lkZW50c0tleWZyYW1lS2V5c1tpbmNpZGVudElkXSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2V4cG9ydFN0YXRlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGV4cG9ydFN0YXRlKCkge1xuICAgICAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgdmFyIGluY2lkZW50cyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5jaWRlbnRzW2ldLmluY2lkZW50LmF1dG9HZW5lcmF0ZWQgPT09IHRydWUgJiYgcHJvcHMudW5wcm9jZXNzZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBpbmNpZGVudCA9IHt9O1xuICAgICAgICAgICAgICAgIGluY2lkZW50Lm1pbGxpc2Vjb25kID0gdGhpcy5pbmNpZGVudHNbaV0ubWlsbGlzZWNvbmQ7XG4gICAgICAgICAgICAgICAgaW5jaWRlbnQuaW5jaWRlbnQgPSB0aGlzLmluY2lkZW50c1tpXS5pbmNpZGVudC5leHBvcnRTdGF0ZShwcm9wcyk7XG4gICAgICAgICAgICAgICAgaW5jaWRlbnQuaWQgPSB0aGlzLmluY2lkZW50c1tpXS5pZDtcbiAgICAgICAgICAgICAgICBpbmNpZGVudHMucHVzaChpbmNpZGVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IF9nZXQoR3JvdXAucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoR3JvdXAucHJvdG90eXBlKSwgJ2V4cG9ydFN0YXRlJywgdGhpcykuY2FsbCh0aGlzLCBwcm9wcyk7XG4gICAgICAgICAgICBzdGF0ZS5pbmNpZGVudHMgPSBpbmNpZGVudHM7XG5cbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2V0Q3VycmVudE1pbGxpc2Vjb25kJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEN1cnJlbnRNaWxsaXNlY29uZChtaWxsaXNlY29uZCkge1xuICAgICAgICAgICAgLy8gaGVscGVyLmxvZyhgc2V0dGluZyBjdXJyZW50VXNlciBvZiAke3RoaXMuaWR9IHRvICR7bWlsbGlzZWNvbmR9YCk7XG4gICAgICAgICAgICB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCA9IG1pbGxpc2Vjb25kO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkSW5jaWRlbnQgPSB0aGlzLmluY2lkZW50c1tpXTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjaGlsZCBpbmNpZGVudCBzdGFydHMgYmVmb3JlIHRoZSBtaWxsaXNlY29uZCBhbmQgaGFzIG5vdCBlbmRlZCB5ZXRcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRJbmNpZGVudC5taWxsaXNlY29uZCA8IG1pbGxpc2Vjb25kICYmIGNoaWxkSW5jaWRlbnQuaW5jaWRlbnQuZHVyYXRpb24gKyBjaGlsZEluY2lkZW50Lm1pbGxpc2Vjb25kID4gbWlsbGlzZWNvbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRJbmNpZGVudC5pbmNpZGVudC5zZXRDdXJyZW50TWlsbGlzZWNvbmQobWlsbGlzZWNvbmQgLSBjaGlsZEluY2lkZW50Lm1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZEluY2lkZW50LmluY2lkZW50LnNldEN1cnJlbnRNaWxsaXNlY29uZCgwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgSW5jaWRlbnQgYnkgSUQgbm8gbWF0dGVyIGlmIHRoZSBJbmNpZGVudCBiYWxvbmdzIGRpcmVjdGx5IHRvIHRoZSBTY2VuZSBvZiB0byBhIGNoaWxkIFNjZW5lXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIHRoZSBpZCBvZiB0aGUgSW5jaWRlbnQgdG8gZ2V0XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldEluY2lkZW50QnlJZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbmNpZGVudEJ5SWQoaWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluY2lkZW50c0J5SWQuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5jaWRlbnRzQnlJZFtpZF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5jaWRlbnRzW2ldLmluY2lkZW50Lmhhc0luY2lkZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluY2lkZW50ID0gdGhpcy5pbmNpZGVudHNbaV0uaW5jaWRlbnQuZ2V0SW5jaWRlbnRCeUlkKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmNpZGVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluY2lkZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgLy8gSU5DSURFTlRTIE1BTkFHRU1FTlQgTUVUSE9EU1xuICAgICAgICAvLyBQT0xZTU9SUEhJU00gQVBQTElFRC4gSUYgVEhFIEdST1VQIEhBUyBOTyBQQVJFTlQgSVQgQUNUUyBBUyBBIFNDRU5FLiBJRiBUSEUgR1JPVVAgSEFTIFBBUkVOVCBJVCBBQ1RTIEFTXG4gICAgICAgIC8vIEEgXCJUUkFOU1BBUkVOVCBHUk9VUFwiXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjaGVja0FkZGl0aW9uIG1ldGhvZCBzZXJ2ZXMgZXhhY3RseSB3aGF0IGl0cyBuYW1lIGltcGxpZXMuIFRvIGNoZWNrIGlmIHRoZSBhZGRpdGlvbiBvZiBhbiBJbmNpZGVudFxuICAgICAgICAgKiBpcyB2YWxpZCBhbmQgYWNjZXB0ZWQsIGFjY29yZGluZyB0byB0aGUgcnVsZXMgZGVmaW5lZCBvbiB0aGUgY2hhbm5lbHMuXG4gICAgICAgICAqIFRoZSBtZXRob2QgYm9vYmxlcyB1cCB1bnRpbCBpdCByZWFjaGVzIHRoZSBDbGlwIGJ5IGNhcnJ5aW5nIGFkanVzdGluZyB0aGUgbWlsbGlzZWNvbmQuXG4gICAgICAgICAqIFRoZSBtZXRob2QgdGFrZXMgYXMgaW5wdXQgdGhlIG1hbmFnZW1lbnQgdHlwZS4gT24gZXJyb3IgLyBjb25mbGljdDpcbiAgICAgICAgICogIC0gb24gdHlwZSA9PT0gJ2FsbC1vci1ub3RoaW5nJyBjb21wbGV0ZWx5IGRpc2NhcmQgYWRkaXRpb24gb2YgYWxsIGluY2lkZW50c1xuICAgICAgICAgKiAgLSBvbiB0eXBlID09PSAna2VlcC1wYXNzaW5nJyBpdCB3aWxsIG9ubHkgYWRkIHRoZSBwYXNzaW5nIGluY2lkZW50cyBubyBtYXR0ZXIgaWYgc29tZSBvdGhlciBpbmNpZGVudHMgb2YgdGhlIGFkZGl0aW9uIGZhaWxlZFxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gaW5jaWRlbnQgLSB0aGUgaW5jaWRlbnQgdG8gYWRkXG4gICAgICAgICAqIEBwYXJhbSB7aW50fSBtaWxsaXNlY29uZCAtIHRoZSBtaWxsaXNlY29uZCB0byBhZGQgdGhlIEluY2lkZW50IHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gYXMgZXhwbGFpbmVkIGFib3ZlXG4gICAgICAgICAqIFRoZSBtZXRob2QgcmV0dXJucyBlaXRoZXI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVzdWx0OnRydWUsXG4gICAgICAgICAgICAgICAgZXhlY3V0ZTogLy8gYW4gYXJyYXkgb2YgZnVuY3Rpb25zIHRoYXQgd2hlbiBleGVjdXRlZCBpdCB3aWxsIGFkZCB0aGUgSW5jaWRlbnRzIG9uIHRoZSBDaGFubmVsc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3JcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yc1xuICAgICAgICAgICAgfVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjaGVja0FkZGl0aW9uJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrQWRkaXRpb24oaW5jaWRlbnQsIG1pbGxpc2Vjb25kKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogXCJhbGwtb3Itbm90aGluZ1wiO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5pc0hlYWRsZXNzQ2xpcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogdHJ1ZSwgZXhlY3V0ZTogZnVuY3Rpb24gZXhlY3V0ZSgpIHt9IH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElGIFRIRSBHUk9VUCBIQVMgTk8gUEFSRU5UIChBQ1QgQVMgVEhFIENMSVApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50U2NlbmVPYmplY3QuY2hlY2tBZGRpdGlvbihpbmNpZGVudCwgbWlsbGlzZWNvbmQgKyB0aGlzLnBhcmVudFNjZW5lT2JqZWN0LmdldEluY2lkZW50TWlsbGlzZWNvbmQodGhpcy5pZCksIHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjaGVja0VkaXQgbWV0aG9kIHNlcnZlcyBleGFjdGx5IHdoYXQgaXRzIG5hbWUgaW1wbGllcy4gVG8gY2hlY2sgaWYgdGhlIGVkaXQgb2YgYW4gSW5jaWRlbnQgKGVkaXQgb2YgSW5jaWRlbnQncyBwb3NpdGlvbiBnaXZlbiBpbiBtaWxsaXNlY29uZHMgZGVsdGEpXG4gICAgICAgICAqIGlzIHZhbGlkIGFuZCBhY2NlcHRlZCwgYWNjb3JkaW5nIHRvIHRoZSBydWxlcyBkZWZpbmVkIG9uIHRoZSBjaGFubmVscy5cbiAgICAgICAgICogVGhlIG1ldGhvZCBib29ibGVzIHVwIHVudGlsIGl0IHJlYWNoZXMgdGhlIENsaXAuXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpbmNpZGVudCAtIHRoZSBpbmNpZGVudCB0byBlZGl0XG4gICAgICAgICAqIEBwYXJhbSB7aW50fSBtaWxsaXNlY29uZHNEZWx0YSAtIHRoZSBtaWxsaXNlY29uZHMgZGVsdGEgb2YgdGhlIEluY2lkZW50J3Mgc3RhcnQgdGltZVxuICAgICAgICAgVGhlIG1ldGhvZCBzaG91bGQgcmV0dXJuIGVpdGhlcjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6dHJ1ZSxcbiAgICAgICAgICAgICAgICBleGVjdXRlOiAvLyBhbiBhcnJheSBvZiBmdW5jdGlvbnMgdGhhdCB3aGVuIGV4ZWN1dGVkIGl0IHdpbGwgZWRpdCB0aGUgSW5jaWRlbnRzIG9uIHRoZSBDaGFubmVsc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3JcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yc1xuICAgICAgICAgICAgfVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjaGVja0VkaXQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tFZGl0KGluY2lkZW50LCBtaWxsaXNlY29uZHNEZWx0YSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNIZWFkbGVzc0NsaXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IHRydWUsIGV4ZWN1dGU6IGZ1bmN0aW9uIGV4ZWN1dGUoKSB7fSB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJRiBUSEUgR1JPVVAgSEFTIE5PIFBBUkVOVCAoQUNUIEFTIFRIRSBDTElQKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudFNjZW5lT2JqZWN0LmNoZWNrRWRpdChpbmNpZGVudCwgbWlsbGlzZWNvbmRzRGVsdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjaGVja0RlbGV0ZSBtZXRob2Qgc2VydmVzIGV4YWN0bHkgd2hhdCBpdHMgbmFtZSBpbXBsaWVzLiBUbyBjaGVjayBpZiB0aGUgZGVsZXRpb24gb2YgYW4gSW5jaWRlbnRcbiAgICAgICAgICogaXMgdmFsaWQgYW5kIGFjY2VwdGVkLCBhY2NvcmRpbmcgdG8gdGhlIHJ1bGVzIGRlZmluZWQgb24gdGhlIGNoYW5uZWxzLlxuICAgICAgICAgKiBUaGUgbWV0aG9kIGJvb2JsZXMgdXAgdW50aWwgaXQgcmVhY2hlcyB0aGUgQ2xpcC5cbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGluY2lkZW50IC0gdGhlIGluY2lkZW50IHRvIGVkaXRcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzIC0gaWYgcGFzc2VkIGl0IHN1cHBvcnRzIHRoZSBwcmV2ZW50U2xpcCBrZXkgd2hpY2ggaWYgZmFsc2UgdGhlIGNoYW5uZWwgc2hvdWxkIG5vdCBzbGlwLiBUaGlzIGNhc2UgaXMgZm9yIFxuICAgICAgICAgICAgZmxhc2hET00gb2YgRE9NQXdhcmVJbmNpZGVudHMgd2hlcmUgd2UgaGF2ZSBlbGVtZW50cyBkZWxldGVkIHNvIHNsaXBwaW5nIG9uIHRoZWlyIGxhbmVzIGlzIG5vdCB2YWxpZCBub3IgbmVjZXNzYXJ5XG4gICAgICAgICAgVGhlIHJlc3VsdCBtaWdodCBiZSBlaXRoZXI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVzdWx0OnRydWUsXG4gICAgICAgICAgICAgICAgZXhlY3V0ZTogLy8gYW4gYXJyYXkgb2YgZnVuY3Rpb25zIHRoYXQgd2hlbiBleGVjdXRlZCBpdCB3aWxsIHJlbW92ZSB0aGUgSW5jaWRlbnQgb24gdGhlIENoYW5uZWxzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvclxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3JzXG4gICAgICAgICAgICB9XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NoZWNrRGVsZXRlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrRGVsZXRlKGluY2lkZW50SWQpIHtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmlzSGVhZGxlc3NDbGlwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB0cnVlLCBleGVjdXRlOiBmdW5jdGlvbiBleGVjdXRlKCkge30gfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSUYgVEhFIEdST1VQIEhBUyBOTyBQQVJFTlQgKEFDVCBBUyBUSEUgQ0xJUClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRTY2VuZU9iamVjdC5jaGVja0RlbGV0ZShpbmNpZGVudElkLCBwcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSXQncyBjYWxsZWQgYWx3YXlzIGJ5IGEgY2hpbGQgdG8gU2NlbmUgdGhhdCB3YW50cyB0byBleHBhbmQgdG8gdGhlIGxlZnQgdG8gaXRzIHBhcmVudC5cbiAgICAgICAgICogRXhwYW5kaW5nIGEgU2NlbmUgdG8gdGhlIGxlZnQgbWVhbnMgaXQgdHJpZXMgdG8gYWRkIGV4dHJhIChpbml0aWFsbHkgdW5zdWVkKSBzcGFjZSAoaW4gbWlsbGlzZWNvbmRzKSBiZWZvcmUgaXRzXG4gICAgICAgICAqIGN1cnJlbnQgc3RhcnRpbmcgcG9pbnQuXG4gICAgICAgICAqIEluIG9yZGVyIGZvciB0aGlzIGFjdGlvbiB0byBiZSBhbGxvd2VkIHRoZSBTY2VuZSdzIGNvbnRleHQgc2hvdWxkIGFsbG93IHN1Y2ggYW4gZXhwYW5zaW9uLiBUaGlzIG1lYW5zOlxuICAgICAgICAgKiAgLSB0aGF0IGlmIHRoZSBTY2VuZSBoYXMgbm8gcGFyZW50cyB0aGlzIGV4cGFuc2lvbiBpcyBub3QgbGVnYWxcbiAgICAgICAgICogIC0gdGhhdCBpZiB0aGUgcm9vdCBTY2VuZSBvZiB0aGUgU2NlbmUncyBwYXJlbnRzIHRyZWUgbmVlZHMgdG8gZXhwYW5kIG9uIHRoZSBsZWZ0IGluIG9yZGVyIHRvIGFwcGx5IHRoZSBleHBhbnNpb25cbiAgICAgICAgICogICAgICB0aGVuIHRoZSBleHBhbnNpb24gaXMgbm90IGFjY2VwdGFibGVcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IGhvd01hbnlNaWxsaXNlY29uZHMgLSB0aGUgbWlsbGlzZWNvbmRzIHRvIGV4cGFuZCB0aGUgU2NlbmUgdG8gdGhlIGxlZnRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNjZW5lSWQgLSB0aGUgY2hpbGQgc2NlbmUgaWQgdGhhdCB3YW50cyB0byBnYWluIGV4dHJhIHNwYWNlIHRvIHRoZSBsZWZ0XG4gICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9IC0gdGhlIHJlc3VsdCBpcyBhbiBvYmplY3Qgd2l0aCB0d28ga2V5czpcbiAgICAgICAgICogIC0gdGhlIGZpcnN0IGtleSBpcyB0aGUgXCJyZXN1bHRcIiB3aGljaCBtaWdodCBlaXRoZXIgYmUgdHJ1ZSBvciBmYWxzZVxuICAgICAgICAgKiAgLSB0aGUgc2Vjb25kIGtleSBpcyB0aGUgXCJ1bmRvXCIgd2hpY2ggaXMgYSBmdW5jdGlvbiB0aGF0IGNhbiB1bmRvIHRoZSAoYXBwcm92ZWQpIGV4cGFuc2lvblxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdleHBhbmRTY2VuZVRvVGhlTGVmdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBleHBhbmRTY2VuZVRvVGhlTGVmdChob3dNYW55TWlsbGlzZWNvbmRzLCBzY2VuZUlkKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAgICAgLy8gRmlyc3Qgd2UgaWRlbnRpZnkgdGhlIGV4cGFuc2lvbiB3aXRoaW4gdGhlIGNvbnRleHQgb2YgdGhlIHBhcmVudCAodGhpcykgU2NlbmVcbiAgICAgICAgICAgIHZhciBjdXJyZW50U3RhcnRNaWxsaXNlY29uZE9mVGhlQ2hpbGRTY2VuZSA9IHRoaXMuZ2V0SW5jaWRlbnRNaWxsaXNlY29uZChzY2VuZUlkKTtcbiAgICAgICAgICAgIHZhciBuZXdTdGFydE1pbGxpc2Vjb25kT2ZUaGVDaGlsZFNjZW5lID0gaG93TWFueU1pbGxpc2Vjb25kcyAtIGN1cnJlbnRTdGFydE1pbGxpc2Vjb25kT2ZUaGVDaGlsZFNjZW5lO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgZXhwYW5zaW9uIGlzIGFsbG93ZWRcbiAgICAgICAgICAgIC8vIGlmIHRoZSBtaWxsaXNlY29ucyB0byBleHBhbmQgYXJlIHplcm8gb3IgbGVzcyAobWVhbmluZyB0aGUgY3VycmVudCBTY2VuZSBpcyBhY3R1YWxseSBub3QgYWZmZWN0ZWQgYnkgdGhlIGV4cGFuc2lvbilcbiAgICAgICAgICAgIGlmIChuZXdTdGFydE1pbGxpc2Vjb25kT2ZUaGVDaGlsZFNjZW5lIDw9IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgcm9vdFNjZW5lID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgY2hhbmdlUmVzdWx0ID0gdGhpcy5jaGFuZ2VJbmNpZGVudHNTdGFydE1pbGxpc2Vjb25kKC1uZXdTdGFydE1pbGxpc2Vjb25kT2ZUaGVDaGlsZFNjZW5lLCBzY2VuZUlkKTtcbiAgICAgICAgICAgICAgICB2YXIgdW5kbyA9IGZ1bmN0aW9uIHVuZG8oKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzMi5jaGFuZ2VJbmNpZGVudHNTdGFydE1pbGxpc2Vjb25kKGNoYW5nZVJlc3VsdC5vbGRNaWxsaXNlY29uZCwgc2NlbmVJZCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHVuZG86IHVuZG8sXG4gICAgICAgICAgICAgICAgICAgIHJvb3RTY2VuZTogcm9vdFNjZW5lXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgaXQgcmVhY2hlcyB0byB0aGF0IHBvaW50IHRoYXQgbWVhbnMgdGhlIGV4cGFuc2lvbiBhZmVjdHMgdGhlIGxlZnQgYm9yZGVycyBvZiB0aGlzIChwYXJlbnQpIFNjZW5lIGFzIHdlbGxcbiAgICAgICAgICAgIC8vIElmIGl0IGRvZXNuJ3QgaGF2ZSBhIHBhcmVudCBzY2VuZSB0aGF0IG1lYW5zIHRoZSBleHBhbnNpb24gaXMgaWxsZWdhbFxuICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWNrUGFyZW50U2NlbmUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogZmFsc2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiBpdCBoYXMgYSBwYXJlbnQgc2NlbmUgYW5kIHRoZSB0aGlzIFNjZW5lIG5lZWRzIHRvIGV4cGFuZCB0byB0aGUgbGVmdCBhcyB3ZWxsIHRoZW4gdGhpcyBTY2VuZVxuICAgICAgICAgICAgLy8gYXNzaWducyB0aGUgb2JsaWdhdGlvbiB0byBldmFsdWF0ZSB0aGUgZXhwYW5zaW9uIHRvIGl0cyBwYXJlbnRcbiAgICAgICAgICAgIHZhciBwYXJlbnREZWNpc2lvbiA9IHRoaXMucGFyZW50U2NlbmVPYmplY3QuZXhwYW5kU2NlbmVUb1RoZUxlZnQobmV3U3RhcnRNaWxsaXNlY29uZE9mVGhlQ2hpbGRTY2VuZSwgdGhpcy5pZCk7XG4gICAgICAgICAgICAvLyBpZiB0aGUgcGFyZW50IGFwcHJvdmVzIHRoZSBleHBhbnNpb25cbiAgICAgICAgICAgIGlmIChwYXJlbnREZWNpc2lvbi5yZXN1bHQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIGFwcGx5IHRoZSBleHBhbnNpb24gaXRzZWxmIGFuZCBidW5kbGUgaXRzIHVuZG8gYWxvbmcgd2l0aCB0aGUgdW5kbyBjb21pbmcgZnJvbSB0aGUgcGFyZW50XG4gICAgICAgICAgICAgICAgdGhpcy5leHBhbmRTdGFydFBvaW50KC1uZXdTdGFydE1pbGxpc2Vjb25kT2ZUaGVDaGlsZFNjZW5lKTtcbiAgICAgICAgICAgICAgICB2YXIgb3ZlcmFsbFVuZG8gPSBmdW5jdGlvbiBvdmVyYWxsVW5kbygpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50RGVjaXNpb24udW5kbygpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpczIuZXhwYW5kU3RhcnRQb2ludChuZXdTdGFydE1pbGxpc2Vjb25kT2ZUaGVDaGlsZFNjZW5lKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdW5kbzogb3ZlcmFsbFVuZG8sXG4gICAgICAgICAgICAgICAgICAgIHJvb3RTY2VuZTogcGFyZW50RGVjaXNpb24ucm9vdFNjZW5lXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogZXhwYW5kcyBvciBjb2xsYXBzZXMgdGhlIFNjZW5lJ3Mgc3RhcnQgbWlsbGlzZWNvbmQgYnkgdGhlIGdpdmVuIG1pbGxpc2Vjb25kc1xuICAgICAgICAgKiBlLmcuIGV4cGFuZFN0YXJ0UG9pbnQoMjAwKSB3aWxsIGV4cGFuZCB0aGUgU2NlbmUgYnkgMjAwIG1pbGxpc2Vjb25kcyB0byB0aGUgbGVmdCBrZWVwaW5nIGFsbFxuICAgICAgICAgKiAgICAgIG9mIGl0cyBpbmNpZGVudHMgdG8gdGhlIGV4YWN0IHNhbWUgcGxhY2UgdGhleSB3ZXJlIGJlZm9yZSBvbiB0aGUgb3ZlcmFsbCB0aW1lbGluZVxuICAgICAgICAgKiBlLmcuIGV4cGFuZFN0YXJ0UG9pbnQoLTIwMCkgd2lsbCBjb2xsYXBzZSB0aGUgU2NlbmUsIG1vdmluZyBpdHMgc3RhcnQgcG9pbnQgYnkgMjAwIG1pbGxpc2Vjb25kc1xuICAgICAgICAgKiAgICAgIHRvIHRoZSByaWdodCwgYWdhaW4gd2l0aG91dCBhZmZlY3RpbmcgYXQgYWxsIGl0cyBJbmNpZGVudHMnIHN0YXJ0IHBvaW50IG9uIHRoZSBvdmVyYWxsIHRpbWVsaW5lXG4gICAgICAgICAqIEBwYXJhbSB7aW50fSBieU1pbGxpc2Vjb25kcyAtIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGV4cGFuZCAocG9zaXRpdmUgbnVtYmVyKSBvciBjb2xsYXBzZSAobWludXMgbnVtYmVyKSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2V4cGFuZFN0YXJ0UG9pbnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZXhwYW5kU3RhcnRQb2ludChieU1pbGxpc2Vjb25kcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpbmNpZGVudCA9IHRoaXMuaW5jaWRlbnRzW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlSW5jaWRlbnRzU3RhcnRNaWxsaXNlY29uZChpbmNpZGVudC5taWxsaXNlY29uZCArIGJ5TWlsbGlzZWNvbmRzLCBpbmNpZGVudC5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogaXQgYWx0ZXJzIHRoZSBzdGFydCBtaWxsaXNlY29uZCBvZiBhbnkgYWxyZWFkeSBleGlzdGluZyBJbmNpZGVudCBvZiB0aGUgU2NlbmVcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IG5ld21pbGxpc2Vjb25kIC0gdGhlIG5ldyBtaWxsaXNlY29uZCB0byBwbGFjZSB0aGUgSW5jaWRlbnRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGluY2lkZW50SWQgLSB0aGUgaW5jaWRlbnQgaWRcbiAgICAgICAgICogQHJldHVybnMge2Z1bmN0aW9ufSAtIHRoZSB1bmRvIGZ1bmN0aW9uIG9mIHRoZSBjaGFuZ2VcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2hhbmdlSW5jaWRlbnRzU3RhcnRNaWxsaXNlY29uZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGFuZ2VJbmNpZGVudHNTdGFydE1pbGxpc2Vjb25kKG5ld21pbGxpc2Vjb25kLCBpZCkge1xuICAgICAgICAgICAgdmFyIGtleWZyYW1lX3NlY19rZXkgPSB0aGlzLmluY2lkZW50c0tleWZyYW1lS2V5c1tpZF07XG4gICAgICAgICAgICAvL09QVElNSVpFIGRlbGV0ZSBpcyBzbG93IG9uIHY4IGVuZ2luZSB3ZSBzaG91bGQgY2hlY2sgaWYgd2UgY2FuIGFjaGlldmUgdGhlIHNhbWUgcmVzdWx0IGJ5IHNldHRpbmcgdGhlIHZhbHVlIG9mIHRoZSBrZXkgdG8gdW5kZWZpbmVkXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5rZXlmcmFtZXNba2V5ZnJhbWVfc2VjX2tleV1baWRdO1xuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5rZXlmcmFtZXNba2V5ZnJhbWVfc2VjX2tleV0pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmtleWZyYW1lc1trZXlmcmFtZV9zZWNfa2V5XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIHRoaXMubGlzdGVuZXJzW2lkXTsgLy8gZGVsZXRlIHRoZSBsaXN0ZW5lciB0aGF0IGN1cnJlbnRseSBtYW5hZ2VzIHRoZSBJbmNpZGVudCdzIGV4ZWN1dGlvblxuXG5cbiAgICAgICAgICAgIHZhciBvbGRNaWxsaXNlY29uZCA9IHZvaWQgMDsgLy8gdGhlIHByZXZpb3VzIG1pbGxpc2Vjb25kIG9mIHRoZSBlZGl0ZWQgaW5jaWRlbnQgYmVmb3JlIHRoZSBlZGl0XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5jaWRlbnRzW2ldLmlkID09PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICBvbGRNaWxsaXNlY29uZCA9IHRoaXMuaW5jaWRlbnRzW2ldLm1pbGxpc2Vjb25kICogMTsgLy8gKjEgdG8gYXZvaWQgcmVmZXJlbmNlLCBrZWVwIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5jaWRlbnRzW2ldLm1pbGxpc2Vjb25kID0gbmV3bWlsbGlzZWNvbmQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGluY2lkZW50ID0gdGhpcy5pbmNpZGVudHNCeUlkW2lkXTtcbiAgICAgICAgICAgIHZhciBuZXdfa2V5ZnJhbWVfc2VjX2tleSA9IGNvbmYua2V5ZnJhbWVfc2VjX2tleSArIG5ld21pbGxpc2Vjb25kO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmtleWZyYW1lcy5oYXNPd25Qcm9wZXJ0eShuZXdfa2V5ZnJhbWVfc2VjX2tleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmtleWZyYW1lc1tuZXdfa2V5ZnJhbWVfc2VjX2tleV0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMua2V5ZnJhbWVzW25ld19rZXlmcmFtZV9zZWNfa2V5XVtpbmNpZGVudC5pZF0gPSBpbmNpZGVudDtcbiAgICAgICAgICAgIHRoaXMuaW5jaWRlbnRzS2V5ZnJhbWVLZXlzW2luY2lkZW50LmlkXSA9IG5ld19rZXlmcmFtZV9zZWNfa2V5O1xuXG4gICAgICAgICAgICAvLyBzdWJzY3JpYmUgSW5jaWRlbnQgc3RhcnQgb24gdGhlIGxpc3RlbmVyc1xuICAgICAgICAgICAgdmFyIGZ1bmN0ID0gZnVuY3Rpb24gZnVuY3Qoc2NlbmVNaWxsaXNlY29uZCwgcHJldmlvdXNUaW1lU3RhbXAsIHNjZW5lU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NlbmVNaWxsaXNlY29uZCA+PSBuZXdtaWxsaXNlY29uZCAmJiBzY2VuZU1pbGxpc2Vjb25kIDw9IG5ld21pbGxpc2Vjb25kICsgaW5jaWRlbnQuZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5jaWRlbnQucGxheSh7IHN0YXJ0RnJvbTogc2NlbmVNaWxsaXNlY29uZCAtIG5ld21pbGxpc2Vjb25kLCBwcmV2aW91c1RpbWVTdGFtcDogcHJldmlvdXNUaW1lU3RhbXAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUoaW5jaWRlbnQuaWQsIGZ1bmN0KTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBvbGRNaWxsaXNlY29uZDogb2xkTWlsbGlzZWNvbmQsXG4gICAgICAgICAgICAgICAgaW5jaWRlbnQ6IGluY2lkZW50XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBsYWluIGdyb3Vwc1xuICAgICAgICAgICAgQ2FuIGhhdmUgb24gdGhlaXIgdGltZWxpbmU6XG4gICAgICAgICAgICAtIEFub3RoZXIgcGxhaW4gZ3JvdXBcbiAgICAgICAgICAgIC0gQW4gaW5jaWRlbnQgd2l0aCBubyBzZWxlY3RvclxuICAgICAgICAgICAgLSBBIGRvbSBncm91cCAodGhpcyBtZXRob2Qgc2hvdWxkIGFjdHVhbGx5IHR1cm4gYW55IGluY2lkZW50IHdpdGggc2VsZWN0b3IgdG8gb25lKVxuICAgICAgICAgICAgQ2Fu4oCZdCBoYXZlIG9uIHRoZWlyIHRpbWVsaW5lOlxuICAgICAgICAgICAgLSBBbiBhdHRyaWJ1dGUgZ3JvdXBcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19wcmVwYXJlSW5pY2RlbnRGb3JBZGRpdGlvbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcHJlcGFyZUluaWNkZW50Rm9yQWRkaXRpb24oaW5jaWRlbnQpIHtcbiAgICAgICAgICAgIGlmICghaW5jaWRlbnQucHJvcHMuaGFzT3duUHJvcGVydHkoJ3NlbGVjdG9yJykgJiYgIWluY2lkZW50Lmhhc0luY2lkZW50cykge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBpbmNpZGVudCBpcyBub3QgYSBncm91cCBhbmQgaXQgaGFzIG5vIHNlbGVjdG9yIHByb2NlZWQgbm9ybWFsbHlcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5jaWRlbnQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluY2lkZW50Lmdyb3VwVHlwZSA9PT0gXCJwbGFpblwiKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIEluY2lkZW50IGlzIGEgcGxhaW4gZ3JvdXAgcHJvY2VlZCBub3JtYWxseVxuICAgICAgICAgICAgICAgIHJldHVybiBpbmNpZGVudDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5jaWRlbnQuZ3JvdXBUeXBlID09PSBcImF0dHJpYnV0ZVwiKSB7XG4gICAgICAgICAgICAgICAgaGVscGVyLmVycm9yKFwiUGxhaW4gZ3JvdXBzIGNhbiBub3QgYWNjZXB0IGF0dHJpYnV0ZSBncm91cHMgb24gdGhlaXIgdGltZWxpbmVcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gdHVybiB0aGUgSW5jaWRlbnQgdG8gYSBET01Bd2FyZUluY2lkZW50XG4gICAgICAgICAgICAvLyBiZWZvcmUgYWRkaW5nIGl0IHRvIHRoZSBncm91cFxuICAgICAgICAgICAgdmFyIERPTUF3YXJlSW5jaWRlbnQgPSByZXF1aXJlKCcuLi9fcmVzcG9uc2l2ZW5lc3MvRE9NQXdhcmVJbmNpZGVudCcpO1xuICAgICAgICAgICAgdmFyIHRoZURPTUF3YXJlSW5jaWRlbnQgPSBuZXcgRE9NQXdhcmVJbmNpZGVudChpbmNpZGVudCk7XG4gICAgICAgICAgICByZXR1cm4gdGhlRE9NQXdhcmVJbmNpZGVudDtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZmxhc2hET00nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZmxhc2hET00oKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIGZhaWxlZEFkZGl0aW9uczogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZsYXNoUmVzdWx0ID0gdGhpcy5pbmNpZGVudHNbaV0uaW5jaWRlbnQuZmxhc2hET00oKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuZmFpbGVkQWRkaXRpb25zID0gcmVzdWx0LmZhaWxlZEFkZGl0aW9ucy5jb25jYXQoZmxhc2hSZXN1bHQuZmFpbGVkQWRkaXRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2FkZFBhc3NpdmVJbmNpZGVudCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRQYXNzaXZlSW5jaWRlbnQoaW5jaWRlbnQsIG1pbGxpc2Vjb25kLCBzY2VuZUlkKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogXCJhbGwtb3Itbm90aGluZ1wiO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRJbmNpZGVudChpbmNpZGVudCwgbWlsbGlzZWNvbmQsIHNjZW5lSWQsIHR5cGUsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgIEFueSBTY2VuZSBjYW4gcmVjZWl2ZSB0aGUgYWRkSW5jZGVudCBjb21tYW5kIGVpdGhlciBmb3IgYWRkaW5nIGFuIEluY2lkZW50IG9uIGl0cyBvd24gSW5jaWRlbnRzIGxpc3Qgb3IgaW4gb3JkZXJcbiAgICAgICAgdG8gcGFzcyBkZWVwZXIgdGhlIGNvbW1hbmQgdG8gdGhlIHBhcmVudCBTY2VuZSBvZiB0aGUgSW5jaWRlbnQgKHNjZW5lSWQpLlxuICAgICAgICBObyBtYXR0ZXIgd2hpY2ggU2NlbmUgdG9vayB0aGUgY29tbWFuZCwgYWxsIHBhcmVudCBTY2VuZXMgZ2V0IGluZm9ybWVkXG4gICAgICAgICBhZGRJbmNpZGVudCB0YWtlcyAzIGFyZ3VtZW50czpcbiAgICAgICAgQHBhcmFtIHtJbmNpZGVudH0gaW5jaWRlbnQgLSB0aGUgSW5jaWRlbnQgb2JqZWN0IHRvIGdldCBhZGRlZFxuICAgICAgICBAcGFyYW0ge2ludH0gbWlsbGlzZWNvbmQgLSB0aGUgbWlsbGlzZWNvbmQgdG8gd2hpY2ggd2Ugd2FudCB0aGUgSW5jaWRlbnQgdG8gZ2V0IGFkZGVkLCBzdGFydGluZyBmcm9tIHRoZSB6ZXJvIHBvaW50IG9mIHRoZVxuICAgICAgICAgICAgdGFyZ2V0IFNjZW5lLiBJdCBjYW4ndCBiZSBuZWdhdGl2ZS4gTWlsbGlzZWNvbmQgY2FuIGFsc28gdGFrZSB0aGUgc3RyaW5nIHZhbHVlIFwiZW5kXCIgd2hpY2ggbWVhbnMgdGhlIG5ldyBJbmNpZGVudCBzaG91bGQgYmUgYWRkZWQgYXQgdGhlIGVuZCBvZiB0aGUgR3JvdXBcbiAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHNjZW5lSWQgLSB0aGUgc2NlbmVJZCB0byB3aGljaCB3ZSB3YW50IHRvIHB1dCB0aGUgbmV3IEluY2lkZW50LiBJdCBpcyBvcHRpb25hbCBhbmQgaWYgaXQgaXMgbm90IHNwZWNpZmllZCB0aGVcbiAgICAgICAgICAgIHRhcmdldCBTY2VuZSBpcyB0aGUgY3VycmVudCBvbmVcbiAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBvbmUgb2YgXCJhbGwtb3Itbm90aGluZ1wiIC8gXCJrZWVwLXBhc3NpbmdcIlxuICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IGF1dG9HZW5lcmF0ZWQgLSBpZiBzZXQgdG8gdHJ1ZSwgaXQgbWVhbnMgdGhlIEluY2lkZW50IHdhcyBhdXRvIGdlbmVyYXRlZCBieSBhbm90aGVyIGluY2lkZW50IGFuZCBpdCBzaG91bGQgbm90IGV4cG9ydCBpdHNlbGYgb24gZXhwb3J0U3RhdGUgd2l0aCB1bnByb2Nlc3NlZCA9IHRydWVcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2FkZEluY2lkZW50JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEluY2lkZW50KGluY2lkZW50LCBtaWxsaXNlY29uZCwgc2NlbmVJZCkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IFwiYWxsLW9yLW5vdGhpbmdcIjtcbiAgICAgICAgICAgIHZhciBhdXRvR2VuZXJhdGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKG1pbGxpc2Vjb25kIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZsaWN0czogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdtaW51cyBtaWxsaXNlY29uZCB2aW9sYXRpb24nXG4gICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1pbGxpc2Vjb25kID09PSBfQ09OU1QuYXRUaGVFbmRPZlRoZUdyb3VwLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmQgPSB0aGlzLmR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxNaWxsaXNlY29uZCA9IG1pbGxpc2Vjb25kICogMTsgLy8gYSBiYWNrdXAgdmFyaWFibGUgaG9sZGluZyB0aGUgb3JpZ2luYWwgbWlsbGlzZWNvbmQgcGFzc2VkIGFzXG4gICAgICAgICAgICAvLyB0aGlzIG1pZ2h0IGNoYW5nZSBkdXJpbmcgcG90ZW50aWFsIGxlZnQgZXhwYW5zaW9uIG1hbmlwdWxhdGlvblxuXG4gICAgICAgICAgICBpZiAoIXNjZW5lSWQgfHwgc2NlbmVJZCA9PT0gdGhpcy5pZCkge1xuICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgICAgICBpbmNpZGVudCA9IHRoaXMuX3ByZXBhcmVJbmljZGVudEZvckFkZGl0aW9uKGluY2lkZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoYXV0b0dlbmVyYXRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpbmNpZGVudC5hdXRvR2VuZXJhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB3aGVuIGFkZGluZyBoZWFkbGVzcyBDbGlwcyB0byBhIGdyb3VwIHRoYXQgaGFzIGNvbnRleHQgKGVpdGhlciBiZWNhdXNlIGl0J3MgdGhlIGNsaXAgaXRzZWxmIG9yIGJlY2F1c2VcbiAgICAgICAgICAgICAgICAvLyBpdCBiZWxvbmdzIHRvIGEgY2xpcCB0aGF0IGhhcyBjb250ZXh0KSB3ZSBuZWVkIHRvIHJ1biBmbGFzaCB0aGUgbmV3bHkgZW50ZXJlZCBncm91cCdzIGRvbSBzbyBpdCBjcmVhdGVzXG4gICAgICAgICAgICAgICAgLy8gaXRzIGVsZW1lbnRJbmNpZGVudHNcbiAgICAgICAgICAgICAgICB2YXIgZmxhc2hJbmNpZGVudHNET01BZnRlckVudGVyID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5jaWRlbnQuaGFzSW5jaWRlbnRzICYmIGluY2lkZW50LmlzSGVhZGxlc3NDbGlwICYmIHRoaXMuY29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYXNoSW5jaWRlbnRzRE9NQWZ0ZXJFbnRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaW5jaWRlbnQuc2V0UGFyZW50U2NlbmUodGhhdCk7XG5cbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgSW5jaWRlbnQgaXMgZWxpZ2libGUgZm9yIGFkZGl0aW9uXG4gICAgICAgICAgICAgICAgdmFyIGFkZGl0aW9uQ2hlY2sgPSB0aGlzLmNoZWNrQWRkaXRpb24oaW5jaWRlbnQsIG1pbGxpc2Vjb25kLCB0eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoYWRkaXRpb25DaGVjay5yZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRpdGlvbkNoZWNrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRpdGlvbkNoZWNrLmV4ZWN1dGUoKTtcblxuICAgICAgICAgICAgICAgIC8vIGluZGV4aW5nIHN0YXJ0XG4gICAgICAgICAgICAgICAgdGhpcy5pbmNpZGVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpbmNpZGVudC5pZCxcbiAgICAgICAgICAgICAgICAgICAgaW5jaWRlbnQ6IGluY2lkZW50LFxuICAgICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZDogbWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmluY2lkZW50c0J5SWRbaW5jaWRlbnQuaWRdID0gaW5jaWRlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGtleWZyYW1lX3NlY19rZXkgPSBjb25mLmtleWZyYW1lX3NlY19rZXkgKyBtaWxsaXNlY29uZDtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMua2V5ZnJhbWVzLmhhc093blByb3BlcnR5KGtleWZyYW1lX3NlY19rZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMua2V5ZnJhbWVzW2tleWZyYW1lX3NlY19rZXldID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMua2V5ZnJhbWVzW2tleWZyYW1lX3NlY19rZXldW2luY2lkZW50LmlkXSA9IGluY2lkZW50O1xuICAgICAgICAgICAgICAgIHRoaXMuaW5jaWRlbnRzS2V5ZnJhbWVLZXlzW2luY2lkZW50LmlkXSA9IGtleWZyYW1lX3NlY19rZXk7XG4gICAgICAgICAgICAgICAgLy8gaW5kZXhpbmcgZW5kXG5cbiAgICAgICAgICAgICAgICBpbmNpZGVudC5leGVjdXRpb25TcGVlZCA9IHRoaXMuc3BlZWQ7XG5cbiAgICAgICAgICAgICAgICAvLyBzdWJzY3JpYmUgSW5jaWRlbnQgc3RhcnQgb24gdGhlIGxpc3RlbmVyc1xuICAgICAgICAgICAgICAgIC8vIGN1cnJlbnRNaWxsaXNlY29uZDogdGhlIG1pbGxpc2Vjb25kIHRoZSBHcm91cCBpcyBvblxuICAgICAgICAgICAgICAgIC8vIG1pbGxpc2Vjb25kOiB0aGUgbWlsbGlzZWNvbmQgd2Ugc2V0IG91ciBJbmNpZGVudCB0byBnZXQgZXhlY3V0ZWQgb24gdGhlIEdyb3VwJ3MgdGltZWxpbmVcbiAgICAgICAgICAgICAgICB2YXIgZnVuY3QgPSBmdW5jdGlvbiBmdW5jdChjdXJyZW50TWlsbGlzZWNvbmQsIHByZXZpb3VzVGltZVN0YW1wLCBzY2VuZVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmNpZGVudC5zcGVlZCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TWlsbGlzZWNvbmQgPj0gbWlsbGlzZWNvbmQgJiYgY3VycmVudE1pbGxpc2Vjb25kIDw9IG1pbGxpc2Vjb25kICsgaW5jaWRlbnQuZHVyYXRpb24gfHwgaW5jaWRlbnQuc3RhdGUgPT09ICdpZGxlJyAmJiBjdXJyZW50TWlsbGlzZWNvbmQgPiBtaWxsaXNlY29uZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhlbHBlci5sb2coJ2dyZWF0ZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNpZGVudC5wbGF5KHsgc3RhcnRGcm9tOiBjdXJyZW50TWlsbGlzZWNvbmQgLSBtaWxsaXNlY29uZCwgcHJldmlvdXNUaW1lU3RhbXA6IHByZXZpb3VzVGltZVN0YW1wIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRNaWxsaXNlY29uZCA+PSBtaWxsaXNlY29uZCAmJiBjdXJyZW50TWlsbGlzZWNvbmQgPD0gbWlsbGlzZWNvbmQgKyBpbmNpZGVudC5kdXJhdGlvbiB8fCBpbmNpZGVudC5zdGF0ZSA9PT0gJ2NvbXBsZXRlZCcgJiYgY3VycmVudE1pbGxpc2Vjb25kIDwgbWlsbGlzZWNvbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBoZWxwZXIubG9nKCdncmVhdGVyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jaWRlbnQucGxheSh7IHN0YXJ0RnJvbTogY3VycmVudE1pbGxpc2Vjb25kIC0gbWlsbGlzZWNvbmQsIHByZXZpb3VzVGltZVN0YW1wOiBwcmV2aW91c1RpbWVTdGFtcCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmliZShpbmNpZGVudC5pZCwgZnVuY3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0RHVyYXRpb25BZnRlckluY2lkZW50QWRkZWQobWlsbGlzZWNvbmQsIGluY2lkZW50LmR1cmF0aW9uKTtcblxuICAgICAgICAgICAgICAgIGlmIChmbGFzaEluY2lkZW50c0RPTUFmdGVyRW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGluY2lkZW50LmZsYXNoRE9NKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZmFpbGVkQWRkaXRpb25zLmxlbmd0aCA+IDAgJiYgdHlwZSA9PT0gXCJhbGwtb3Itbm90aGluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUluY2lkZW50KGluY2lkZW50LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2lkZW50LnBhcmVudFNjZW5lT2JqZWN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25mbGljdHM6IHJlc3VsdC5mYWlsZWRBZGRpdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBmbGFzaGluZyBpbmNpZGVudCdzIERPTSBwYXNzZXMgbGV0IHRoZSBJbmNpZGVudCBrbm93IHRoYXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0IG5vdyBoYXMgY29udGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jaWRlbnQuX29uR2V0Q29udGV4dE9uY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25BZGRJbmNpZGVudChpbmNpZGVudCwgbWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNhbGNTdGF0ZSh0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmZhaWxlZEFkZGl0aW9ucy5sZW5ndGggPiAwICYmIHR5cGUgPT09ICdrZWVwLXBhc3NpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jaWRlbnQucmVtb3ZlRW10cHlHcm91cHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGhlbHBlci5ub3RpY2UoJ2luY2lkZW50IGFkZGVkJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmxpY3RzOiByZXN1bHQuZmFpbGVkQWRkaXRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5jaWRlbnQuX29uR2V0Q29udGV4dE9uY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQWRkSW5jaWRlbnQoaW5jaWRlbnQsIG1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyLm5vdGljZSgnaW5jaWRlbnQgYWRkZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNpZGVudElkOiBpbmNpZGVudC5pZFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmNpZGVudHNbaV0uaW5jaWRlbnQuaGFzSW5jaWRlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmNpZGVudHNbaV0uaW5jaWRlbnQuYWRkSW5jaWRlbnQoaW5jaWRlbnQsIG1pbGxpc2Vjb25kIC0gdGhpcy5pbmNpZGVudHNbaV0ubWlsbGlzZWNvbmQsIHNjZW5lSWQpLnJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jaWRlbnRJZDogaW5jaWRlbnQuaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIGlmIGl0IHJlYWNoZXMgdGhlIGVuZCBvZiB0aGUgbG9vcCB3aXRob3V0IGhhdmluZyByZXR1cm5lZCB0cnVlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiBmYWxzZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgIEFueSBTY2VuZSBjYW4gcmVjZWl2ZSB0aGUgZWRpdEluY2lkZW50IGNvbW1hbmQgaW4gb3JkZXIgdG8gc2V0IGEgbmV3IHN0YXJ0aW5nIHBvaW50IGZvciBvbmUgb2YgaXRzIG93biBJbmNpZGVudHMgb3IgdG9cbiAgICAgICAgcGFzcyB0aGUgY29tbWFuZCBkZWVwZXIgZG93biB0byBpdHMgY2hpbGRyZW4gU2NlbmVzIHNvIHRoZSBwYXJlbnQgb2YgaXQgY2FuIHRha2UgY2FyZSBvZiBpdC5cbiAgICAgICAgVGhlIEluY2lkZW50IG9iamVjdCBhbmQgaWQgcmVtYWluIHRoZSBzYW1lIGFmdGVyIHRoZSBlZGl0LlxuICAgICAgICBObyBtYXR0ZXIgd2hpY2ggU2NlbmUgdGFrZXMgdGhlIGNvbW1hbmQsIGFsbCBQYXJlbnRzIGdldCBpbmZvbWVkIGFib3V0IHRoZSBlZGl0LlxuICAgICAgICAgSXQgdGFrZXMgdHdvIHBhcmFtczpcbiAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBpZCAtIHRoZSBpZCBvZiB0aGUgaW5jaWRlbnQgdG8gYmUgZWRpdGVkXG4gICAgICAgICBAcGFyYW0ge2ludH0gbmV3bWlsbGlzZWNvbmQgLSB0aGUgbmV3IHBvc2l0aW9uIG9mIHRoZSBJbmNpZGVudCBjb21wYXJlZCB0byB0aGUgdGFyZ2V0IFNjZW5lIHN0YXJ0IChhbmQgbm90IHRvIHRoZSBTY2VuZSBpdCBiZWxvbmdzKVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZWRpdEluY2lkZW50JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVkaXRJbmNpZGVudChpZCwgbmV3bWlsbGlzZWNvbmQpIHtcbiAgICAgICAgICAgIHZhciBleHBhbnNpb25WYWxpZGF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbE1pbGxpc2Vjb25kID0gbmV3bWlsbGlzZWNvbmQgKiAxO1xuXG4gICAgICAgICAgICBpZiAoIWhlbHBlci5pc1N0cmluZyhpZCkpIHtcbiAgICAgICAgICAgICAgICBoZWxwZXIuZXJyb3IoJ2VkaXRJbmNpZGVudCBtZXRob2Qgb2YgR3JvdXAgZXhwZWN0cyBhcyBpdHMgZmlyc3QgYXJndW1lbnQgdGhlIGlkIG9mIHRoZSBJbmNpZGVudCB0byBlZGl0IGluIHN0cmluZyBmb3JtYXQuICcgKyAodHlwZW9mIGlkID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihpZCkpICsgJyBwYXNzZWQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjb25mbGljdHM6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnd3JvbmcgcGFyYW1ldGVyIHR5cGUnXG4gICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuaW5jaWRlbnRzQnlJZFtpZF0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmdNaWxsaXNlY29uZCA9IHRoaXMuZ2V0SW5jaWRlbnRNaWxsaXNlY29uZChpZCk7XG4gICAgICAgICAgICAgICAgdmFyIG1pbGxpc2Vjb25kRGVsdGEgPSBuZXdtaWxsaXNlY29uZCAtIGV4aXN0aW5nTWlsbGlzZWNvbmQ7XG4gICAgICAgICAgICAgICAgLy8gZmlyc3QgY2hlY2sgZm9yIG1pbnVzIGV4cGFuc2lvblxuICAgICAgICAgICAgICAgIGlmIChuZXdtaWxsaXNlY29uZCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIFNjZW5lIGRvZXNuJ3QgaGF2ZSBhIHBhcmVudCB0aGVuIGl0IGlzIHRoZSByb290IGFuZCB0aHVzIGl0IGNhbid0IGV4cGFuZCB0byB0aGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY2hlY2tQYXJlbnRTY2VuZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmxpY3RzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbWludXMgbWlsbGlzZWNvbmQgdmlvbGF0aW9uJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZXhwYW5zaW9uVmFsaWRhdGlvbiA9IHRoaXMucGFyZW50U2NlbmVPYmplY3QuZXhwYW5kU2NlbmVUb1RoZUxlZnQoLW5ld21pbGxpc2Vjb25kLCB0aGlzLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cGFuc2lvblZhbGlkYXRpb24ucmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZsaWN0czogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ21pbnVzIG1pbGxpc2Vjb25kIHZpb2xhdGlvbidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld21pbGxpc2Vjb25kID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gZW5kIG9mIGlmIG1pbGxpc2Vjb25kIDwgMFxuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGVkaXQgaXMgYWxsb3dlZCAodGh1cyB3ZSBjb21lIHRvIHRoYXQgcG9pbnQpIGFuZCB0aGUgb3JpZ2luYWxNaWxsaXNlY29uZCBpcyBsb3dlciB0aGFuIDBcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxNaWxsaXNlY29uZCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBhbmRTdGFydFBvaW50KC1vcmlnaW5hbE1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmluY2lkZW50c0J5SWRbaWRdLnN0b3AoKTtcblxuICAgICAgICAgICAgICAgIHZhciBlZGl0Q2hlY2sgPSB0aGlzLmNoZWNrRWRpdCh0aGlzLmluY2lkZW50c0J5SWRbaWRdLCBtaWxsaXNlY29uZERlbHRhKTtcbiAgICAgICAgICAgICAgICBpZiAoZWRpdENoZWNrLnJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyLmVycm9yKGVkaXRDaGVjayk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHBhbnNpb25WYWxpZGF0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBhbnNpb25WYWxpZGF0aW9uLnVuZG8oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwYW5kU3RhcnRQb2ludChvcmlnaW5hbE1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWRpdENoZWNrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGVkaXRDaGVjay5leGVjdXRlKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZWRpdEluY2lkZW50U3RhcnRSZXN1bHQgPSB0aGlzLmNoYW5nZUluY2lkZW50c1N0YXJ0TWlsbGlzZWNvbmQobmV3bWlsbGlzZWNvbmQsIGlkKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0RHVyYXRpb25BZnRlckluY2lkZW50QWZmZWN0ZWQoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMub25FZGl0SW5jaWRlbnQodGhpcy5pbmNpZGVudHNCeUlkW2lkXSwgZWRpdEluY2lkZW50U3RhcnRSZXN1bHQub2xkTWlsbGlzZWNvbmQsIG5ld21pbGxpc2Vjb25kKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogdHJ1ZSB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmluY2lkZW50c1tpXS5pbmNpZGVudC5oYXNJbmNpZGVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmluY2lkZW50c1tpXS5pbmNpZGVudC5lZGl0SW5jaWRlbnQoaWQsIG5ld21pbGxpc2Vjb25kIC0gdGhpcy5pbmNpZGVudHNbaV0ubWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5yZXN1bHQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IHRydWUgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0Lmhhc093blByb3BlcnR5KCdlcnJvcnMnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSByZXN1bHQucmVzdWx0IGlzIGZhbHNlIGJ1dCBpdCBjb250YWlucyBubyBlcnJvcnMgdGhhdCBtZWFucyB0aGUgSW5jaWRlbnQgd2UncmUgbG9va2luZyBmb3IganVzdCBub3QgYmVsb25nIHRvIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBHcm91cCB3ZSBhcmUgaXRlcmF0aW5nIGluLiBUaG91Z2ggaWYgcmVzdWx0LnJlc3VsdD09ZmFsc2UgJiYgcmVzdWx0Lmhhc093blByb3BlcnR5KCdlcnJvcnMnKSB0aGF0IG1lYW5zIHRoZSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbmNpZGVudCBoYXMgYmVlbiBmb3VuZCBidXQgZWRpdGluZyBpdCByZXN1bHRzIHRvIGVycm9ycy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBpZiBpdCByZWFjaGVzIHRoZSBlbmQgb2YgdGhlIGxvb3Agd2l0aG91dCBoYXZpbmcgcmV0dXJuZWQgdHJ1ZVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogZmFsc2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICBBbnkgU2NlbmUgY2FuIHJlY2VpdmUgdGhlIHJlbW92ZUluY2lkZW50IGNvbW1hbmQgZWl0aGVyIGZvciByZW1vdmluZyBvbmUgb2YgaXRzIG93biBJbmNpZGVudHMgb3IgZm9yIHBhc3NpbmcgdGhlIGNvbW1hbmRcbiAgICAgICAgZGVlcGVyIGRvd24gdG8gaXRzIFNjZW5lcyB0cmVlIGFuZCBoYXZlIHRoZSBJbmNpZGVudCBkZWxldGVkIG5vIG1hdHRlciB0byB3aGljaCBjaGlsZCBTY2VuZSBpdCBiZWxvbmdzXG4gICAgICAgIE5vIG1hdHRlciB3aGljaCBTY2VuZSB0b29rIHRoZSBjb21tYW5kLCBhbGwgcGFyZW50IFNjZW5lcyBnZXQgaW5mb3JtZWRcbiAgICAgICAgIEl0IHRha2VzIGp1c3Qgb25lIGFyZ3VtZW50OlxuICAgICAgICBAcGFyYW0ge3N0cmluZ30gaWQgLSB0aGUgaWQgb2YgdGhlIEluY2lkZW50IHRvIGJlIGRlbGV0ZWRcbiAgICAgICAgQHBhcmFtIHtvYmplY3R9IHByb3BzIC0gaWYgcGFzc2VkIGl0IHN1cHBvcnRzIHRoZSBwcmV2ZW50U2xpcCBrZXkgd2hpY2ggaWYgZmFsc2UgdGhlIGNoYW5uZWwgc2hvdWxkIG5vdCBzbGlwLiBUaGlzIGNhc2UgaXMgZm9yIFxuICAgICAgICAgICAgZmxhc2hET00gb2YgRE9NQXdhcmVJbmNpZGVudHMgd2hlcmUgd2UgaGF2ZSBlbGVtZW50cyBkZWxldGVkIHNvIHNsaXBwaW5nIG9uIHRoZWlyIGxhbmVzIGlzIG5vdCB2YWxpZCBub3IgbmVjZXNzYXJ5XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZW1vdmVJbmNpZGVudCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVJbmNpZGVudChpZCkge1xuICAgICAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaW5jaWRlbnRzQnlJZFtpZF0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVsZXRlQ2hlY2sgPSB0aGlzLmNoZWNrRGVsZXRlKGlkLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgaWYgKGRlbGV0ZUNoZWNrLnJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyLmVycm9yKGRlbGV0ZUNoZWNrKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZUNoZWNrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRlbGV0ZUNoZWNrLmV4ZWN1dGUoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuaW5jaWRlbnRzQnlJZFtpZF0ubGFzdFdpc2goKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluY2lkZW50c0J5SWRbaWRdLnBhcmVudFNjZW5lT2JqZWN0ID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIHZhciBrZXlmcmFtZV9zZWNfa2V5ID0gdGhpcy5pbmNpZGVudHNLZXlmcmFtZUtleXNbaWRdO1xuICAgICAgICAgICAgICAgIC8vT1BUSU1JWkUgZGVsZXRlIGlzIHNsb3cgb24gdjggZW5naW5lIHdlIHNob3VsZCBjaGVjayBpZiB3ZSBjYW4gYWNoaWV2ZSB0aGUgc2FtZSByZXN1bHQgYnkgc2V0dGluZyB0aGUgdmFsdWUgb2YgdGhlIGtleSB0byB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5pbmNpZGVudHNLZXlmcmFtZUtleXNbaWRdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmtleWZyYW1lc1trZXlmcmFtZV9zZWNfa2V5XVtpZF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuaW5jaWRlbnRzQnlJZFtpZF07XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMua2V5ZnJhbWVzW2tleWZyYW1lX3NlY19rZXldKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMua2V5ZnJhbWVzW2tleWZyYW1lX3NlY19rZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5saXN0ZW5lcnNbaWRdOyAvLyBkZWxldGUgdGhlIGxpc3RlbmVyIHRoYXQgbWFuYWdlcyB0aGUgSW5jaWRlbnQncyBleGVjdXRpb25cblxuICAgICAgICAgICAgICAgIHZhciBkZWxldGVkSW5jaWRlbnQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmNpZGVudHNbaV0uaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVkSW5jaWRlbnQgPSB0aGlzLmluY2lkZW50cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0RHVyYXRpb25BZnRlckluY2lkZW50QWZmZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uUmVtb3ZlSW5jaWRlbnQoZGVsZXRlZEluY2lkZW50WzBdKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogdHJ1ZSB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCB0aGlzLmluY2lkZW50cy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmluY2lkZW50c1tfaTJdLmluY2lkZW50Lmhhc0luY2lkZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5jaWRlbnRzW19pMl0uaW5jaWRlbnQucmVtb3ZlSW5jaWRlbnQoaWQpLnJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBpZiBpdCByZWFjaGVzIHRoZSBlbmQgb2YgdGhlIGxvb3Agd2l0aG91dCBoYXZpbmcgcmV0dXJuZWQgdHJ1ZVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogZmFsc2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aGljaCBpcyBwcm92aWRlZCBvbmx5IGJ5IEdyb3VwcyBhY2NlcHRzIGFuIGluY2lkZW50SWQgYW5kIGEgbmV3IGR1cmF0aW9uIGFuZCBcbiAgICAgICAgICogZWRpdHMgdGhlIGR1cmF0aW9uIG9mIHRoZSBjb3JyZXNwb25kaW5nIGluY2lkZW50IGFjY29yZGluZ2x5XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbmNpZGVudElkIC0gdGhlIGlkIG9mIHRoZSBpbmNpZGVudCB0byByZXNpemVcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IG5ld0R1cmF0aW9uIC0gdGhlIG5ldyBkdXJhdGlvbiBvZiB0aGUgaW5jaWRlbnQgaW4gbWlsbGlzZWNvbmRzXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3Jlc2l6ZUluY2lkZW50JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZUluY2lkZW50KGluY2lkZW50SWQsIG5ld0R1cmF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdJbmNpZGVudCA9IHRoaXMuZ2V0SW5jaWRlbnRCeUlkKGluY2lkZW50SWQpO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nSW5jaWRlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IGZhbHNlLCBlcnJvcnM6IFt7IHJlYXNvbjogJ1RoZSBpbmNpZGVudCB3aXRoIGlkICcgKyBpbmNpZGVudElkICsgJyBkb2VzIG5vdCBiZWxvbmcgdG8gdGhlIEdyb3VwIG9yIGFueSBvZiBpdHMgY2hpbGQgR3JvdXBzJyB9XSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nSW5jaWRlbnQucmVzaXplKG5ld0R1cmF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aGljaCBpcyBwcm92aWRlZCBvbmx5IGJ5IEdyb3VwcyBhY2NlcHRzIGFuIGluY2lkZW50SWQgYW5kIGEgbmV3IGF0dHJzIG9iamVjdCBcbiAgICAgICAgICogYW5kIGVkaXRzIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBjb3JyZXNwb25kaW5nIGluY2lkZW50IGFjY29yZGluZ2x5XG4gICAgICAgICAqIElmIHRoZSBhdHRyaWJ1dGUgZWRpdGluZyBlbmRzIHVwIHdpdGggY29uZmxpY3RzIHRoZSBlZGl0IGlzIGRpc2NhcmRlZC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGluY2lkZW50SWQgLSB0aGUgaWQgb2YgdGhlIGluY2lkZW50IHRvIHJlc2l6ZVxuICAgICAgICAgKiBAcGFyYW0ge2ludH0gYXR0cnMgLSB0aGUgbmV3IGF0dHJzIG9mIHRoZSBJbmNpZGVudFxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdlZGl0SW5jaWRlbnRBdHRyaWJ1dGVzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVkaXRJbmNpZGVudEF0dHJpYnV0ZXMoaW5jaWRlbnRJZCwgYXR0cnMpIHtcbiAgICAgICAgICAgIHZhciBkaXJlY3RQYXJlbnQgPSB0aGlzLl9nZXREaXJlY3RQYXJlbnQoaW5jaWRlbnRJZCk7XG4gICAgICAgICAgICBpZiAoZGlyZWN0UGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiBbJ1RoZSBJbmNpZGVudCB3aXRoIGlkICcgKyBpbmNpZGVudElkICsgJyBkb2VzIG5vdCBiZWxvbmcgdG8gdGhlIEdyb3VwIG9yIGFueSBvZiBpdHMgY2hpbGQgR3JvdXBzJ11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRpcmVjdFBhcmVudC5fZWRpdENoaWxkSW5jaWRlbnRBdHRyaWJ1dGVzKGluY2lkZW50SWQsIGF0dHJzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCeSB0aGlzIG1ldGhvZCBhIEdyb3VwIHRyaWVzIHRvIGVkaXQgdGhlIGF0dHJpYnV0ZXMgb2Ygb25lIG9mIGl0cyBjaGlsZHJlbi4gVGhlIHByb2Nlc3MgZ29lcyBhcyBmb2xsb3dzOlxuICAgICAgICAgKiAxLiBUaGUgR3JvdXAgZ2V0cyBhbiBleHBvcnQgb2YgdGhlIEluY2lkZW50J3Mgc3RhdGVcbiAgICAgICAgICogMi4gVGhlIEdyb3VwIGRlbGV0ZXMgdGhlIEluY2lkZW50XG4gICAgICAgICAqIDMuIFRoZSBHcm91cCB0cmllcyB0byBjcmVhdGUgYSBuZXcgSW5jaWRlbnQgd2l0aCB0aGUgc2FtZSBpZCBhcyB0aGUgb2xkIG9uZSBhbmQgd2l0aCB0eXBlPVwiYWxsLW9yLW5vdGhpbmdcIlxuICAgICAgICAgKiA0LmEuIElmIHRoZSBuZXcgSW5jaWRlbnQgZ2V0cyBhZGRlZCBvayBwcm9jZXNzIGZpbmlzaGVzXG4gICAgICAgICAqIDQuYi4gSWYgdGhlIG5ldyBJbmNpZGVudCBkb2Vzbid0IGdldCBhZGRlZCBiZWNhdXNlIG9mIGNvbmZsaWN0cyB0aGUgcHJldmlvdXMgSW5jaWRlbnQgZ2V0cyBiYWNrIGluXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbmNpZGVudElkIC0gdGhlIGlkIG9mIHRoZSBJbmNpZGVudCB0byBlZGl0IGl0cyBhdHRyc1xuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gYXR0cnMgLSB0aGUgbmV3IGF0dHJpYnV0ZXMgb2YgdGhlIEluY2lkZW50XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19lZGl0Q2hpbGRJbmNpZGVudEF0dHJpYnV0ZXMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2VkaXRDaGlsZEluY2lkZW50QXR0cmlidXRlcyhpbmNpZGVudElkLCBhdHRycykge1xuICAgICAgICAgICAgdmFyIGluY2lkZW50VG9FZGl0ID0gdGhpcy5nZXRJbmNpZGVudEJ5SWQoaW5jaWRlbnRJZCk7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdJbmNpZGVudERlZmluaXRpb24gPSBpbmNpZGVudFRvRWRpdC5leHBvcnRTdGF0ZSgpO1xuICAgICAgICAgICAgdmFyIG1pbGxpc2Vjb25kID0gdGhpcy5nZXRJbmNpZGVudE1pbGxpc2Vjb25kKGluY2lkZW50SWQpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVJbmNpZGVudChpbmNpZGVudElkKTtcbiAgICAgICAgICAgIHZhciBuZXdJbmNpZGVudFByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmdJbmNpZGVudERlZmluaXRpb24ucHJvcHMpO1xuICAgICAgICAgICAgdmFyIG5ld0luY2lkZW50ID0gbmV3IGV4aXN0aW5nSW5jaWRlbnREZWZpbml0aW9uLkluY2lkZW50KGF0dHJzLCBuZXdJbmNpZGVudFByb3BzKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmFkZEluY2lkZW50KG5ld0luY2lkZW50LCBtaWxsaXNlY29uZCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXlPbGRJbmNpZGVudCA9IG5ldyBleGlzdGluZ0luY2lkZW50RGVmaW5pdGlvbi5JbmNpZGVudChleGlzdGluZ0luY2lkZW50RGVmaW5pdGlvbi5hdHRycywgbmV3SW5jaWRlbnRQcm9wcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRJbmNpZGVudChteU9sZEluY2lkZW50LCBtaWxsaXNlY29uZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB0cnVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGFydGluZyBmcm9tIGl0c2VsZiBhbmQgZ29pbmcgYWxsIHRoZSB3YXkgZG93biB0byBlYWNoIGFuZCBldmVyeSBsZWFmIG9mIGl0cyB0cmVlIGl0IHN5c3RvbHMvZGlhc3RvbGVzIHRoZVxuICAgICAgICAgKiBJbmNpZGVudHNcbiAgICAgICAgICogQHBhcmFtIHtmbG9hdH0gZHVyYXRpb25GcmFjdGlvbiB0aGUgZnJhY3Rpb24gb2YgdGhlIG5ldyBkdXJhdGlvbiB0byB0aGUgZXhpc3RpbmcgZHVyYXRpb25cbiAgICAgICAgKiovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3N5c3RvbERpYXN0b2xlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN5c3RvbERpYXN0b2xlKGR1cmF0aW9uRnJhY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlZER1cmF0aW9uID0gZHVyYXRpb25GcmFjdGlvbiAqIHRoaXMuZHVyYXRpb247XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VJbmNpZGVudHNTdGFydE1pbGxpc2Vjb25kKHRoaXMuaW5jaWRlbnRzW2ldLm1pbGxpc2Vjb25kICogZHVyYXRpb25GcmFjdGlvbiwgdGhpcy5pbmNpZGVudHNbaV0uaW5jaWRlbnQuaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5jaWRlbnRzW2ldLmluY2lkZW50LnN5c3RvbERpYXN0b2xlKGR1cmF0aW9uRnJhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVEhFIFwiRUFSU1wiIE9GIFRIRSBTQ0VORSBUTyBJVFMgQ0hJTEQgSU5DSURFTlRTXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgICBORVcgU1RBVEUgQ0FMQ1VMQVRJT04gUlVMRVM6XG4gICAgICAgICAgICAgIElmIGEgU2NlbmUgaGFzIGF0IGxlYXN0IG9uZSBjbGlwQmxvY2tpbmdXYWl0aW5nIChtZWFuaW5nIHRoZSBmdWxsIENsaXAgaXMgaGFsdGVkIGF0IHRoZSBtb21lbnQpIHRoZSBTY2VuZeKAmXMgc3RhdGUgd2lsbCBiZSDigJxjbGlwQmxvY2tpbmdXYWl0aW5n4oCdIHVubGVzcyBpdCBpcyB0aGUgQ2xpcCBzbyBpdHMgc3RhdGUgd2lsbCBiZSDigJx3YWl0aW5n4oCdLlxuICAgICAgICAgICAgICBJZiBhIFNjZW5lIGhhcyBhbGwgY2hpbGRyZW4gb24gdGhlIGNvbXBsZXRlZCBzdGF0ZSwgdGhlIFNjZW5lIGhhcyB0aGUgY29tcGxldGVkIHN0YXRlIGFzIHdlbGwuXG4gICAgICAgICAgICAgIElmIGEgU2NlbmUgaGFzIGF0IGxlYXN0IG9uZSBvZiBpdHMgY2hpbGRyZW4gb24gb25lIG9mIHRoZSBmb2xsb3dpbmcgc3RhdGVzOlxuICAgICAgICAgICAgICAgICAgICB3YWl0aW5nICAgICBpdCBoYXMgc3RhcnRlZCBwbGF5aW5nIGFuZCBoYXMgYmVlbiBoYWx0ZWQgaW50ZXJuYWxseVxuICAgICAgICAgICAgICAgICAgICBwbGF5aW5nICAgICBpdCBoYXMgc3RhcnRlZCBwbGF5aW5nXG4gICAgICAgICAgICAgICAgICAgIGlkbGUgICAgICAgICAgICBpdCBoYXMgbm90IGJlZW4gZXhlY3V0ZWQgeWV0XG4gICAgICAgICAgICAgIHRoZSBTY2VuZSBpcyBvbiBwbGF5aW5nIHN0YXRlXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdpbmNpZGVudFN0YXRlQ2hhbmdlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluY2lkZW50U3RhdGVDaGFuZ2UoaWQsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgcHJvcHMpIHtcbiAgICAgICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gJ2NsaXBCbG9ja2luZ1dhaXRpbmcnIHx8IG5ld1N0YXRlID09PSAnc2NlbmVCbG9ja2luZ1dhaXRpbmcnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BzVG9QYXNzID0gcHJvcHM7XG4gICAgICAgICAgICAgICAgcHJvcHNUb1Bhc3MuY2FsbGVySWQgPSBpZDtcbiAgICAgICAgICAgICAgICBpZiAobmV3U3RhdGUgPT09ICdzY2VuZUJsb2NraW5nV2FpdGluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcCBwcm9wYWdhdGlvbiBhcyB0aGlzIHNob3VsZCBvbmx5IGFmZmVjdCB0aGUgU2NlbmUgYW5kIG5vdCBpdHMgcGFyZW50c1xuICAgICAgICAgICAgICAgICAgICBwcm9wcy53YWl0aW5nU3RhdGVOYW1lID0gJ3dhaXRpbmcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLndhaXQocHJvcHNUb1Bhc3MpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuZXdTdGF0ZSA9PT0gJ2NvbXBsZXRlZCcgJiYgdGhpcy5zcGVlZCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBoZWxwZXIubG9nKCdJbmNpZGVudCAnICsgaWQgKyAnIGdvdCBpbnRvIGNvbXBsZXRlZCBzdGF0ZScpO1xuICAgICAgICAgICAgICAgIC8vIGhlbHBlci5sb2coJ0luY2lkZW50ICcgKyB0aGlzLmlkICsgJyB0YWtlcyBjYXJlIG9mIGl0Jyk7XG4gICAgICAgICAgICAgICAgdmFyIGFsbENvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gaGVscGVyLmxvZygnZ29pbmcgdG8gaXRlcmF0ZSBvbiBhbGwgSW5jaWRlbnRzJyk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBoZWxwZXIubG9nKFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgdGhpcy5pbmNpZGVudHNbaV0uaW5jaWRlbnQuaWQgKyAnLnN0YXRlID0gJyArIHRoaXMuaW5jaWRlbnRzW2ldLmluY2lkZW50LnN0YXRlXG4gICAgICAgICAgICAgICAgICAgIC8vICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmluY2lkZW50c1tpXS5pbmNpZGVudC5zdGF0ZSAhPSAnY29tcGxldGVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsQ29tcGxldGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWxsQ29tcGxldGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5ld1N0YXRlID09PSAnaWRsZScgJiYgdGhpcy5zcGVlZCA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBoZWxwZXIubG9nKCdJbmNpZGVudCAnICsgaWQgKyAnIGdvdCBpbnRvIGNvbXBsZXRlZCBzdGF0ZScpO1xuICAgICAgICAgICAgICAgIC8vIGhlbHBlci5sb2coJ0luY2lkZW50ICcgKyB0aGlzLmlkICsgJyB0YWtlcyBjYXJlIG9mIGl0Jyk7XG4gICAgICAgICAgICAgICAgdmFyIF9hbGxDb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIGhlbHBlci5sb2coJ2dvaW5nIHRvIGl0ZXJhdGUgb24gYWxsIEluY2lkZW50cycpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IHRoaXMuaW5jaWRlbnRzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaGVscGVyLmxvZyhcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIHRoaXMuaW5jaWRlbnRzW2ldLmluY2lkZW50LmlkICsgJy5zdGF0ZSA9ICcgKyB0aGlzLmluY2lkZW50c1tpXS5pbmNpZGVudC5zdGF0ZVxuICAgICAgICAgICAgICAgICAgICAvLyApO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmNpZGVudHNbX2kzXS5pbmNpZGVudC5zdGF0ZSAhPSAnaWRsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hbGxDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfYWxsQ29tcGxldGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGluIGNhc2UgdGhlIGNoaWxkIHdhcyBlaXRoZXIgb24gc2NlbmVCbG9ja2luZ1dhaXRpbmcgb3IgY2xpcEJsb2NraW5nV2FpdGluZyBhbmQgbm93IGlzIGNoYW5naW5nXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpdCBjaGVja3MgaWYgYSBibG9jayB3aXRoIHRoZSBwcm92aWRlZCBwcm9wcyBleGlzdHMgb24gaXRzIGJsb2NraW5nV2FpdGluZ3MgYXJyYXlcbiAgICAgICAgICogaWYgaXQgZXhpc3RzIGl0IHJlbW92ZXMgaXQuXG4gICAgICAgICAqIElmIHRoZSByZW1haW5pbmcgYmxvY2tpbmcgd2FpdGluZ3MgYXJlIGVxdWFsIHRvIDAgaXQgcmV0dXJucyB0cnVlIG90aGVyd2lzZSBpdCByZXR1cm5zIGZhbHNlXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3JlbW92ZUJsb2NrJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUJsb2NrKHByb3BzKSB7XG4gICAgICAgICAgICB2YXIgbmV3QmxvY2tpbmdXYWl0aW5ncyA9IFtdO1xuICAgICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYmxvY2tpbmdXYWl0aW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBiV2FpdGluZyA9IHRoaXMuYmxvY2tpbmdXYWl0aW5nc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoYldhaXRpbmcuaWQgPT09IHByb3BzLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ld0Jsb2NraW5nV2FpdGluZ3MucHVzaCh0aGlzLmJsb2NraW5nV2FpdGluZ3NbaV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmJsb2NraW5nV2FpdGluZ3MgPSBuZXdCbG9ja2luZ1dhaXRpbmdzO1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdvVG8gbWV0aG9kIHNob3VsZCBhbHdheXMgYmUgaGFuZGxlZCBieSB0aGUgQ2xpcC4gTm8gb3RoZXIgR3JvdXAgbm9yIEluY2lkZW50IGNhbiBoYW5kbGUgZ29UbyBhbG9uZS5cbiAgICAgICAgICogVGh1cywgaWYgdGhlIEdyb3VwIGlzIG5vdCB0aGUgQ2xpcCBpdCBwYXNzZXMgdGhlIGNvbW1hbmQgdXAuIElmIHRoZSBHcm91cCBpcyB0aGUgQ2xpcCB0aGVuIGl0IGhhbmRsZXMgZ29Ub1xuICAgICAgICAgKiBieSBwYXNzaW5nIHRoZSBjb21tYW5kIHRvIGl0cyBDaGFubmVscy5cbiAgICAgICAgKiovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dvVG8nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ29UbyhtaWxsaXNlY29uZCkge1xuICAgICAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICAgICAgLy8gZmlyc3QgZGVjaWRlIHRoZSBtaWxsaXNlY29uZCB3ZSB3YW50IHRvIGdvVG9cbiAgICAgICAgICAgIGlmIChtaWxsaXNlY29uZCA9PT0gbnVsbCB8fCBtaWxsaXNlY29uZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmQgPSB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgncmVsYXRpdmVUbycpKSB7XG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmQgKz0gdGhpcy5nZXRJbmNpZGVudE1pbGxpc2Vjb25kKHByb3BzLnJlbGF0aXZlVG8pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWlsbGlzZWNvbmQgPiB0aGlzLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmQgPSB0aGlzLmR1cmF0aW9uO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtaWxsaXNlY29uZCA8IDApIHtcbiAgICAgICAgICAgICAgICBtaWxsaXNlY29uZCA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmlzSGVhZGxlc3NDbGlwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9wcy5yZWxhdGl2ZVRvID0gdGhpcy5pZDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnRTY2VuZU9iamVjdC5nb1RvKG1pbGxpc2Vjb25kLCBwcm9wcykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHdoZW4gdGhlIEdyb3VwIGlzIG9uIHRlc3QgbW9kZSAodGhpcy5pc09uVGVzdE1vZGUgPSB0cnVlKSB0aGUgZW11bGF0ZVN0ZXAgbWV0aG9kXG4gICAgICAgICAqIGJlY29tZXMgZnVuY3Rpb25hbC5cbiAgICAgICAgICogVGhlIG1ldGhvZCB0YWtlcyBhcyBpbnB1dCB0aGUgbWlsbGlzZWNvbmRzRGVsdGEgZnJvbSB0aGUgcHJldmlvdXMgdGltZXN0YW1wIGFuZCB0cmlnZ2Vyc1xuICAgICAgICAgKiB0aGUgc3RlcCBmdW5jdGlvbiBwYXNzaW5nIGluIGEgYmFrZWQgdGltZXN0YW1wIHNvIHRoZSBJbmNpZGVudCBiZWhhdmVzIGV4YWN0bHkgYXMgaWYgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBydW5cbiAgICAgICAgICogcGFzc2luZyBhIHRpbWVzdGFtcCB0aGF0IGhhcyBleGFjdGx5IG1pbGxpc2Vjb25kc0RlbHRhIGRpZmZlcmVuY2UgZnJvbSB0aGUgcHJldmlvdXMgb25lXG4gICAgICAgICAqIEBwYXJhbSB7aW50fSBtaWxsaXNlY29uZHNEZWx0YSAtIHRoZSBtaWxsaXNlY29uZHMgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBwcmV2aW91cyB0aW1lc3RhbXAgYW5kIHRoZSBuZXcgb25lXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2VtdWxhdGVTdGVwJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVtdWxhdGVTdGVwKG1pbGxpc2Vjb25kc0RlbHRhKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNPblRlc3RNb2RlKSB7XG4gICAgICAgICAgICAgICAgaGVscGVyLmVycm9yKCdlbXVsYXRlU3RlcCBtZXRob2QgY2FuIG9ubHkgYmUgdXNlZCBvbiB0ZXN0IG1vZGUnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGVwKHRoaXMucnVuVGltZUluZm8ucHJldmlvdXNUaW1lU3RhbXAgKyBtaWxsaXNlY29uZHNEZWx0YSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRJbmNpZGVudCA9IHRoaXMuaW5jaWRlbnRzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZEluY2lkZW50LmluY2lkZW50LnN0YXRlID09PSBcInBsYXlpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRJbmNpZGVudC5pbmNpZGVudC5lbXVsYXRlU3RlcChNYXRoLmFicygodGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQgLSBjaGlsZEluY2lkZW50Lm1pbGxpc2Vjb25kIC0gY2hpbGRJbmNpZGVudC5pbmNpZGVudC5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQpIC8gdGhpcy5zcGVlZCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAvLyBTVEVQIEZVTkNUSU9OXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3N0ZXAnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3RlcCh0aW1lc3RhbXApIHtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcblxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyBzdGFydCBmcm9tIGlzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGVsYXBzZWQgZnJvbSB0aGUgYWN0dWFsIHN0YXJ0aW5nIHBvaW50IG9mIHRoZSBJbmNpZGVudCBjYXVzZWQgbWFpbmx5XG4gICAgICAgICAgICAvLyBieSBDUFUgcGVyZm9ybWFuY2UuIChlYWNoIHJlcXVlc3RBbmltYXRpb25GcmFtZSBjaXJsY2UgZG9lc24ndCBoYXBwZW4gZXZlcnkgb25lIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAvLyBzbyBhbiBJbmNpZGVudCB0aGF0IHdhcyBzdXBwb3NlZCB0byBzdGFydCBvbiBtaWxsaXNlY29uZCAxMDAgb2YgYSBHcm91cCBtaWdodCBnZXQgZmlyZWQgMTAgbWlsbGlzZWNvbmRzIGxhdGVyIHRoYW5cbiAgICAgICAgICAgIC8vIGl0cyBhY3R1YWwgc3RhcnRpbmcgcG9pbnQsIHNvIHR0aCBzdGFydEZyb20gd2lsbCBiZSAxMClcbiAgICAgICAgICAgIGlmIChwcm9wcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0RnJvbSA9IHByb3BzLnN0YXJ0RnJvbTtcbiAgICAgICAgICAgICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KCdzdGFydEZyb20nKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09IFwiZm9yd2FyZHNcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRGcm9tID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RnJvbSA9IHRoaXMuZHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zcGVlZCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5UaW1lSW5mby5wcmV2aW91c1RpbWVTdGFtcCA9IHRpbWVzdGFtcCAtIHN0YXJ0RnJvbSAvIHRoaXMuc3BlZWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5UaW1lSW5mby5wcmV2aW91c1RpbWVTdGFtcCA9IHRpbWVzdGFtcCAtICh0aGlzLmR1cmF0aW9uIC0gc3RhcnRGcm9tKSAvIE1hdGguYWJzKHRoaXMuc3BlZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGluZm9ybUxpc3RlbmVycyA9IGZ1bmN0aW9uIGluZm9ybUxpc3RlbmVycyhwcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGF0Lmxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdG5lciA9IHRoYXQubGlzdGVuZXJzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhwcm9ncmVzcy5taWxsaXNlY29uZHMgKyBsaXN0bmVyLmNhdmFEZWx0YSAtIHRoYXQucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kKSA+IGxpc3RuZXIudGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0bmVyLmZ1bmN0KHByb2dyZXNzLm1pbGxpc2Vjb25kcywgdGltZXN0YW1wLCBoZWxwZXIucm91bmROdW1iZXJUbyhsaXN0bmVyLnJvdW5kVG8pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RuZXIuY2F2YURlbHRhID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RuZXIuY2F2YURlbHRhICs9IE1hdGguYWJzKHByb2dyZXNzLm1pbGxpc2Vjb25kcyAtIHRoYXQucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIGhlbHBlci5sb2coJ2dvdCBpbnRvIHN0ZXAgb24gJyArIHRoaXMuaWQpO1xuICAgICAgICAgICAgaWYgKHRoaXMucnVuVGltZUluZm8uc3RhdGUgIT09ICdwbGF5aW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcHJvZ3Jlc3NTdGVwIGlzIHRoZSBwcm9ncmVzcyBtYWRlIGZyb20gcHJldmlvdXNUaW1lU3RhbXAgYm90aCBpbiBtaWxsaXNlY29uZHMgYW5kIGluIGZyYWN0aW9uIFswIHRvIDFdXG4gICAgICAgICAgICB2YXIgcHJvZ3Jlc3MgPSB7XG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBNYXRoLnJvdW5kKHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kICsgKHRpbWVzdGFtcCAtIHRoaXMucnVuVGltZUluZm8ucHJldmlvdXNUaW1lU3RhbXApICogdGhpcy5zcGVlZCksXG4gICAgICAgICAgICAgICAgZnJhY3Rpb246ICh0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCArICh0aW1lc3RhbXAgLSB0aGlzLnJ1blRpbWVJbmZvLnByZXZpb3VzVGltZVN0YW1wKSAqIHRoaXMuc3BlZWQpIC8gdGhpcy5kdXJhdGlvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGhlbHBlci5ub3RpY2UoYGNhbGN1bGF0aW9uIHByb3BlcnRpZXMgb2YgcHJvZ3Jlc3MgZm9yICR7dGhpcy5pZH1gKTtcbiAgICAgICAgICAgIC8vIGhlbHBlci5sb2coYHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kOiAke3RoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kfSwgdGltZXN0YW1wOiAke3RpbWVzdGFtcH0sIHRoaXMucnVuVGltZUluZm8ucHJldmlvdXNUaW1lU3RhbXA6ICR7dGhpcy5ydW5UaW1lSW5mby5wcmV2aW91c1RpbWVTdGFtcH1gKVxuXG4gICAgICAgICAgICAvLyBoZWxwZXIubG9nKHRoaXMuaWQsIHByb2dyZXNzKTtcblxuICAgICAgICAgICAgaWYgKHByb2dyZXNzLmZyYWN0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25Qcm9ncmVzcygwLCAwKTtcbiAgICAgICAgICAgICAgICBpbmZvcm1MaXN0ZW5lcnMoeyBmcmFjdGlvbjogMCwgbWlsbGlzZWNvbmRzOiAwIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RvbnRUZWxsTWFtYVN0YXRlQ2hhbmdlKCdpZGxlJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RFdmVudCgnc3RhdGUtY2hhbmdlJywgeyBvbGRTdGF0ZTogXCJwbGF5aW5nXCIsIG5ld1N0YXRlOiBcImlkbGVcIiB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMub25Qcm9ncmVzcyhwcm9ncmVzcy5mcmFjdGlvbiwgcHJvZ3Jlc3MubWlsbGlzZWNvbmRzKTtcblxuICAgICAgICAgICAgLy8gaGVscGVyLmxvZyh0aGlzLmlkKTtcbiAgICAgICAgICAgIC8vIGhlbHBlci5sb2codGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgLy8gaGVscGVyLmxvZyh0aGlzLmlkICsgJyBwcm9ncmVzczogJywgcHJvZ3Jlc3MpO1xuICAgICAgICAgICAgLy8gaGFuZGxlIGxpc3RlbmVyc1xuICAgICAgICAgICAgaW5mb3JtTGlzdGVuZXJzKHByb2dyZXNzKTtcblxuICAgICAgICAgICAgdGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQgPSBwcm9ncmVzcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICB0aGlzLnJ1blRpbWVJbmZvLnByZXZpb3VzVGltZVN0YW1wID0gdGltZXN0YW1wO1xuXG4gICAgICAgICAgICAvLyBoZWxwZXIubG9nKHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kKTtcblxuICAgICAgICAgICAgLy8gaGVscGVyLmxvZygndGhpcy5ydW50aW1lSW5mby5zdGF0ZSBvbiAnICsgdGhpcy5pZCArICcgPSAnICsgdGhpcy5ydW5UaW1lSW5mby5zdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RBbmltYUZyYW1lKHRoYXQuc3RlcC5iaW5kKHRoYXQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgU2NlbmUgcmVjZWl2ZXMgdGhpcyBjb21tYW5kIGZyb20gaXRzIGNoaWxyZW4gYW5kIHRoZSBwdXJwb3NlIG9mIGl0IGlzIHRvIGhlbHAgdGhlIGNhbGxlclxuICAgICAgICAgKiBpZGVudGlmeSB0aGUgbWlsbGlzZWNvbmRzIGRlbHRhIG9mIGl0cyBzdGFydCBjb21wYXJlZCB0byB0aGUgcm9vdCBTY2VuZSBvZiBpdC5cbiAgICAgICAgICogSW4gYSBtdWx0aS1sZXZlbCBzaXR1YXRpb24gd2l0aCBTY2VuZXMgd2l0aGluIHNjZW5lcyB0aGUgU2NlbmUgdGhhdCByZWNlaXZlcyB0aGlzIGNvbW1hbmQgbWlnaHQgbm90IG93blxuICAgICAgICAgKiB0aGUgSW5jaWRlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyB0aHJlYWQgZGlyZWN0bHkuIFRoYXQncyB3aHkgd2UgdXNlIHRoZSBleHRyYURlbHRhIGhlbHBpbmcgcGFyYW1ldGVyIHRoYXRcbiAgICAgICAgICogYWN0dWFsbHkgZGVsaXZlcnMgbGV2ZWwgYnkgbGV2ZWwgdGhlIGRlbHRhIG9mIHRoZSB0cmlnZ2VyaW5nIEluY2lkZW50IHdpdGhpbiB0aGUgdHJlZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5jaWRlbnRJZCA9IHRoZSBpZCBvZiB0aGUgY2hpbGQgaW5jaWRlbnQgb2YgdGhlIHNjZW5lIHRoYXQgdHJpZ2VycmVkIHRoZSBtZXRob2RcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IGV4dHJhRGVsdGEgLSB0aGUgZXh0cmEgZGVsdGEgdG8gYWRkIHRvIHRoZSByZXN1bHRcbiAgICAgICAgKiovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldFJvb3RDdXJyZW50TWlsbGlzZWNvbmREZWx0YUZyb21JbmNpZGVudHNTdGFydCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSb290Q3VycmVudE1pbGxpc2Vjb25kRGVsdGFGcm9tSW5jaWRlbnRzU3RhcnQoaW5jaWRlbnRJZCkge1xuICAgICAgICAgICAgdmFyIGV4dHJhRGVsdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG5cbiAgICAgICAgICAgIC8vIGZpcnN0IHN0ZXAgZmluZCB0aGUgc3RhcnQgbWlsbGlzZWNvbmQgb2YgdGhlIGluY2lkZW50XG4gICAgICAgICAgICB2YXIgaW5jaWRlbnRNaWxsaXNlY29uZCA9IHRoaXMuZ2V0SW5jaWRlbnRNaWxsaXNlY29uZChpbmNpZGVudElkKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5jaGVja1BhcmVudFNjZW5lKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQgLSBpbmNpZGVudE1pbGxpc2Vjb25kIC0gZXh0cmFEZWx0YTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50U2NlbmVPYmplY3QuZ2V0Um9vdEN1cnJlbnRNaWxsaXNlY29uZERlbHRhRnJvbUluY2lkZW50c1N0YXJ0KHRoaXMuaWQsIGluY2lkZW50TWlsbGlzZWNvbmQgKyBleHRyYURlbHRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qXG4gICAgICAgIENBTExCQUNLUyBBRlRFUiBTVUNDRVNTRlVMIEFERElORyAvIEVESVRJTkcgLyBERUxFVElORyBBTiBJTkNJREVOVFxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnb25BZGRJbmNpZGVudCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkFkZEluY2lkZW50KGluY2lkZW50LCBtaWxsaXNlY29uZCkge31cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ29uRWRpdEluY2lkZW50JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uRWRpdEluY2lkZW50KGluY2lkZW50LCBvbGRNaWxsaXNlY29uZCwgbmV3TWlsbGlzZWNvbmQpIHt9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdvblJlbW92ZUluY2lkZW50JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uUmVtb3ZlSW5jaWRlbnQoaW5jaWRlbnQpIHt9XG5cbiAgICAgICAgLy8gb24gR3JvdXBzIHRoZXJlIGlzIG5vIG5lZWQgdG8gcHJldmVudCByZS1pbnZva2luZyB0aGUgb25HZXRDb250ZXh0IG1ldGhvZFxuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfb25HZXRDb250ZXh0T25jZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25HZXRDb250ZXh0T25jZSgpIHtcbiAgICAgICAgICAgIHRoaXMub25HZXRDb250ZXh0KCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmNpZGVudHNbaV0uaW5jaWRlbnQuX29uR2V0Q29udGV4dE9uY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZHVyYXRpb24nLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGN1bGF0ZWREdXJhdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZHVyYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlZER1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dyb3VwVHlwZScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIFwicGxhaW5cIjtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncHJvamVjdGVkSW5jaWRlbnRzJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQcm9qZWN0ZWRJbmNpZGVudHMoKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZXhlY3V0aW9uU3BlZWQnLFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChzcGVlZCkge1xuICAgICAgICAgICAgaGVscGVyLm5vdGljZSh0aGlzLmlkICsgJyBpcyBzZXR0aW5nIGl0cyBleGVjdXRpb24gc3BlZWQgdG86ICcgKyBzcGVlZCArICcgd2hpbGUgb24gbWlsbGlzZWNvbmQ6ICcgKyB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCk7XG4gICAgICAgICAgICBpZiAoc3BlZWQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBoZWxwZXIuZXJyb3IoXCJTcGVlZCBjYW4ndCBiZSAwXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zcGVlZCA9IHNwZWVkO1xuICAgICAgICAgICAgdGhpcy5vblNwZWVkQ2hhbmdlKHNwZWVkKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluY2lkZW50c1tpXS5pbmNpZGVudC5leGVjdXRpb25TcGVlZCA9IHNwZWVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEdyb3VwO1xufShUaW1lZEluY2lkZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcm91cDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Group.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Incident.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Incident.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Helper = __webpack_require__(/*! ../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar checkTransition = __webpack_require__(/*! ../configuration/allowedStateChanges */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/allowedStateChanges.js\").checkTransition;\nvar helper = new Helper();\nvar Channel = __webpack_require__(/*! ../_Channels/Channel */ \"./node_modules/@kissmybutton/motorcortex/dist/_Channels/Channel.js\");\nvar pipeMessges = __webpack_require__(/*! ../configuration/pipesConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/pipesConf.js\");\nvar generalConf = __webpack_require__(/*! ../configuration/generalConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\n\n/** @classdesc\n * Incidents are all events that should happen on a specific time on the timeline. An incident can have parametric\n      execution behaviour based on the times it has been executed and (might be) on other parameters.\n\n      The state an Incident can have is one of the following:\n                 idle\n                 playing\n                 waiting\n                 sceneBlockingWaiting\n                 clipBlockingWaiting\n                 blocked    // in the case the Incident is blocked / paused by a waiting\n                 completed\n\n      Each Incident has the obligation to inform the Scene about its state changes.\n      For this Incident provides the method setParentScene which takes just one argument a Timer object.\n      Timer provides the method incidentStateChange which lets the Incidents change their state by\n      providing their id and their new state.\n * */\n\nvar Incident = function () {\n    /**\n     It takes just one argument, \"props\". Props pass data useful only for the following:\n     An incident can be set to be either inexhaustible (meaning it can be executed again and again infinite times -- default)\n     or finite meaning it can only be executed a limited (specific) number of times. This info can be found on the maxLifeCycles\n     Of course the incident can be reset to its initial condition at any time through the \"reset\" method it provides.\n      As a luxuriousness, and along WITH the maxLifeCycles parameter, the Incident also provides the executionPattern parameter\n     through which the programmer / user can define a more complex behaviour of the Incident execution depending on the number times\n     the incident has alrady be executed ( is the 1st time, the 2nd time, the 3rd time etc) and any custom parameter it\n     holds. The execution times are held on the \"executionTimes\" attribute of the class.\n      props:\n     {\n        id: if passed that's the id of the Incident. If not we create a new one\n        plugin_channel_class - if passed gets set to it\n        mc_plugin_npm_name - if passed gets set to it\n        \n     }\n        @param {object} props */\n    function Incident() {\n        var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        _classCallCheck(this, Incident);\n\n        this.attrs = attrs;\n        this.props = props;\n\n        // auto-generated id. This parameter indicates whether the id of the Incident was given by the user or \n        // it was auto-generated by MC. Auto-generated ids do not get checked for duplicates on checkAddition \n        // process, for the shake of performance\n        this.autoGeneratedID = false;\n        if (!props.hasOwnProperty('id') && props.autogeneratedID != true) {\n            this.autoGeneratedID = true;\n        }\n        this.id = props.id || helper.getAnId();\n\n        // this parameter is initialised to false. Once the onGetContext method gets invoked this parameter\n        // is set to true so we prevent multiple executions of the onGetContext method\n        this.gotContext = false;\n\n        /*\n        these are the default values that define channeling for the default Incidents. These values get ovewriden through\n        the loadPlugin method of MC with the values found on the main.js file of the plugin\n        */\n        this.plugin_channel_class = Channel;\n        this.mc_plugin_npm_name = \"motor-cortex-js\";\n        if (props.hasOwnProperty('plugin_channel_class')) {\n            this.plugin_channel_class = props.plugin_channel_class;\n        }\n        if (props.hasOwnProperty('mc_plugin_npm_name')) {\n            this.mc_plugin_npm_name = props.mc_plugin_npm_name;\n        }\n\n        /* \n        The following two properties (\"statusBeforeHalt\" and \"stateBeforeStop\") which have stupidly \n        used \"status\" in the one case and \"state\" in the other\n        act as the memory of the Incident in the case of a stop or\n        a halting command (wait or block), storing the state of it just before any of the two get \n        executed. \n        These properties can be used in various ways in the program\n        and they do not target specific functionality.\n        */\n        // the status of the Incident before it got halted by either the block or the wait command\n        this.statusBeforeHalt = 'idle';\n        // holds the state of the Incident before the stop command\n        this.stateBeforeStop = 'idle';\n\n        this.timesExecuted = 0;\n        this.parentSceneObject = null;\n\n        this.runTimeInfo = {\n            state: 'idle' // one of \"idle\", \"playing\", \"waiting\"\n        };\n\n        this.bitIncident = true;\n        this.hasIncidents = false;\n\n        /* an array holding all  */\n        this.eventsSubscriptions = {};\n\n        /*\n        Right now many keys of the Incident (such as \"props\", \"attrs\", etc) are already been used by the Incident \n        class. The final users of the library (the plugin developers) might want to keep special / specific data\n        on their Incidents and:\n        a) they might don't know which keys are already taken and which are not\n        b) might use an already used key and ruin the functionality\n        c) so they feel unsafe keeping data and it's not safe for the lib too\n        For this reason we have a blank object reserved for them, the \"customParams\", in order for them to \n        put anything they want and we encourage them to use the built-in methods:\n        setParam\n        getParam\n        setParams\n        for this job\n        */\n        this.customParams = {};\n\n        this.speed = 1;\n\n        /*\n        initialValues is an object holding the autmatically computed initial values of the animatedAttrs \n        (if any). The initialValues are calculated by the AttributesChannel (only Incidents belonging to \n        an AttributesChannel have initialValues).\n        The keys set of this object is identical to the object attrs.animatedAttrs \n        The only thing the generic AttributesChannel can't calculate is the initial value of an animated attr\n        of a specific element when there are no other Incidents entered on its lanes yet. These values are\n        the \"scratchValues\" and they are strongly dependend on the nature of the lib. E.g. for a CSS animation\n        what we are looking for can be found on the computedStyle.\n        */\n        this.initialValues = {};\n\n        /*\n        The user has the ability to explicitely define the initial values for any of the animatedAttrs. The user\n        can do that by providing the initialValues object on the attrs of the constructor.\n        */\n        this.userDefinedInitialValues = {};\n        if (attrs != null && attrs != undefined) {\n            if (attrs.hasOwnProperty('initialValues')) {\n                this.userDefinedInitialValues = attrs.initialValues;\n            }\n        }\n\n        /*\n        blockingWaitings is an array, a collection, of blocing waitings that have the Scene as target.\n        The logic is simple:\n        - if the scene receives a \"sceneBlockingWaiting\" then it is the target and it adopts it\n        - if the scene receives a \"channelBlockingWaiting\" then if it is a channel it adopts it otherwise it tries to\n            pass it further up until it finds a channel\n        - if the scene receives a \"clipBlockingWaiting\" if it is the Clip it adopts it otherwise it tries to pass it\n            further up until it reaches the clip\n        Each object on this array represents a blocking waiting triggered by a child of the Scene\n            and which targets the Scene itself.\n        Each child signs the blocking waiting by assigning its own id to it. Each child can only assign just one\n            blocking waiting at a time.\n        The structure of each blocking waiting appearing on this array is the following:\n        {\n            id: the-signature-of-the-triggering-incident,\n            type: any of the sceneBlockingWaiting / channelBlockingWaiting / ClipBlockingWaiting,\n            nature: any of the scheduled / dynamic / system-problem\n        }\n        */\n        this.blockingWaitings = [];\n\n        /**\n        * @member {boolean} - if testingMode is set to true the requestAnimationFrame method is not going\n        * to get executed automatically but instead the emaulateStep method will start functioning allowing\n        * developers to pass the milliseconds difference from the previous timestamp manually\n        **/\n        this.testMode = false;\n        if (props.hasOwnProperty('testMode')) {\n            this.testMode = props.testMode;\n        }\n\n        if (props.hasOwnProperty('initialValues')) {\n            this.initialValues = props.initialValues;\n        }\n\n        /**\n         * @member {boolean} - if autoGenerated is set to true, it means that this Incident has been auto-generated by its parent on initialisation.\n         * This happens when plugins export Incidents that on initialisation they automatically create other incidents and automatically put them \n         * on specific points on their timeline. \n         * In such cases we don't want these Incidents to be exported on getState with unprocessed = true and this because they will be re-generated\n         * automatically on the clip's reconstruction process based on the exported json. \n        */\n        this.autoGenerated = false;\n\n        this.onInitialise(attrs, props);\n    }\n\n    _createClass(Incident, [{\n        key: 'getScratchValue',\n\n\n        /**\n        This method shoudl be overwritten by the Incidents of the plugins. The method accepts\n        as arguments the mcid (an element) and the attribue (one of the animatedAttrs, if any)\n        and return the initial value of them as the library calculates / defines them. The \n        returned value represents the very initial value of the element's attribute before\n        any Incident that alters it gets added.\n        @param {string} mcid\n        @param {string} attribute\n        @returns {mixed} - the initial value of the element's attribute just when the HTML & CSS\n        of the Clip gets rendered\n        */\n        value: function getScratchValue(mcid, attribute) {\n            return 0;\n        }\n    }, {\n        key: 'getElementAttribute',\n        value: function getElementAttribute(attr) {\n            return this.element.getAttribute(attr);\n        }\n    }, {\n        key: 'getElementByMCID',\n        value: function getElementByMCID(mcid) {\n            if (this.context === null) {\n                return null;\n            }\n\n            return this.context.getElementByMCID(mcid);\n        }\n    }, {\n        key: 'flashDOM',\n        value: function flashDOM() {\n            return {\n                failedAdditions: []\n            };\n        }\n    }, {\n        key: 'turnIncidentToMC',\n        value: function turnIncidentToMC() {\n            this.plugin_channel_class = Channel;\n            this.mc_plugin_npm_name = \"motor-cortex-js\";\n        }\n    }, {\n        key: 'resetState',\n        value: function resetState() {}\n    }, {\n        key: 'getIncidentsByChannel',\n\n\n        /**\n         * Returns an object that has the key of the npm plugin name the Channel of which manages the specific Incident\n        */\n        value: function getIncidentsByChannel() {\n            var adjustMillisecond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n            var incidentsByPlugin = {};\n            var keyToUse = this.mc_plugin_npm_name;\n            if (this.bypassChannel === true) {\n                keyToUse = 'motor-cortex-js';\n            }\n            incidentsByPlugin[keyToUse] = [{\n                millisecond: adjustMillisecond,\n                incident: this,\n                id: this.id\n            }];\n            return incidentsByPlugin;\n        }\n    }, {\n        key: 'setParam',\n        value: function setParam(param, value) {\n            this.customParams[param] = value;\n        }\n    }, {\n        key: 'getParam',\n        value: function getParam(param) {\n            return this.customParams[param];\n        }\n    }, {\n        key: 'setParams',\n        value: function setParams() {\n            var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            this.customParams = params;\n        }\n\n        /** *************************************************\n        HELPER FUNCTIONS\n        checks if the parent Scene object has been defined */\n\n    }, {\n        key: 'checkParentScene',\n        value: function checkParentScene() {\n            if (this.parentSceneObject === null) {\n                return false;\n            } else {\n                return true;\n            }\n        }\n    }, {\n        key: 'checkStateTransition',\n        value: function checkStateTransition(targetState) {\n            // we prevent play (and thus any other transition) in cases the Incident has no parent\n            // group. The method changes on Group\n            if (this.checkParentScene()) {\n                if (checkTransition(this.runTimeInfo.state, targetState, this.direction)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }, {\n        key: '_hasUserDefinedInitialValue',\n        value: function _hasUserDefinedInitialValue(attr) {\n            return this.userDefinedInitialValues.hasOwnProperty(attr);\n        }\n    }, {\n        key: '_getUserDefinedInitialValue',\n        value: function _getUserDefinedInitialValue(attr) {\n            return this.userDefinedInitialValues[attr];\n        }\n    }, {\n        key: 'setInitialValue',\n        value: function setInitialValue(attr, value) {\n            if (this._hasUserDefinedInitialValue(attr)) {\n                helper.notice('Incident with id ' + this.id + ' has initial value defined for ' + attr + ' and no change is allowed on it');\n                return;\n            }\n            this.initialValues[attr] = value;\n        }\n    }, {\n        key: 'hasInitialValue',\n        value: function hasInitialValue(attr) {\n            return this._hasUserDefinedInitialValue(attr) || this.initialValues.hasOwnProperty(attr);\n        }\n    }, {\n        key: 'getInitialValue',\n        value: function getInitialValue(attr) {\n            if (this._hasUserDefinedInitialValue(attr)) {\n                return this._getUserDefinedInitialValue(attr);\n            }\n            return this.initialValues[attr];\n        }\n    }, {\n        key: 'setParentScene',\n        value: function setParentScene(parentSceneObject) {\n            this.parentSceneObject = parentSceneObject;\n        }\n\n        /* *************************************************\n        STATE CHANGING FUNCTION\n        method from which we can set the state of the Incident.\n        this method should never be invoked directly from code outside the core definition of Incident. All state changes\n        should occur through the corresponding built-in functions (play, wait, etc) */\n\n    }, {\n        key: '_setState',\n        value: function _setState(state) {\n            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n            var oldState = this.runTimeInfo.state;\n            this.runTimeInfo.state = state;\n\n            if (this.checkParentScene() && state === 'completed' && this.speed > 0) {\n                this.parentSceneObject.incidentStateChange(this.id, oldState, state, props);\n            } else if (this.checkParentScene() && state === 'idle' && this.speed < 0) {\n                this.parentSceneObject.incidentStateChange(this.id, oldState, state, props);\n            }\n\n            var newState = state;\n            if ((state === 'waiting' || state === 'blocked') && props.waitingStateName != 'waiting') {\n                newState = props.waitingStateName;\n            }\n            this.broadcastEvent('state-change', { oldState: oldState, newState: newState });\n        }\n    }, {\n        key: 'setCurrentMillisecond',\n        value: function setCurrentMillisecond(millisecond) {\n            this.runTimeInfo.currentMillisecond = millisecond;\n        }\n\n        /**\n         * sets the state of the Incident silently without broadcasting the event nor informing the parent Incident\n         */\n\n    }, {\n        key: '_dontTellMamaStateChange',\n        value: function _dontTellMamaStateChange(state) {\n            if (this.checkStateTransition(state)) {\n                // helper.log('setting state of ' + this.id + ' to ' + state);\n                var oldState = this.runTimeInfo.state;\n                this.runTimeInfo.state = state;\n                this.broadcastEvent('state-change', { oldState: oldState, newState: state });\n            }\n        }\n\n        /** *************************************************\n        EXECUTION FUNCTIONS\n        sets state to \"playing\" */\n\n    }, {\n        key: 'play',\n        value: function play() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            if (!this.onBeforePlay(props)) {\n                return false;\n            }\n            if (!this.checkStateTransition('playing')) {\n                return false;\n            }\n\n            this.timesExecuted += 1;\n            this.onPlay(props);\n            this._setState('playing');\n\n            if (this.bitIncident) {\n                this.complete();\n            }\n            return true;\n        }\n\n        /**\n         wait method can be invoked by the object itself or by its parent Scene. No children are allowd to call the wait\n         method.\n          the nature of a waiting might be:\n             - scheduled    *                               default\n             - dynamic\n             - system-error\n          the waitingStateName of a waiting can be:\n             - waiting *                                    default\n             - sceneBlockingWaiting\n             - clipBlockingWaiting\n          An Incident can only exit waiting mode through the resume method\n          */\n\n    }, {\n        key: 'wait',\n        value: function wait(props) {\n            if (!props.waitingStateName) {\n                props = { nature: 'scheduled', waitingStateName: 'waiting' };\n            }\n\n            if (!this.checkStateTransition('waiting')) {\n                return false;\n            }\n\n            this.statusBeforeHalt = this.runTimeInfo.state;\n            this._setState('waiting', props);\n            this.onWait(props);\n            return true;\n        }\n    }, {\n        key: 'unblock',\n        value: function unblock() {\n            if (this.statusBeforeHalt === 'playing') {\n                this.resume();\n            }\n        }\n\n        /**\n         block and unblock methods can only be invoked by a parent of the Incident. No children (in the case of a Scene) nor\n         the Incident itself can block or unblock itself.\n          */\n\n    }, {\n        key: 'block',\n        value: function block() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            if (!this.checkStateTransition('blocked')) {\n                return false;\n            }\n\n            this.statusBeforeHalt = this.runTimeInfo.state;\n            this._setState('blocked', props);\n            this.onBlock(props);\n            return true;\n        }\n    }, {\n        key: 'resume',\n        value: function resume() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            if (!this.onBeforeResume(props)) {\n                return false;\n            }\n            if (!this.checkStateTransition(this.statusBeforeHalt)) {\n                return false;\n            }\n\n            this.onResume(props);\n            this._setState(this.statusBeforeHalt);\n\n            return true;\n        }\n    }, {\n        key: 'reset',\n        value: function reset() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            // this.stop();\n            if (!this.checkStateTransition('idle')) {\n                return false;\n            }\n\n            this.blockingWaitings = [];\n\n            this.timesExecuted = 0;\n            this._setState('idle');\n            this.onReset(props);\n            return true;\n        }\n    }, {\n        key: 'complete',\n        value: function complete() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            if (this.speed > 0) {\n                if (!this.checkStateTransition('completed')) {\n                    return false;\n                }\n            } else {\n                if (!this.checkStateTransition('idle')) {\n                    return false;\n                }\n            }\n\n            this.onBeforeComplete(props);\n\n            if (this.speed > 0) {\n                this._setState('completed');\n            } else {\n                this._setState('idle');\n            }\n\n            if (this.speed > 0) {\n                this.runTimeInfo.currentMillisecond = this.duration;\n            } else {\n                this.runTimeInfo.currentMillisecond = 0;\n            }\n\n            return true;\n        }\n    }, {\n        key: 'stop',\n        value: function stop() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            if (!this.checkStateTransition('transitional')) {\n                return false;\n            }\n\n            this.blockingWaitings = [];\n\n            this.stateBeforeStop = this.state + \"\";\n            this._setState('transitional');\n            this.onStop(props);\n            return true;\n        }\n\n        /**\n         * Restores the execution of the Incident after a stop\n        **/\n\n    }, {\n        key: 'restore',\n        value: function restore() {\n            if ((this.state === 'waiting' || this.state === 'blocked') && this.stateBeforeStop === 'playing') {\n                this.resume();\n            }\n        }\n    }, {\n        key: 'arm',\n        value: function arm() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            if (!this.checkStateTransition('waiting')) {\n                return false;\n            }\n\n            this.blockingWaitings = [];\n\n            this._dontTellMamaStateChange('waiting');\n            this.onArm(props);\n            return true;\n        }\n\n        /**\n         * There are various events happening on the scope of an Incident. Any class extending Incident might have / define its own\n         * events.\n         *\n         * The \"broadcastEvent\" method of the Incident allows the Incident (of any type, even on classes extending it) broadcast\n         * events on any of the interested parties that have subscribed to it.\n         *\n         * The \"subscribeToEvents\" method allows any third party subscribe and listen to events' broadcasts by any Incident\n         *\n         * @param {string} id - the unique id of the event listener\n         * @param {function} fnct - a function to get executed whenever an event gets broadcasted by the specific Incident. The\n         *  fnct will be executed on all events' broadcasts and it will receive the event object as argument. The event object is\n         *  of format:\n         *  {\n                name: the name of the event,\n                meta: an object holding all the meta-info of the event\n            }\n         }\n        */\n\n    }, {\n        key: 'subscribeToEvents',\n        value: function subscribeToEvents(id, fnct) {\n            this.eventsSubscriptions[id] = fnct;\n        }\n\n        /**\n         * unsubscribes any subscribed listener to the Incident's events broadcasting\n         * @param {string} id\n         */\n\n    }, {\n        key: 'unsubscribeFromEvents',\n        value: function unsubscribeFromEvents(id) {\n            if (this.eventsSubscriptions[id]) {\n                delete this.eventsSubscriptions[id];\n            }\n        }\n\n        /**\n         * broadcasts any event\n         * @param {string} eventName\n         * @param {object} meta\n         */\n\n    }, {\n        key: 'broadcastEvent',\n        value: function broadcastEvent(eventName, meta) {\n            for (var key in this.eventsSubscriptions) {\n                this.eventsSubscriptions[key](eventName, meta);\n            }\n        }\n\n        /**\n         * This method's (which should be called whenever a slip ends) purpose is to calculate and set\n         * the right state of the Incident based on the target millisecond.\n         * The parameter it takes is relative to the beginning of the Incident itself and it might be negative\n         * Negative targetMillisecond means the target millisecond is N milliseconds BEFORE the start of the Incident\n         * @param {int} targetMillisecondDeltaFromStart - the delta of the target millisecond compared to the Incident start\n         */\n\n    }, {\n        key: 'recalcState',\n        value: function recalcState(targetMillisecondDeltaFromStart) {\n            if (targetMillisecondDeltaFromStart >= 0) {\n                // if it ends before the target millisecond\n                this._dontTellMamaStateChange('completed');\n            } else {\n                // if it has been completed on targetMillisecond\n                this._dontTellMamaStateChange('idle');\n            }\n        }\n    }, {\n        key: 'resize',\n        value: function resize(duration) {\n            this.systolDiastole(duration / this.duration);\n            return { result: true };\n        }\n    }, {\n        key: 'systolDiastole',\n        value: function systolDiastole(durationFraction) {\n            return true;\n        }\n    }, {\n        key: 'exportState',\n        value: function exportState() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            var toExport = {\n                id: this.id,\n                duration: this.duration,\n                class: this.constructor.name,\n                mc_plugin_npm_name: this.mc_plugin_npm_name,\n                customParams: this.customParams,\n                attrs: Object.assign({}, this.attrs),\n                props: Object.assign({ id: this.id, autogeneratedID: true }, this.props)\n            };\n\n            var exportType = 'live';\n            if (props.hasOwnProperty('type')) {\n                if (props.type === \"json\") {\n                    toExport.initialValues = this.initialValues;\n                    exportType = 'json';\n                }\n            }\n\n            if (exportType === 'live') {\n                toExport.plugin_channel_class = this.plugin_channel_class;\n                toExport.state = this.state;\n                toExport.Incident = this.constructor;\n            }\n\n            return toExport;\n        }\n\n        // *************************************************\n        /* PIPES SYSTEM\n            The Pipes system is a vertical interconnection system that runs out the full Incidents tree and connects all of them.\n            Through Pipes any Incident can communicate anything to all of its children or parents.\n            \n            In order to initialise a pipe message the user should use the putMessageOnPipe method. This method is exposed by all\n                Incidents, of all types, and it is first been processed by the receiver Incident and then passed further down to\n                its children (if any).\n            This method takes exactly 5 arguments:\n            - name (the name of the command). This should be unique among the full MC ecosystem including native message names & \n                plugins' message names. In order to avoid conflicts is good to use the convention: <plugin_npm_name>.<message_name>\n            - parameters (an object holding the parameters of the command)\n            - selfExecute (true/false) - If true the Incident will try to process the pipe command before further passing further up or down\n            - direction (default \"down\") - defines the direction of the pipe command. It can be either \"down\" so it passes it down to \n                its children or \"up\" so it passes it up to its parents\n            - target. The target defines / describes the receivers of the pipe message. This might be:\n                - null (default) - targets all incidents\n                - type: \"group\" - targets only groups (including clips)\n                - type: \"clip\" - targets only clips\n                - type: \"rootClip\" - targets only the root clip of the tree\n                - id: \"<id>\" - targets a specific incident with specific id\n                - plugin: \"<plugin_npm_name>\" - targets only Incidents of a specific plugin\n            \n            Handling pipe messages:\n            The putMessageOnPipe method decides whether it should be processed or\n            not by the Incident depending on the target. This method is the _processPipeMessage. If the Incident should process the \n            pipe message the _processPipeMessage method calls the \"handlePipeMessage\" method passing the name and the parameters.\n            The \"handlePipeMessage\" is a built in method as well and the developers should just overwrite it so they handle the \n            various pipes messages based on their names.\n            \n            Pipe messages targeting the clip return a result.\n        */\n\n    }, {\n        key: 'putMessageOnPipe',\n        value: function putMessageOnPipe(name, params, selfExecute, direction) {\n            var target = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\n            if (selfExecute) {\n                if (target === null) {\n                    this.handlePipeMessage(name, params);\n                } else {\n                    if (target.hasOwnProperty('type')) {\n                        if (target.type === 'group' && this.hasIncidents) {\n                            this.handlePipeMessage(name, params);\n                        } else if (target.type === 'clip' && this.isTheClip) {\n                            this.handlePipeMessage(name, params);\n                        } else if (target.type === \"rootClip\" && this.isTheClip && !this.checkParentScene()) {\n                            return this.handlePipeMessage(name, params);\n                        }\n                    } else if (target.hasOwnProperty('id')) {\n                        if (this.id === target.id) {\n                            this.handlePipeMessage(name, params);\n                            return;\n                        }\n                    } else if (target.hasOwnProperty('plugin')) {\n                        if (this.mc_plugin_npm_name === target.plugin) {\n                            this.handlePipeMessage(name, params);\n                        }\n                    }\n                }\n            }\n\n            if (direction === \"down\" && this.hasIncidents) {\n                for (var i = 0; i < this.incidents.length; i++) {\n                    this.incidents[i].incident.putMessageOnPipe(name, params, true, direction, target);\n                }\n            } else if (direction === \"up\" && this.checkParentScene()) {\n                this.parentSceneObject.putMessageOnPipe(name, params, true, direction, target);\n            }\n        }\n    }, {\n        key: 'handlePipeMessage',\n        value: function handlePipeMessage(name, params) {}\n        // Plugins developers can overwrite this method so they can handle pipe messages per name\n\n\n        // *************************************************\n        /* BLOCKING WAITINGS\n        The triggerBlockingWatiing method that can be used by any Incident at any time. The Incident can trigger a blocking waiting. \n        The \"blocking waitings\" block the root Clip's execution (puts it to blocked state). \n        Any blocking waiting has an id (it must be unique) and it can be unblocked by any Incident at any time through the triggerUnblock\n        method which takes an id and removes the corresponding blocking waiting. \n        */\n\n    }, {\n        key: 'triggerBlockingWatiing',\n        value: function triggerBlockingWatiing(id) {\n            var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n            params.blockingWaitingID = id;\n            this.putMessageOnPipe(pipeMessges._BLOCKING_WAITING, params, true, \"up\", { type: 'rootClip' });\n        }\n    }, {\n        key: 'triggerUnblock',\n        value: function triggerUnblock(id) {\n            var params = {\n                blockingWaitingID: id\n            };\n            this.putMessageOnPipe(pipeMessges._UNBLOCK_WAITING, params, true, \"up\", { type: 'rootClip' });\n        }\n\n        // *************************************************\n        // ACTUAL BAHAVIOUR FUNCTIONS THAT SHOULD BE IMPLEMENTED BY ALL CLASSES EXTENDING INCIDENT\n        // this is a chance to block play of an incident by returning false\n\n    }, {\n        key: 'onBeforePlay',\n        value: function onBeforePlay() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            return true;\n        }\n    }, {\n        key: 'onPlay',\n        value: function onPlay(props) {\n            helper.info('Overwritte the \"onPlay\" method with the code you want to get executed', 'info');\n        }\n    }, {\n        key: 'onResume',\n        value: function onResume(props) {\n            helper.info('Overwritte the \"onResume\" method with the code you want to get executed', 'info');\n        }\n    }, {\n        key: 'onBeforeResume',\n        value: function onBeforeResume() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            return true;\n        }\n\n        /**\n         * Helper function that normalises the millisecond to pass to the Incidents on goTo\n         * If millisecond < 0 it makes it 0\n         * If millisecond > duration of the Incident it makes it equals to the duration\n         * @param {int} millisecond - the millisecond to normalise. It represents the distance of the time to go to from\n         *  the start of the Incident\n         * @returns {int} - the normalised millisecond\n        **/\n\n    }, {\n        key: 'normaliseGoToTarget',\n        value: function normaliseGoToTarget(millisecond) {\n            if (millisecond < 0) {\n                millisecond = 0;\n            } else if (millisecond > this.duration) {\n                millisecond = this.duration;\n            }\n\n            return millisecond;\n        }\n\n        /**\n         * goTo on the Incident level implements the logic of passing the authority of execution to its parent\n         * (if there is any)\n         * Incidents that implement their own goTo logic should overwrite the goTo method otherwise the goTo\n         * will be passed up until either it reaches a context owner or a tree root\n         * @param {int} millisecond - (optional) the millisecond where we want to goTo. If not provided we use the current millisecond of the Incident\n         * @returns {boolean} - if the context owner of the Incident actually executes the goTo command the\n         *  method returns true otherwise it returns false\n        **/\n\n    }, {\n        key: 'goTo',\n        value: function goTo(millisedond) {\n            // if the incident has a parent scene\n            if (this.checkParentScene()) {\n                if (this.parentSceneObject.goTo(millisedond, { relativeTo: this.id })) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        /**\n         * Returns the milliseconds delta between the Incident's start point and its root Scene's current millisecond.\n         * If the result is negative it means the root scene's current millisecond is prior to the Incident's start point\n         * @returns {int}\n        **/\n\n    }, {\n        key: 'getRootCurrentMillisecondDeltaFromStart',\n        value: function getRootCurrentMillisecondDeltaFromStart() {\n            if (this.checkParentScene()) {\n                return this.parentSceneObject.getRootCurrentMillisecondDeltaFromIncidentsStart(this.id);\n            } else {\n                return this.runTimeInfo.currentMillisecond;\n            }\n        }\n    }, {\n        key: 'beOn',\n        value: function beOn(millisecond) {\n            var goTo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n            var previousState = this.state + \"\";\n            this.stop();\n            if (goTo) {\n                this.goTo(millisecond);\n            }\n            this.setCurrentMillisecond(millisecond);\n            this.recalcState(millisecond);\n            var newState = this.state + \"\";\n            return {\n                previousState: previousState,\n                newState: newState\n            };\n        }\n    }, {\n        key: '_onGetContextOnce',\n        value: function _onGetContextOnce() {\n            if (!this.gotContext) {\n                this.onGetContext();\n                this.gotContext = true;\n            }\n        }\n    }, {\n        key: 'onGetContext',\n        value: function onGetContext() {\n            helper.info('Overwritte the \"onGetContext\" method with the code you want to get executed', 'info');\n        }\n    }, {\n        key: 'onStop',\n        value: function onStop(props) {\n            helper.info('Overwritte the \"onBeforeStop\" method with the code you want to get executed', 'info');\n        }\n    }, {\n        key: 'onReset',\n        value: function onReset(props) {\n            helper.info('Overwritte the \"onReset\" method with the code you want to get executed', 'info');\n        }\n    }, {\n        key: 'onBeforeComplete',\n        value: function onBeforeComplete(props) {\n            helper.info('Overwritte the \"onBeforeEnd\" method with the code you want to get executed', 'info');\n        }\n    }, {\n        key: 'onBlock',\n        value: function onBlock(props) {\n            helper.info('Overwritte the \"onBlock\" method with the code you want to get executed', 'info');\n        }\n    }, {\n        key: 'onUnblock',\n        value: function onUnblock(props) {\n            helper.info('Overwritte the \"onUnblock\" method with the code you want to get executed', 'info');\n        }\n    }, {\n        key: 'onWait',\n        value: function onWait(props) {\n            helper.info('Overwritte the \"onWait\" method with the code you want to get executed', 'info');\n        }\n    }, {\n        key: 'onArm',\n        value: function onArm(props) {\n            helper.info('Overwritte the \"onArm\" method with the code you want to get executed', 'info');\n        }\n    }, {\n        key: 'lastWish',\n        value: function lastWish() {\n            this.stop();\n        }\n    }, {\n        key: 'onInitialise',\n        value: function onInitialise(attrs, props) {\n            helper.info('Overwritte the \"onInialise\" method with the code you want to get executed', 'info');\n        }\n    }, {\n        key: 'onSpeedChange',\n        value: function onSpeedChange(speed) {\n            helper.info('Overwritte the \"onSpeedChange\" method with the code you want to get executed', 'info');\n        }\n    }, {\n        key: 'isOnTestMode',\n        get: function get() {\n            if (this.checkParentScene()) {\n                return this.parentSceneObject.isOnTestMode;\n            } else {\n                return this.testMode;\n            }\n        }\n    }, {\n        key: 'selector',\n        get: function get() {\n            return this.props.selector;\n        }\n\n        /* shortcuts for attrs.attrs and attrs.animatedAttrs */\n\n    }, {\n        key: 'animAttributes',\n        get: function get() {\n            return this.attrs.animatedAttrs;\n        }\n    }, {\n        key: 'confAttributes',\n        get: function get() {\n            return this.attrs.attrs;\n        }\n    }, {\n        key: 'isHeadlessClip',\n        get: function get() {\n            return !this.checkParentScene();\n        }\n    }, {\n        key: 'context',\n        get: function get() {\n            if (this.checkParentScene()) {\n                return this.parentSceneObject.context;\n            } else {\n                return null;\n            }\n        }\n    }, {\n        key: 'element',\n        get: function get() {\n            if (this.contex === null) {\n                return [];\n            }\n            if (this.context.getElementByMCID) {\n                return this.context.getElementByMCID(this.props.mcid);\n            }\n            return this.context.getElements(this.selector)[0];\n        }\n\n        /*\n        returns the initialised channel by the Clip the Incident belongs to\n        */\n\n    }, {\n        key: 'channel',\n        get: function get() {\n            if (this.checkParentScene()) {\n                return this.parentSceneObject._getChannel(this.mc_plugin_npm_name);\n            } else {\n                return null;\n            }\n        }\n    }, {\n        key: 'elements',\n        get: function get() {\n            if (this.contex === null) {\n                return [];\n            }\n            return this.context.getElements(this.selector);\n        }\n    }, {\n        key: 'executionSpeed',\n        set: function set(speed) {\n            this.speed = parseFloat(speed);\n            this.onSpeedChange(speed);\n            // this.beOn(this.runTimeInfo.currentMillisecond);\n        }\n\n        /**\n         * gets the Incident's duration. This method should be overwriten accordingly by all Incidents\n         */\n\n    }, {\n        key: 'duration',\n        get: function get() {\n            return 0;\n        },\n        set: function set(duration) {\n            ;\n        }\n    }, {\n        key: 'state',\n        get: function get() {\n            return this.runTimeInfo.state;\n        }\n    }, {\n        key: 'direction',\n        get: function get() {\n            return this.speed > 0 ? \"forwards\" : \"backwards\";\n        }\n    }]);\n\n    return Incident;\n}();\n\nmodule.exports = Incident;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19CYXNlQ2xhc3Nlcy9JbmNpZGVudC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2Rpc3QvX0Jhc2VDbGFzc2VzL0luY2lkZW50LmpzP2Q2ZWEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgSGVscGVyID0gcmVxdWlyZSgnLi4vX2NvcmVVdGlscy9IZWxwZXInKTtcbnZhciBjaGVja1RyYW5zaXRpb24gPSByZXF1aXJlKCcuLi9jb25maWd1cmF0aW9uL2FsbG93ZWRTdGF0ZUNoYW5nZXMnKS5jaGVja1RyYW5zaXRpb247XG52YXIgaGVscGVyID0gbmV3IEhlbHBlcigpO1xudmFyIENoYW5uZWwgPSByZXF1aXJlKCcuLi9fQ2hhbm5lbHMvQ2hhbm5lbCcpO1xudmFyIHBpcGVNZXNzZ2VzID0gcmVxdWlyZSgnLi4vY29uZmlndXJhdGlvbi9waXBlc0NvbmYnKTtcbnZhciBnZW5lcmFsQ29uZiA9IHJlcXVpcmUoJy4uL2NvbmZpZ3VyYXRpb24vZ2VuZXJhbENvbmYnKTtcblxuLyoqIEBjbGFzc2Rlc2NcbiAqIEluY2lkZW50cyBhcmUgYWxsIGV2ZW50cyB0aGF0IHNob3VsZCBoYXBwZW4gb24gYSBzcGVjaWZpYyB0aW1lIG9uIHRoZSB0aW1lbGluZS4gQW4gaW5jaWRlbnQgY2FuIGhhdmUgcGFyYW1ldHJpY1xuICAgICAgZXhlY3V0aW9uIGJlaGF2aW91ciBiYXNlZCBvbiB0aGUgdGltZXMgaXQgaGFzIGJlZW4gZXhlY3V0ZWQgYW5kIChtaWdodCBiZSkgb24gb3RoZXIgcGFyYW1ldGVycy5cblxuICAgICAgVGhlIHN0YXRlIGFuIEluY2lkZW50IGNhbiBoYXZlIGlzIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuICAgICAgICAgICAgICAgICBpZGxlXG4gICAgICAgICAgICAgICAgIHBsYXlpbmdcbiAgICAgICAgICAgICAgICAgd2FpdGluZ1xuICAgICAgICAgICAgICAgICBzY2VuZUJsb2NraW5nV2FpdGluZ1xuICAgICAgICAgICAgICAgICBjbGlwQmxvY2tpbmdXYWl0aW5nXG4gICAgICAgICAgICAgICAgIGJsb2NrZWQgICAgLy8gaW4gdGhlIGNhc2UgdGhlIEluY2lkZW50IGlzIGJsb2NrZWQgLyBwYXVzZWQgYnkgYSB3YWl0aW5nXG4gICAgICAgICAgICAgICAgIGNvbXBsZXRlZFxuXG4gICAgICBFYWNoIEluY2lkZW50IGhhcyB0aGUgb2JsaWdhdGlvbiB0byBpbmZvcm0gdGhlIFNjZW5lIGFib3V0IGl0cyBzdGF0ZSBjaGFuZ2VzLlxuICAgICAgRm9yIHRoaXMgSW5jaWRlbnQgcHJvdmlkZXMgdGhlIG1ldGhvZCDigJxzZXRQYXJlbnRTY2VuZeKAnSB3aGljaCB0YWtlcyBqdXN0IG9uZSBhcmd1bWVudCBhIFRpbWVyIG9iamVjdC5cbiAgICAgIFRpbWVyIHByb3ZpZGVzIHRoZSBtZXRob2Qg4oCcaW5jaWRlbnRTdGF0ZUNoYW5nZeKAnSB3aGljaCBsZXRzIHRoZSBJbmNpZGVudHMgY2hhbmdlIHRoZWlyIHN0YXRlIGJ5XG4gICAgICBwcm92aWRpbmcgdGhlaXIgaWQgYW5kIHRoZWlyIG5ldyBzdGF0ZS5cbiAqICovXG5cbnZhciBJbmNpZGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgSXQgdGFrZXMganVzdCBvbmUgYXJndW1lbnQsIFwicHJvcHNcIi4gUHJvcHMgcGFzcyBkYXRhIHVzZWZ1bCBvbmx5IGZvciB0aGUgZm9sbG93aW5nOlxuICAgICBBbiBpbmNpZGVudCBjYW4gYmUgc2V0IHRvIGJlIGVpdGhlciBpbmV4aGF1c3RpYmxlIChtZWFuaW5nIGl0IGNhbiBiZSBleGVjdXRlZCBhZ2FpbiBhbmQgYWdhaW4gaW5maW5pdGUgdGltZXMgLS0gZGVmYXVsdClcbiAgICAgb3IgZmluaXRlIG1lYW5pbmcgaXQgY2FuIG9ubHkgYmUgZXhlY3V0ZWQgYSBsaW1pdGVkIChzcGVjaWZpYykgbnVtYmVyIG9mIHRpbWVzLiBUaGlzIGluZm8gY2FuIGJlIGZvdW5kIG9uIHRoZSBtYXhMaWZlQ3ljbGVzXG4gICAgIE9mIGNvdXJzZSB0aGUgaW5jaWRlbnQgY2FuIGJlIHJlc2V0IHRvIGl0cyBpbml0aWFsIGNvbmRpdGlvbiBhdCBhbnkgdGltZSB0aHJvdWdoIHRoZSBcInJlc2V0XCIgbWV0aG9kIGl0IHByb3ZpZGVzLlxuICAgICAgQXMgYSBsdXh1cmlvdXNuZXNzLCBhbmQgYWxvbmcgV0lUSCB0aGUgbWF4TGlmZUN5Y2xlcyBwYXJhbWV0ZXIsIHRoZSBJbmNpZGVudCBhbHNvIHByb3ZpZGVzIHRoZSBleGVjdXRpb25QYXR0ZXJuIHBhcmFtZXRlclxuICAgICB0aHJvdWdoIHdoaWNoIHRoZSBwcm9ncmFtbWVyIC8gdXNlciBjYW4gZGVmaW5lIGEgbW9yZSBjb21wbGV4IGJlaGF2aW91ciBvZiB0aGUgSW5jaWRlbnQgZXhlY3V0aW9uIGRlcGVuZGluZyBvbiB0aGUgbnVtYmVyIHRpbWVzXG4gICAgIHRoZSBpbmNpZGVudCBoYXMgYWxyYWR5IGJlIGV4ZWN1dGVkICggaXMgdGhlIDFzdCB0aW1lLCB0aGUgMm5kIHRpbWUsIHRoZSAzcmQgdGltZSBldGMpIGFuZCBhbnkgY3VzdG9tIHBhcmFtZXRlciBpdFxuICAgICBob2xkcy4gVGhlIGV4ZWN1dGlvbiB0aW1lcyBhcmUgaGVsZCBvbiB0aGUgXCJleGVjdXRpb25UaW1lc1wiIGF0dHJpYnV0ZSBvZiB0aGUgY2xhc3MuXG4gICAgICBwcm9wczpcbiAgICAge1xuICAgICAgICBpZDogaWYgcGFzc2VkIHRoYXQncyB0aGUgaWQgb2YgdGhlIEluY2lkZW50LiBJZiBub3Qgd2UgY3JlYXRlIGEgbmV3IG9uZVxuICAgICAgICBwbHVnaW5fY2hhbm5lbF9jbGFzcyAtIGlmIHBhc3NlZCBnZXRzIHNldCB0byBpdFxuICAgICAgICBtY19wbHVnaW5fbnBtX25hbWUgLSBpZiBwYXNzZWQgZ2V0cyBzZXQgdG8gaXRcbiAgICAgICAgXG4gICAgIH1cbiAgICAgICAgQHBhcmFtIHtvYmplY3R9IHByb3BzICovXG4gICAgZnVuY3Rpb24gSW5jaWRlbnQoKSB7XG4gICAgICAgIHZhciBhdHRycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluY2lkZW50KTtcblxuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcblxuICAgICAgICAvLyBhdXRvLWdlbmVyYXRlZCBpZC4gVGhpcyBwYXJhbWV0ZXIgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIGlkIG9mIHRoZSBJbmNpZGVudCB3YXMgZ2l2ZW4gYnkgdGhlIHVzZXIgb3IgXG4gICAgICAgIC8vIGl0IHdhcyBhdXRvLWdlbmVyYXRlZCBieSBNQy4gQXV0by1nZW5lcmF0ZWQgaWRzIGRvIG5vdCBnZXQgY2hlY2tlZCBmb3IgZHVwbGljYXRlcyBvbiBjaGVja0FkZGl0aW9uIFxuICAgICAgICAvLyBwcm9jZXNzLCBmb3IgdGhlIHNoYWtlIG9mIHBlcmZvcm1hbmNlXG4gICAgICAgIHRoaXMuYXV0b0dlbmVyYXRlZElEID0gZmFsc2U7XG4gICAgICAgIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkoJ2lkJykgJiYgcHJvcHMuYXV0b2dlbmVyYXRlZElEICE9IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0b0dlbmVyYXRlZElEID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlkID0gcHJvcHMuaWQgfHwgaGVscGVyLmdldEFuSWQoKTtcblxuICAgICAgICAvLyB0aGlzIHBhcmFtZXRlciBpcyBpbml0aWFsaXNlZCB0byBmYWxzZS4gT25jZSB0aGUgb25HZXRDb250ZXh0IG1ldGhvZCBnZXRzIGludm9rZWQgdGhpcyBwYXJhbWV0ZXJcbiAgICAgICAgLy8gaXMgc2V0IHRvIHRydWUgc28gd2UgcHJldmVudCBtdWx0aXBsZSBleGVjdXRpb25zIG9mIHRoZSBvbkdldENvbnRleHQgbWV0aG9kXG4gICAgICAgIHRoaXMuZ290Q29udGV4dCA9IGZhbHNlO1xuXG4gICAgICAgIC8qXG4gICAgICAgIHRoZXNlIGFyZSB0aGUgZGVmYXVsdCB2YWx1ZXMgdGhhdCBkZWZpbmUgY2hhbm5lbGluZyBmb3IgdGhlIGRlZmF1bHQgSW5jaWRlbnRzLiBUaGVzZSB2YWx1ZXMgZ2V0IG92ZXdyaWRlbiB0aHJvdWdoXG4gICAgICAgIHRoZSBsb2FkUGx1Z2luIG1ldGhvZCBvZiBNQyB3aXRoIHRoZSB2YWx1ZXMgZm91bmQgb24gdGhlIG1haW4uanMgZmlsZSBvZiB0aGUgcGx1Z2luXG4gICAgICAgICovXG4gICAgICAgIHRoaXMucGx1Z2luX2NoYW5uZWxfY2xhc3MgPSBDaGFubmVsO1xuICAgICAgICB0aGlzLm1jX3BsdWdpbl9ucG1fbmFtZSA9IFwibW90b3ItY29ydGV4LWpzXCI7XG4gICAgICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgncGx1Z2luX2NoYW5uZWxfY2xhc3MnKSkge1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5fY2hhbm5lbF9jbGFzcyA9IHByb3BzLnBsdWdpbl9jaGFubmVsX2NsYXNzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnbWNfcGx1Z2luX25wbV9uYW1lJykpIHtcbiAgICAgICAgICAgIHRoaXMubWNfcGx1Z2luX25wbV9uYW1lID0gcHJvcHMubWNfcGx1Z2luX25wbV9uYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogXG4gICAgICAgIFRoZSBmb2xsb3dpbmcgdHdvIHByb3BlcnRpZXMgKFwic3RhdHVzQmVmb3JlSGFsdFwiIGFuZCBcInN0YXRlQmVmb3JlU3RvcFwiKSB3aGljaCBoYXZlIHN0dXBpZGx5IFxuICAgICAgICB1c2VkIFwic3RhdHVzXCIgaW4gdGhlIG9uZSBjYXNlIGFuZCBcInN0YXRlXCIgaW4gdGhlIG90aGVyXG4gICAgICAgIGFjdCBhcyB0aGUgbWVtb3J5IG9mIHRoZSBJbmNpZGVudCBpbiB0aGUgY2FzZSBvZiBhIHN0b3Agb3JcbiAgICAgICAgYSBoYWx0aW5nIGNvbW1hbmQgKHdhaXQgb3IgYmxvY2spLCBzdG9yaW5nIHRoZSBzdGF0ZSBvZiBpdCBqdXN0IGJlZm9yZSBhbnkgb2YgdGhlIHR3byBnZXQgXG4gICAgICAgIGV4ZWN1dGVkLiBcbiAgICAgICAgVGhlc2UgcHJvcGVydGllcyBjYW4gYmUgdXNlZCBpbiB2YXJpb3VzIHdheXMgaW4gdGhlIHByb2dyYW1cbiAgICAgICAgYW5kIHRoZXkgZG8gbm90IHRhcmdldCBzcGVjaWZpYyBmdW5jdGlvbmFsaXR5LlxuICAgICAgICAqL1xuICAgICAgICAvLyB0aGUgc3RhdHVzIG9mIHRoZSBJbmNpZGVudCBiZWZvcmUgaXQgZ290IGhhbHRlZCBieSBlaXRoZXIgdGhlIGJsb2NrIG9yIHRoZSB3YWl0IGNvbW1hbmRcbiAgICAgICAgdGhpcy5zdGF0dXNCZWZvcmVIYWx0ID0gJ2lkbGUnO1xuICAgICAgICAvLyBob2xkcyB0aGUgc3RhdGUgb2YgdGhlIEluY2lkZW50IGJlZm9yZSB0aGUgc3RvcCBjb21tYW5kXG4gICAgICAgIHRoaXMuc3RhdGVCZWZvcmVTdG9wID0gJ2lkbGUnO1xuXG4gICAgICAgIHRoaXMudGltZXNFeGVjdXRlZCA9IDA7XG4gICAgICAgIHRoaXMucGFyZW50U2NlbmVPYmplY3QgPSBudWxsO1xuXG4gICAgICAgIHRoaXMucnVuVGltZUluZm8gPSB7XG4gICAgICAgICAgICBzdGF0ZTogJ2lkbGUnIC8vIG9uZSBvZiBcImlkbGVcIiwgXCJwbGF5aW5nXCIsIFwid2FpdGluZ1wiXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5iaXRJbmNpZGVudCA9IHRydWU7XG4gICAgICAgIHRoaXMuaGFzSW5jaWRlbnRzID0gZmFsc2U7XG5cbiAgICAgICAgLyogYW4gYXJyYXkgaG9sZGluZyBhbGwgICovXG4gICAgICAgIHRoaXMuZXZlbnRzU3Vic2NyaXB0aW9ucyA9IHt9O1xuXG4gICAgICAgIC8qXG4gICAgICAgIFJpZ2h0IG5vdyBtYW55IGtleXMgb2YgdGhlIEluY2lkZW50IChzdWNoIGFzIFwicHJvcHNcIiwgXCJhdHRyc1wiLCBldGMpIGFyZSBhbHJlYWR5IGJlZW4gdXNlZCBieSB0aGUgSW5jaWRlbnQgXG4gICAgICAgIGNsYXNzLiBUaGUgZmluYWwgdXNlcnMgb2YgdGhlIGxpYnJhcnkgKHRoZSBwbHVnaW4gZGV2ZWxvcGVycykgbWlnaHQgd2FudCB0byBrZWVwIHNwZWNpYWwgLyBzcGVjaWZpYyBkYXRhXG4gICAgICAgIG9uIHRoZWlyIEluY2lkZW50cyBhbmQ6XG4gICAgICAgIGEpIHRoZXkgbWlnaHQgZG9uJ3Qga25vdyB3aGljaCBrZXlzIGFyZSBhbHJlYWR5IHRha2VuIGFuZCB3aGljaCBhcmUgbm90XG4gICAgICAgIGIpIG1pZ2h0IHVzZSBhbiBhbHJlYWR5IHVzZWQga2V5IGFuZCBydWluIHRoZSBmdW5jdGlvbmFsaXR5XG4gICAgICAgIGMpIHNvIHRoZXkgZmVlbCB1bnNhZmUga2VlcGluZyBkYXRhIGFuZCBpdCdzIG5vdCBzYWZlIGZvciB0aGUgbGliIHRvb1xuICAgICAgICBGb3IgdGhpcyByZWFzb24gd2UgaGF2ZSBhIGJsYW5rIG9iamVjdCByZXNlcnZlZCBmb3IgdGhlbSwgdGhlIFwiY3VzdG9tUGFyYW1zXCIsIGluIG9yZGVyIGZvciB0aGVtIHRvIFxuICAgICAgICBwdXQgYW55dGhpbmcgdGhleSB3YW50IGFuZCB3ZSBlbmNvdXJhZ2UgdGhlbSB0byB1c2UgdGhlIGJ1aWx0LWluIG1ldGhvZHM6XG4gICAgICAgIHNldFBhcmFtXG4gICAgICAgIGdldFBhcmFtXG4gICAgICAgIHNldFBhcmFtc1xuICAgICAgICBmb3IgdGhpcyBqb2JcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jdXN0b21QYXJhbXMgPSB7fTtcblxuICAgICAgICB0aGlzLnNwZWVkID0gMTtcblxuICAgICAgICAvKlxuICAgICAgICBpbml0aWFsVmFsdWVzIGlzIGFuIG9iamVjdCBob2xkaW5nIHRoZSBhdXRtYXRpY2FsbHkgY29tcHV0ZWQgaW5pdGlhbCB2YWx1ZXMgb2YgdGhlIGFuaW1hdGVkQXR0cnMgXG4gICAgICAgIChpZiBhbnkpLiBUaGUgaW5pdGlhbFZhbHVlcyBhcmUgY2FsY3VsYXRlZCBieSB0aGUgQXR0cmlidXRlc0NoYW5uZWwgKG9ubHkgSW5jaWRlbnRzIGJlbG9uZ2luZyB0byBcbiAgICAgICAgYW4gQXR0cmlidXRlc0NoYW5uZWwgaGF2ZSBpbml0aWFsVmFsdWVzKS5cbiAgICAgICAgVGhlIGtleXMgc2V0IG9mIHRoaXMgb2JqZWN0IGlzIGlkZW50aWNhbCB0byB0aGUgb2JqZWN0IGF0dHJzLmFuaW1hdGVkQXR0cnMgXG4gICAgICAgIFRoZSBvbmx5IHRoaW5nIHRoZSBnZW5lcmljIEF0dHJpYnV0ZXNDaGFubmVsIGNhbid0IGNhbGN1bGF0ZSBpcyB0aGUgaW5pdGlhbCB2YWx1ZSBvZiBhbiBhbmltYXRlZCBhdHRyXG4gICAgICAgIG9mIGEgc3BlY2lmaWMgZWxlbWVudCB3aGVuIHRoZXJlIGFyZSBubyBvdGhlciBJbmNpZGVudHMgZW50ZXJlZCBvbiBpdHMgbGFuZXMgeWV0LiBUaGVzZSB2YWx1ZXMgYXJlXG4gICAgICAgIHRoZSBcInNjcmF0Y2hWYWx1ZXNcIiBhbmQgdGhleSBhcmUgc3Ryb25nbHkgZGVwZW5kZW5kIG9uIHRoZSBuYXR1cmUgb2YgdGhlIGxpYi4gRS5nLiBmb3IgYSBDU1MgYW5pbWF0aW9uXG4gICAgICAgIHdoYXQgd2UgYXJlIGxvb2tpbmcgZm9yIGNhbiBiZSBmb3VuZCBvbiB0aGUgY29tcHV0ZWRTdHlsZS5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbml0aWFsVmFsdWVzID0ge307XG5cbiAgICAgICAgLypcbiAgICAgICAgVGhlIHVzZXIgaGFzIHRoZSBhYmlsaXR5IHRvIGV4cGxpY2l0ZWx5IGRlZmluZSB0aGUgaW5pdGlhbCB2YWx1ZXMgZm9yIGFueSBvZiB0aGUgYW5pbWF0ZWRBdHRycy4gVGhlIHVzZXJcbiAgICAgICAgY2FuIGRvIHRoYXQgYnkgcHJvdmlkaW5nIHRoZSBpbml0aWFsVmFsdWVzIG9iamVjdCBvbiB0aGUgYXR0cnMgb2YgdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnVzZXJEZWZpbmVkSW5pdGlhbFZhbHVlcyA9IHt9O1xuICAgICAgICBpZiAoYXR0cnMgIT0gbnVsbCAmJiBhdHRycyAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChhdHRycy5oYXNPd25Qcm9wZXJ0eSgnaW5pdGlhbFZhbHVlcycpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51c2VyRGVmaW5lZEluaXRpYWxWYWx1ZXMgPSBhdHRycy5pbml0aWFsVmFsdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLypcbiAgICAgICAgYmxvY2tpbmdXYWl0aW5ncyBpcyBhbiBhcnJheSwgYSBjb2xsZWN0aW9uLCBvZiBibG9jaW5nIHdhaXRpbmdzIHRoYXQgaGF2ZSB0aGUgU2NlbmUgYXMgdGFyZ2V0LlxuICAgICAgICBUaGUgbG9naWMgaXMgc2ltcGxlOlxuICAgICAgICAtIGlmIHRoZSBzY2VuZSByZWNlaXZlcyBhIFwic2NlbmVCbG9ja2luZ1dhaXRpbmdcIiB0aGVuIGl0IGlzIHRoZSB0YXJnZXQgYW5kIGl0IGFkb3B0cyBpdFxuICAgICAgICAtIGlmIHRoZSBzY2VuZSByZWNlaXZlcyBhIFwiY2hhbm5lbEJsb2NraW5nV2FpdGluZ1wiIHRoZW4gaWYgaXQgaXMgYSBjaGFubmVsIGl0IGFkb3B0cyBpdCBvdGhlcndpc2UgaXQgdHJpZXMgdG9cbiAgICAgICAgICAgIHBhc3MgaXQgZnVydGhlciB1cCB1bnRpbCBpdCBmaW5kcyBhIGNoYW5uZWxcbiAgICAgICAgLSBpZiB0aGUgc2NlbmUgcmVjZWl2ZXMgYSBcImNsaXBCbG9ja2luZ1dhaXRpbmdcIiBpZiBpdCBpcyB0aGUgQ2xpcCBpdCBhZG9wdHMgaXQgb3RoZXJ3aXNlIGl0IHRyaWVzIHRvIHBhc3MgaXRcbiAgICAgICAgICAgIGZ1cnRoZXIgdXAgdW50aWwgaXQgcmVhY2hlcyB0aGUgY2xpcFxuICAgICAgICBFYWNoIG9iamVjdCBvbiB0aGlzIGFycmF5IHJlcHJlc2VudHMgYSBibG9ja2luZyB3YWl0aW5nIHRyaWdnZXJlZCBieSBhIGNoaWxkIG9mIHRoZSBTY2VuZVxuICAgICAgICAgICAgYW5kIHdoaWNoIHRhcmdldHMgdGhlIFNjZW5lIGl0c2VsZi5cbiAgICAgICAgRWFjaCBjaGlsZCBzaWducyB0aGUgYmxvY2tpbmcgd2FpdGluZyBieSBhc3NpZ25pbmcgaXRzIG93biBpZCB0byBpdC4gRWFjaCBjaGlsZCBjYW4gb25seSBhc3NpZ24ganVzdCBvbmVcbiAgICAgICAgICAgIGJsb2NraW5nIHdhaXRpbmcgYXQgYSB0aW1lLlxuICAgICAgICBUaGUgc3RydWN0dXJlIG9mIGVhY2ggYmxvY2tpbmcgd2FpdGluZyBhcHBlYXJpbmcgb24gdGhpcyBhcnJheSBpcyB0aGUgZm9sbG93aW5nOlxuICAgICAgICB7XG4gICAgICAgICAgICBpZDogdGhlLXNpZ25hdHVyZS1vZi10aGUtdHJpZ2dlcmluZy1pbmNpZGVudCxcbiAgICAgICAgICAgIHR5cGU6IGFueSBvZiB0aGUgc2NlbmVCbG9ja2luZ1dhaXRpbmcgLyBjaGFubmVsQmxvY2tpbmdXYWl0aW5nIC8gQ2xpcEJsb2NraW5nV2FpdGluZyxcbiAgICAgICAgICAgIG5hdHVyZTogYW55IG9mIHRoZSBzY2hlZHVsZWQgLyBkeW5hbWljIC8gc3lzdGVtLXByb2JsZW1cbiAgICAgICAgfVxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmJsb2NraW5nV2FpdGluZ3MgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufSAtIGlmIHRlc3RpbmdNb2RlIGlzIHNldCB0byB0cnVlIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgbWV0aG9kIGlzIG5vdCBnb2luZ1xuICAgICAgICAqIHRvIGdldCBleGVjdXRlZCBhdXRvbWF0aWNhbGx5IGJ1dCBpbnN0ZWFkIHRoZSBlbWF1bGF0ZVN0ZXAgbWV0aG9kIHdpbGwgc3RhcnQgZnVuY3Rpb25pbmcgYWxsb3dpbmdcbiAgICAgICAgKiBkZXZlbG9wZXJzIHRvIHBhc3MgdGhlIG1pbGxpc2Vjb25kcyBkaWZmZXJlbmNlIGZyb20gdGhlIHByZXZpb3VzIHRpbWVzdGFtcCBtYW51YWxseVxuICAgICAgICAqKi9cbiAgICAgICAgdGhpcy50ZXN0TW9kZSA9IGZhbHNlO1xuICAgICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoJ3Rlc3RNb2RlJykpIHtcbiAgICAgICAgICAgIHRoaXMudGVzdE1vZGUgPSBwcm9wcy50ZXN0TW9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnaW5pdGlhbFZhbHVlcycpKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxWYWx1ZXMgPSBwcm9wcy5pbml0aWFsVmFsdWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59IC0gaWYgYXV0b0dlbmVyYXRlZCBpcyBzZXQgdG8gdHJ1ZSwgaXQgbWVhbnMgdGhhdCB0aGlzIEluY2lkZW50IGhhcyBiZWVuIGF1dG8tZ2VuZXJhdGVkIGJ5IGl0cyBwYXJlbnQgb24gaW5pdGlhbGlzYXRpb24uXG4gICAgICAgICAqIFRoaXMgaGFwcGVucyB3aGVuIHBsdWdpbnMgZXhwb3J0IEluY2lkZW50cyB0aGF0IG9uIGluaXRpYWxpc2F0aW9uIHRoZXkgYXV0b21hdGljYWxseSBjcmVhdGUgb3RoZXIgaW5jaWRlbnRzIGFuZCBhdXRvbWF0aWNhbGx5IHB1dCB0aGVtIFxuICAgICAgICAgKiBvbiBzcGVjaWZpYyBwb2ludHMgb24gdGhlaXIgdGltZWxpbmUuIFxuICAgICAgICAgKiBJbiBzdWNoIGNhc2VzIHdlIGRvbid0IHdhbnQgdGhlc2UgSW5jaWRlbnRzIHRvIGJlIGV4cG9ydGVkIG9uIGdldFN0YXRlIHdpdGggdW5wcm9jZXNzZWQgPSB0cnVlIGFuZCB0aGlzIGJlY2F1c2UgdGhleSB3aWxsIGJlIHJlLWdlbmVyYXRlZFxuICAgICAgICAgKiBhdXRvbWF0aWNhbGx5IG9uIHRoZSBjbGlwJ3MgcmVjb25zdHJ1Y3Rpb24gcHJvY2VzcyBiYXNlZCBvbiB0aGUgZXhwb3J0ZWQganNvbi4gXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuYXV0b0dlbmVyYXRlZCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMub25Jbml0aWFsaXNlKGF0dHJzLCBwcm9wcyk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEluY2lkZW50LCBbe1xuICAgICAgICBrZXk6ICdnZXRTY3JhdGNoVmFsdWUnLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgIFRoaXMgbWV0aG9kIHNob3VkbCBiZSBvdmVyd3JpdHRlbiBieSB0aGUgSW5jaWRlbnRzIG9mIHRoZSBwbHVnaW5zLiBUaGUgbWV0aG9kIGFjY2VwdHNcbiAgICAgICAgYXMgYXJndW1lbnRzIHRoZSBtY2lkIChhbiBlbGVtZW50KSBhbmQgdGhlIGF0dHJpYnVlIChvbmUgb2YgdGhlIGFuaW1hdGVkQXR0cnMsIGlmIGFueSlcbiAgICAgICAgYW5kIHJldHVybiB0aGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGVtIGFzIHRoZSBsaWJyYXJ5IGNhbGN1bGF0ZXMgLyBkZWZpbmVzIHRoZW0uIFRoZSBcbiAgICAgICAgcmV0dXJuZWQgdmFsdWUgcmVwcmVzZW50cyB0aGUgdmVyeSBpbml0aWFsIHZhbHVlIG9mIHRoZSBlbGVtZW50J3MgYXR0cmlidXRlIGJlZm9yZVxuICAgICAgICBhbnkgSW5jaWRlbnQgdGhhdCBhbHRlcnMgaXQgZ2V0cyBhZGRlZC5cbiAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG1jaWRcbiAgICAgICAgQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICAgICAgICBAcmV0dXJucyB7bWl4ZWR9IC0gdGhlIGluaXRpYWwgdmFsdWUgb2YgdGhlIGVsZW1lbnQncyBhdHRyaWJ1dGUganVzdCB3aGVuIHRoZSBIVE1MICYgQ1NTXG4gICAgICAgIG9mIHRoZSBDbGlwIGdldHMgcmVuZGVyZWRcbiAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNjcmF0Y2hWYWx1ZShtY2lkLCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRFbGVtZW50QXR0cmlidXRlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVsZW1lbnRBdHRyaWJ1dGUoYXR0cikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldEVsZW1lbnRCeU1DSUQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWxlbWVudEJ5TUNJRChtY2lkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuZ2V0RWxlbWVudEJ5TUNJRChtY2lkKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZmxhc2hET00nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZmxhc2hET00oKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZhaWxlZEFkZGl0aW9uczogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3R1cm5JbmNpZGVudFRvTUMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdHVybkluY2lkZW50VG9NQygpIHtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luX2NoYW5uZWxfY2xhc3MgPSBDaGFubmVsO1xuICAgICAgICAgICAgdGhpcy5tY19wbHVnaW5fbnBtX25hbWUgPSBcIm1vdG9yLWNvcnRleC1qc1wiO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZXNldFN0YXRlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0U3RhdGUoKSB7fVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0SW5jaWRlbnRzQnlDaGFubmVsJyxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGhhcyB0aGUga2V5IG9mIHRoZSBucG0gcGx1Z2luIG5hbWUgdGhlIENoYW5uZWwgb2Ygd2hpY2ggbWFuYWdlcyB0aGUgc3BlY2lmaWMgSW5jaWRlbnRcbiAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluY2lkZW50c0J5Q2hhbm5lbCgpIHtcbiAgICAgICAgICAgIHZhciBhZGp1c3RNaWxsaXNlY29uZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcblxuICAgICAgICAgICAgdmFyIGluY2lkZW50c0J5UGx1Z2luID0ge307XG4gICAgICAgICAgICB2YXIga2V5VG9Vc2UgPSB0aGlzLm1jX3BsdWdpbl9ucG1fbmFtZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ5cGFzc0NoYW5uZWwgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBrZXlUb1VzZSA9ICdtb3Rvci1jb3J0ZXgtanMnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5jaWRlbnRzQnlQbHVnaW5ba2V5VG9Vc2VdID0gW3tcbiAgICAgICAgICAgICAgICBtaWxsaXNlY29uZDogYWRqdXN0TWlsbGlzZWNvbmQsXG4gICAgICAgICAgICAgICAgaW5jaWRlbnQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMuaWRcbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgcmV0dXJuIGluY2lkZW50c0J5UGx1Z2luO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzZXRQYXJhbScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQYXJhbShwYXJhbSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tUGFyYW1zW3BhcmFtXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRQYXJhbScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQYXJhbShwYXJhbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VzdG9tUGFyYW1zW3BhcmFtXTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2V0UGFyYW1zJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBhcmFtcygpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICB0aGlzLmN1c3RvbVBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIEhFTFBFUiBGVU5DVElPTlNcbiAgICAgICAgY2hlY2tzIGlmIHRoZSBwYXJlbnQgU2NlbmUgb2JqZWN0IGhhcyBiZWVuIGRlZmluZWQgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2hlY2tQYXJlbnRTY2VuZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja1BhcmVudFNjZW5lKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50U2NlbmVPYmplY3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjaGVja1N0YXRlVHJhbnNpdGlvbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja1N0YXRlVHJhbnNpdGlvbih0YXJnZXRTdGF0ZSkge1xuICAgICAgICAgICAgLy8gd2UgcHJldmVudCBwbGF5IChhbmQgdGh1cyBhbnkgb3RoZXIgdHJhbnNpdGlvbikgaW4gY2FzZXMgdGhlIEluY2lkZW50IGhhcyBubyBwYXJlbnRcbiAgICAgICAgICAgIC8vIGdyb3VwLiBUaGUgbWV0aG9kIGNoYW5nZXMgb24gR3JvdXBcbiAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrUGFyZW50U2NlbmUoKSkge1xuICAgICAgICAgICAgICAgIGlmIChjaGVja1RyYW5zaXRpb24odGhpcy5ydW5UaW1lSW5mby5zdGF0ZSwgdGFyZ2V0U3RhdGUsIHRoaXMuZGlyZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19oYXNVc2VyRGVmaW5lZEluaXRpYWxWYWx1ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFzVXNlckRlZmluZWRJbml0aWFsVmFsdWUoYXR0cikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXNlckRlZmluZWRJbml0aWFsVmFsdWVzLmhhc093blByb3BlcnR5KGF0dHIpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfZ2V0VXNlckRlZmluZWRJbml0aWFsVmFsdWUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFVzZXJEZWZpbmVkSW5pdGlhbFZhbHVlKGF0dHIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVzZXJEZWZpbmVkSW5pdGlhbFZhbHVlc1thdHRyXTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2V0SW5pdGlhbFZhbHVlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEluaXRpYWxWYWx1ZShhdHRyLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2hhc1VzZXJEZWZpbmVkSW5pdGlhbFZhbHVlKGF0dHIpKSB7XG4gICAgICAgICAgICAgICAgaGVscGVyLm5vdGljZSgnSW5jaWRlbnQgd2l0aCBpZCAnICsgdGhpcy5pZCArICcgaGFzIGluaXRpYWwgdmFsdWUgZGVmaW5lZCBmb3IgJyArIGF0dHIgKyAnIGFuZCBubyBjaGFuZ2UgaXMgYWxsb3dlZCBvbiBpdCcpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbFZhbHVlc1thdHRyXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdoYXNJbml0aWFsVmFsdWUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFzSW5pdGlhbFZhbHVlKGF0dHIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYXNVc2VyRGVmaW5lZEluaXRpYWxWYWx1ZShhdHRyKSB8fCB0aGlzLmluaXRpYWxWYWx1ZXMuaGFzT3duUHJvcGVydHkoYXR0cik7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldEluaXRpYWxWYWx1ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbml0aWFsVmFsdWUoYXR0cikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2hhc1VzZXJEZWZpbmVkSW5pdGlhbFZhbHVlKGF0dHIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFVzZXJEZWZpbmVkSW5pdGlhbFZhbHVlKGF0dHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbFZhbHVlc1thdHRyXTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2V0UGFyZW50U2NlbmUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UGFyZW50U2NlbmUocGFyZW50U2NlbmVPYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50U2NlbmVPYmplY3QgPSBwYXJlbnRTY2VuZU9iamVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgU1RBVEUgQ0hBTkdJTkcgRlVOQ1RJT05cbiAgICAgICAgbWV0aG9kIGZyb20gd2hpY2ggd2UgY2FuIHNldCB0aGUgc3RhdGUgb2YgdGhlIEluY2lkZW50LlxuICAgICAgICB0aGlzIG1ldGhvZCBzaG91bGQgbmV2ZXIgYmUgaW52b2tlZCBkaXJlY3RseSBmcm9tIGNvZGUgb3V0c2lkZSB0aGUgY29yZSBkZWZpbml0aW9uIG9mIEluY2lkZW50LiBBbGwgc3RhdGUgY2hhbmdlc1xuICAgICAgICBzaG91bGQgb2NjdXIgdGhyb3VnaCB0aGUgY29ycmVzcG9uZGluZyBidWlsdC1pbiBmdW5jdGlvbnMgKHBsYXksIHdhaXQsIGV0YykgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3NldFN0YXRlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRTdGF0ZShzdGF0ZSkge1xuICAgICAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICAgICAgdmFyIG9sZFN0YXRlID0gdGhpcy5ydW5UaW1lSW5mby5zdGF0ZTtcbiAgICAgICAgICAgIHRoaXMucnVuVGltZUluZm8uc3RhdGUgPSBzdGF0ZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tQYXJlbnRTY2VuZSgpICYmIHN0YXRlID09PSAnY29tcGxldGVkJyAmJiB0aGlzLnNwZWVkID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50U2NlbmVPYmplY3QuaW5jaWRlbnRTdGF0ZUNoYW5nZSh0aGlzLmlkLCBvbGRTdGF0ZSwgc3RhdGUsIHByb3BzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5jaGVja1BhcmVudFNjZW5lKCkgJiYgc3RhdGUgPT09ICdpZGxlJyAmJiB0aGlzLnNwZWVkIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50U2NlbmVPYmplY3QuaW5jaWRlbnRTdGF0ZUNoYW5nZSh0aGlzLmlkLCBvbGRTdGF0ZSwgc3RhdGUsIHByb3BzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG5ld1N0YXRlID0gc3RhdGU7XG4gICAgICAgICAgICBpZiAoKHN0YXRlID09PSAnd2FpdGluZycgfHwgc3RhdGUgPT09ICdibG9ja2VkJykgJiYgcHJvcHMud2FpdGluZ1N0YXRlTmFtZSAhPSAnd2FpdGluZycpIHtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHByb3BzLndhaXRpbmdTdGF0ZU5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdEV2ZW50KCdzdGF0ZS1jaGFuZ2UnLCB7IG9sZFN0YXRlOiBvbGRTdGF0ZSwgbmV3U3RhdGU6IG5ld1N0YXRlIH0pO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzZXRDdXJyZW50TWlsbGlzZWNvbmQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q3VycmVudE1pbGxpc2Vjb25kKG1pbGxpc2Vjb25kKSB7XG4gICAgICAgICAgICB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCA9IG1pbGxpc2Vjb25kO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNldHMgdGhlIHN0YXRlIG9mIHRoZSBJbmNpZGVudCBzaWxlbnRseSB3aXRob3V0IGJyb2FkY2FzdGluZyB0aGUgZXZlbnQgbm9yIGluZm9ybWluZyB0aGUgcGFyZW50IEluY2lkZW50XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfZG9udFRlbGxNYW1hU3RhdGVDaGFuZ2UnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2RvbnRUZWxsTWFtYVN0YXRlQ2hhbmdlKHN0YXRlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGVja1N0YXRlVHJhbnNpdGlvbihzdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBoZWxwZXIubG9nKCdzZXR0aW5nIHN0YXRlIG9mICcgKyB0aGlzLmlkICsgJyB0byAnICsgc3RhdGUpO1xuICAgICAgICAgICAgICAgIHZhciBvbGRTdGF0ZSA9IHRoaXMucnVuVGltZUluZm8uc3RhdGU7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5UaW1lSW5mby5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0RXZlbnQoJ3N0YXRlLWNoYW5nZScsIHsgb2xkU3RhdGU6IG9sZFN0YXRlLCBuZXdTdGF0ZTogc3RhdGUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBFWEVDVVRJT04gRlVOQ1RJT05TXG4gICAgICAgIHNldHMgc3RhdGUgdG8gXCJwbGF5aW5nXCIgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncGxheScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwbGF5KCkge1xuICAgICAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLm9uQmVmb3JlUGxheShwcm9wcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2hlY2tTdGF0ZVRyYW5zaXRpb24oJ3BsYXlpbmcnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy50aW1lc0V4ZWN1dGVkICs9IDE7XG4gICAgICAgICAgICB0aGlzLm9uUGxheShwcm9wcyk7XG4gICAgICAgICAgICB0aGlzLl9zZXRTdGF0ZSgncGxheWluZycpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5iaXRJbmNpZGVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICB3YWl0IG1ldGhvZCBjYW4gYmUgaW52b2tlZCBieSB0aGUgb2JqZWN0IGl0c2VsZiBvciBieSBpdHMgcGFyZW50IFNjZW5lLiBObyBjaGlsZHJlbiBhcmUgYWxsb3dkIHRvIGNhbGwgdGhlIHdhaXRcbiAgICAgICAgIG1ldGhvZC5cbiAgICAgICAgICB0aGUgbmF0dXJlIG9mIGEgd2FpdGluZyBtaWdodCBiZTpcbiAgICAgICAgICAgICAtIHNjaGVkdWxlZCAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRcbiAgICAgICAgICAgICAtIGR5bmFtaWNcbiAgICAgICAgICAgICAtIHN5c3RlbS1lcnJvclxuICAgICAgICAgIHRoZSB3YWl0aW5nU3RhdGVOYW1lIG9mIGEgd2FpdGluZyBjYW4gYmU6XG4gICAgICAgICAgICAgLSB3YWl0aW5nICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0XG4gICAgICAgICAgICAgLSBzY2VuZUJsb2NraW5nV2FpdGluZ1xuICAgICAgICAgICAgIC0gY2xpcEJsb2NraW5nV2FpdGluZ1xuICAgICAgICAgIEFuIEluY2lkZW50IGNhbiBvbmx5IGV4aXQgd2FpdGluZyBtb2RlIHRocm91Z2ggdGhlIHJlc3VtZSBtZXRob2RcbiAgICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd3YWl0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHdhaXQocHJvcHMpIHtcbiAgICAgICAgICAgIGlmICghcHJvcHMud2FpdGluZ1N0YXRlTmFtZSkge1xuICAgICAgICAgICAgICAgIHByb3BzID0geyBuYXR1cmU6ICdzY2hlZHVsZWQnLCB3YWl0aW5nU3RhdGVOYW1lOiAnd2FpdGluZycgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWNrU3RhdGVUcmFuc2l0aW9uKCd3YWl0aW5nJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc3RhdHVzQmVmb3JlSGFsdCA9IHRoaXMucnVuVGltZUluZm8uc3RhdGU7XG4gICAgICAgICAgICB0aGlzLl9zZXRTdGF0ZSgnd2FpdGluZycsIHByb3BzKTtcbiAgICAgICAgICAgIHRoaXMub25XYWl0KHByb3BzKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd1bmJsb2NrJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVuYmxvY2soKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0dXNCZWZvcmVIYWx0ID09PSAncGxheWluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICBibG9jayBhbmQgdW5ibG9jayBtZXRob2RzIGNhbiBvbmx5IGJlIGludm9rZWQgYnkgYSBwYXJlbnQgb2YgdGhlIEluY2lkZW50LiBObyBjaGlsZHJlbiAoaW4gdGhlIGNhc2Ugb2YgYSBTY2VuZSkgbm9yXG4gICAgICAgICB0aGUgSW5jaWRlbnQgaXRzZWxmIGNhbiBibG9jayBvciB1bmJsb2NrIGl0c2VsZi5cbiAgICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdibG9jaycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBibG9jaygpIHtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5jaGVja1N0YXRlVHJhbnNpdGlvbignYmxvY2tlZCcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnN0YXR1c0JlZm9yZUhhbHQgPSB0aGlzLnJ1blRpbWVJbmZvLnN0YXRlO1xuICAgICAgICAgICAgdGhpcy5fc2V0U3RhdGUoJ2Jsb2NrZWQnLCBwcm9wcyk7XG4gICAgICAgICAgICB0aGlzLm9uQmxvY2socHJvcHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3Jlc3VtZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXN1bWUoKSB7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMub25CZWZvcmVSZXN1bWUocHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWNrU3RhdGVUcmFuc2l0aW9uKHRoaXMuc3RhdHVzQmVmb3JlSGFsdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMub25SZXN1bWUocHJvcHMpO1xuICAgICAgICAgICAgdGhpcy5fc2V0U3RhdGUodGhpcy5zdGF0dXNCZWZvcmVIYWx0KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3Jlc2V0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgLy8gdGhpcy5zdG9wKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2hlY2tTdGF0ZVRyYW5zaXRpb24oJ2lkbGUnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5ibG9ja2luZ1dhaXRpbmdzID0gW107XG5cbiAgICAgICAgICAgIHRoaXMudGltZXNFeGVjdXRlZCA9IDA7XG4gICAgICAgICAgICB0aGlzLl9zZXRTdGF0ZSgnaWRsZScpO1xuICAgICAgICAgICAgdGhpcy5vblJlc2V0KHByb3BzKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjb21wbGV0ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNwZWVkID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jaGVja1N0YXRlVHJhbnNpdGlvbignY29tcGxldGVkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWNrU3RhdGVUcmFuc2l0aW9uKCdpZGxlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5vbkJlZm9yZUNvbXBsZXRlKHByb3BzKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc3BlZWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0U3RhdGUoJ2NvbXBsZXRlZCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRTdGF0ZSgnaWRsZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5zcGVlZCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCA9IHRoaXMuZHVyYXRpb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3N0b3AnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5jaGVja1N0YXRlVHJhbnNpdGlvbigndHJhbnNpdGlvbmFsJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYmxvY2tpbmdXYWl0aW5ncyA9IFtdO1xuXG4gICAgICAgICAgICB0aGlzLnN0YXRlQmVmb3JlU3RvcCA9IHRoaXMuc3RhdGUgKyBcIlwiO1xuICAgICAgICAgICAgdGhpcy5fc2V0U3RhdGUoJ3RyYW5zaXRpb25hbCcpO1xuICAgICAgICAgICAgdGhpcy5vblN0b3AocHJvcHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVzdG9yZXMgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgSW5jaWRlbnQgYWZ0ZXIgYSBzdG9wXG4gICAgICAgICoqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZXN0b3JlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc3RvcmUoKSB7XG4gICAgICAgICAgICBpZiAoKHRoaXMuc3RhdGUgPT09ICd3YWl0aW5nJyB8fCB0aGlzLnN0YXRlID09PSAnYmxvY2tlZCcpICYmIHRoaXMuc3RhdGVCZWZvcmVTdG9wID09PSAncGxheWluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdhcm0nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXJtKCkge1xuICAgICAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWNrU3RhdGVUcmFuc2l0aW9uKCd3YWl0aW5nJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYmxvY2tpbmdXYWl0aW5ncyA9IFtdO1xuXG4gICAgICAgICAgICB0aGlzLl9kb250VGVsbE1hbWFTdGF0ZUNoYW5nZSgnd2FpdGluZycpO1xuICAgICAgICAgICAgdGhpcy5vbkFybShwcm9wcyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGVyZSBhcmUgdmFyaW91cyBldmVudHMgaGFwcGVuaW5nIG9uIHRoZSBzY29wZSBvZiBhbiBJbmNpZGVudC4gQW55IGNsYXNzIGV4dGVuZGluZyBJbmNpZGVudCBtaWdodCBoYXZlIC8gZGVmaW5lIGl0cyBvd25cbiAgICAgICAgICogZXZlbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgXCJicm9hZGNhc3RFdmVudFwiIG1ldGhvZCBvZiB0aGUgSW5jaWRlbnQgYWxsb3dzIHRoZSBJbmNpZGVudCAob2YgYW55IHR5cGUsIGV2ZW4gb24gY2xhc3NlcyBleHRlbmRpbmcgaXQpIGJyb2FkY2FzdFxuICAgICAgICAgKiBldmVudHMgb24gYW55IG9mIHRoZSBpbnRlcmVzdGVkIHBhcnRpZXMgdGhhdCBoYXZlIHN1YnNjcmliZWQgdG8gaXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBcInN1YnNjcmliZVRvRXZlbnRzXCIgbWV0aG9kIGFsbG93cyBhbnkgdGhpcmQgcGFydHkgc3Vic2NyaWJlIGFuZCBsaXN0ZW4gdG8gZXZlbnRzJyBicm9hZGNhc3RzIGJ5IGFueSBJbmNpZGVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSB0aGUgdW5pcXVlIGlkIG9mIHRoZSBldmVudCBsaXN0ZW5lclxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbmN0IC0gYSBmdW5jdGlvbiB0byBnZXQgZXhlY3V0ZWQgd2hlbmV2ZXIgYW4gZXZlbnQgZ2V0cyBicm9hZGNhc3RlZCBieSB0aGUgc3BlY2lmaWMgSW5jaWRlbnQuIFRoZVxuICAgICAgICAgKiAgZm5jdCB3aWxsIGJlIGV4ZWN1dGVkIG9uIGFsbCBldmVudHMnIGJyb2FkY2FzdHMgYW5kIGl0IHdpbGwgcmVjZWl2ZSB0aGUgZXZlbnQgb2JqZWN0IGFzIGFyZ3VtZW50LiBUaGUgZXZlbnQgb2JqZWN0IGlzXG4gICAgICAgICAqICBvZiBmb3JtYXQ6XG4gICAgICAgICAqICB7XG4gICAgICAgICAgICAgICAgbmFtZTogdGhlIG5hbWUgb2YgdGhlIGV2ZW50LFxuICAgICAgICAgICAgICAgIG1ldGE6IGFuIG9iamVjdCBob2xkaW5nIGFsbCB0aGUgbWV0YS1pbmZvIG9mIHRoZSBldmVudFxuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzdWJzY3JpYmVUb0V2ZW50cycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdWJzY3JpYmVUb0V2ZW50cyhpZCwgZm5jdCkge1xuICAgICAgICAgICAgdGhpcy5ldmVudHNTdWJzY3JpcHRpb25zW2lkXSA9IGZuY3Q7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogdW5zdWJzY3JpYmVzIGFueSBzdWJzY3JpYmVkIGxpc3RlbmVyIHRvIHRoZSBJbmNpZGVudCdzIGV2ZW50cyBicm9hZGNhc3RpbmdcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd1bnN1YnNjcmliZUZyb21FdmVudHMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdW5zdWJzY3JpYmVGcm9tRXZlbnRzKGlkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudHNTdWJzY3JpcHRpb25zW2lkXSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmV2ZW50c1N1YnNjcmlwdGlvbnNbaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGJyb2FkY2FzdHMgYW55IGV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG1ldGFcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Jyb2FkY2FzdEV2ZW50JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJyb2FkY2FzdEV2ZW50KGV2ZW50TmFtZSwgbWV0YSkge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuZXZlbnRzU3Vic2NyaXB0aW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzU3Vic2NyaXB0aW9uc1trZXldKGV2ZW50TmFtZSwgbWV0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2QncyAod2hpY2ggc2hvdWxkIGJlIGNhbGxlZCB3aGVuZXZlciBhIHNsaXAgZW5kcykgcHVycG9zZSBpcyB0byBjYWxjdWxhdGUgYW5kIHNldFxuICAgICAgICAgKiB0aGUgcmlnaHQgc3RhdGUgb2YgdGhlIEluY2lkZW50IGJhc2VkIG9uIHRoZSB0YXJnZXQgbWlsbGlzZWNvbmQuXG4gICAgICAgICAqIFRoZSBwYXJhbWV0ZXIgaXQgdGFrZXMgaXMgcmVsYXRpdmUgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgSW5jaWRlbnQgaXRzZWxmIGFuZCBpdCBtaWdodCBiZSBuZWdhdGl2ZVxuICAgICAgICAgKiBOZWdhdGl2ZSB0YXJnZXRNaWxsaXNlY29uZCBtZWFucyB0aGUgdGFyZ2V0IG1pbGxpc2Vjb25kIGlzIE4gbWlsbGlzZWNvbmRzIEJFRk9SRSB0aGUgc3RhcnQgb2YgdGhlIEluY2lkZW50XG4gICAgICAgICAqIEBwYXJhbSB7aW50fSB0YXJnZXRNaWxsaXNlY29uZERlbHRhRnJvbVN0YXJ0IC0gdGhlIGRlbHRhIG9mIHRoZSB0YXJnZXQgbWlsbGlzZWNvbmQgY29tcGFyZWQgdG8gdGhlIEluY2lkZW50IHN0YXJ0XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZWNhbGNTdGF0ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWNhbGNTdGF0ZSh0YXJnZXRNaWxsaXNlY29uZERlbHRhRnJvbVN0YXJ0KSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0TWlsbGlzZWNvbmREZWx0YUZyb21TdGFydCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgaXQgZW5kcyBiZWZvcmUgdGhlIHRhcmdldCBtaWxsaXNlY29uZFxuICAgICAgICAgICAgICAgIHRoaXMuX2RvbnRUZWxsTWFtYVN0YXRlQ2hhbmdlKCdjb21wbGV0ZWQnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgaXQgaGFzIGJlZW4gY29tcGxldGVkIG9uIHRhcmdldE1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgICAgdGhpcy5fZG9udFRlbGxNYW1hU3RhdGVDaGFuZ2UoJ2lkbGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVzaXplJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShkdXJhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zeXN0b2xEaWFzdG9sZShkdXJhdGlvbiAvIHRoaXMuZHVyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB0cnVlIH07XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3N5c3RvbERpYXN0b2xlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN5c3RvbERpYXN0b2xlKGR1cmF0aW9uRnJhY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdleHBvcnRTdGF0ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBleHBvcnRTdGF0ZSgpIHtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgIHZhciB0b0V4cG9ydCA9IHtcbiAgICAgICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgICAgICBjbGFzczogdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLFxuICAgICAgICAgICAgICAgIG1jX3BsdWdpbl9ucG1fbmFtZTogdGhpcy5tY19wbHVnaW5fbnBtX25hbWUsXG4gICAgICAgICAgICAgICAgY3VzdG9tUGFyYW1zOiB0aGlzLmN1c3RvbVBhcmFtcyxcbiAgICAgICAgICAgICAgICBhdHRyczogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5hdHRycyksXG4gICAgICAgICAgICAgICAgcHJvcHM6IE9iamVjdC5hc3NpZ24oeyBpZDogdGhpcy5pZCwgYXV0b2dlbmVyYXRlZElEOiB0cnVlIH0sIHRoaXMucHJvcHMpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgZXhwb3J0VHlwZSA9ICdsaXZlJztcbiAgICAgICAgICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgndHlwZScpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzLnR5cGUgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvRXhwb3J0LmluaXRpYWxWYWx1ZXMgPSB0aGlzLmluaXRpYWxWYWx1ZXM7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydFR5cGUgPSAnanNvbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXhwb3J0VHlwZSA9PT0gJ2xpdmUnKSB7XG4gICAgICAgICAgICAgICAgdG9FeHBvcnQucGx1Z2luX2NoYW5uZWxfY2xhc3MgPSB0aGlzLnBsdWdpbl9jaGFubmVsX2NsYXNzO1xuICAgICAgICAgICAgICAgIHRvRXhwb3J0LnN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgICAgICB0b0V4cG9ydC5JbmNpZGVudCA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0b0V4cG9ydDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgLyogUElQRVMgU1lTVEVNXG4gICAgICAgICAgICBUaGUgUGlwZXMgc3lzdGVtIGlzIGEgdmVydGljYWwgaW50ZXJjb25uZWN0aW9uIHN5c3RlbSB0aGF0IHJ1bnMgb3V0IHRoZSBmdWxsIEluY2lkZW50cyB0cmVlIGFuZCBjb25uZWN0cyBhbGwgb2YgdGhlbS5cbiAgICAgICAgICAgIFRocm91Z2ggUGlwZXMgYW55IEluY2lkZW50IGNhbiBjb21tdW5pY2F0ZSBhbnl0aGluZyB0byBhbGwgb2YgaXRzIGNoaWxkcmVuIG9yIHBhcmVudHMuXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIEluIG9yZGVyIHRvIGluaXRpYWxpc2UgYSBwaXBlIG1lc3NhZ2UgdGhlIHVzZXIgc2hvdWxkIHVzZSB0aGUgcHV0TWVzc2FnZU9uUGlwZSBtZXRob2QuIFRoaXMgbWV0aG9kIGlzIGV4cG9zZWQgYnkgYWxsXG4gICAgICAgICAgICAgICAgSW5jaWRlbnRzLCBvZiBhbGwgdHlwZXMsIGFuZCBpdCBpcyBmaXJzdCBiZWVuIHByb2Nlc3NlZCBieSB0aGUgcmVjZWl2ZXIgSW5jaWRlbnQgYW5kIHRoZW4gcGFzc2VkIGZ1cnRoZXIgZG93biB0b1xuICAgICAgICAgICAgICAgIGl0cyBjaGlsZHJlbiAoaWYgYW55KS5cbiAgICAgICAgICAgIFRoaXMgbWV0aG9kIHRha2VzIGV4YWN0bHkgNSBhcmd1bWVudHM6XG4gICAgICAgICAgICAtIG5hbWUgKHRoZSBuYW1lIG9mIHRoZSBjb21tYW5kKS4gVGhpcyBzaG91bGQgYmUgdW5pcXVlIGFtb25nIHRoZSBmdWxsIE1DIGVjb3N5c3RlbSBpbmNsdWRpbmcgbmF0aXZlIG1lc3NhZ2UgbmFtZXMgJiBcbiAgICAgICAgICAgICAgICBwbHVnaW5zJyBtZXNzYWdlIG5hbWVzLiBJbiBvcmRlciB0byBhdm9pZCBjb25mbGljdHMgaXMgZ29vZCB0byB1c2UgdGhlIGNvbnZlbnRpb246IDxwbHVnaW5fbnBtX25hbWU+LjxtZXNzYWdlX25hbWU+XG4gICAgICAgICAgICAtIHBhcmFtZXRlcnMgKGFuIG9iamVjdCBob2xkaW5nIHRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBjb21tYW5kKVxuICAgICAgICAgICAgLSBzZWxmRXhlY3V0ZSAodHJ1ZS9mYWxzZSkgLSBJZiB0cnVlIHRoZSBJbmNpZGVudCB3aWxsIHRyeSB0byBwcm9jZXNzIHRoZSBwaXBlIGNvbW1hbmQgYmVmb3JlIGZ1cnRoZXIgcGFzc2luZyBmdXJ0aGVyIHVwIG9yIGRvd25cbiAgICAgICAgICAgIC0gZGlyZWN0aW9uIChkZWZhdWx0IFwiZG93blwiKSAtIGRlZmluZXMgdGhlIGRpcmVjdGlvbiBvZiB0aGUgcGlwZSBjb21tYW5kLiBJdCBjYW4gYmUgZWl0aGVyIFwiZG93blwiIHNvIGl0IHBhc3NlcyBpdCBkb3duIHRvIFxuICAgICAgICAgICAgICAgIGl0cyBjaGlsZHJlbiBvciBcInVwXCIgc28gaXQgcGFzc2VzIGl0IHVwIHRvIGl0cyBwYXJlbnRzXG4gICAgICAgICAgICAtIHRhcmdldC4gVGhlIHRhcmdldCBkZWZpbmVzIC8gZGVzY3JpYmVzIHRoZSByZWNlaXZlcnMgb2YgdGhlIHBpcGUgbWVzc2FnZS4gVGhpcyBtaWdodCBiZTpcbiAgICAgICAgICAgICAgICAtIG51bGwgKGRlZmF1bHQpIC0gdGFyZ2V0cyBhbGwgaW5jaWRlbnRzXG4gICAgICAgICAgICAgICAgLSB0eXBlOiBcImdyb3VwXCIgLSB0YXJnZXRzIG9ubHkgZ3JvdXBzIChpbmNsdWRpbmcgY2xpcHMpXG4gICAgICAgICAgICAgICAgLSB0eXBlOiBcImNsaXBcIiAtIHRhcmdldHMgb25seSBjbGlwc1xuICAgICAgICAgICAgICAgIC0gdHlwZTogXCJyb290Q2xpcFwiIC0gdGFyZ2V0cyBvbmx5IHRoZSByb290IGNsaXAgb2YgdGhlIHRyZWVcbiAgICAgICAgICAgICAgICAtIGlkOiBcIjxpZD5cIiAtIHRhcmdldHMgYSBzcGVjaWZpYyBpbmNpZGVudCB3aXRoIHNwZWNpZmljIGlkXG4gICAgICAgICAgICAgICAgLSBwbHVnaW46IFwiPHBsdWdpbl9ucG1fbmFtZT5cIiAtIHRhcmdldHMgb25seSBJbmNpZGVudHMgb2YgYSBzcGVjaWZpYyBwbHVnaW5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgSGFuZGxpbmcgcGlwZSBtZXNzYWdlczpcbiAgICAgICAgICAgIFRoZSBwdXRNZXNzYWdlT25QaXBlIG1ldGhvZCBkZWNpZGVzIHdoZXRoZXIgaXQgc2hvdWxkIGJlIHByb2Nlc3NlZCBvclxuICAgICAgICAgICAgbm90IGJ5IHRoZSBJbmNpZGVudCBkZXBlbmRpbmcgb24gdGhlIHRhcmdldC4gVGhpcyBtZXRob2QgaXMgdGhlIF9wcm9jZXNzUGlwZU1lc3NhZ2UuIElmIHRoZSBJbmNpZGVudCBzaG91bGQgcHJvY2VzcyB0aGUgXG4gICAgICAgICAgICBwaXBlIG1lc3NhZ2UgdGhlIF9wcm9jZXNzUGlwZU1lc3NhZ2UgbWV0aG9kIGNhbGxzIHRoZSBcImhhbmRsZVBpcGVNZXNzYWdlXCIgbWV0aG9kIHBhc3NpbmcgdGhlIG5hbWUgYW5kIHRoZSBwYXJhbWV0ZXJzLlxuICAgICAgICAgICAgVGhlIFwiaGFuZGxlUGlwZU1lc3NhZ2VcIiBpcyBhIGJ1aWx0IGluIG1ldGhvZCBhcyB3ZWxsIGFuZCB0aGUgZGV2ZWxvcGVycyBzaG91bGQganVzdCBvdmVyd3JpdGUgaXQgc28gdGhleSBoYW5kbGUgdGhlIFxuICAgICAgICAgICAgdmFyaW91cyBwaXBlcyBtZXNzYWdlcyBiYXNlZCBvbiB0aGVpciBuYW1lcy5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgUGlwZSBtZXNzYWdlcyB0YXJnZXRpbmcgdGhlIGNsaXAgcmV0dXJuIGEgcmVzdWx0LlxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdwdXRNZXNzYWdlT25QaXBlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHB1dE1lc3NhZ2VPblBpcGUobmFtZSwgcGFyYW1zLCBzZWxmRXhlY3V0ZSwgZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBudWxsO1xuXG4gICAgICAgICAgICBpZiAoc2VsZkV4ZWN1dGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUGlwZU1lc3NhZ2UobmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0Lmhhc093blByb3BlcnR5KCd0eXBlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQudHlwZSA9PT0gJ2dyb3VwJyAmJiB0aGlzLmhhc0luY2lkZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUGlwZU1lc3NhZ2UobmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0LnR5cGUgPT09ICdjbGlwJyAmJiB0aGlzLmlzVGhlQ2xpcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUGlwZU1lc3NhZ2UobmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0LnR5cGUgPT09IFwicm9vdENsaXBcIiAmJiB0aGlzLmlzVGhlQ2xpcCAmJiAhdGhpcy5jaGVja1BhcmVudFNjZW5lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVQaXBlTWVzc2FnZShuYW1lLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldC5oYXNPd25Qcm9wZXJ0eSgnaWQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaWQgPT09IHRhcmdldC5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUGlwZU1lc3NhZ2UobmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0Lmhhc093blByb3BlcnR5KCdwbHVnaW4nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWNfcGx1Z2luX25wbV9uYW1lID09PSB0YXJnZXQucGx1Z2luKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVQaXBlTWVzc2FnZShuYW1lLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBcImRvd25cIiAmJiB0aGlzLmhhc0luY2lkZW50cykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmNpZGVudHNbaV0uaW5jaWRlbnQucHV0TWVzc2FnZU9uUGlwZShuYW1lLCBwYXJhbXMsIHRydWUsIGRpcmVjdGlvbiwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gXCJ1cFwiICYmIHRoaXMuY2hlY2tQYXJlbnRTY2VuZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRTY2VuZU9iamVjdC5wdXRNZXNzYWdlT25QaXBlKG5hbWUsIHBhcmFtcywgdHJ1ZSwgZGlyZWN0aW9uLCB0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdoYW5kbGVQaXBlTWVzc2FnZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVQaXBlTWVzc2FnZShuYW1lLCBwYXJhbXMpIHt9XG4gICAgICAgIC8vIFBsdWdpbnMgZGV2ZWxvcGVycyBjYW4gb3ZlcndyaXRlIHRoaXMgbWV0aG9kIHNvIHRoZXkgY2FuIGhhbmRsZSBwaXBlIG1lc3NhZ2VzIHBlciBuYW1lXG5cblxuICAgICAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIC8qIEJMT0NLSU5HIFdBSVRJTkdTXG4gICAgICAgIFRoZSB0cmlnZ2VyQmxvY2tpbmdXYXRpaW5nIG1ldGhvZCB0aGF0IGNhbiBiZSB1c2VkIGJ5IGFueSBJbmNpZGVudCBhdCBhbnkgdGltZS4gVGhlIEluY2lkZW50IGNhbiB0cmlnZ2VyIGEgYmxvY2tpbmcgd2FpdGluZy4gXG4gICAgICAgIFRoZSBcImJsb2NraW5nIHdhaXRpbmdzXCIgYmxvY2sgdGhlIHJvb3QgQ2xpcCdzIGV4ZWN1dGlvbiAocHV0cyBpdCB0byBibG9ja2VkIHN0YXRlKS4gXG4gICAgICAgIEFueSBibG9ja2luZyB3YWl0aW5nIGhhcyBhbiBpZCAoaXQgbXVzdCBiZSB1bmlxdWUpIGFuZCBpdCBjYW4gYmUgdW5ibG9ja2VkIGJ5IGFueSBJbmNpZGVudCBhdCBhbnkgdGltZSB0aHJvdWdoIHRoZSB0cmlnZ2VyVW5ibG9ja1xuICAgICAgICBtZXRob2Qgd2hpY2ggdGFrZXMgYW4gaWQgYW5kIHJlbW92ZXMgdGhlIGNvcnJlc3BvbmRpbmcgYmxvY2tpbmcgd2FpdGluZy4gXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RyaWdnZXJCbG9ja2luZ1dhdGlpbmcnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdHJpZ2dlckJsb2NraW5nV2F0aWluZyhpZCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgICAgIHBhcmFtcy5ibG9ja2luZ1dhaXRpbmdJRCA9IGlkO1xuICAgICAgICAgICAgdGhpcy5wdXRNZXNzYWdlT25QaXBlKHBpcGVNZXNzZ2VzLl9CTE9DS0lOR19XQUlUSU5HLCBwYXJhbXMsIHRydWUsIFwidXBcIiwgeyB0eXBlOiAncm9vdENsaXAnIH0pO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0cmlnZ2VyVW5ibG9jaycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0cmlnZ2VyVW5ibG9jayhpZCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBibG9ja2luZ1dhaXRpbmdJRDogaWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnB1dE1lc3NhZ2VPblBpcGUocGlwZU1lc3NnZXMuX1VOQkxPQ0tfV0FJVElORywgcGFyYW1zLCB0cnVlLCBcInVwXCIsIHsgdHlwZTogJ3Jvb3RDbGlwJyB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgLy8gQUNUVUFMIEJBSEFWSU9VUiBGVU5DVElPTlMgVEhBVCBTSE9VTEQgQkUgSU1QTEVNRU5URUQgQlkgQUxMIENMQVNTRVMgRVhURU5ESU5HIElOQ0lERU5UXG4gICAgICAgIC8vIHRoaXMgaXMgYSBjaGFuY2UgdG8gYmxvY2sgcGxheSBvZiBhbiBpbmNpZGVudCBieSByZXR1cm5pbmcgZmFsc2VcblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnb25CZWZvcmVQbGF5JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uQmVmb3JlUGxheSgpIHtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdvblBsYXknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25QbGF5KHByb3BzKSB7XG4gICAgICAgICAgICBoZWxwZXIuaW5mbygnT3ZlcndyaXR0ZSB0aGUgXCJvblBsYXlcIiBtZXRob2Qgd2l0aCB0aGUgY29kZSB5b3Ugd2FudCB0byBnZXQgZXhlY3V0ZWQnLCAnaW5mbycpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdvblJlc3VtZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblJlc3VtZShwcm9wcykge1xuICAgICAgICAgICAgaGVscGVyLmluZm8oJ092ZXJ3cml0dGUgdGhlIFwib25SZXN1bWVcIiBtZXRob2Qgd2l0aCB0aGUgY29kZSB5b3Ugd2FudCB0byBnZXQgZXhlY3V0ZWQnLCAnaW5mbycpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdvbkJlZm9yZVJlc3VtZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkJlZm9yZVJlc3VtZSgpIHtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IG5vcm1hbGlzZXMgdGhlIG1pbGxpc2Vjb25kIHRvIHBhc3MgdG8gdGhlIEluY2lkZW50cyBvbiBnb1RvXG4gICAgICAgICAqIElmIG1pbGxpc2Vjb25kIDwgMCBpdCBtYWtlcyBpdCAwXG4gICAgICAgICAqIElmIG1pbGxpc2Vjb25kID4gZHVyYXRpb24gb2YgdGhlIEluY2lkZW50IGl0IG1ha2VzIGl0IGVxdWFscyB0byB0aGUgZHVyYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtpbnR9IG1pbGxpc2Vjb25kIC0gdGhlIG1pbGxpc2Vjb25kIHRvIG5vcm1hbGlzZS4gSXQgcmVwcmVzZW50cyB0aGUgZGlzdGFuY2Ugb2YgdGhlIHRpbWUgdG8gZ28gdG8gZnJvbVxuICAgICAgICAgKiAgdGhlIHN0YXJ0IG9mIHRoZSBJbmNpZGVudFxuICAgICAgICAgKiBAcmV0dXJucyB7aW50fSAtIHRoZSBub3JtYWxpc2VkIG1pbGxpc2Vjb25kXG4gICAgICAgICoqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdub3JtYWxpc2VHb1RvVGFyZ2V0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG5vcm1hbGlzZUdvVG9UYXJnZXQobWlsbGlzZWNvbmQpIHtcbiAgICAgICAgICAgIGlmIChtaWxsaXNlY29uZCA8IDApIHtcbiAgICAgICAgICAgICAgICBtaWxsaXNlY29uZCA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1pbGxpc2Vjb25kID4gdGhpcy5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kID0gdGhpcy5kdXJhdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1pbGxpc2Vjb25kO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdvVG8gb24gdGhlIEluY2lkZW50IGxldmVsIGltcGxlbWVudHMgdGhlIGxvZ2ljIG9mIHBhc3NpbmcgdGhlIGF1dGhvcml0eSBvZiBleGVjdXRpb24gdG8gaXRzIHBhcmVudFxuICAgICAgICAgKiAoaWYgdGhlcmUgaXMgYW55KVxuICAgICAgICAgKiBJbmNpZGVudHMgdGhhdCBpbXBsZW1lbnQgdGhlaXIgb3duIGdvVG8gbG9naWMgc2hvdWxkIG92ZXJ3cml0ZSB0aGUgZ29UbyBtZXRob2Qgb3RoZXJ3aXNlIHRoZSBnb1RvXG4gICAgICAgICAqIHdpbGwgYmUgcGFzc2VkIHVwIHVudGlsIGVpdGhlciBpdCByZWFjaGVzIGEgY29udGV4dCBvd25lciBvciBhIHRyZWUgcm9vdFxuICAgICAgICAgKiBAcGFyYW0ge2ludH0gbWlsbGlzZWNvbmQgLSAob3B0aW9uYWwpIHRoZSBtaWxsaXNlY29uZCB3aGVyZSB3ZSB3YW50IHRvIGdvVG8uIElmIG5vdCBwcm92aWRlZCB3ZSB1c2UgdGhlIGN1cnJlbnQgbWlsbGlzZWNvbmQgb2YgdGhlIEluY2lkZW50XG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIGlmIHRoZSBjb250ZXh0IG93bmVyIG9mIHRoZSBJbmNpZGVudCBhY3R1YWxseSBleGVjdXRlcyB0aGUgZ29UbyBjb21tYW5kIHRoZVxuICAgICAgICAgKiAgbWV0aG9kIHJldHVybnMgdHJ1ZSBvdGhlcndpc2UgaXQgcmV0dXJucyBmYWxzZVxuICAgICAgICAqKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ29UbycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnb1RvKG1pbGxpc2Vkb25kKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgaW5jaWRlbnQgaGFzIGEgcGFyZW50IHNjZW5lXG4gICAgICAgICAgICBpZiAodGhpcy5jaGVja1BhcmVudFNjZW5lKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnRTY2VuZU9iamVjdC5nb1RvKG1pbGxpc2Vkb25kLCB7IHJlbGF0aXZlVG86IHRoaXMuaWQgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIG1pbGxpc2Vjb25kcyBkZWx0YSBiZXR3ZWVuIHRoZSBJbmNpZGVudCdzIHN0YXJ0IHBvaW50IGFuZCBpdHMgcm9vdCBTY2VuZSdzIGN1cnJlbnQgbWlsbGlzZWNvbmQuXG4gICAgICAgICAqIElmIHRoZSByZXN1bHQgaXMgbmVnYXRpdmUgaXQgbWVhbnMgdGhlIHJvb3Qgc2NlbmUncyBjdXJyZW50IG1pbGxpc2Vjb25kIGlzIHByaW9yIHRvIHRoZSBJbmNpZGVudCdzIHN0YXJ0IHBvaW50XG4gICAgICAgICAqIEByZXR1cm5zIHtpbnR9XG4gICAgICAgICoqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRSb290Q3VycmVudE1pbGxpc2Vjb25kRGVsdGFGcm9tU3RhcnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Um9vdEN1cnJlbnRNaWxsaXNlY29uZERlbHRhRnJvbVN0YXJ0KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tQYXJlbnRTY2VuZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50U2NlbmVPYmplY3QuZ2V0Um9vdEN1cnJlbnRNaWxsaXNlY29uZERlbHRhRnJvbUluY2lkZW50c1N0YXJ0KHRoaXMuaWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2JlT24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYmVPbihtaWxsaXNlY29uZCkge1xuICAgICAgICAgICAgdmFyIGdvVG8gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG5cbiAgICAgICAgICAgIHZhciBwcmV2aW91c1N0YXRlID0gdGhpcy5zdGF0ZSArIFwiXCI7XG4gICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICAgIGlmIChnb1RvKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nb1RvKG1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudE1pbGxpc2Vjb25kKG1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgIHRoaXMucmVjYWxjU3RhdGUobWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgdmFyIG5ld1N0YXRlID0gdGhpcy5zdGF0ZSArIFwiXCI7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzU3RhdGU6IHByZXZpb3VzU3RhdGUsXG4gICAgICAgICAgICAgICAgbmV3U3RhdGU6IG5ld1N0YXRlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfb25HZXRDb250ZXh0T25jZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25HZXRDb250ZXh0T25jZSgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5nb3RDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkdldENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdvdENvbnRleHQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdvbkdldENvbnRleHQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25HZXRDb250ZXh0KCkge1xuICAgICAgICAgICAgaGVscGVyLmluZm8oJ092ZXJ3cml0dGUgdGhlIFwib25HZXRDb250ZXh0XCIgbWV0aG9kIHdpdGggdGhlIGNvZGUgeW91IHdhbnQgdG8gZ2V0IGV4ZWN1dGVkJywgJ2luZm8nKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnb25TdG9wJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uU3RvcChwcm9wcykge1xuICAgICAgICAgICAgaGVscGVyLmluZm8oJ092ZXJ3cml0dGUgdGhlIFwib25CZWZvcmVTdG9wXCIgbWV0aG9kIHdpdGggdGhlIGNvZGUgeW91IHdhbnQgdG8gZ2V0IGV4ZWN1dGVkJywgJ2luZm8nKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnb25SZXNldCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblJlc2V0KHByb3BzKSB7XG4gICAgICAgICAgICBoZWxwZXIuaW5mbygnT3ZlcndyaXR0ZSB0aGUgXCJvblJlc2V0XCIgbWV0aG9kIHdpdGggdGhlIGNvZGUgeW91IHdhbnQgdG8gZ2V0IGV4ZWN1dGVkJywgJ2luZm8nKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnb25CZWZvcmVDb21wbGV0ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkJlZm9yZUNvbXBsZXRlKHByb3BzKSB7XG4gICAgICAgICAgICBoZWxwZXIuaW5mbygnT3ZlcndyaXR0ZSB0aGUgXCJvbkJlZm9yZUVuZFwiIG1ldGhvZCB3aXRoIHRoZSBjb2RlIHlvdSB3YW50IHRvIGdldCBleGVjdXRlZCcsICdpbmZvJyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ29uQmxvY2snLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25CbG9jayhwcm9wcykge1xuICAgICAgICAgICAgaGVscGVyLmluZm8oJ092ZXJ3cml0dGUgdGhlIFwib25CbG9ja1wiIG1ldGhvZCB3aXRoIHRoZSBjb2RlIHlvdSB3YW50IHRvIGdldCBleGVjdXRlZCcsICdpbmZvJyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ29uVW5ibG9jaycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblVuYmxvY2socHJvcHMpIHtcbiAgICAgICAgICAgIGhlbHBlci5pbmZvKCdPdmVyd3JpdHRlIHRoZSBcIm9uVW5ibG9ja1wiIG1ldGhvZCB3aXRoIHRoZSBjb2RlIHlvdSB3YW50IHRvIGdldCBleGVjdXRlZCcsICdpbmZvJyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ29uV2FpdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbldhaXQocHJvcHMpIHtcbiAgICAgICAgICAgIGhlbHBlci5pbmZvKCdPdmVyd3JpdHRlIHRoZSBcIm9uV2FpdFwiIG1ldGhvZCB3aXRoIHRoZSBjb2RlIHlvdSB3YW50IHRvIGdldCBleGVjdXRlZCcsICdpbmZvJyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ29uQXJtJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uQXJtKHByb3BzKSB7XG4gICAgICAgICAgICBoZWxwZXIuaW5mbygnT3ZlcndyaXR0ZSB0aGUgXCJvbkFybVwiIG1ldGhvZCB3aXRoIHRoZSBjb2RlIHlvdSB3YW50IHRvIGdldCBleGVjdXRlZCcsICdpbmZvJyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2xhc3RXaXNoJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxhc3RXaXNoKCkge1xuICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ29uSW5pdGlhbGlzZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkluaXRpYWxpc2UoYXR0cnMsIHByb3BzKSB7XG4gICAgICAgICAgICBoZWxwZXIuaW5mbygnT3ZlcndyaXR0ZSB0aGUgXCJvbkluaWFsaXNlXCIgbWV0aG9kIHdpdGggdGhlIGNvZGUgeW91IHdhbnQgdG8gZ2V0IGV4ZWN1dGVkJywgJ2luZm8nKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnb25TcGVlZENoYW5nZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblNwZWVkQ2hhbmdlKHNwZWVkKSB7XG4gICAgICAgICAgICBoZWxwZXIuaW5mbygnT3ZlcndyaXR0ZSB0aGUgXCJvblNwZWVkQ2hhbmdlXCIgbWV0aG9kIHdpdGggdGhlIGNvZGUgeW91IHdhbnQgdG8gZ2V0IGV4ZWN1dGVkJywgJ2luZm8nKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaXNPblRlc3RNb2RlJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGVja1BhcmVudFNjZW5lKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRTY2VuZU9iamVjdC5pc09uVGVzdE1vZGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRlc3RNb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzZWxlY3RvcicsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuc2VsZWN0b3I7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBzaG9ydGN1dHMgZm9yIGF0dHJzLmF0dHJzIGFuZCBhdHRycy5hbmltYXRlZEF0dHJzICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2FuaW1BdHRyaWJ1dGVzJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRycy5hbmltYXRlZEF0dHJzO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjb25mQXR0cmlidXRlcycsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cnMuYXR0cnM7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2lzSGVhZGxlc3NDbGlwJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuY2hlY2tQYXJlbnRTY2VuZSgpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjb250ZXh0JyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGVja1BhcmVudFNjZW5lKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRTY2VuZU9iamVjdC5jb250ZXh0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZWxlbWVudCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5nZXRFbGVtZW50QnlNQ0lEKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5nZXRFbGVtZW50QnlNQ0lEKHRoaXMucHJvcHMubWNpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LmdldEVsZW1lbnRzKHRoaXMuc2VsZWN0b3IpWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgLypcbiAgICAgICAgcmV0dXJucyB0aGUgaW5pdGlhbGlzZWQgY2hhbm5lbCBieSB0aGUgQ2xpcCB0aGUgSW5jaWRlbnQgYmVsb25ncyB0b1xuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjaGFubmVsJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGVja1BhcmVudFNjZW5lKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRTY2VuZU9iamVjdC5fZ2V0Q2hhbm5lbCh0aGlzLm1jX3BsdWdpbl9ucG1fbmFtZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdlbGVtZW50cycsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5nZXRFbGVtZW50cyh0aGlzLnNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZXhlY3V0aW9uU3BlZWQnLFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChzcGVlZCkge1xuICAgICAgICAgICAgdGhpcy5zcGVlZCA9IHBhcnNlRmxvYXQoc3BlZWQpO1xuICAgICAgICAgICAgdGhpcy5vblNwZWVkQ2hhbmdlKHNwZWVkKTtcbiAgICAgICAgICAgIC8vIHRoaXMuYmVPbih0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0cyB0aGUgSW5jaWRlbnQncyBkdXJhdGlvbi4gVGhpcyBtZXRob2Qgc2hvdWxkIGJlIG92ZXJ3cml0ZW4gYWNjb3JkaW5nbHkgYnkgYWxsIEluY2lkZW50c1xuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZHVyYXRpb24nLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChkdXJhdGlvbikge1xuICAgICAgICAgICAgO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzdGF0ZScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnVuVGltZUluZm8uc3RhdGU7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2RpcmVjdGlvbicsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3BlZWQgPiAwID8gXCJmb3J3YXJkc1wiIDogXCJiYWNrd2FyZHNcIjtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBJbmNpZGVudDtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmNpZGVudDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Incident.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/TimedIncident.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/TimedIncident.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Incident = __webpack_require__(/*! ./Incident */ \"./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Incident.js\");\nvar Helper = __webpack_require__(/*! ../_coreUtils//Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar isTimePausingState = __webpack_require__(/*! ../configuration/allowedStateChanges */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/allowedStateChanges.js\").isTimePausingState;\n\n/** @classdesc\n * A TimedIncident is an incident that lasts some time. It has duration and a timer of its own. It can take all the states.\n *\n */\n\nvar TimedIncident = function (_Incident) {\n    _inherits(TimedIncident, _Incident);\n\n    function TimedIncident() {\n        var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        _classCallCheck(this, TimedIncident);\n\n        /**\n         * @member {object} - repeat\n         * - times: the repeatFactor property defines the times an Incident should be executed repeatedly.\n         * For Bit Inicdents this is not acceptable as Bit Incidents have 0 duration and thus positioning them on a chain\n         * the one after the other doesn't make sense.\n         * This property has practical value on TimedIncidents.\n         * In any case the default value of this member is 1 and it can only accept unsigned integer values\n         * - delay: the left gap in milliseconds\n         * - gap: the right gap in milliseconds\n        */\n        var _this = _possibleConstructorReturn(this, (TimedIncident.__proto__ || Object.getPrototypeOf(TimedIncident)).call(this, attrs, props));\n\n        _this.repeat = {\n            times: 1,\n            delay: 0,\n            hiatus: 0\n        };\n        _this.repetationDuration = _this.props.duration;\n        if (props.hasOwnProperty('repeat')) {\n            if (props.repeat.hasOwnProperty('times')) {\n                _this.repeat.times = props.repeat.times;\n            }\n            if (props.repeat.hasOwnProperty('delay')) {\n                _this.repeat.delay = props.repeat.delay;\n                _this.repetationDuration += props.repeat.delay;\n            }\n            if (props.repeat.hasOwnProperty('hiatus')) {\n                _this.repeat.hiatus = props.repeat.hiatus;\n                _this.repetationDuration += props.repeat.hiatus;\n            }\n        }\n\n        _this.resetState();\n\n        /**\n          @member {object} - listeners are functions to be executed on time change of the Timed Incident. It has the following format:\n           listeners: {\n            listener_id: {\n                     funct : the function to be executed\n                     threshold : the threshold of delta\n                     roundTo : round millisecond\n                 },\n                 listener_id: {\n                     funct : the function to be executed\n                     threshold : the threshold of delta\n                     roundTo : round millisecond\n                 },\n                 ...\n           }\n           */\n        _this.listeners = {};\n\n        _this.bitIncident = false;\n        return _this;\n    }\n\n    _createClass(TimedIncident, [{\n        key: 'requestAnimaFrame',\n        value: function requestAnimaFrame(fn) {\n            /* if the Incident is on test mode we want to prevent requestAnimationFrame as execution\n                during testing is controlled through emulateStep method */\n            if (this.isOnTestMode) {\n                return function () {};\n            }\n\n            try {\n                return this.context.window.requestAnimationFrame(fn);\n            } catch (e) {\n                helper.error('Your browser does not support requestAnimationFrame');\n                return function (fn) {};\n            }\n        }\n\n        /**\n         * when the Incident is on test mode (this.isOnTestMode = true) the emulateStep method\n         * becomes functional.\n         * The method takes as input the millisecondsDelta from the previous timestamp and triggers\n         * the step function passing in a baked timestamp so the Incident behaves exactly as if the requestAnimationFrame run\n         * passing a timestamp that has exactly millisecondsDelta difference from the previous one\n         * @param {int} millisecondsDelta - the milliseconds difference between the previous timestamp and the new one\n        */\n\n    }, {\n        key: 'emulateStep',\n        value: function emulateStep(millisecondsDelta) {\n            if (!this.isOnTestMode) {\n                helper.error('emulateStep method can only be used on test mode');\n            } else {\n                this.step(this.runTimeInfo.previousTimeStamp + millisecondsDelta);\n            }\n        }\n\n        /**\n         * All TimedIncidents must implement the get duration method\n        **/\n\n    }, {\n        key: 'checkResizedIncident',\n\n\n        /**\n         * checks if a duration edit is feasible and doesn't cause conflicts\n         * @param {int} duration - the new duration\n        **/\n        value: function checkResizedIncident(durationFraction, incident) {\n            var adjustMillisecond = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n            if (this.isHeadlessClip) {\n                return { result: true, execute: function execute() {} };\n            } else {\n                // IF THE GROUP HAS NO PARENT (ACT AS THE CLIP)\n                return this.parentSceneObject.checkResizedIncident(durationFraction, incident, adjustMillisecond + this.parentSceneObject.getIncidentMillisecond(this.id));\n            }\n        }\n\n        /**\n         * Edits the total duration of the Incident, as this is calculated based on the sum of delay, duration and hiatus\n         * @param {int} duration - the new duration in milliseconds\n        **/\n\n    }, {\n        key: 'resize',\n        value: function resize(duration) {\n            // console.trace();\n            // don't waste cpu resources if the new duration equals the current value\n            if (duration === this.duration) {\n                return { result: true };\n            } else if (duration <= 0) {\n                helper.error('resizeIncident method of Scene only accepts integers > 0 as the new duration of the Scene. ' + duration + ' provided.');\n                return {\n                    result: false\n                };\n            }\n            // stop the execution\n            this.stop();\n\n            var editCheck = this.checkResizedIncident(duration / this.duration, this);\n\n            if (editCheck.result === false) {\n                helper.error(editCheck);\n                return editCheck;\n            }\n\n            this.systolDiastole(duration / this.duration);\n            editCheck.execute();\n\n            if (this.checkParentScene()) {\n                this.parentSceneObject.getDurationAfterIncidentAffected();\n            }\n            this.broadcastEvent('duration-change', { newDuration: this.duration });\n            return { result: true };\n        }\n\n        /**\n         * This method edits the duration params. As \"duration params\" we define:\n         * - the props.duration\n         * - the props.repeat (with all of its keys: times, delay, hiatus)\n         * @param {object} params - An object that accepts at least one of the following keys:\n         * - duration\n         * - times\n         * - delay\n         * - hiatus\n        */\n\n    }, {\n        key: 'editDurationParams',\n        value: function editDurationParams(params) {\n            // stop the execution\n            this.stop();\n\n            // calculate the new values for props.duration and props.repeat\n            var newPropsDuration = this.props.duration;\n            if (params.hasOwnProperty('duration')) {\n                newPropsDuration = params.duration;\n            }\n            var newRepeat = JSON.parse(JSON.stringify(this.repeat));\n            if (params.hasOwnProperty('times')) {\n                newRepeat.times = params.times;\n            }\n            if (params.hasOwnProperty('delay')) {\n                newRepeat.delay = params.delay;\n            }\n            if (params.hasOwnProperty('hiatus')) {\n                newRepeat.hiatus = params.hiatus;\n            }\n\n            // calculate the new total duration\n            var newTotalDuration = newRepeat.times * (newPropsDuration + newRepeat.delay + newRepeat.hiatus);\n\n            // check the edit\n            var editCheck = {\n                result: true,\n                execute: function execute() {}\n            };\n            if (newTotalDuration != this.duration) {\n                editCheck = this.checkResizedIncident(newTotalDuration / this.duration, this);\n            }\n\n            if (editCheck.result === false) {\n                helper.error(editCheck);\n                return editCheck;\n            }\n\n            // update the Incident's values\n            this.props.duration = newPropsDuration;\n            this.repeat = newRepeat;\n\n            editCheck.execute();\n\n            if (this.checkParentScene() && newTotalDuration != this.duration) {\n                this.parentSceneObject.getDurationAfterIncidentAffected();\n                this.broadcastEvent('duration-change', { newDuration: this.duration });\n            }\n\n            return { result: true };\n        }\n    }, {\n        key: 'systolDiastole',\n        value: function systolDiastole(durationFraction) {\n            this.duration = this.duration * durationFraction;\n        }\n    }, {\n        key: 'resetState',\n        value: function resetState() {\n            _get(TimedIncident.prototype.__proto__ || Object.getPrototypeOf(TimedIncident.prototype), 'resetState', this).call(this);\n            // the current millisecond having as 0 the start of the animation\n            if (this.state === 'idle') this.runTimeInfo.currentMillisecond = 0; // the current millisecond of the incident as it's calculated based on the speed of the Incident\n            else if (this.state === 'completed') this.runTimeInfo.currentMillisecond = this.duration;\n            // in other words the millisecond that the Incident is on the UI\n            this.runTimeInfo.start = null; // the millisecond started as provided by requestAnimationFrame\n            this.runTimeInfo.previousTimeStamp = null; // the timestamp of the previous circle as provided by requestAnimationFrame\n            this.runTimeInfo.pauseMoment = null; // the pause moment as provided by new Date().getTime()\n            this.runTimeInfo.pauseMillisecond = 0; // the pauseMillisecond is the current millisecond at the pause moment\n            for (var key in this.listeners) {\n                this.listeners[key].cavaDelta = 0;\n            }\n        }\n\n        /**\n         * This method calculates the previousTimeStamp based on the target UI millisecond we want to go to and\n         * the speed of the Incident.\n         * E.g. if targetUIMillisecond = 2000 and speed =2 then we will take the timestamp from requestAnimationFrame (ra_stamp) and\n         * set the previousMillisecond to ra_stamp-1000\n         * @param {int} currentMIllisecond - the millisecond to which we want our Inicdent to be on\n        */\n\n    }, {\n        key: 'programmaticSetPreviousTimeStamp',\n        value: function programmaticSetPreviousTimeStamp(targetUIMillisecond) {\n            var _this2 = this;\n\n            var that = this;\n\n            if (this.isOnTestMode) {\n                that.runTimeInfo.previousTimeStamp = 0;\n            }\n\n            this.requestAnimaFrame(function (timestamp) {\n                that.runTimeInfo.previousTimeStamp = timestamp - targetUIMillisecond / _this2.speed;\n            });\n        }\n\n        // ******** INCIDENT METHODS IMPLEMENTATION **************\n        // *******************************************************\n\n    }, {\n        key: 'play',\n        value: function play() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            if (!this.onBeforePlay(props)) {\n                return false;\n            }\n            if (!this.checkStateTransition('playing')) {\n                return false;\n            }\n\n            var that = this;\n            this._setState('playing');\n            this.onPlay(props);\n\n            if (!this.isOnTestMode) {\n                this.requestAnimaFrame(function (timestamp) {\n                    that.step(timestamp, props);\n                }.bind(that));\n            } else {\n                this.runTimeInfo.previousTimeStamp = 0;\n                this.emulateStep(props.startFrom);\n            }\n        }\n    }, {\n        key: 'complete',\n        value: function complete() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            _get(TimedIncident.prototype.__proto__ || Object.getPrototypeOf(TimedIncident.prototype), 'complete', this).call(this);\n            this.resetState();\n        }\n\n        // timer blocking\n\n    }, {\n        key: 'wait',\n        value: function wait(props, waitCallerId) {\n            var previousState = this.runTimeInfo.state;\n            if (_get(TimedIncident.prototype.__proto__ || Object.getPrototypeOf(TimedIncident.prototype), 'wait', this).call(this, props, waitCallerId)) {\n                if (!isTimePausingState(previousState)) {\n                    this.runTimeInfo.pauseMillisecond = this.runTimeInfo.currentMillisecond * 1;\n                    this.runTimeInfo.pauseMoment = new Date().getTime();\n                }\n                return true;\n            }\n            return false;\n        }\n\n        // timer blocking\n\n    }, {\n        key: 'block',\n        value: function block(props) {\n            var previousState = this.runTimeInfo.state;\n            if (_get(TimedIncident.prototype.__proto__ || Object.getPrototypeOf(TimedIncident.prototype), 'block', this).call(this, props)) {\n                if (!isTimePausingState(previousState)) {\n                    this.runTimeInfo.pauseMillisecond = this.runTimeInfo.currentMillisecond * 1;\n                    this.runTimeInfo.pauseMoment = new Date().getTime();\n                }\n                return true;\n            }\n            return false;\n        }\n\n        // timer unblocking\n\n    }, {\n        key: 'resume',\n        value: function resume(props) {\n            if (_get(TimedIncident.prototype.__proto__ || Object.getPrototypeOf(TimedIncident.prototype), 'resume', this).call(this, props)) {\n                var delta = new Date().getTime() - this.runTimeInfo.pauseMoment;\n                this.runTimeInfo.previousTimeStamp += delta;\n                this.requestAnimaFrame(this.step.bind(this));\n                return true;\n            }\n            return false;\n        }\n    }, {\n        key: 'reset',\n        value: function reset(props) {\n            if (_get(TimedIncident.prototype.__proto__ || Object.getPrototypeOf(TimedIncident.prototype), 'reset', this).call(this, props)) {\n                this.resetState();\n            }\n\n            return false;\n        }\n    }, {\n        key: 'stop',\n        value: function stop(props) {\n            if (_get(TimedIncident.prototype.__proto__ || Object.getPrototypeOf(TimedIncident.prototype), 'stop', this).call(this, props)) {\n                return true;\n            }\n            return false;\n        }\n    }, {\n        key: 'arm',\n        value: function arm(props) {\n            if (_get(TimedIncident.prototype.__proto__ || Object.getPrototypeOf(TimedIncident.prototype), 'arm', this).call(this, props)) {\n                // sets the pause moment to the current time...\n                this.runTimeInfo.pauseMoment = new Date().getTime();\n                var that = this;\n\n                this.programmaticSetPreviousTimeStamp(0);\n                this.runTimeInfo.currentMillisecond = props.targetMillisecondDeltaFromStart;\n                this.runTimeInfo.pauseMillisecond = this.runTimeInfo.currentMillisecond * 1;\n                return true;\n            }\n            return false;\n        }\n\n        // *******************************************************\n        // STEP FUNCTION\n        // Step method is identical for Groups and thus we use the \"hasIncidents\" flag to check whether the Incident is a Group or a TimeIncident\n\n    }, {\n        key: 'step',\n        value: function step(timestamp) {\n            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n            var that = this;\n\n            // start from is the number of milliseconds elapsed from the actual starting point of the Incident caused mainly\n            // by CPU performance. (each requestAnimationFrame cirlce doesn't happen every one millisecond\n            // so an Incident that was supposed to start on millisecond 100 of a Group might get fired 10 milliseconds later than\n            // its actual starting point, so tth startFrom will be 10)\n            if (props != null) {\n                var startFrom = props.startFrom;\n                if (!props.hasOwnProperty('startFrom')) {\n                    if (this.direction === \"forwards\") {\n                        startFrom = 0;\n                    } else {\n                        startFrom = this.duration;\n                    }\n                }\n\n                if (this.speed > 0) {\n                    this.runTimeInfo.previousTimeStamp = timestamp - startFrom / this.speed;\n                } else {\n                    this.runTimeInfo.previousTimeStamp = timestamp - (this.duration - startFrom) / Math.abs(this.speed);\n                }\n            }\n\n            var informListeners = function informListeners(progress) {\n                for (var key in that.listeners) {\n                    var listner = that.listeners[key];\n                    if (Math.abs(progress.milliseconds + listner.cavaDelta - that.runTimeInfo.currentMillisecond) > listner.threshold) {\n                        listner.funct(progress.milliseconds, timestamp, helper.roundNumberTo(listner.roundTo));\n                        listner.cavaDelta = 0;\n                    } else {\n                        listner.cavaDelta += Math.abs(progress.milliseconds - that.runTimeInfo.currentMillisecond);\n                    }\n                }\n            };\n\n            // helper.log('got into step on ' + this.id);\n            if (this.runTimeInfo.state !== 'playing') {\n                return;\n            }\n\n            // progressStep is the progress made from previousTimeStamp both in milliseconds and in fraction [0 to 1]\n            var overall_progress = {\n                milliseconds: Math.round(this.runTimeInfo.currentMillisecond + (timestamp - this.runTimeInfo.previousTimeStamp) * this.speed),\n                fraction: (this.runTimeInfo.currentMillisecond + (timestamp - this.runTimeInfo.previousTimeStamp) * this.speed) / this.duration\n            };\n            // the repeatation_progress is the progress made for just the running Incident\n            var timeInRepatation = overall_progress.milliseconds % this.repetationDuration - this.repeat.delay;\n            if (timeInRepatation < 0) {\n                // that means the current millisecond is on the delay\n                timeInRepatation = 0;\n            } else if (timeInRepatation > this.props.duration) {\n                // that means the current millisecond is on the hiatus\n                timeInRepatation = this.props.duration;\n            }\n            var repeatation_progress = {\n                milliseconds: timeInRepatation,\n                fraction: timeInRepatation / this.props.duration\n                // helper.notice(`calculation properties of progress for ${this.id}`);\n                // helper.log(`this.runTimeInfo.currentMillisecond: ${this.runTimeInfo.currentMillisecond}, timestamp: ${timestamp}, this.runTimeInfo.previousTimeStamp: ${this.runTimeInfo.previousTimeStamp}`)\n\n                // helper.log(this.id, progress);\n\n            };if (overall_progress.fraction >= 1) {\n                this.onProgress(1, this.props.duration);\n                informListeners({ fraction: 1, milliseconds: this.duration });\n                this.complete();\n                return;\n            } else if (overall_progress.fraction < 0) {\n                this.onProgress(0, 0);\n                informListeners({ fraction: 0, milliseconds: 0 });\n                this._dontTellMamaStateChange('idle');\n                this.broadcastEvent('state-change', { oldState: \"playing\", newState: \"idle\" });\n                this.resetState();\n                return;\n            }\n\n            this.onProgress(repeatation_progress.fraction, repeatation_progress.milliseconds);\n\n            // helper.log(this.id);\n            // helper.log(this.runTimeInfo.currentMillisecond);\n            // helper.log(this.id + ' progress: ', progress);\n            // handle listeners\n            informListeners(repeatation_progress);\n\n            this.runTimeInfo.currentMillisecond = overall_progress.milliseconds;\n            this.runTimeInfo.previousTimeStamp = timestamp;\n\n            // helper.log(this.runTimeInfo.currentMillisecond);\n\n            // helper.log('this.runtimeInfo.state on ' + this.id + ' = ' + this.runTimeInfo.state);\n            this.requestAnimaFrame(that.step.bind(that));\n        }\n\n        // ***** PUB SUB ***********\n        // *************************\n\n        /** Scene is responsible for knowing the time of it at any given moment. Also it acts as the single pipeline\n          that transfers play, wait, resume, goto requests from to its Incidents.\n          Scene is responsible for distributing the time information to any interested party\n           In order for any Class / module to be aware about the time of any Scene it should subscribe to its dispatch functions\n          By subscribing a module can get notified about changes on the Scene's time\n           subscribe method subscribes a function to the time change dispatcher. As Scene uses requestAnimationFrame for its timing\n          each cyrcle / step gets the current time and subtracts the previous time so it know how many milliseconds has elapsed\n          since last step. Subscribers can set to get informed about time changes only if the delta is greater than a given\n          number (e.g. greater than 300ms). That property is passed as the second argument \"threshold\".\n          Finally if any of the subscribers want the Scene to provide back a rounded number of the milliseconds. Options:\n            - 1 (round it on its actual units\n           - 10 (round it on tenths)\n           - 100 (round it on hundreds)\n           - 1000 (round it on thousands)\n           the first argument provides an id to the listener for future reference (deletion etc)\n          the second argument is a function that takes two arguments: millisecond, state (current millisecond of the Scene\n          and the state of it  */\n\n    }, {\n        key: 'subscribe',\n        value: function subscribe(id, funct, threshold, roundTo) {\n            if (!threshold) {\n                threshold = 0;\n            }\n            if (!roundTo) {\n                roundTo = 1; // round second to its units, meaning leave it as it is\n            }\n            this.listeners[id] = {\n                funct: funct,\n                threshold: threshold,\n                roundTo: roundTo,\n                cavaDelta: 0\n            };\n        }\n\n        /**\n         * This method's (which should be called whenever a slip ends) purpose is to calculate and set\n         * the right state of the Incident based on the target millisecond.\n         * The parameter it takes is relative to the beginning of the Incident itself and it might be negative\n         * Negative targetMillisecond means the target millisecond is N milliseconds BEFORE the start of the Incident\n         * @param {int} targetMillisecondDeltaFromStart - the delta of the target millisecond compared to the Incident start\n         */\n\n    }, {\n        key: 'recalcState',\n        value: function recalcState() {\n            var targetMillisecondDeltaFromStart = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            if (targetMillisecondDeltaFromStart === null) {\n                targetMillisecondDeltaFromStart = this.runTimeInfo.currentMillisecond;\n            }\n            // helper.log('recalculating state for Incident: ' + this.id, targetMillisecondDeltaFromStart);\n            if (targetMillisecondDeltaFromStart >= this.duration) {\n                // if it ends before the targetMillisecond\n                // helper.log('completes');\n                this.statusBeforeHalt = \"completed\";\n                this.runTimeInfo.currentMillisecond = this.duration;\n                this._dontTellMamaStateChange('completed');\n            } else if (targetMillisecondDeltaFromStart <= this.duration && targetMillisecondDeltaFromStart > 0) {\n                // if the targetMillisecond is in the middle of it\n                if (this.state === 'playing') {\n                    return;\n                }\n                this.statusBeforeHalt = \"playing\";\n                this.arm({ targetMillisecondDeltaFromStart: targetMillisecondDeltaFromStart });\n            } else if (targetMillisecondDeltaFromStart <= 0) {\n                // if it has been completed on targetMillisecond\n                // helper.log('resets to idle');\n                this.statusBeforeHalt = \"idle\";\n                this.runTimeInfo.currentMillisecond = 0;\n                this._dontTellMamaStateChange('idle');\n                this.resetState();\n            }\n        }\n\n        /**\n         * Method called on progress of the timed incident.\n         * @param {float} fraction - a number from 0 to 1 representing the fraction of duration covered\n         * @param {int} milliseconds - the number of milliseconds passed from start of the incident\n        */\n\n    }, {\n        key: 'onProgress',\n        value: function onProgress(fraction, milliseconds) {}\n\n        /**\n         * This method is the all external parties should call when they want to force the Incident to progress\n         * on a specific fraction & millisecond\n         * @param {float} fraction - a number from 0 to 1 representing the fraction of duration covered\n         * @param {int} milliseconds - the number of milliseconds passed from start of the incident\n        */\n\n    }, {\n        key: 'progress',\n        value: function progress(fraction, millisecond) {\n            if (fraction >= 1) {\n                this.onProgress(1, this.props.duration);\n                return;\n            }\n            // the repeatation_progress is the progress made for just the running Incident\n            // the repeatation_progress is the progress made for just the running Incident\n            var timeInRepatation = millisecond % this.repetationDuration - this.repeat.delay;\n            if (timeInRepatation < 0) {\n                // that means the current millisecond is on the delay\n                timeInRepatation = 0;\n            } else if (timeInRepatation > this.props.duration) {\n                // that means the current millisecond is on the hiatus\n                timeInRepatation = this.props.duration;\n            }\n\n            var repeatation_progress = {\n                milliseconds: timeInRepatation,\n                fraction: timeInRepatation / this.props.duration\n            };\n            this.onProgress(repeatation_progress.fraction, repeatation_progress.milliseconds);\n        }\n    }, {\n        key: 'beOn',\n        value: function beOn(millisecond) {\n            var beOnResult = _get(TimedIncident.prototype.__proto__ || Object.getPrototypeOf(TimedIncident.prototype), 'beOn', this).call(this, millisecond);\n            if (beOnResult.previousState === \"playing\" && beOnResult.newState === \"waiting\") {\n                this.resume();\n                beOnResult.newState = \"playing\";\n            }\n            return beOnResult;\n        }\n    }, {\n        key: 'duration',\n        get: function get() {\n            return this.repeat.times * (this.props.duration + this.repeat.delay + this.repeat.hiatus);\n        }\n\n        /**\n         * All TimedIncidents must implement the duration setter method\n        **/\n        ,\n        set: function set(duration) {\n            var durationFraction = duration / this.duration;\n            this.props.duration = this.props.duration * durationFraction;\n            this.repeat.delay = this.repeat.delay * durationFraction;\n            this.repeat.hiatus = this.repeat.hiatus * durationFraction;\n        }\n    }]);\n\n    return TimedIncident;\n}(Incident);\n\nmodule.exports = TimedIncident;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19CYXNlQ2xhc3Nlcy9UaW1lZEluY2lkZW50LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fQmFzZUNsYXNzZXMvVGltZWRJbmNpZGVudC5qcz83NGRmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBJbmNpZGVudCA9IHJlcXVpcmUoJy4vSW5jaWRlbnQnKTtcbnZhciBIZWxwZXIgPSByZXF1aXJlKCcuLi9fY29yZVV0aWxzLy9IZWxwZXInKTtcbnZhciBoZWxwZXIgPSBuZXcgSGVscGVyKCk7XG52YXIgaXNUaW1lUGF1c2luZ1N0YXRlID0gcmVxdWlyZSgnLi4vY29uZmlndXJhdGlvbi9hbGxvd2VkU3RhdGVDaGFuZ2VzJykuaXNUaW1lUGF1c2luZ1N0YXRlO1xuXG4vKiogQGNsYXNzZGVzY1xuICogQSBUaW1lZEluY2lkZW50IGlzIGFuIGluY2lkZW50IHRoYXQgbGFzdHMgc29tZSB0aW1lLiBJdCBoYXMgZHVyYXRpb24gYW5kIGEgdGltZXIgb2YgaXRzIG93bi4gSXQgY2FuIHRha2UgYWxsIHRoZSBzdGF0ZXMuXG4gKlxuICovXG5cbnZhciBUaW1lZEluY2lkZW50ID0gZnVuY3Rpb24gKF9JbmNpZGVudCkge1xuICAgIF9pbmhlcml0cyhUaW1lZEluY2lkZW50LCBfSW5jaWRlbnQpO1xuXG4gICAgZnVuY3Rpb24gVGltZWRJbmNpZGVudCgpIHtcbiAgICAgICAgdmFyIGF0dHJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGltZWRJbmNpZGVudCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge29iamVjdH0gLSByZXBlYXRcbiAgICAgICAgICogLSB0aW1lczogdGhlIHJlcGVhdEZhY3RvciBwcm9wZXJ0eSBkZWZpbmVzIHRoZSB0aW1lcyBhbiBJbmNpZGVudCBzaG91bGQgYmUgZXhlY3V0ZWQgcmVwZWF0ZWRseS5cbiAgICAgICAgICogRm9yIEJpdCBJbmljZGVudHMgdGhpcyBpcyBub3QgYWNjZXB0YWJsZSBhcyBCaXQgSW5jaWRlbnRzIGhhdmUgMCBkdXJhdGlvbiBhbmQgdGh1cyBwb3NpdGlvbmluZyB0aGVtIG9uIGEgY2hhaW5cbiAgICAgICAgICogdGhlIG9uZSBhZnRlciB0aGUgb3RoZXIgZG9lc24ndCBtYWtlIHNlbnNlLlxuICAgICAgICAgKiBUaGlzIHByb3BlcnR5IGhhcyBwcmFjdGljYWwgdmFsdWUgb24gVGltZWRJbmNpZGVudHMuXG4gICAgICAgICAqIEluIGFueSBjYXNlIHRoZSBkZWZhdWx0IHZhbHVlIG9mIHRoaXMgbWVtYmVyIGlzIDEgYW5kIGl0IGNhbiBvbmx5IGFjY2VwdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlc1xuICAgICAgICAgKiAtIGRlbGF5OiB0aGUgbGVmdCBnYXAgaW4gbWlsbGlzZWNvbmRzXG4gICAgICAgICAqIC0gZ2FwOiB0aGUgcmlnaHQgZ2FwIGluIG1pbGxpc2Vjb25kc1xuICAgICAgICAqL1xuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoVGltZWRJbmNpZGVudC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRpbWVkSW5jaWRlbnQpKS5jYWxsKHRoaXMsIGF0dHJzLCBwcm9wcykpO1xuXG4gICAgICAgIF90aGlzLnJlcGVhdCA9IHtcbiAgICAgICAgICAgIHRpbWVzOiAxLFxuICAgICAgICAgICAgZGVsYXk6IDAsXG4gICAgICAgICAgICBoaWF0dXM6IDBcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVwZXRhdGlvbkR1cmF0aW9uID0gX3RoaXMucHJvcHMuZHVyYXRpb247XG4gICAgICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgncmVwZWF0JykpIHtcbiAgICAgICAgICAgIGlmIChwcm9wcy5yZXBlYXQuaGFzT3duUHJvcGVydHkoJ3RpbWVzJykpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZXBlYXQudGltZXMgPSBwcm9wcy5yZXBlYXQudGltZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvcHMucmVwZWF0Lmhhc093blByb3BlcnR5KCdkZWxheScpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVwZWF0LmRlbGF5ID0gcHJvcHMucmVwZWF0LmRlbGF5O1xuICAgICAgICAgICAgICAgIF90aGlzLnJlcGV0YXRpb25EdXJhdGlvbiArPSBwcm9wcy5yZXBlYXQuZGVsYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvcHMucmVwZWF0Lmhhc093blByb3BlcnR5KCdoaWF0dXMnKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlcGVhdC5oaWF0dXMgPSBwcm9wcy5yZXBlYXQuaGlhdHVzO1xuICAgICAgICAgICAgICAgIF90aGlzLnJlcGV0YXRpb25EdXJhdGlvbiArPSBwcm9wcy5yZXBlYXQuaGlhdHVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMucmVzZXRTdGF0ZSgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgIEBtZW1iZXIge29iamVjdH0gLSBsaXN0ZW5lcnMgYXJlIGZ1bmN0aW9ucyB0byBiZSBleGVjdXRlZCBvbiB0aW1lIGNoYW5nZSBvZiB0aGUgVGltZWQgSW5jaWRlbnQuIEl0IGhhcyB0aGUgZm9sbG93aW5nIGZvcm1hdDpcbiAgICAgICAgICAgbGlzdGVuZXJzOiB7XG4gICAgICAgICAgICBsaXN0ZW5lcl9pZDoge1xuICAgICAgICAgICAgICAgICAgICAgZnVuY3QgOiB0aGUgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWRcbiAgICAgICAgICAgICAgICAgICAgIHRocmVzaG9sZCA6IHRoZSB0aHJlc2hvbGQgb2YgZGVsdGFcbiAgICAgICAgICAgICAgICAgICAgIHJvdW5kVG8gOiByb3VuZCBtaWxsaXNlY29uZFxuICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICBsaXN0ZW5lcl9pZDoge1xuICAgICAgICAgICAgICAgICAgICAgZnVuY3QgOiB0aGUgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWRcbiAgICAgICAgICAgICAgICAgICAgIHRocmVzaG9sZCA6IHRoZSB0aHJlc2hvbGQgb2YgZGVsdGFcbiAgICAgICAgICAgICAgICAgICAgIHJvdW5kVG8gOiByb3VuZCBtaWxsaXNlY29uZFxuICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAuLi5cbiAgICAgICAgICAgfVxuICAgICAgICAgICAqL1xuICAgICAgICBfdGhpcy5saXN0ZW5lcnMgPSB7fTtcblxuICAgICAgICBfdGhpcy5iaXRJbmNpZGVudCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFRpbWVkSW5jaWRlbnQsIFt7XG4gICAgICAgIGtleTogJ3JlcXVlc3RBbmltYUZyYW1lJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlcXVlc3RBbmltYUZyYW1lKGZuKSB7XG4gICAgICAgICAgICAvKiBpZiB0aGUgSW5jaWRlbnQgaXMgb24gdGVzdCBtb2RlIHdlIHdhbnQgdG8gcHJldmVudCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgYXMgZXhlY3V0aW9uXG4gICAgICAgICAgICAgICAgZHVyaW5nIHRlc3RpbmcgaXMgY29udHJvbGxlZCB0aHJvdWdoIGVtdWxhdGVTdGVwIG1ldGhvZCAqL1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNPblRlc3RNb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQud2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmbik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaGVscGVyLmVycm9yKCdZb3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB3aGVuIHRoZSBJbmNpZGVudCBpcyBvbiB0ZXN0IG1vZGUgKHRoaXMuaXNPblRlc3RNb2RlID0gdHJ1ZSkgdGhlIGVtdWxhdGVTdGVwIG1ldGhvZFxuICAgICAgICAgKiBiZWNvbWVzIGZ1bmN0aW9uYWwuXG4gICAgICAgICAqIFRoZSBtZXRob2QgdGFrZXMgYXMgaW5wdXQgdGhlIG1pbGxpc2Vjb25kc0RlbHRhIGZyb20gdGhlIHByZXZpb3VzIHRpbWVzdGFtcCBhbmQgdHJpZ2dlcnNcbiAgICAgICAgICogdGhlIHN0ZXAgZnVuY3Rpb24gcGFzc2luZyBpbiBhIGJha2VkIHRpbWVzdGFtcCBzbyB0aGUgSW5jaWRlbnQgYmVoYXZlcyBleGFjdGx5IGFzIGlmIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgcnVuXG4gICAgICAgICAqIHBhc3NpbmcgYSB0aW1lc3RhbXAgdGhhdCBoYXMgZXhhY3RseSBtaWxsaXNlY29uZHNEZWx0YSBkaWZmZXJlbmNlIGZyb20gdGhlIHByZXZpb3VzIG9uZVxuICAgICAgICAgKiBAcGFyYW0ge2ludH0gbWlsbGlzZWNvbmRzRGVsdGEgLSB0aGUgbWlsbGlzZWNvbmRzIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgcHJldmlvdXMgdGltZXN0YW1wIGFuZCB0aGUgbmV3IG9uZVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdlbXVsYXRlU3RlcCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbXVsYXRlU3RlcChtaWxsaXNlY29uZHNEZWx0YSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzT25UZXN0TW9kZSkge1xuICAgICAgICAgICAgICAgIGhlbHBlci5lcnJvcignZW11bGF0ZVN0ZXAgbWV0aG9kIGNhbiBvbmx5IGJlIHVzZWQgb24gdGVzdCBtb2RlJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RlcCh0aGlzLnJ1blRpbWVJbmZvLnByZXZpb3VzVGltZVN0YW1wICsgbWlsbGlzZWNvbmRzRGVsdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbCBUaW1lZEluY2lkZW50cyBtdXN0IGltcGxlbWVudCB0aGUgZ2V0IGR1cmF0aW9uIG1ldGhvZFxuICAgICAgICAqKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2hlY2tSZXNpemVkSW5jaWRlbnQnLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNoZWNrcyBpZiBhIGR1cmF0aW9uIGVkaXQgaXMgZmVhc2libGUgYW5kIGRvZXNuJ3QgY2F1c2UgY29uZmxpY3RzXG4gICAgICAgICAqIEBwYXJhbSB7aW50fSBkdXJhdGlvbiAtIHRoZSBuZXcgZHVyYXRpb25cbiAgICAgICAgKiovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja1Jlc2l6ZWRJbmNpZGVudChkdXJhdGlvbkZyYWN0aW9uLCBpbmNpZGVudCkge1xuICAgICAgICAgICAgdmFyIGFkanVzdE1pbGxpc2Vjb25kID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5pc0hlYWRsZXNzQ2xpcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogdHJ1ZSwgZXhlY3V0ZTogZnVuY3Rpb24gZXhlY3V0ZSgpIHt9IH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElGIFRIRSBHUk9VUCBIQVMgTk8gUEFSRU5UIChBQ1QgQVMgVEhFIENMSVApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50U2NlbmVPYmplY3QuY2hlY2tSZXNpemVkSW5jaWRlbnQoZHVyYXRpb25GcmFjdGlvbiwgaW5jaWRlbnQsIGFkanVzdE1pbGxpc2Vjb25kICsgdGhpcy5wYXJlbnRTY2VuZU9iamVjdC5nZXRJbmNpZGVudE1pbGxpc2Vjb25kKHRoaXMuaWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFZGl0cyB0aGUgdG90YWwgZHVyYXRpb24gb2YgdGhlIEluY2lkZW50LCBhcyB0aGlzIGlzIGNhbGN1bGF0ZWQgYmFzZWQgb24gdGhlIHN1bSBvZiBkZWxheSwgZHVyYXRpb24gYW5kIGhpYXR1c1xuICAgICAgICAgKiBAcGFyYW0ge2ludH0gZHVyYXRpb24gLSB0aGUgbmV3IGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kc1xuICAgICAgICAqKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVzaXplJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShkdXJhdGlvbikge1xuICAgICAgICAgICAgLy8gY29uc29sZS50cmFjZSgpO1xuICAgICAgICAgICAgLy8gZG9uJ3Qgd2FzdGUgY3B1IHJlc291cmNlcyBpZiB0aGUgbmV3IGR1cmF0aW9uIGVxdWFscyB0aGUgY3VycmVudCB2YWx1ZVxuICAgICAgICAgICAgaWYgKGR1cmF0aW9uID09PSB0aGlzLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB0cnVlIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGR1cmF0aW9uIDw9IDApIHtcbiAgICAgICAgICAgICAgICBoZWxwZXIuZXJyb3IoJ3Jlc2l6ZUluY2lkZW50IG1ldGhvZCBvZiBTY2VuZSBvbmx5IGFjY2VwdHMgaW50ZWdlcnMgPiAwIGFzIHRoZSBuZXcgZHVyYXRpb24gb2YgdGhlIFNjZW5lLiAnICsgZHVyYXRpb24gKyAnIHByb3ZpZGVkLicpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogZmFsc2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc3RvcCB0aGUgZXhlY3V0aW9uXG4gICAgICAgICAgICB0aGlzLnN0b3AoKTtcblxuICAgICAgICAgICAgdmFyIGVkaXRDaGVjayA9IHRoaXMuY2hlY2tSZXNpemVkSW5jaWRlbnQoZHVyYXRpb24gLyB0aGlzLmR1cmF0aW9uLCB0aGlzKTtcblxuICAgICAgICAgICAgaWYgKGVkaXRDaGVjay5yZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaGVscGVyLmVycm9yKGVkaXRDaGVjayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVkaXRDaGVjaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zeXN0b2xEaWFzdG9sZShkdXJhdGlvbiAvIHRoaXMuZHVyYXRpb24pO1xuICAgICAgICAgICAgZWRpdENoZWNrLmV4ZWN1dGUoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tQYXJlbnRTY2VuZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRTY2VuZU9iamVjdC5nZXREdXJhdGlvbkFmdGVySW5jaWRlbnRBZmZlY3RlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RFdmVudCgnZHVyYXRpb24tY2hhbmdlJywgeyBuZXdEdXJhdGlvbjogdGhpcy5kdXJhdGlvbiB9KTtcbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogdHJ1ZSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGVkaXRzIHRoZSBkdXJhdGlvbiBwYXJhbXMuIEFzIFwiZHVyYXRpb24gcGFyYW1zXCIgd2UgZGVmaW5lOlxuICAgICAgICAgKiAtIHRoZSBwcm9wcy5kdXJhdGlvblxuICAgICAgICAgKiAtIHRoZSBwcm9wcy5yZXBlYXQgKHdpdGggYWxsIG9mIGl0cyBrZXlzOiB0aW1lcywgZGVsYXksIGhpYXR1cylcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIEFuIG9iamVjdCB0aGF0IGFjY2VwdHMgYXQgbGVhc3Qgb25lIG9mIHRoZSBmb2xsb3dpbmcga2V5czpcbiAgICAgICAgICogLSBkdXJhdGlvblxuICAgICAgICAgKiAtIHRpbWVzXG4gICAgICAgICAqIC0gZGVsYXlcbiAgICAgICAgICogLSBoaWF0dXNcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZWRpdER1cmF0aW9uUGFyYW1zJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVkaXREdXJhdGlvblBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgICAgIC8vIHN0b3AgdGhlIGV4ZWN1dGlvblxuICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG5cbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgbmV3IHZhbHVlcyBmb3IgcHJvcHMuZHVyYXRpb24gYW5kIHByb3BzLnJlcGVhdFxuICAgICAgICAgICAgdmFyIG5ld1Byb3BzRHVyYXRpb24gPSB0aGlzLnByb3BzLmR1cmF0aW9uO1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5oYXNPd25Qcm9wZXJ0eSgnZHVyYXRpb24nKSkge1xuICAgICAgICAgICAgICAgIG5ld1Byb3BzRHVyYXRpb24gPSBwYXJhbXMuZHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmV3UmVwZWF0ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLnJlcGVhdCkpO1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5oYXNPd25Qcm9wZXJ0eSgndGltZXMnKSkge1xuICAgICAgICAgICAgICAgIG5ld1JlcGVhdC50aW1lcyA9IHBhcmFtcy50aW1lcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbXMuaGFzT3duUHJvcGVydHkoJ2RlbGF5JykpIHtcbiAgICAgICAgICAgICAgICBuZXdSZXBlYXQuZGVsYXkgPSBwYXJhbXMuZGVsYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyYW1zLmhhc093blByb3BlcnR5KCdoaWF0dXMnKSkge1xuICAgICAgICAgICAgICAgIG5ld1JlcGVhdC5oaWF0dXMgPSBwYXJhbXMuaGlhdHVzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIG5ldyB0b3RhbCBkdXJhdGlvblxuICAgICAgICAgICAgdmFyIG5ld1RvdGFsRHVyYXRpb24gPSBuZXdSZXBlYXQudGltZXMgKiAobmV3UHJvcHNEdXJhdGlvbiArIG5ld1JlcGVhdC5kZWxheSArIG5ld1JlcGVhdC5oaWF0dXMpO1xuXG4gICAgICAgICAgICAvLyBjaGVjayB0aGUgZWRpdFxuICAgICAgICAgICAgdmFyIGVkaXRDaGVjayA9IHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHRydWUsXG4gICAgICAgICAgICAgICAgZXhlY3V0ZTogZnVuY3Rpb24gZXhlY3V0ZSgpIHt9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKG5ld1RvdGFsRHVyYXRpb24gIT0gdGhpcy5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGVkaXRDaGVjayA9IHRoaXMuY2hlY2tSZXNpemVkSW5jaWRlbnQobmV3VG90YWxEdXJhdGlvbiAvIHRoaXMuZHVyYXRpb24sIHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWRpdENoZWNrLnJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBoZWxwZXIuZXJyb3IoZWRpdENoZWNrKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWRpdENoZWNrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIEluY2lkZW50J3MgdmFsdWVzXG4gICAgICAgICAgICB0aGlzLnByb3BzLmR1cmF0aW9uID0gbmV3UHJvcHNEdXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMucmVwZWF0ID0gbmV3UmVwZWF0O1xuXG4gICAgICAgICAgICBlZGl0Q2hlY2suZXhlY3V0ZSgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5jaGVja1BhcmVudFNjZW5lKCkgJiYgbmV3VG90YWxEdXJhdGlvbiAhPSB0aGlzLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRTY2VuZU9iamVjdC5nZXREdXJhdGlvbkFmdGVySW5jaWRlbnRBZmZlY3RlZCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0RXZlbnQoJ2R1cmF0aW9uLWNoYW5nZScsIHsgbmV3RHVyYXRpb246IHRoaXMuZHVyYXRpb24gfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzeXN0b2xEaWFzdG9sZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzeXN0b2xEaWFzdG9sZShkdXJhdGlvbkZyYWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmR1cmF0aW9uID0gdGhpcy5kdXJhdGlvbiAqIGR1cmF0aW9uRnJhY3Rpb247XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3Jlc2V0U3RhdGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXRTdGF0ZSgpIHtcbiAgICAgICAgICAgIF9nZXQoVGltZWRJbmNpZGVudC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUaW1lZEluY2lkZW50LnByb3RvdHlwZSksICdyZXNldFN0YXRlJywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IG1pbGxpc2Vjb25kIGhhdmluZyBhcyAwIHRoZSBzdGFydCBvZiB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ2lkbGUnKSB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCA9IDA7IC8vIHRoZSBjdXJyZW50IG1pbGxpc2Vjb25kIG9mIHRoZSBpbmNpZGVudCBhcyBpdCdzIGNhbGN1bGF0ZWQgYmFzZWQgb24gdGhlIHNwZWVkIG9mIHRoZSBJbmNpZGVudFxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gJ2NvbXBsZXRlZCcpIHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kID0gdGhpcy5kdXJhdGlvbjtcbiAgICAgICAgICAgIC8vIGluIG90aGVyIHdvcmRzIHRoZSBtaWxsaXNlY29uZCB0aGF0IHRoZSBJbmNpZGVudCBpcyBvbiB0aGUgVUlcbiAgICAgICAgICAgIHRoaXMucnVuVGltZUluZm8uc3RhcnQgPSBudWxsOyAvLyB0aGUgbWlsbGlzZWNvbmQgc3RhcnRlZCBhcyBwcm92aWRlZCBieSByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICAgIHRoaXMucnVuVGltZUluZm8ucHJldmlvdXNUaW1lU3RhbXAgPSBudWxsOyAvLyB0aGUgdGltZXN0YW1wIG9mIHRoZSBwcmV2aW91cyBjaXJjbGUgYXMgcHJvdmlkZWQgYnkgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICB0aGlzLnJ1blRpbWVJbmZvLnBhdXNlTW9tZW50ID0gbnVsbDsgLy8gdGhlIHBhdXNlIG1vbWVudCBhcyBwcm92aWRlZCBieSBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuICAgICAgICAgICAgdGhpcy5ydW5UaW1lSW5mby5wYXVzZU1pbGxpc2Vjb25kID0gMDsgLy8gdGhlIHBhdXNlTWlsbGlzZWNvbmQgaXMgdGhlIGN1cnJlbnQgbWlsbGlzZWNvbmQgYXQgdGhlIHBhdXNlIG1vbWVudFxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMubGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNba2V5XS5jYXZhRGVsdGEgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGNhbGN1bGF0ZXMgdGhlIHByZXZpb3VzVGltZVN0YW1wIGJhc2VkIG9uIHRoZSB0YXJnZXQgVUkgbWlsbGlzZWNvbmQgd2Ugd2FudCB0byBnbyB0byBhbmRcbiAgICAgICAgICogdGhlIHNwZWVkIG9mIHRoZSBJbmNpZGVudC5cbiAgICAgICAgICogRS5nLiBpZiB0YXJnZXRVSU1pbGxpc2Vjb25kID0gMjAwMCBhbmQgc3BlZWQgPTIgdGhlbiB3ZSB3aWxsIHRha2UgdGhlIHRpbWVzdGFtcCBmcm9tIHJlcXVlc3RBbmltYXRpb25GcmFtZSAocmFfc3RhbXApIGFuZFxuICAgICAgICAgKiBzZXQgdGhlIHByZXZpb3VzTWlsbGlzZWNvbmQgdG8gcmFfc3RhbXAtMTAwMFxuICAgICAgICAgKiBAcGFyYW0ge2ludH0gY3VycmVudE1JbGxpc2Vjb25kIC0gdGhlIG1pbGxpc2Vjb25kIHRvIHdoaWNoIHdlIHdhbnQgb3VyIEluaWNkZW50IHRvIGJlIG9uXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3Byb2dyYW1tYXRpY1NldFByZXZpb3VzVGltZVN0YW1wJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByb2dyYW1tYXRpY1NldFByZXZpb3VzVGltZVN0YW1wKHRhcmdldFVJTWlsbGlzZWNvbmQpIHtcbiAgICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmlzT25UZXN0TW9kZSkge1xuICAgICAgICAgICAgICAgIHRoYXQucnVuVGltZUluZm8ucHJldmlvdXNUaW1lU3RhbXAgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RBbmltYUZyYW1lKGZ1bmN0aW9uICh0aW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICB0aGF0LnJ1blRpbWVJbmZvLnByZXZpb3VzVGltZVN0YW1wID0gdGltZXN0YW1wIC0gdGFyZ2V0VUlNaWxsaXNlY29uZCAvIF90aGlzMi5zcGVlZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gKioqKioqKiogSU5DSURFTlQgTUVUSE9EUyBJTVBMRU1FTlRBVElPTiAqKioqKioqKioqKioqKlxuICAgICAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3BsYXknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcGxheSgpIHtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5vbkJlZm9yZVBsYXkocHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWNrU3RhdGVUcmFuc2l0aW9uKCdwbGF5aW5nJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX3NldFN0YXRlKCdwbGF5aW5nJyk7XG4gICAgICAgICAgICB0aGlzLm9uUGxheShwcm9wcyk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5pc09uVGVzdE1vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RBbmltYUZyYW1lKGZ1bmN0aW9uICh0aW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zdGVwKHRpbWVzdGFtcCwgcHJvcHMpO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGF0KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucnVuVGltZUluZm8ucHJldmlvdXNUaW1lU3RhbXAgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuZW11bGF0ZVN0ZXAocHJvcHMuc3RhcnRGcm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY29tcGxldGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGxldGUoKSB7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICBfZ2V0KFRpbWVkSW5jaWRlbnQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGltZWRJbmNpZGVudC5wcm90b3R5cGUpLCAnY29tcGxldGUnLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5yZXNldFN0YXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aW1lciBibG9ja2luZ1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd3YWl0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHdhaXQocHJvcHMsIHdhaXRDYWxsZXJJZCkge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzU3RhdGUgPSB0aGlzLnJ1blRpbWVJbmZvLnN0YXRlO1xuICAgICAgICAgICAgaWYgKF9nZXQoVGltZWRJbmNpZGVudC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUaW1lZEluY2lkZW50LnByb3RvdHlwZSksICd3YWl0JywgdGhpcykuY2FsbCh0aGlzLCBwcm9wcywgd2FpdENhbGxlcklkKSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNUaW1lUGF1c2luZ1N0YXRlKHByZXZpb3VzU3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnVuVGltZUluZm8ucGF1c2VNaWxsaXNlY29uZCA9IHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kICogMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5UaW1lSW5mby5wYXVzZU1vbWVudCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRpbWVyIGJsb2NraW5nXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Jsb2NrJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJsb2NrKHByb3BzKSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNTdGF0ZSA9IHRoaXMucnVuVGltZUluZm8uc3RhdGU7XG4gICAgICAgICAgICBpZiAoX2dldChUaW1lZEluY2lkZW50LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRpbWVkSW5jaWRlbnQucHJvdG90eXBlKSwgJ2Jsb2NrJywgdGhpcykuY2FsbCh0aGlzLCBwcm9wcykpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVGltZVBhdXNpbmdTdGF0ZShwcmV2aW91c1N0YXRlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1blRpbWVJbmZvLnBhdXNlTWlsbGlzZWNvbmQgPSB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCAqIDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnVuVGltZUluZm8ucGF1c2VNb21lbnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aW1lciB1bmJsb2NraW5nXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3Jlc3VtZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXN1bWUocHJvcHMpIHtcbiAgICAgICAgICAgIGlmIChfZ2V0KFRpbWVkSW5jaWRlbnQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGltZWRJbmNpZGVudC5wcm90b3R5cGUpLCAncmVzdW1lJywgdGhpcykuY2FsbCh0aGlzLCBwcm9wcykpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGEgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMucnVuVGltZUluZm8ucGF1c2VNb21lbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5UaW1lSW5mby5wcmV2aW91c1RpbWVTdGFtcCArPSBkZWx0YTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RBbmltYUZyYW1lKHRoaXMuc3RlcC5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVzZXQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQocHJvcHMpIHtcbiAgICAgICAgICAgIGlmIChfZ2V0KFRpbWVkSW5jaWRlbnQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGltZWRJbmNpZGVudC5wcm90b3R5cGUpLCAncmVzZXQnLCB0aGlzKS5jYWxsKHRoaXMsIHByb3BzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRTdGF0ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3N0b3AnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcChwcm9wcykge1xuICAgICAgICAgICAgaWYgKF9nZXQoVGltZWRJbmNpZGVudC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUaW1lZEluY2lkZW50LnByb3RvdHlwZSksICdzdG9wJywgdGhpcykuY2FsbCh0aGlzLCBwcm9wcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYXJtJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFybShwcm9wcykge1xuICAgICAgICAgICAgaWYgKF9nZXQoVGltZWRJbmNpZGVudC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUaW1lZEluY2lkZW50LnByb3RvdHlwZSksICdhcm0nLCB0aGlzKS5jYWxsKHRoaXMsIHByb3BzKSkge1xuICAgICAgICAgICAgICAgIC8vIHNldHMgdGhlIHBhdXNlIG1vbWVudCB0byB0aGUgY3VycmVudCB0aW1lLi4uXG4gICAgICAgICAgICAgICAgdGhpcy5ydW5UaW1lSW5mby5wYXVzZU1vbWVudCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHRoaXMucHJvZ3JhbW1hdGljU2V0UHJldmlvdXNUaW1lU3RhbXAoMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQgPSBwcm9wcy50YXJnZXRNaWxsaXNlY29uZERlbHRhRnJvbVN0YXJ0O1xuICAgICAgICAgICAgICAgIHRoaXMucnVuVGltZUluZm8ucGF1c2VNaWxsaXNlY29uZCA9IHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kICogMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgLy8gU1RFUCBGVU5DVElPTlxuICAgICAgICAvLyBTdGVwIG1ldGhvZCBpcyBpZGVudGljYWwgZm9yIEdyb3VwcyBhbmQgdGh1cyB3ZSB1c2UgdGhlIFwiaGFzSW5jaWRlbnRzXCIgZmxhZyB0byBjaGVjayB3aGV0aGVyIHRoZSBJbmNpZGVudCBpcyBhIEdyb3VwIG9yIGEgVGltZUluY2lkZW50XG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3N0ZXAnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3RlcCh0aW1lc3RhbXApIHtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcblxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyBzdGFydCBmcm9tIGlzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGVsYXBzZWQgZnJvbSB0aGUgYWN0dWFsIHN0YXJ0aW5nIHBvaW50IG9mIHRoZSBJbmNpZGVudCBjYXVzZWQgbWFpbmx5XG4gICAgICAgICAgICAvLyBieSBDUFUgcGVyZm9ybWFuY2UuIChlYWNoIHJlcXVlc3RBbmltYXRpb25GcmFtZSBjaXJsY2UgZG9lc24ndCBoYXBwZW4gZXZlcnkgb25lIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAvLyBzbyBhbiBJbmNpZGVudCB0aGF0IHdhcyBzdXBwb3NlZCB0byBzdGFydCBvbiBtaWxsaXNlY29uZCAxMDAgb2YgYSBHcm91cCBtaWdodCBnZXQgZmlyZWQgMTAgbWlsbGlzZWNvbmRzIGxhdGVyIHRoYW5cbiAgICAgICAgICAgIC8vIGl0cyBhY3R1YWwgc3RhcnRpbmcgcG9pbnQsIHNvIHR0aCBzdGFydEZyb20gd2lsbCBiZSAxMClcbiAgICAgICAgICAgIGlmIChwcm9wcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0RnJvbSA9IHByb3BzLnN0YXJ0RnJvbTtcbiAgICAgICAgICAgICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KCdzdGFydEZyb20nKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09IFwiZm9yd2FyZHNcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRGcm9tID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RnJvbSA9IHRoaXMuZHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zcGVlZCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5UaW1lSW5mby5wcmV2aW91c1RpbWVTdGFtcCA9IHRpbWVzdGFtcCAtIHN0YXJ0RnJvbSAvIHRoaXMuc3BlZWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5UaW1lSW5mby5wcmV2aW91c1RpbWVTdGFtcCA9IHRpbWVzdGFtcCAtICh0aGlzLmR1cmF0aW9uIC0gc3RhcnRGcm9tKSAvIE1hdGguYWJzKHRoaXMuc3BlZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGluZm9ybUxpc3RlbmVycyA9IGZ1bmN0aW9uIGluZm9ybUxpc3RlbmVycyhwcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGF0Lmxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdG5lciA9IHRoYXQubGlzdGVuZXJzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhwcm9ncmVzcy5taWxsaXNlY29uZHMgKyBsaXN0bmVyLmNhdmFEZWx0YSAtIHRoYXQucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kKSA+IGxpc3RuZXIudGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0bmVyLmZ1bmN0KHByb2dyZXNzLm1pbGxpc2Vjb25kcywgdGltZXN0YW1wLCBoZWxwZXIucm91bmROdW1iZXJUbyhsaXN0bmVyLnJvdW5kVG8pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RuZXIuY2F2YURlbHRhID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RuZXIuY2F2YURlbHRhICs9IE1hdGguYWJzKHByb2dyZXNzLm1pbGxpc2Vjb25kcyAtIHRoYXQucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIGhlbHBlci5sb2coJ2dvdCBpbnRvIHN0ZXAgb24gJyArIHRoaXMuaWQpO1xuICAgICAgICAgICAgaWYgKHRoaXMucnVuVGltZUluZm8uc3RhdGUgIT09ICdwbGF5aW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcHJvZ3Jlc3NTdGVwIGlzIHRoZSBwcm9ncmVzcyBtYWRlIGZyb20gcHJldmlvdXNUaW1lU3RhbXAgYm90aCBpbiBtaWxsaXNlY29uZHMgYW5kIGluIGZyYWN0aW9uIFswIHRvIDFdXG4gICAgICAgICAgICB2YXIgb3ZlcmFsbF9wcm9ncmVzcyA9IHtcbiAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHM6IE1hdGgucm91bmQodGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQgKyAodGltZXN0YW1wIC0gdGhpcy5ydW5UaW1lSW5mby5wcmV2aW91c1RpbWVTdGFtcCkgKiB0aGlzLnNwZWVkKSxcbiAgICAgICAgICAgICAgICBmcmFjdGlvbjogKHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kICsgKHRpbWVzdGFtcCAtIHRoaXMucnVuVGltZUluZm8ucHJldmlvdXNUaW1lU3RhbXApICogdGhpcy5zcGVlZCkgLyB0aGlzLmR1cmF0aW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gdGhlIHJlcGVhdGF0aW9uX3Byb2dyZXNzIGlzIHRoZSBwcm9ncmVzcyBtYWRlIGZvciBqdXN0IHRoZSBydW5uaW5nIEluY2lkZW50XG4gICAgICAgICAgICB2YXIgdGltZUluUmVwYXRhdGlvbiA9IG92ZXJhbGxfcHJvZ3Jlc3MubWlsbGlzZWNvbmRzICUgdGhpcy5yZXBldGF0aW9uRHVyYXRpb24gLSB0aGlzLnJlcGVhdC5kZWxheTtcbiAgICAgICAgICAgIGlmICh0aW1lSW5SZXBhdGF0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgbWVhbnMgdGhlIGN1cnJlbnQgbWlsbGlzZWNvbmQgaXMgb24gdGhlIGRlbGF5XG4gICAgICAgICAgICAgICAgdGltZUluUmVwYXRhdGlvbiA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRpbWVJblJlcGF0YXRpb24gPiB0aGlzLnByb3BzLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhhdCBtZWFucyB0aGUgY3VycmVudCBtaWxsaXNlY29uZCBpcyBvbiB0aGUgaGlhdHVzXG4gICAgICAgICAgICAgICAgdGltZUluUmVwYXRhdGlvbiA9IHRoaXMucHJvcHMuZHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVwZWF0YXRpb25fcHJvZ3Jlc3MgPSB7XG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiB0aW1lSW5SZXBhdGF0aW9uLFxuICAgICAgICAgICAgICAgIGZyYWN0aW9uOiB0aW1lSW5SZXBhdGF0aW9uIC8gdGhpcy5wcm9wcy5kdXJhdGlvblxuICAgICAgICAgICAgICAgIC8vIGhlbHBlci5ub3RpY2UoYGNhbGN1bGF0aW9uIHByb3BlcnRpZXMgb2YgcHJvZ3Jlc3MgZm9yICR7dGhpcy5pZH1gKTtcbiAgICAgICAgICAgICAgICAvLyBoZWxwZXIubG9nKGB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZDogJHt0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZH0sIHRpbWVzdGFtcDogJHt0aW1lc3RhbXB9LCB0aGlzLnJ1blRpbWVJbmZvLnByZXZpb3VzVGltZVN0YW1wOiAke3RoaXMucnVuVGltZUluZm8ucHJldmlvdXNUaW1lU3RhbXB9YClcblxuICAgICAgICAgICAgICAgIC8vIGhlbHBlci5sb2codGhpcy5pZCwgcHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgICB9O2lmIChvdmVyYWxsX3Byb2dyZXNzLmZyYWN0aW9uID49IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uUHJvZ3Jlc3MoMSwgdGhpcy5wcm9wcy5kdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgaW5mb3JtTGlzdGVuZXJzKHsgZnJhY3Rpb246IDEsIG1pbGxpc2Vjb25kczogdGhpcy5kdXJhdGlvbiB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvdmVyYWxsX3Byb2dyZXNzLmZyYWN0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25Qcm9ncmVzcygwLCAwKTtcbiAgICAgICAgICAgICAgICBpbmZvcm1MaXN0ZW5lcnMoeyBmcmFjdGlvbjogMCwgbWlsbGlzZWNvbmRzOiAwIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RvbnRUZWxsTWFtYVN0YXRlQ2hhbmdlKCdpZGxlJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RFdmVudCgnc3RhdGUtY2hhbmdlJywgeyBvbGRTdGF0ZTogXCJwbGF5aW5nXCIsIG5ld1N0YXRlOiBcImlkbGVcIiB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMub25Qcm9ncmVzcyhyZXBlYXRhdGlvbl9wcm9ncmVzcy5mcmFjdGlvbiwgcmVwZWF0YXRpb25fcHJvZ3Jlc3MubWlsbGlzZWNvbmRzKTtcblxuICAgICAgICAgICAgLy8gaGVscGVyLmxvZyh0aGlzLmlkKTtcbiAgICAgICAgICAgIC8vIGhlbHBlci5sb2codGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgLy8gaGVscGVyLmxvZyh0aGlzLmlkICsgJyBwcm9ncmVzczogJywgcHJvZ3Jlc3MpO1xuICAgICAgICAgICAgLy8gaGFuZGxlIGxpc3RlbmVyc1xuICAgICAgICAgICAgaW5mb3JtTGlzdGVuZXJzKHJlcGVhdGF0aW9uX3Byb2dyZXNzKTtcblxuICAgICAgICAgICAgdGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQgPSBvdmVyYWxsX3Byb2dyZXNzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIHRoaXMucnVuVGltZUluZm8ucHJldmlvdXNUaW1lU3RhbXAgPSB0aW1lc3RhbXA7XG5cbiAgICAgICAgICAgIC8vIGhlbHBlci5sb2codGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQpO1xuXG4gICAgICAgICAgICAvLyBoZWxwZXIubG9nKCd0aGlzLnJ1bnRpbWVJbmZvLnN0YXRlIG9uICcgKyB0aGlzLmlkICsgJyA9ICcgKyB0aGlzLnJ1blRpbWVJbmZvLnN0YXRlKTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdEFuaW1hRnJhbWUodGhhdC5zdGVwLmJpbmQodGhhdCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gKioqKiogUFVCIFNVQiAqKioqKioqKioqKlxuICAgICAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgICAgICAgLyoqIFNjZW5lIGlzIHJlc3BvbnNpYmxlIGZvciBrbm93aW5nIHRoZSB0aW1lIG9mIGl0IGF0IGFueSBnaXZlbiBtb21lbnQuIEFsc28gaXQgYWN0cyBhcyB0aGUgc2luZ2xlIHBpcGVsaW5lXG4gICAgICAgICAgdGhhdCB0cmFuc2ZlcnMgcGxheSwgd2FpdCwgcmVzdW1lLCBnb3RvIHJlcXVlc3RzIGZyb20gdG8gaXRzIEluY2lkZW50cy5cbiAgICAgICAgICBTY2VuZSBpcyByZXNwb25zaWJsZSBmb3IgZGlzdHJpYnV0aW5nIHRoZSB0aW1lIGluZm9ybWF0aW9uIHRvIGFueSBpbnRlcmVzdGVkIHBhcnR5XG4gICAgICAgICAgIEluIG9yZGVyIGZvciBhbnkgQ2xhc3MgLyBtb2R1bGUgdG8gYmUgYXdhcmUgYWJvdXQgdGhlIHRpbWUgb2YgYW55IFNjZW5lIGl0IHNob3VsZCBzdWJzY3JpYmUgdG8gaXRzIGRpc3BhdGNoIGZ1bmN0aW9uc1xuICAgICAgICAgIEJ5IHN1YnNjcmliaW5nIGEgbW9kdWxlIGNhbiBnZXQgbm90aWZpZWQgYWJvdXQgY2hhbmdlcyBvbiB0aGUgU2NlbmUncyB0aW1lXG4gICAgICAgICAgIHN1YnNjcmliZSBtZXRob2Qgc3Vic2NyaWJlcyBhIGZ1bmN0aW9uIHRvIHRoZSB0aW1lIGNoYW5nZSBkaXNwYXRjaGVyLiBBcyBTY2VuZSB1c2VzIHJlcXVlc3RBbmltYXRpb25GcmFtZSBmb3IgaXRzIHRpbWluZ1xuICAgICAgICAgIGVhY2ggY3lyY2xlIC8gc3RlcCBnZXRzIHRoZSBjdXJyZW50IHRpbWUgYW5kIHN1YnRyYWN0cyB0aGUgcHJldmlvdXMgdGltZSBzbyBpdCBrbm93IGhvdyBtYW55IG1pbGxpc2Vjb25kcyBoYXMgZWxhcHNlZFxuICAgICAgICAgIHNpbmNlIGxhc3Qgc3RlcC4gU3Vic2NyaWJlcnMgY2FuIHNldCB0byBnZXQgaW5mb3JtZWQgYWJvdXQgdGltZSBjaGFuZ2VzIG9ubHkgaWYgdGhlIGRlbHRhIGlzIGdyZWF0ZXIgdGhhbiBhIGdpdmVuXG4gICAgICAgICAgbnVtYmVyIChlLmcuIGdyZWF0ZXIgdGhhbiAzMDBtcykuIFRoYXQgcHJvcGVydHkgaXMgcGFzc2VkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgXCJ0aHJlc2hvbGRcIi5cbiAgICAgICAgICBGaW5hbGx5IGlmIGFueSBvZiB0aGUgc3Vic2NyaWJlcnMgd2FudCB0aGUgU2NlbmUgdG8gcHJvdmlkZSBiYWNrIGEgcm91bmRlZCBudW1iZXIgb2YgdGhlIG1pbGxpc2Vjb25kcy4gT3B0aW9uczpcbiAgICAgICAgICAgIC0gMSAocm91bmQgaXQgb24gaXRzIGFjdHVhbCB1bml0c1xuICAgICAgICAgICAtIDEwIChyb3VuZCBpdCBvbiB0ZW50aHMpXG4gICAgICAgICAgIC0gMTAwIChyb3VuZCBpdCBvbiBodW5kcmVkcylcbiAgICAgICAgICAgLSAxMDAwIChyb3VuZCBpdCBvbiB0aG91c2FuZHMpXG4gICAgICAgICAgIHRoZSBmaXJzdCBhcmd1bWVudCBwcm92aWRlcyBhbiBpZCB0byB0aGUgbGlzdGVuZXIgZm9yIGZ1dHVyZSByZWZlcmVuY2UgKGRlbGV0aW9uIGV0YylcbiAgICAgICAgICB0aGUgc2Vjb25kIGFyZ3VtZW50IGlzIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyB0d28gYXJndW1lbnRzOiBtaWxsaXNlY29uZCwgc3RhdGUgKGN1cnJlbnQgbWlsbGlzZWNvbmQgb2YgdGhlIFNjZW5lXG4gICAgICAgICAgYW5kIHRoZSBzdGF0ZSBvZiBpdCAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc3Vic2NyaWJlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN1YnNjcmliZShpZCwgZnVuY3QsIHRocmVzaG9sZCwgcm91bmRUbykge1xuICAgICAgICAgICAgaWYgKCF0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyb3VuZFRvKSB7XG4gICAgICAgICAgICAgICAgcm91bmRUbyA9IDE7IC8vIHJvdW5kIHNlY29uZCB0byBpdHMgdW5pdHMsIG1lYW5pbmcgbGVhdmUgaXQgYXMgaXQgaXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzW2lkXSA9IHtcbiAgICAgICAgICAgICAgICBmdW5jdDogZnVuY3QsXG4gICAgICAgICAgICAgICAgdGhyZXNob2xkOiB0aHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgcm91bmRUbzogcm91bmRUbyxcbiAgICAgICAgICAgICAgICBjYXZhRGVsdGE6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2QncyAod2hpY2ggc2hvdWxkIGJlIGNhbGxlZCB3aGVuZXZlciBhIHNsaXAgZW5kcykgcHVycG9zZSBpcyB0byBjYWxjdWxhdGUgYW5kIHNldFxuICAgICAgICAgKiB0aGUgcmlnaHQgc3RhdGUgb2YgdGhlIEluY2lkZW50IGJhc2VkIG9uIHRoZSB0YXJnZXQgbWlsbGlzZWNvbmQuXG4gICAgICAgICAqIFRoZSBwYXJhbWV0ZXIgaXQgdGFrZXMgaXMgcmVsYXRpdmUgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgSW5jaWRlbnQgaXRzZWxmIGFuZCBpdCBtaWdodCBiZSBuZWdhdGl2ZVxuICAgICAgICAgKiBOZWdhdGl2ZSB0YXJnZXRNaWxsaXNlY29uZCBtZWFucyB0aGUgdGFyZ2V0IG1pbGxpc2Vjb25kIGlzIE4gbWlsbGlzZWNvbmRzIEJFRk9SRSB0aGUgc3RhcnQgb2YgdGhlIEluY2lkZW50XG4gICAgICAgICAqIEBwYXJhbSB7aW50fSB0YXJnZXRNaWxsaXNlY29uZERlbHRhRnJvbVN0YXJ0IC0gdGhlIGRlbHRhIG9mIHRoZSB0YXJnZXQgbWlsbGlzZWNvbmQgY29tcGFyZWQgdG8gdGhlIEluY2lkZW50IHN0YXJ0XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZWNhbGNTdGF0ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWNhbGNTdGF0ZSgpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRNaWxsaXNlY29uZERlbHRhRnJvbVN0YXJ0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuXG4gICAgICAgICAgICBpZiAodGFyZ2V0TWlsbGlzZWNvbmREZWx0YUZyb21TdGFydCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRhcmdldE1pbGxpc2Vjb25kRGVsdGFGcm9tU3RhcnQgPSB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhlbHBlci5sb2coJ3JlY2FsY3VsYXRpbmcgc3RhdGUgZm9yIEluY2lkZW50OiAnICsgdGhpcy5pZCwgdGFyZ2V0TWlsbGlzZWNvbmREZWx0YUZyb21TdGFydCk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0TWlsbGlzZWNvbmREZWx0YUZyb21TdGFydCA+PSB0aGlzLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgaXQgZW5kcyBiZWZvcmUgdGhlIHRhcmdldE1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgICAgLy8gaGVscGVyLmxvZygnY29tcGxldGVzJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXNCZWZvcmVIYWx0ID0gXCJjb21wbGV0ZWRcIjtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCA9IHRoaXMuZHVyYXRpb247XG4gICAgICAgICAgICAgICAgdGhpcy5fZG9udFRlbGxNYW1hU3RhdGVDaGFuZ2UoJ2NvbXBsZXRlZCcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0YXJnZXRNaWxsaXNlY29uZERlbHRhRnJvbVN0YXJ0IDw9IHRoaXMuZHVyYXRpb24gJiYgdGFyZ2V0TWlsbGlzZWNvbmREZWx0YUZyb21TdGFydCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgdGFyZ2V0TWlsbGlzZWNvbmQgaXMgaW4gdGhlIG1pZGRsZSBvZiBpdFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAncGxheWluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1c0JlZm9yZUhhbHQgPSBcInBsYXlpbmdcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmFybSh7IHRhcmdldE1pbGxpc2Vjb25kRGVsdGFGcm9tU3RhcnQ6IHRhcmdldE1pbGxpc2Vjb25kRGVsdGFGcm9tU3RhcnQgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldE1pbGxpc2Vjb25kRGVsdGFGcm9tU3RhcnQgPD0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIGl0IGhhcyBiZWVuIGNvbXBsZXRlZCBvbiB0YXJnZXRNaWxsaXNlY29uZFxuICAgICAgICAgICAgICAgIC8vIGhlbHBlci5sb2coJ3Jlc2V0cyB0byBpZGxlJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXNCZWZvcmVIYWx0ID0gXCJpZGxlXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RvbnRUZWxsTWFtYVN0YXRlQ2hhbmdlKCdpZGxlJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldFN0YXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIGNhbGxlZCBvbiBwcm9ncmVzcyBvZiB0aGUgdGltZWQgaW5jaWRlbnQuXG4gICAgICAgICAqIEBwYXJhbSB7ZmxvYXR9IGZyYWN0aW9uIC0gYSBudW1iZXIgZnJvbSAwIHRvIDEgcmVwcmVzZW50aW5nIHRoZSBmcmFjdGlvbiBvZiBkdXJhdGlvbiBjb3ZlcmVkXG4gICAgICAgICAqIEBwYXJhbSB7aW50fSBtaWxsaXNlY29uZHMgLSB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBwYXNzZWQgZnJvbSBzdGFydCBvZiB0aGUgaW5jaWRlbnRcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnb25Qcm9ncmVzcycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblByb2dyZXNzKGZyYWN0aW9uLCBtaWxsaXNlY29uZHMpIHt9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGlzIHRoZSBhbGwgZXh0ZXJuYWwgcGFydGllcyBzaG91bGQgY2FsbCB3aGVuIHRoZXkgd2FudCB0byBmb3JjZSB0aGUgSW5jaWRlbnQgdG8gcHJvZ3Jlc3NcbiAgICAgICAgICogb24gYSBzcGVjaWZpYyBmcmFjdGlvbiAmIG1pbGxpc2Vjb25kXG4gICAgICAgICAqIEBwYXJhbSB7ZmxvYXR9IGZyYWN0aW9uIC0gYSBudW1iZXIgZnJvbSAwIHRvIDEgcmVwcmVzZW50aW5nIHRoZSBmcmFjdGlvbiBvZiBkdXJhdGlvbiBjb3ZlcmVkXG4gICAgICAgICAqIEBwYXJhbSB7aW50fSBtaWxsaXNlY29uZHMgLSB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBwYXNzZWQgZnJvbSBzdGFydCBvZiB0aGUgaW5jaWRlbnRcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncHJvZ3Jlc3MnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcHJvZ3Jlc3MoZnJhY3Rpb24sIG1pbGxpc2Vjb25kKSB7XG4gICAgICAgICAgICBpZiAoZnJhY3Rpb24gPj0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25Qcm9ncmVzcygxLCB0aGlzLnByb3BzLmR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGUgcmVwZWF0YXRpb25fcHJvZ3Jlc3MgaXMgdGhlIHByb2dyZXNzIG1hZGUgZm9yIGp1c3QgdGhlIHJ1bm5pbmcgSW5jaWRlbnRcbiAgICAgICAgICAgIC8vIHRoZSByZXBlYXRhdGlvbl9wcm9ncmVzcyBpcyB0aGUgcHJvZ3Jlc3MgbWFkZSBmb3IganVzdCB0aGUgcnVubmluZyBJbmNpZGVudFxuICAgICAgICAgICAgdmFyIHRpbWVJblJlcGF0YXRpb24gPSBtaWxsaXNlY29uZCAlIHRoaXMucmVwZXRhdGlvbkR1cmF0aW9uIC0gdGhpcy5yZXBlYXQuZGVsYXk7XG4gICAgICAgICAgICBpZiAodGltZUluUmVwYXRhdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyB0aGF0IG1lYW5zIHRoZSBjdXJyZW50IG1pbGxpc2Vjb25kIGlzIG9uIHRoZSBkZWxheVxuICAgICAgICAgICAgICAgIHRpbWVJblJlcGF0YXRpb24gPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aW1lSW5SZXBhdGF0aW9uID4gdGhpcy5wcm9wcy5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgbWVhbnMgdGhlIGN1cnJlbnQgbWlsbGlzZWNvbmQgaXMgb24gdGhlIGhpYXR1c1xuICAgICAgICAgICAgICAgIHRpbWVJblJlcGF0YXRpb24gPSB0aGlzLnByb3BzLmR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVwZWF0YXRpb25fcHJvZ3Jlc3MgPSB7XG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiB0aW1lSW5SZXBhdGF0aW9uLFxuICAgICAgICAgICAgICAgIGZyYWN0aW9uOiB0aW1lSW5SZXBhdGF0aW9uIC8gdGhpcy5wcm9wcy5kdXJhdGlvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMub25Qcm9ncmVzcyhyZXBlYXRhdGlvbl9wcm9ncmVzcy5mcmFjdGlvbiwgcmVwZWF0YXRpb25fcHJvZ3Jlc3MubWlsbGlzZWNvbmRzKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYmVPbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBiZU9uKG1pbGxpc2Vjb25kKSB7XG4gICAgICAgICAgICB2YXIgYmVPblJlc3VsdCA9IF9nZXQoVGltZWRJbmNpZGVudC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUaW1lZEluY2lkZW50LnByb3RvdHlwZSksICdiZU9uJywgdGhpcykuY2FsbCh0aGlzLCBtaWxsaXNlY29uZCk7XG4gICAgICAgICAgICBpZiAoYmVPblJlc3VsdC5wcmV2aW91c1N0YXRlID09PSBcInBsYXlpbmdcIiAmJiBiZU9uUmVzdWx0Lm5ld1N0YXRlID09PSBcIndhaXRpbmdcIikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdW1lKCk7XG4gICAgICAgICAgICAgICAgYmVPblJlc3VsdC5uZXdTdGF0ZSA9IFwicGxheWluZ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJlT25SZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2R1cmF0aW9uJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXBlYXQudGltZXMgKiAodGhpcy5wcm9wcy5kdXJhdGlvbiArIHRoaXMucmVwZWF0LmRlbGF5ICsgdGhpcy5yZXBlYXQuaGlhdHVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGwgVGltZWRJbmNpZGVudHMgbXVzdCBpbXBsZW1lbnQgdGhlIGR1cmF0aW9uIHNldHRlciBtZXRob2RcbiAgICAgICAgKiovXG4gICAgICAgICxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZHVyYXRpb24pIHtcbiAgICAgICAgICAgIHZhciBkdXJhdGlvbkZyYWN0aW9uID0gZHVyYXRpb24gLyB0aGlzLmR1cmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5kdXJhdGlvbiA9IHRoaXMucHJvcHMuZHVyYXRpb24gKiBkdXJhdGlvbkZyYWN0aW9uO1xuICAgICAgICAgICAgdGhpcy5yZXBlYXQuZGVsYXkgPSB0aGlzLnJlcGVhdC5kZWxheSAqIGR1cmF0aW9uRnJhY3Rpb247XG4gICAgICAgICAgICB0aGlzLnJlcGVhdC5oaWF0dXMgPSB0aGlzLnJlcGVhdC5oaWF0dXMgKiBkdXJhdGlvbkZyYWN0aW9uO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFRpbWVkSW5jaWRlbnQ7XG59KEluY2lkZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUaW1lZEluY2lkZW50OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/TimedIncident.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_Channels/Channel.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_Channels/Channel.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Helper = __webpack_require__(/*! ../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar conf = __webpack_require__(/*! ../configuration/generalConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\n\nvar Channel = function () {\n    function Channel(props) {\n        _classCallCheck(this, Channel);\n\n        this.runTimeInfo = props.runTimeInfo;\n        this.context = props.context;\n        this.onInitialise();\n        // this.type = \"plain\";\n    }\n\n    _createClass(Channel, [{\n        key: 'onInitialise',\n        value: function onInitialise() {\n            ;\n        }\n    }, {\n        key: '_resize',\n        value: function _resize() {\n            helper.log('Please overwite the _resize method of the Channel');\n        }\n\n        /**\n         * @param {array} incidents - A collection of Incidents in the form:\n         * {\n         *  millisecond\n         *  incident\n         *  id\n         * }\n         * @returns either:\n         *   {\n         *       result:true,\n         *       execute: // an array of functions that when executed it will add the Incidents on the Channels\n         *   }\n         *   or\n         *   {\n         *       result: false,\n         *       errors\n         *   }\n        */\n\n    }, {\n        key: 'addIncidents',\n        value: function addIncidents(incidents) {\n            // first check the Incidents addition directly using the checkAddition method of the class\n            var result = this.checkAddition(incidents);\n\n            if (result.result === false) {\n                return {\n                    result: false,\n                    errors: result.errors\n                };\n            } else {\n                return {\n                    result: true,\n                    execute: result.execute\n                };\n            }\n        }\n\n        /**\n         * It initially checks if the edit is allowed and if it is it retuns an array of executable functions\n         * that apply the change\n         * @param {array} incidents - the list of the incidents to edit in an array format [object, object, ...]\n         * @param {int} millisecondsDelta - the milliseconds delta to apply to the incidents\n         * @returns {object} -\n         * either:\n         {\n            result: true,\n            execute: // array of functions to be executed in order to apply the edit\n         }\n         or\n         {\n             result: false,\n             errors: // an array including all the errors / conflicts found on edit\n         }\n        */\n\n    }, {\n        key: 'editIncidents',\n        value: function editIncidents(incidents, millisecondsDelta, instantiatedChannels) {\n            // first check the Incidents addition directly using the checkAddition method of the class\n            var result = this.checkEdit(incidents, millisecondsDelta);\n            if (result.result === false) {\n                return {\n                    result: false,\n                    errors: result.errors\n                };\n            } else {\n                return {\n                    result: true,\n                    execute: result.execute\n                };\n            }\n        }\n\n        /**\n         * Method to remove incidents\n         * @param {array} incidents - the ids of the incidents to remove in an array format\n         * @param {object} props - if passed it supports the preventSlip key which if false the channel should not slip. This case is for \n            flashDOM of DOMAwareIncidents where we have elements deleted so slipping on their lanes is not valid nor necessaryi\n         * @retuns {object} -\n         * either:\n         {\n            result: true,\n            execute: // array of functions to be executed in order to apply the edit\n         }\n         or\n         {\n             result: false,\n             errors: // an array including all the errors / conflicts found on edit\n         }\n        */\n\n    }, {\n        key: 'removeIncidents',\n        value: function removeIncidents(incidents) {\n            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n            // first check the Incidents addition directly using the checkAddition method of the class\n            var result = this.checkDelete(incidents, props);\n            if (result.result === false) {\n                return {\n                    result: false,\n                    errors: result.errors\n                };\n            } else {\n                return {\n                    result: true,\n                    execute: result.execute\n                };\n            }\n        }\n\n        /**\n         * On this method the user defines the specific rules that apply on the plugin itself and on the Incidents of the plugin itself\n         * The method should either return {result: true} or {result: false, errors:[{error-object}]}, where error-object has the structure:\n         *  {\n                incident: // reference to the Incident object that has bee discarded\n                error: // text\n            }\n        * @param {array} incidents - a colleciton of all incidents to be added on the form:\n        *\n            {\n                id\n                millisecond\n                incident\n            }\n        * @returns {object} -\n        * either:\n            {\n                result:true,\n                execute: // a function that when executed it will add the Incidents on the Channels\n            }\n            or\n            {\n                result: false,\n                errors\n            }\n        */\n\n    }, {\n        key: 'checkAddition',\n        value: function checkAddition(incidents) {\n            return { result: true, execute: function execute() {} };\n        }\n    }, {\n        key: 'checkEdit',\n        value: function checkEdit(incidentsArray, millisecondsDelta) {\n            return { result: true, execute: function execute() {} };\n        }\n    }, {\n        key: 'checkDelete',\n        value: function checkDelete(incidentIds) {\n            return { result: true, execute: function execute() {} };\n        }\n    }, {\n        key: 'checkResizedIncidents',\n        value: function checkResizedIncidents(incidents) {\n            return { result: true, execute: function execute() {} };\n        }\n    }, {\n        key: 'goTo',\n        value: function goTo(millisecond) {\n            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n            // first decide the millisecond we want to goTo\n            if (millisecond === null || millisecond === undefined) {\n                millisecond = this.runTimeInfo.currentMillisecond;\n            }\n            if (props.hasOwnProperty('relativeTo')) {\n                millisecond += this.getIncidentMillisecond(props.relativeTo);\n            }\n\n            var startFrom = this.runTimeInfo.currentMillisecond;\n            if (props.hasOwnProperty('previousStop')) {\n                startFrom = props.previousStop;\n            }\n\n            this.moveTo(startFrom, millisecond);\n        }\n    }, {\n        key: 'moveTo',\n        value: function moveTo(from, to) {\n            ;\n        }\n    }, {\n        key: 'exportState',\n        value: function exportState(props) {\n            return {\n                class: this.constructor.name,\n                Incident: this.constructor\n            };\n        }\n    }], [{\n        key: 'type',\n        get: function get() {\n            return \"plain\";\n        }\n    }]);\n\n    return Channel;\n}();\n\nmodule.exports = Channel;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DaGFubmVscy9DaGFubmVsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fQ2hhbm5lbHMvQ2hhbm5lbC5qcz9lMzQyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEhlbHBlciA9IHJlcXVpcmUoJy4uL19jb3JlVXRpbHMvSGVscGVyJyk7XG52YXIgaGVscGVyID0gbmV3IEhlbHBlcigpO1xudmFyIGNvbmYgPSByZXF1aXJlKCcuLi9jb25maWd1cmF0aW9uL2dlbmVyYWxDb25mJyk7XG5cbnZhciBDaGFubmVsID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENoYW5uZWwocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENoYW5uZWwpO1xuXG4gICAgICAgIHRoaXMucnVuVGltZUluZm8gPSBwcm9wcy5ydW5UaW1lSW5mbztcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gcHJvcHMuY29udGV4dDtcbiAgICAgICAgdGhpcy5vbkluaXRpYWxpc2UoKTtcbiAgICAgICAgLy8gdGhpcy50eXBlID0gXCJwbGFpblwiO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhDaGFubmVsLCBbe1xuICAgICAgICBrZXk6ICdvbkluaXRpYWxpc2UnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25Jbml0aWFsaXNlKCkge1xuICAgICAgICAgICAgO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfcmVzaXplJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNpemUoKSB7XG4gICAgICAgICAgICBoZWxwZXIubG9nKCdQbGVhc2Ugb3ZlcndpdGUgdGhlIF9yZXNpemUgbWV0aG9kIG9mIHRoZSBDaGFubmVsJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHthcnJheX0gaW5jaWRlbnRzIC0gQSBjb2xsZWN0aW9uIG9mIEluY2lkZW50cyBpbiB0aGUgZm9ybTpcbiAgICAgICAgICoge1xuICAgICAgICAgKiAgbWlsbGlzZWNvbmRcbiAgICAgICAgICogIGluY2lkZW50XG4gICAgICAgICAqICBpZFxuICAgICAgICAgKiB9XG4gICAgICAgICAqIEByZXR1cm5zIGVpdGhlcjpcbiAgICAgICAgICogICB7XG4gICAgICAgICAqICAgICAgIHJlc3VsdDp0cnVlLFxuICAgICAgICAgKiAgICAgICBleGVjdXRlOiAvLyBhbiBhcnJheSBvZiBmdW5jdGlvbnMgdGhhdCB3aGVuIGV4ZWN1dGVkIGl0IHdpbGwgYWRkIHRoZSBJbmNpZGVudHMgb24gdGhlIENoYW5uZWxzXG4gICAgICAgICAqICAgfVxuICAgICAgICAgKiAgIG9yXG4gICAgICAgICAqICAge1xuICAgICAgICAgKiAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgKiAgICAgICBlcnJvcnNcbiAgICAgICAgICogICB9XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2FkZEluY2lkZW50cycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRJbmNpZGVudHMoaW5jaWRlbnRzKSB7XG4gICAgICAgICAgICAvLyBmaXJzdCBjaGVjayB0aGUgSW5jaWRlbnRzIGFkZGl0aW9uIGRpcmVjdGx5IHVzaW5nIHRoZSBjaGVja0FkZGl0aW9uIG1ldGhvZCBvZiB0aGUgY2xhc3NcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNoZWNrQWRkaXRpb24oaW5jaWRlbnRzKTtcblxuICAgICAgICAgICAgaWYgKHJlc3VsdC5yZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiByZXN1bHQuZXJyb3JzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGVjdXRlOiByZXN1bHQuZXhlY3V0ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSXQgaW5pdGlhbGx5IGNoZWNrcyBpZiB0aGUgZWRpdCBpcyBhbGxvd2VkIGFuZCBpZiBpdCBpcyBpdCByZXR1bnMgYW4gYXJyYXkgb2YgZXhlY3V0YWJsZSBmdW5jdGlvbnNcbiAgICAgICAgICogdGhhdCBhcHBseSB0aGUgY2hhbmdlXG4gICAgICAgICAqIEBwYXJhbSB7YXJyYXl9IGluY2lkZW50cyAtIHRoZSBsaXN0IG9mIHRoZSBpbmNpZGVudHMgdG8gZWRpdCBpbiBhbiBhcnJheSBmb3JtYXQgW29iamVjdCwgb2JqZWN0LCAuLi5dXG4gICAgICAgICAqIEBwYXJhbSB7aW50fSBtaWxsaXNlY29uZHNEZWx0YSAtIHRoZSBtaWxsaXNlY29uZHMgZGVsdGEgdG8gYXBwbHkgdG8gdGhlIGluY2lkZW50c1xuICAgICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSAtXG4gICAgICAgICAqIGVpdGhlcjpcbiAgICAgICAgIHtcbiAgICAgICAgICAgIHJlc3VsdDogdHJ1ZSxcbiAgICAgICAgICAgIGV4ZWN1dGU6IC8vIGFycmF5IG9mIGZ1bmN0aW9ucyB0byBiZSBleGVjdXRlZCBpbiBvcmRlciB0byBhcHBseSB0aGUgZWRpdFxuICAgICAgICAgfVxuICAgICAgICAgb3JcbiAgICAgICAgIHtcbiAgICAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgIGVycm9yczogLy8gYW4gYXJyYXkgaW5jbHVkaW5nIGFsbCB0aGUgZXJyb3JzIC8gY29uZmxpY3RzIGZvdW5kIG9uIGVkaXRcbiAgICAgICAgIH1cbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZWRpdEluY2lkZW50cycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlZGl0SW5jaWRlbnRzKGluY2lkZW50cywgbWlsbGlzZWNvbmRzRGVsdGEsIGluc3RhbnRpYXRlZENoYW5uZWxzKSB7XG4gICAgICAgICAgICAvLyBmaXJzdCBjaGVjayB0aGUgSW5jaWRlbnRzIGFkZGl0aW9uIGRpcmVjdGx5IHVzaW5nIHRoZSBjaGVja0FkZGl0aW9uIG1ldGhvZCBvZiB0aGUgY2xhc3NcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNoZWNrRWRpdChpbmNpZGVudHMsIG1pbGxpc2Vjb25kc0RlbHRhKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQucmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yczogcmVzdWx0LmVycm9yc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZTogcmVzdWx0LmV4ZWN1dGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byByZW1vdmUgaW5jaWRlbnRzXG4gICAgICAgICAqIEBwYXJhbSB7YXJyYXl9IGluY2lkZW50cyAtIHRoZSBpZHMgb2YgdGhlIGluY2lkZW50cyB0byByZW1vdmUgaW4gYW4gYXJyYXkgZm9ybWF0XG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyAtIGlmIHBhc3NlZCBpdCBzdXBwb3J0cyB0aGUgcHJldmVudFNsaXAga2V5IHdoaWNoIGlmIGZhbHNlIHRoZSBjaGFubmVsIHNob3VsZCBub3Qgc2xpcC4gVGhpcyBjYXNlIGlzIGZvciBcbiAgICAgICAgICAgIGZsYXNoRE9NIG9mIERPTUF3YXJlSW5jaWRlbnRzIHdoZXJlIHdlIGhhdmUgZWxlbWVudHMgZGVsZXRlZCBzbyBzbGlwcGluZyBvbiB0aGVpciBsYW5lcyBpcyBub3QgdmFsaWQgbm9yIG5lY2Vzc2FyeWlcbiAgICAgICAgICogQHJldHVucyB7b2JqZWN0fSAtXG4gICAgICAgICAqIGVpdGhlcjpcbiAgICAgICAgIHtcbiAgICAgICAgICAgIHJlc3VsdDogdHJ1ZSxcbiAgICAgICAgICAgIGV4ZWN1dGU6IC8vIGFycmF5IG9mIGZ1bmN0aW9ucyB0byBiZSBleGVjdXRlZCBpbiBvcmRlciB0byBhcHBseSB0aGUgZWRpdFxuICAgICAgICAgfVxuICAgICAgICAgb3JcbiAgICAgICAgIHtcbiAgICAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgIGVycm9yczogLy8gYW4gYXJyYXkgaW5jbHVkaW5nIGFsbCB0aGUgZXJyb3JzIC8gY29uZmxpY3RzIGZvdW5kIG9uIGVkaXRcbiAgICAgICAgIH1cbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVtb3ZlSW5jaWRlbnRzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUluY2lkZW50cyhpbmNpZGVudHMpIHtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgICAgIC8vIGZpcnN0IGNoZWNrIHRoZSBJbmNpZGVudHMgYWRkaXRpb24gZGlyZWN0bHkgdXNpbmcgdGhlIGNoZWNrQWRkaXRpb24gbWV0aG9kIG9mIHRoZSBjbGFzc1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2hlY2tEZWxldGUoaW5jaWRlbnRzLCBwcm9wcyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IHJlc3VsdC5lcnJvcnNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGV4ZWN1dGU6IHJlc3VsdC5leGVjdXRlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPbiB0aGlzIG1ldGhvZCB0aGUgdXNlciBkZWZpbmVzIHRoZSBzcGVjaWZpYyBydWxlcyB0aGF0IGFwcGx5IG9uIHRoZSBwbHVnaW4gaXRzZWxmIGFuZCBvbiB0aGUgSW5jaWRlbnRzIG9mIHRoZSBwbHVnaW4gaXRzZWxmXG4gICAgICAgICAqIFRoZSBtZXRob2Qgc2hvdWxkIGVpdGhlciByZXR1cm4ge3Jlc3VsdDogdHJ1ZX0gb3Ige3Jlc3VsdDogZmFsc2UsIGVycm9yczpbe2Vycm9yLW9iamVjdH1dfSwgd2hlcmUgZXJyb3Itb2JqZWN0IGhhcyB0aGUgc3RydWN0dXJlOlxuICAgICAgICAgKiAge1xuICAgICAgICAgICAgICAgIGluY2lkZW50OiAvLyByZWZlcmVuY2UgdG8gdGhlIEluY2lkZW50IG9iamVjdCB0aGF0IGhhcyBiZWUgZGlzY2FyZGVkXG4gICAgICAgICAgICAgICAgZXJyb3I6IC8vIHRleHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgKiBAcGFyYW0ge2FycmF5fSBpbmNpZGVudHMgLSBhIGNvbGxlY2l0b24gb2YgYWxsIGluY2lkZW50cyB0byBiZSBhZGRlZCBvbiB0aGUgZm9ybTpcbiAgICAgICAgKlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkXG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgICBpbmNpZGVudFxuICAgICAgICAgICAgfVxuICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9IC1cbiAgICAgICAgKiBlaXRoZXI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVzdWx0OnRydWUsXG4gICAgICAgICAgICAgICAgZXhlY3V0ZTogLy8gYSBmdW5jdGlvbiB0aGF0IHdoZW4gZXhlY3V0ZWQgaXQgd2lsbCBhZGQgdGhlIEluY2lkZW50cyBvbiB0aGUgQ2hhbm5lbHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9yXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2hlY2tBZGRpdGlvbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0FkZGl0aW9uKGluY2lkZW50cykge1xuICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB0cnVlLCBleGVjdXRlOiBmdW5jdGlvbiBleGVjdXRlKCkge30gfTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2hlY2tFZGl0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrRWRpdChpbmNpZGVudHNBcnJheSwgbWlsbGlzZWNvbmRzRGVsdGEpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogdHJ1ZSwgZXhlY3V0ZTogZnVuY3Rpb24gZXhlY3V0ZSgpIHt9IH07XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NoZWNrRGVsZXRlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrRGVsZXRlKGluY2lkZW50SWRzKSB7XG4gICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IHRydWUsIGV4ZWN1dGU6IGZ1bmN0aW9uIGV4ZWN1dGUoKSB7fSB9O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjaGVja1Jlc2l6ZWRJbmNpZGVudHMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tSZXNpemVkSW5jaWRlbnRzKGluY2lkZW50cykge1xuICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB0cnVlLCBleGVjdXRlOiBmdW5jdGlvbiBleGVjdXRlKCkge30gfTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ29UbycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnb1RvKG1pbGxpc2Vjb25kKSB7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgICAgICAvLyBmaXJzdCBkZWNpZGUgdGhlIG1pbGxpc2Vjb25kIHdlIHdhbnQgdG8gZ29Ub1xuICAgICAgICAgICAgaWYgKG1pbGxpc2Vjb25kID09PSBudWxsIHx8IG1pbGxpc2Vjb25kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtaWxsaXNlY29uZCA9IHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KCdyZWxhdGl2ZVRvJykpIHtcbiAgICAgICAgICAgICAgICBtaWxsaXNlY29uZCArPSB0aGlzLmdldEluY2lkZW50TWlsbGlzZWNvbmQocHJvcHMucmVsYXRpdmVUbyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzdGFydEZyb20gPSB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZDtcbiAgICAgICAgICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgncHJldmlvdXNTdG9wJykpIHtcbiAgICAgICAgICAgICAgICBzdGFydEZyb20gPSBwcm9wcy5wcmV2aW91c1N0b3A7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubW92ZVRvKHN0YXJ0RnJvbSwgbWlsbGlzZWNvbmQpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdtb3ZlVG8nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZVRvKGZyb20sIHRvKSB7XG4gICAgICAgICAgICA7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2V4cG9ydFN0YXRlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGV4cG9ydFN0YXRlKHByb3BzKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNsYXNzOiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUsXG4gICAgICAgICAgICAgICAgSW5jaWRlbnQ6IHRoaXMuY29uc3RydWN0b3JcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgICAga2V5OiAndHlwZScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIFwicGxhaW5cIjtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDaGFubmVsO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoYW5uZWw7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_Channels/Channel.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/AttributeChannel.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/AttributeChannel.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Channel = __webpack_require__(/*! ../Channel */ \"./node_modules/@kissmybutton/motorcortex/dist/_Channels/Channel.js\");\nvar Helper = __webpack_require__(/*! ../../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar conf = __webpack_require__(/*! ../../configuration/generalConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\n\nvar _filter = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.filter/index */ \"./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.filter/index.js\");\nvar _sortBy = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.sortby/index */ \"./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.sortby/index.js\");\n\nvar lanesHandler = __webpack_require__(/*! ./LanesHandler */ \"./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/LanesHandler.js\");\n\nvar AttributeChannel = function (_Channel) {\n    _inherits(AttributeChannel, _Channel);\n\n    function AttributeChannel(props) {\n        _classCallCheck(this, AttributeChannel);\n\n        /*\n        comboAttributes are attributes of type object, holding a number of other attributes.\n        E.g. CSS \"transform\" attribute is a combo that holds a number of other attributes such as:\n        translateX, translateY, etc. The lanes handler keeps just one lane for the combo attrs \n        in an object format keeping the value of each attribute at any given point.\n        Combo attributes are passed on the constructor of the Channel in the format:\n        props.comboAttributes: {\n            transition: ['translateX', 'translateY', ...],\n            <something_else>: ['<attrName1>', '<attrName2>', ...]\n        }\n        */\n        var _this = _possibleConstructorReturn(this, (AttributeChannel.__proto__ || Object.getPrototypeOf(AttributeChannel)).call(this, props));\n\n        _this.comboAttributes = {};\n\n        /**\n         * For incidents that do not have animatedAttrs there should be only one lane per element. \n         * The attributes Channel will use a default (fake), fixed attribute for this cases so it always ends\n         * up with just one lane per element: <element_id>_<this.fixedAttributeName>\n        */\n        _this.fixedAttributeName = \"_\";\n\n        if (props.comboAttributes != null) {\n            _this.comboAttributes = props.comboAttributes;\n        }\n\n        _this.LanesHandler = new lanesHandler({ comboAttributes: _this.comboAttributes });\n        // this.type = \"attributes\";\n        return _this;\n    }\n\n    _createClass(AttributeChannel, [{\n        key: 'setComboAttributes',\n        value: function setComboAttributes(comboAttributes) {\n            this.comboAttributes = comboAttributes;\n            this.LanesHandler = new lanesHandler({ comboAttributes: this.comboAttributes });\n        }\n    }, {\n        key: '_resize',\n        value: function _resize(durationFraction) {\n            this.LanesHandler._resize(durationFraction);\n        }\n\n        /**\n         * Checks whether the incident has animatedAttrs or not. \n        **/\n\n    }, {\n        key: '_incidentHasAnimatedAttrs',\n        value: function _incidentHasAnimatedAttrs(incident) {\n            if (incident.attrs.hasOwnProperty('animatedAttrs')) {\n                return true;\n            }\n            return false;\n        }\n\n        /* *******************************************************\n         DECISION METHODS\n         ********************************************************/\n\n        /**\n         * All of the incidents coming to this method are element-attribute incidents meaning that they only\n         * target just one element and also they include just a single attribute on the incident.attrs.animatedAttrs\n         * object\n         *\n         * @param {array} incidents - A collection of Incidents in the form:\n         * {\n         *  millisecond\n         *  incident\n         *  id\n         * }\n         * @param {string} type - can be either \"all-or-nothing\" (default) or \"keep-passing\". If type = \"all-or-nothing\"\n         *  the addition passes only if all incidents pass. If type = \"keep-passing\" the method will still return true\n         *  but will also include an errors array on its return and also will only include the success callbacks on \n         *  the execute key of its return\n         * @returns either:\n         *   {\n         *       result:true,\n         *       execute: // an array of functions that when executed it will add the Incidents on the Channels\n         *   }\n         *   or\n         *   {\n         *       result: false,\n         *       errors\n         *   }\n        */\n\n    }, {\n        key: 'checkAddition',\n        value: function checkAddition(incidents) {\n            var _this2 = this;\n\n            var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"all-or-nothing\";\n\n            var LanesHandlerSandbox = this.LanesHandler.createTestLanesSanbox();\n            /* an array where we keep all affected lanes so we can slip on them at the end. \n            The format for each affected lane we keep is:\n            {\n                mcid: mcid,\n                attribute: attribute\n            }\n            */\n            var affectedLanes = [];\n\n            // while the LanesHandlerSanbox adds lane items it makes decisions of which permanent changes should be made to\n            // the permanent and pre-existing objects it handles, such as changes on the initial values of existing animations.\n            // Because of the fact the LanesSandboxHandler is only there for testing we don't want to execute these changes\n            // during checks but still we need to know them on success. For this, the onSuccessActions array holds all executable\n            // functions retured by various LanesHandlerSanbox functions so it can execute them on success.\n            var onSuccessActions = [];\n\n            var conflicts = [];\n\n            var _loop = function _loop(i) {\n                var incidentConflicts = false; // a boolean that keeps the information whether the incident conflicts or not\n                var laneItem = incidents[i];\n                var incident = laneItem.incident;\n\n                var mcid = _this2.context.getMCID(incident.element);\n\n                // console.log(\"the incident\",incident)\n                var attribute = _this2.fixedAttributeName;\n                if (_this2._incidentHasAnimatedAttrs(incident)) {\n                    attribute = Object.keys(incident.attrs.animatedAttrs)[0];\n                }\n\n                LanesHandlerSandbox.laneExists(mcid, attribute); // create the lane if it doesn't exist already\n\n                affectedLanes.push({\n                    mcid: mcid,\n                    attribute: attribute\n                });\n\n                if (LanesHandlerSandbox.animationIDExists(mcid, attribute, incident.id)) {\n                    incidentConflicts = true;\n                    conflicts.push({\n                        type: 'duplicate Animation id',\n                        meta: {\n                            id: incident.id\n                        }\n                    });\n                }\n\n                // **** if the lane did exist before the new addition check for conflicts\n                var overlappingAnims = LanesHandlerSandbox.getOverlappingAnims(laneItem, mcid, attribute);\n\n                // helper.log(overlappingAnim)\n                if (overlappingAnims.length > 0) {\n                    incidentConflicts = true;\n                    conflicts.push({\n                        type: 'unauthorised, overlapping incidents on the same element',\n                        meta: {\n                            element_mcid: mcid,\n                            attribute: attribute,\n                            incident: laneItem,\n                            overlappingAnims: overlappingAnims\n                        }\n                    });\n                }\n\n                if (!incidentConflicts) {\n                    onSuccessActions.push(function () {\n                        LanesHandlerSandbox.addElementToLane(mcid, attribute, laneItem.millisecond, incident);\n                        incident._onGetContextOnce();\n                    });\n                }\n            };\n\n            for (var i = 0; i < incidents.length; i++) {\n                _loop(i);\n            } // end for each incident\n\n            // if we have conflicts and the type = \"all-or-nothing\"\n            if (conflicts.length > 0 && type === \"all-or-nothing\") {\n                return {\n                    result: false,\n                    errors: conflicts\n                };\n            } else {\n                // as soon as we want all passing additions to get applied the Lanes Handler will create a callback that will be passed to the result.\n                // This callback will apply all passing additions.\n\n                // success message\n                var that = this;\n                var exec = function exec() {\n                    for (var i = 0; i < onSuccessActions.length; i++) {\n                        onSuccessActions[i]();\n                    }\n                    that.LanesHandler.applySandboxChanges(LanesHandlerSandbox);\n\n                    // TODO how exactly are we handling slipping?\n                    for (var _i = 0; _i < affectedLanes.length; _i++) {\n                        var affectedLane = affectedLanes[_i];\n                        that.slipIntoLaneForwards(that.LanesHandler.getLane(affectedLane.mcid, affectedLane.attribute), affectedLane, 0, that.runTimeInfo.currentMillisecond);\n                    }\n                };\n\n                return {\n                    result: true,\n                    errors: conflicts,\n                    execute: exec\n                };\n            }\n        }\n\n        /**\n        * It initially checks if the edit is allowed and if it is it retuns an array of executable functions\n        * that apply the change\n        * @param {array} incidents - the list of the lane items to edit in an array format [object, object, ...]\n        * @param {int} millisecondsDelta - the milliseconds delta to apply to the incidents\n        * @returns {object} -\n        * either:\n        {\n           result: true,\n           execute: // array of functions to be executed in order to apply the edit\n        }\n        or\n        {\n            result: false,\n            errors: // an array including all the errors / conflicts found on edit\n        }\n        */\n\n    }, {\n        key: 'checkEdit',\n        value: function checkEdit(incidents, millisecondsDelta) {\n\n            var affectedIncidentIds = [];\n            for (var i = 0; i < incidents.length; i++) {\n                affectedIncidentIds.push(incidents[i].id);\n            }\n\n            var LanesHandlerSandbox = this.LanesHandler.createTestLanesSanbox();\n\n            var conflicts = [];\n            var affectedLanes = [];\n\n            // for each of the affectedAnimations\n            for (var _i2 = 0; _i2 < incidents.length; _i2++) {\n                var _incident = incidents[_i2].incident;\n                var incidentId = _incident.id;\n                var _mcid = this.context.getMCID(_incident.element);\n                var _attribute = this.fixedAttributeName;\n                if (this._incidentHasAnimatedAttrs(_incident)) {\n                    _attribute = Object.keys(_incident.attrs.animatedAttrs)[0];\n                }\n                var lane = LanesHandlerSandbox.getLane(_mcid, _attribute);\n                var laneAttrs = {\n                    mcid: _mcid,\n                    attribute: _attribute\n\n                    // check for conflicts and edit lane items millisecond\n                };for (var k = 0; k < lane.length; k++) {\n                    if (lane[k].incident.id === incidentId) {\n                        affectedLanes.push(laneAttrs);\n                        var affectedAnim = lane[k];\n                        var testLaneElement = LanesHandlerSandbox.getLaneElementsClone(affectedAnim);\n                        testLaneElement.millisecond += millisecondsDelta;\n                        var _overlappingAnims = LanesHandlerSandbox.getOverlappingAnims(testLaneElement, _mcid, _attribute, affectedIncidentIds);\n\n                        if (_overlappingAnims.length > 0) {\n                            conflicts.push({\n                                type: 'anauthorised, overlapping animations on the same element',\n                                meta: {\n                                    element_mcid: _mcid,\n                                    attribute: _attribute,\n                                    newAnimation: testLaneElement,\n                                    overlappingAnims: _overlappingAnims\n                                }\n                            });\n                        }\n\n                        break;\n                    } // end of if we found the specific animation on the lane's sequence\n                } // end of each lane's item\n\n            } // end for each affected animation's id\n\n            if (conflicts.length > 0) {\n                return {\n                    result: false,\n                    errors: conflicts\n                };\n            } else {\n                var that = this;\n                var exec = function exec() {\n                    // as soon as there are no conflicts the Lanes Handler applies the changes before sending over the\n                    // success message\n                    that.LanesHandler.updateLane(affectedIncidentIds, millisecondsDelta);\n\n                    for (var _i3 = 0; _i3 < affectedLanes.length; _i3++) {\n                        var affectedLane = affectedLanes[_i3];\n                        var theActualLane = that.LanesHandler.getLane(affectedLane.mcid, affectedLane.attribute);\n                        that.slipIntoLaneForwards(theActualLane, affectedLane, 0, that.runTimeInfo.currentMillisecond);\n                    }\n                };\n                return {\n                    result: true,\n                    execute: exec\n                };\n            }\n        }\n\n        /**\n         * @param {array} affectedAnimations - [{id, start, end, startDelta}]\n         * @param {boolean} fullChannelResize - if set to true then the full html channel is resizing. This is a special case as in\n         *  that case no checks should be actually perfomed nor the projected candidate should be applied directly\n        **/\n\n    }, {\n        key: 'checkResizedIncidents',\n        value: function checkResizedIncidents(affectedAnimations) {\n            var fullChannelResize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n            var excludeIdsFromCheck = [];\n            for (var i = 0; i < affectedAnimations.length; i++) {\n                excludeIdsFromCheck.push(affectedAnimations[i].id);\n            }\n\n            var LanesHandlerSandbox = this.LanesHandler.createTestLanesSanbox();\n\n            var conflicts = [];\n            var affectedLanes = [];\n\n            // for each of the affectedAnimations\n            for (var _i4 = 0; _i4 < affectedAnimations.length; _i4++) {\n                var belongingLanes = LanesHandlerSandbox.belongingLaneKeysByAnimationId._get(affectedAnimations[_i4].id);\n                var testDuration = affectedAnimations[_i4].end - affectedAnimations[_i4].start;\n\n                // for each lane the affected Animation appears in\n                for (var j in belongingLanes) {\n                    var lane = LanesHandlerSandbox.lanes._get(belongingLanes[j]);\n                    var laneData = helper.getMCIDandAttrOutOfLaneKey(belongingLanes[j]);\n\n                    // check for conflicts and edit lane items millisecond\n                    for (var k = 0; k < lane.length; k++) {\n                        if (lane[k].incident.id === affectedAnimations[_i4].id) {\n                            affectedLanes.push(laneData);\n                            if (fullChannelResize === false) {\n                                var affectedAnim = lane[k];\n                                var testLaneElement = LanesHandlerSandbox.getLaneElementsClone(affectedAnim);\n                                testLaneElement.millisecond += affectedAnimations[_i4].startDelta;\n                                var _overlappingAnims2 = LanesHandlerSandbox.getOverlappingAnims(testLaneElement, laneData.mcid, laneData.attribute, excludeIdsFromCheck, testDuration);\n\n                                if (_overlappingAnims2.length > 0) {\n                                    conflicts.push({\n                                        type: 'anauthorised overlapping animations on the same element',\n                                        meta: {\n                                            element_mcid: laneData.mcid,\n                                            attribute: laneData.attribute,\n                                            newAnimation: testLaneElement,\n                                            overlappingAnims: _overlappingAnims2\n                                        }\n                                    });\n                                }\n                            }\n\n                            break;\n                        } // end of if we found the specific animation on the lane's sequence\n                    } // end of each lane's item\n\n                } // end of each belonging lane\n            } // end for each affected animation's id\n\n            if (conflicts.length > 0) {\n                return {\n                    result: false,\n                    conflicts: conflicts\n                };\n            } else {\n                // unlike the case of editing the start millisecond of a Scene / Incident on editing the duration of a Scene\n                // or an Incident slipping to lanes should occur depends not only on the positioning of the Animations on\n                // the lanes but also on their duration. Editing the duration occurs on the Scene that received the editDuration\n                // command and thus at that point the HTMLChannel (and its LanesHaldler) is not ready to slip as the affected\n                // Animations still have the old (un-edited) duration.\n                // For this reason and only on the case of duration edit slip to lanes will take place not here and not now\n                // but on the scope of the Scene that got the command, at the point it receives the success ({result:true}).\n                // For this we will create a callback function which holds the slipping to lanes commands and pass it on the\n                // \"callback\" key of the result object ({success:true, callback:function(){that slips into lanes}})\n                var that = this;\n\n                var exec = function exec() {\n                    var slippingCommands = []; // an array that will hold all of the slipping commands in all of the affected lanes\n\n                    // updateLanes (only this time animation by animation as the milliseconds delta is not standard for all)\n                    // as soon as there are no conflicts the Lanes Handler applies the changes before sending over the\n                    // success message\n                    for (var _i5 = 0; _i5 < affectedAnimations.length; _i5++) {\n                        that.LanesHandler.updateLane([affectedAnimations[_i5].id], affectedAnimations[_i5].startDelta);\n                    }\n\n                    var _loop2 = function _loop2(_i6) {\n                        var affectedLane = affectedLanes[_i6];\n                        var theActualLane = that.LanesHandler.getLane(affectedLane.mcid, affectedLane.attribute);\n                        // put the slip command on the slippingCommands array\n                        slippingCommands.push(function () {\n                            that.slipIntoLaneForwards(theActualLane, affectedLane, 0, that.runTimeInfo.currentMillisecond);\n                        });\n                    };\n\n                    for (var _i6 = 0; _i6 < affectedLanes.length; _i6++) {\n                        _loop2(_i6);\n                    }\n\n                    for (var _i7 = 0; _i7 < slippingCommands.length; _i7++) {\n                        slippingCommands[_i7]();\n                    }\n                };\n\n                return {\n                    execute: exec,\n                    result: true\n                };\n            }\n        }\n\n        /**\n         * \n        */\n\n    }, {\n        key: 'checkDelete',\n        value: function checkDelete(removedAnimations) {\n            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n            var removedAnimationIds = [];\n            for (var i = 0; i < removedAnimations.length; i++) {\n                removedAnimationIds.push(removedAnimations[i].id);\n            }\n\n            // no slipping is needed as on deletion the Animations set their elements to their initial values\n            var that = this;\n            var exec = function exec() {\n                var affectedLanes = that.LanesHandler.deleteAnimations(removedAnimationIds, that.runTimeInfo.currentMillisecond);\n                for (var laneKey in affectedLanes) {\n                    var _affectedLane = affectedLanes[laneKey];\n                    var _theActualLane = that.LanesHandler.getLane(_affectedLane.mcid, _affectedLane.attribute);\n                    if (props.preventSlip != true) {\n                        that.slipIntoLaneForwards(_theActualLane, _affectedLane, 0, that.runTimeInfo.currentMillisecond);\n                    }\n                }\n            };\n\n            return {\n                result: true,\n                execute: exec\n            };\n        }\n\n        /**\n         * checks if a duration edit is feasible and doesn't cause conflicts\n         * @param {int} duration - the new duration\n         * @param {array} ids - (optional) if provided it only checks resizes on the given ids (not all incidents have been re)\n        **/\n\n    }, {\n        key: 'checkDurationEdit',\n        value: function checkDurationEdit(durationFraction) {\n            var ids = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n            // using ProjectionsHanlder it will create the candidates and the projections to pass up to the parent\n            // returned object keys: candidateOwnProjectedAnimations, affectedAnimations\n            var projectedAnimations = this.projectionsHandler.systoleDiastoleProjections(durationFraction, ids);\n            // once it gets the porojectedAnimations from its projections hanlder it will pass it up for check\n\n            // if the ids array is provided that means the checkDurationEdit is been used by an Animation directly\n            // belonging to the html channel, so it's not a full channel resize\n            var check = this.checkResizedAnimations(projectedAnimations.affectedAnimations, ids.length === 0 ? true : false);\n\n            return check;\n        }\n\n        /**\n         * Method that is invoked by Animation objects when one of their attributes value is edited\n         * The purpose of this method here on the HTMLChannel is to update the lanes accordingly and slip into the\n         * corresponding lanes\n         * @param {string} animationId - the id of the Animation object that has been edited\n         * @param {string} attr - the name of the attribute that has been edited\n         * @param {string} value - the new value of the edited attribute\n        */\n\n    }, {\n        key: 'animationAttributeValueChange',\n        value: function animationAttributeValueChange(animationId, attr, value) {\n            var affectedLanes = this.LanesHandler.updateAttributeOnLanes(animationId, attr, value);\n            for (var i = 0; i < affectedLanes.length; i++) {\n                var _affectedLane2 = affectedLanes[i];\n                var _theActualLane2 = this.LanesHandler.getLane(_affectedLane2.mcid, _affectedLane2.attribute);\n                this.slipIntoLaneForwards(_theActualLane2, _affectedLane2, 0, this.runTimeInfo.currentMillisecond);\n            }\n        }\n\n        /**\n         * Slips to just one lane forwards\n         * @param {array} lane - the lane to slip into\n         * @param {object} laneData - an object with keys: attribute & mcid\n         * @param {int} currentMillisecond - the millisecond the slip starts from\n         * @param {int} millisecond - the target millisecond of the slip\n         */\n\n    }, {\n        key: 'slipIntoLaneForwards',\n        value: function slipIntoLaneForwards(lane, laneData, currentMillisecond, millisecond) {\n            // helper.log(lane, currentMillisecond, millisecond);\n            var participatingAnims = _filter(lane, function (laneItem) {\n                return laneItem.millisecond + laneItem.incident.duration >= currentMillisecond && laneItem.millisecond + laneItem.incident.duration <= millisecond || // it ends after currentMillisecond and before target millisecond\n                laneItem.incident.duration + laneItem.millisecond >= millisecond && laneItem.millisecond <= millisecond; // or it ends after the target millisecond but also starts before it\n            });\n\n            if (participatingAnims.length == 0) {\n                return true;\n            }\n\n            participatingAnims = _sortBy(participatingAnims, [function (laneItem) {\n                return laneItem.millisecond;\n            }]);\n\n            // now we have all participatingAnims of the slip action in chronological order\n            // our first job is to create a variable that will hold the last known value of the lane\n            var lastValue = null;\n            for (var i = 0; i < participatingAnims.length; i++) {\n                var participatingAnim = participatingAnims[i].incident;\n                var startMillisecond = participatingAnims[i].millisecond;\n\n                // if the animation has no start values go ahead and calculated them now\n                if (!participatingAnim.hasInitialValue(laneData.attribute) && lastValue === null) {\n                    // helper.log('setting initial value: ', laneData.mcid, laneData.attribute, 'calculated');\n                    participatingAnim.setInitialValue(laneData.mcid, laneData.attribute);\n                } else if (!participatingAnim.hasInitialValue(laneData.attribute) && lastValue != null) {\n                    // helper.log('setting initial value: ', laneData.mcid, laneData.attribute, lastValue);\n                    participatingAnim.setInitialValue(laneData.mcid, laneData.attribute, lastValue);\n                }\n\n                // if the animation ends before the target millisecond\n                // helper.log('participatingAnim.duration + startMillisecond', participatingAnim.duration + startMillisecond, millisecond);\\\n\n                if (participatingAnim.duration + startMillisecond <= millisecond) {\n                    // helper.log('ends before target')\n                    if (participatingAnim.attrs.hasOwnProperty('animatedAttrs')) {\n                        lastValue = participatingAnim.attrs.animatedAttrs[laneData.attribute];\n                    }\n                    if (i === participatingAnims.length - 1) {\n                        participatingAnim.progress(1, participatingAnim.duration);\n                    }\n                } else {\n                    // slip for the specific element and the specific attribute. Set the Animation as paused or playing a\n                    // and store this info somewhere\n                    var percentageComplete = (millisecond - startMillisecond) / participatingAnim.duration;\n                    participatingAnim.progress(percentageComplete, millisecond - startMillisecond);\n                }\n            }\n        }\n\n        /**\n         * Slips to just one lane backwards\n         * @param {array} lane - the lane to slip into\n         * @param {object} laneData - an object with keys: attribute & mcid\n         * @param {int} currentMillisecond - the millisecond the slip starts from\n         * @parama {int} millisecond - the target millisecond of the slip\n         */\n\n    }, {\n        key: 'slipToLaneBackwards',\n        value: function slipToLaneBackwards(lane, laneData, currentMillisecond, millisecond) {\n            // we take all Animations that are either currently running or\n            // they end after the destination point\n            // helper.log('<------');\n            var participatingAnims = _filter(lane, function (laneItem) {\n                var laneItemEnd = laneItem.incident.duration + laneItem.millisecond;\n                return laneItemEnd <= millisecond && laneItemEnd >= currentMillisecond || // they end in the hot area\n                laneItem.millisecond >= currentMillisecond && laneItem.millisecond <= millisecond || // they start in the hot area\n                laneItem.millisecond < currentMillisecond && laneItemEnd > millisecond; // they overlap the hot area\n            });\n\n            if (participatingAnims.length == 0) {\n                return true;\n            }\n\n            participatingAnims = _sortBy(participatingAnims, [function (laneItem) {\n                return laneItem.millisecond;\n            }]);\n\n            var lastValue = null;\n            for (var i = participatingAnims.length - 1; i >= 0; i--) {\n                var participatingAnim = participatingAnims[i].incident;\n                var startMillisecond = participatingAnims[i].millisecond;\n                if (startMillisecond >= millisecond) {\n                    participatingAnim.progress(0, 0);\n                } else {\n                    var percentageComplete = (millisecond - startMillisecond) / participatingAnim.duration;\n\n                    participatingAnim.progress(percentageComplete, millisecond - startMillisecond);\n                }\n            }\n        }\n\n        /**\n         @param {int} from - the millisecond to start from\n         @param {int} to - the millisecond to go to\n         */\n\n    }, {\n        key: 'moveTo',\n        value: function moveTo(from, to) {\n            // step 1: iterate through all lanes\n            var laneKeys = this.lanes._keys();\n            for (var i = 0; i < laneKeys.length; i++) {\n                var laneid = laneKeys[i];\n                var lane = this.lanes._get(laneid);\n                var laneData = helper.getMCIDandAttrOutOfLaneKey(laneid);\n                if (from < to) {\n                    // helper.log(laneid);\n                    this.slipIntoLaneForwards(lane, laneData, from, to);\n                } else if (from >= to) {\n                    this.slipToLaneBackwards(lane, laneData, from, to);\n                }\n            }\n        }\n    }, {\n        key: 'lanes',\n        get: function get() {\n            return this.LanesHandler.lanes;\n        }\n    }], [{\n        key: 'type',\n        get: function get() {\n            return \"attributes\";\n        }\n    }]);\n\n    return AttributeChannel;\n}(Channel);\n\nmodule.exports = AttributeChannel;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DaGFubmVscy9fQXR0cmlidXRlL0F0dHJpYnV0ZUNoYW5uZWwuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DaGFubmVscy9fQXR0cmlidXRlL0F0dHJpYnV0ZUNoYW5uZWwuanM/ODU1NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIENoYW5uZWwgPSByZXF1aXJlKCcuLi9DaGFubmVsJyk7XG52YXIgSGVscGVyID0gcmVxdWlyZSgnLi4vLi4vX2NvcmVVdGlscy9IZWxwZXInKTtcbnZhciBoZWxwZXIgPSBuZXcgSGVscGVyKCk7XG52YXIgY29uZiA9IHJlcXVpcmUoJy4uLy4uL2NvbmZpZ3VyYXRpb24vZ2VuZXJhbENvbmYnKTtcblxudmFyIF9maWx0ZXIgPSByZXF1aXJlKCcuLi8uLi8uLi9sb2Rhc2gtY3VzdG9tLWJ1aWxkL21vZHVsYXJpemUvbG9kYXNoLmZpbHRlci9pbmRleCcpO1xudmFyIF9zb3J0QnkgPSByZXF1aXJlKCcuLi8uLi8uLi9sb2Rhc2gtY3VzdG9tLWJ1aWxkL21vZHVsYXJpemUvbG9kYXNoLnNvcnRieS9pbmRleCcpO1xuXG52YXIgbGFuZXNIYW5kbGVyID0gcmVxdWlyZSgnLi9MYW5lc0hhbmRsZXInKTtcblxudmFyIEF0dHJpYnV0ZUNoYW5uZWwgPSBmdW5jdGlvbiAoX0NoYW5uZWwpIHtcbiAgICBfaW5oZXJpdHMoQXR0cmlidXRlQ2hhbm5lbCwgX0NoYW5uZWwpO1xuXG4gICAgZnVuY3Rpb24gQXR0cmlidXRlQ2hhbm5lbChwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXR0cmlidXRlQ2hhbm5lbCk7XG5cbiAgICAgICAgLypcbiAgICAgICAgY29tYm9BdHRyaWJ1dGVzIGFyZSBhdHRyaWJ1dGVzIG9mIHR5cGUgb2JqZWN0LCBob2xkaW5nIGEgbnVtYmVyIG9mIG90aGVyIGF0dHJpYnV0ZXMuXG4gICAgICAgIEUuZy4gQ1NTIFwidHJhbnNmb3JtXCIgYXR0cmlidXRlIGlzIGEgY29tYm8gdGhhdCBob2xkcyBhIG51bWJlciBvZiBvdGhlciBhdHRyaWJ1dGVzIHN1Y2ggYXM6XG4gICAgICAgIHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVksIGV0Yy4gVGhlIGxhbmVzIGhhbmRsZXIga2VlcHMganVzdCBvbmUgbGFuZSBmb3IgdGhlIGNvbWJvIGF0dHJzIFxuICAgICAgICBpbiBhbiBvYmplY3QgZm9ybWF0IGtlZXBpbmcgdGhlIHZhbHVlIG9mIGVhY2ggYXR0cmlidXRlIGF0IGFueSBnaXZlbiBwb2ludC5cbiAgICAgICAgQ29tYm8gYXR0cmlidXRlcyBhcmUgcGFzc2VkIG9uIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgQ2hhbm5lbCBpbiB0aGUgZm9ybWF0OlxuICAgICAgICBwcm9wcy5jb21ib0F0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIHRyYW5zaXRpb246IFsndHJhbnNsYXRlWCcsICd0cmFuc2xhdGVZJywgLi4uXSxcbiAgICAgICAgICAgIDxzb21ldGhpbmdfZWxzZT46IFsnPGF0dHJOYW1lMT4nLCAnPGF0dHJOYW1lMj4nLCAuLi5dXG4gICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEF0dHJpYnV0ZUNoYW5uZWwuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihBdHRyaWJ1dGVDaGFubmVsKSkuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgICAgIF90aGlzLmNvbWJvQXR0cmlidXRlcyA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3IgaW5jaWRlbnRzIHRoYXQgZG8gbm90IGhhdmUgYW5pbWF0ZWRBdHRycyB0aGVyZSBzaG91bGQgYmUgb25seSBvbmUgbGFuZSBwZXIgZWxlbWVudC4gXG4gICAgICAgICAqIFRoZSBhdHRyaWJ1dGVzIENoYW5uZWwgd2lsbCB1c2UgYSBkZWZhdWx0IChmYWtlKSwgZml4ZWQgYXR0cmlidXRlIGZvciB0aGlzIGNhc2VzIHNvIGl0IGFsd2F5cyBlbmRzXG4gICAgICAgICAqIHVwIHdpdGgganVzdCBvbmUgbGFuZSBwZXIgZWxlbWVudDogPGVsZW1lbnRfaWQ+Xzx0aGlzLmZpeGVkQXR0cmlidXRlTmFtZT5cbiAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuZml4ZWRBdHRyaWJ1dGVOYW1lID0gXCJfXCI7XG5cbiAgICAgICAgaWYgKHByb3BzLmNvbWJvQXR0cmlidXRlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBfdGhpcy5jb21ib0F0dHJpYnV0ZXMgPSBwcm9wcy5jb21ib0F0dHJpYnV0ZXM7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5MYW5lc0hhbmRsZXIgPSBuZXcgbGFuZXNIYW5kbGVyKHsgY29tYm9BdHRyaWJ1dGVzOiBfdGhpcy5jb21ib0F0dHJpYnV0ZXMgfSk7XG4gICAgICAgIC8vIHRoaXMudHlwZSA9IFwiYXR0cmlidXRlc1wiO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEF0dHJpYnV0ZUNoYW5uZWwsIFt7XG4gICAgICAgIGtleTogJ3NldENvbWJvQXR0cmlidXRlcycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDb21ib0F0dHJpYnV0ZXMoY29tYm9BdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICB0aGlzLmNvbWJvQXR0cmlidXRlcyA9IGNvbWJvQXR0cmlidXRlcztcbiAgICAgICAgICAgIHRoaXMuTGFuZXNIYW5kbGVyID0gbmV3IGxhbmVzSGFuZGxlcih7IGNvbWJvQXR0cmlidXRlczogdGhpcy5jb21ib0F0dHJpYnV0ZXMgfSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19yZXNpemUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc2l6ZShkdXJhdGlvbkZyYWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLkxhbmVzSGFuZGxlci5fcmVzaXplKGR1cmF0aW9uRnJhY3Rpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBpbmNpZGVudCBoYXMgYW5pbWF0ZWRBdHRycyBvciBub3QuIFxuICAgICAgICAqKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2luY2lkZW50SGFzQW5pbWF0ZWRBdHRycycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5jaWRlbnRIYXNBbmltYXRlZEF0dHJzKGluY2lkZW50KSB7XG4gICAgICAgICAgICBpZiAoaW5jaWRlbnQuYXR0cnMuaGFzT3duUHJvcGVydHkoJ2FuaW1hdGVkQXR0cnMnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAgREVDSVNJT04gTUVUSE9EU1xuICAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbCBvZiB0aGUgaW5jaWRlbnRzIGNvbWluZyB0byB0aGlzIG1ldGhvZCBhcmUgZWxlbWVudC1hdHRyaWJ1dGUgaW5jaWRlbnRzIG1lYW5pbmcgdGhhdCB0aGV5IG9ubHlcbiAgICAgICAgICogdGFyZ2V0IGp1c3Qgb25lIGVsZW1lbnQgYW5kIGFsc28gdGhleSBpbmNsdWRlIGp1c3QgYSBzaW5nbGUgYXR0cmlidXRlIG9uIHRoZSBpbmNpZGVudC5hdHRycy5hbmltYXRlZEF0dHJzXG4gICAgICAgICAqIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge2FycmF5fSBpbmNpZGVudHMgLSBBIGNvbGxlY3Rpb24gb2YgSW5jaWRlbnRzIGluIHRoZSBmb3JtOlxuICAgICAgICAgKiB7XG4gICAgICAgICAqICBtaWxsaXNlY29uZFxuICAgICAgICAgKiAgaW5jaWRlbnRcbiAgICAgICAgICogIGlkXG4gICAgICAgICAqIH1cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBjYW4gYmUgZWl0aGVyIFwiYWxsLW9yLW5vdGhpbmdcIiAoZGVmYXVsdCkgb3IgXCJrZWVwLXBhc3NpbmdcIi4gSWYgdHlwZSA9IFwiYWxsLW9yLW5vdGhpbmdcIlxuICAgICAgICAgKiAgdGhlIGFkZGl0aW9uIHBhc3NlcyBvbmx5IGlmIGFsbCBpbmNpZGVudHMgcGFzcy4gSWYgdHlwZSA9IFwia2VlcC1wYXNzaW5nXCIgdGhlIG1ldGhvZCB3aWxsIHN0aWxsIHJldHVybiB0cnVlXG4gICAgICAgICAqICBidXQgd2lsbCBhbHNvIGluY2x1ZGUgYW4gZXJyb3JzIGFycmF5IG9uIGl0cyByZXR1cm4gYW5kIGFsc28gd2lsbCBvbmx5IGluY2x1ZGUgdGhlIHN1Y2Nlc3MgY2FsbGJhY2tzIG9uIFxuICAgICAgICAgKiAgdGhlIGV4ZWN1dGUga2V5IG9mIGl0cyByZXR1cm5cbiAgICAgICAgICogQHJldHVybnMgZWl0aGVyOlxuICAgICAgICAgKiAgIHtcbiAgICAgICAgICogICAgICAgcmVzdWx0OnRydWUsXG4gICAgICAgICAqICAgICAgIGV4ZWN1dGU6IC8vIGFuIGFycmF5IG9mIGZ1bmN0aW9ucyB0aGF0IHdoZW4gZXhlY3V0ZWQgaXQgd2lsbCBhZGQgdGhlIEluY2lkZW50cyBvbiB0aGUgQ2hhbm5lbHNcbiAgICAgICAgICogICB9XG4gICAgICAgICAqICAgb3JcbiAgICAgICAgICogICB7XG4gICAgICAgICAqICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAqICAgICAgIGVycm9yc1xuICAgICAgICAgKiAgIH1cbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2hlY2tBZGRpdGlvbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0FkZGl0aW9uKGluY2lkZW50cykge1xuICAgICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciB0eXBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcImFsbC1vci1ub3RoaW5nXCI7XG5cbiAgICAgICAgICAgIHZhciBMYW5lc0hhbmRsZXJTYW5kYm94ID0gdGhpcy5MYW5lc0hhbmRsZXIuY3JlYXRlVGVzdExhbmVzU2FuYm94KCk7XG4gICAgICAgICAgICAvKiBhbiBhcnJheSB3aGVyZSB3ZSBrZWVwIGFsbCBhZmZlY3RlZCBsYW5lcyBzbyB3ZSBjYW4gc2xpcCBvbiB0aGVtIGF0IHRoZSBlbmQuIFxuICAgICAgICAgICAgVGhlIGZvcm1hdCBmb3IgZWFjaCBhZmZlY3RlZCBsYW5lIHdlIGtlZXAgaXM6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWNpZDogbWNpZCxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGU6IGF0dHJpYnV0ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBhZmZlY3RlZExhbmVzID0gW107XG5cbiAgICAgICAgICAgIC8vIHdoaWxlIHRoZSBMYW5lc0hhbmRsZXJTYW5ib3ggYWRkcyBsYW5lIGl0ZW1zIGl0IG1ha2VzIGRlY2lzaW9ucyBvZiB3aGljaCBwZXJtYW5lbnQgY2hhbmdlcyBzaG91bGQgYmUgbWFkZSB0b1xuICAgICAgICAgICAgLy8gdGhlIHBlcm1hbmVudCBhbmQgcHJlLWV4aXN0aW5nIG9iamVjdHMgaXQgaGFuZGxlcywgc3VjaCBhcyBjaGFuZ2VzIG9uIHRoZSBpbml0aWFsIHZhbHVlcyBvZiBleGlzdGluZyBhbmltYXRpb25zLlxuICAgICAgICAgICAgLy8gQmVjYXVzZSBvZiB0aGUgZmFjdCB0aGUgTGFuZXNTYW5kYm94SGFuZGxlciBpcyBvbmx5IHRoZXJlIGZvciB0ZXN0aW5nIHdlIGRvbid0IHdhbnQgdG8gZXhlY3V0ZSB0aGVzZSBjaGFuZ2VzXG4gICAgICAgICAgICAvLyBkdXJpbmcgY2hlY2tzIGJ1dCBzdGlsbCB3ZSBuZWVkIHRvIGtub3cgdGhlbSBvbiBzdWNjZXNzLiBGb3IgdGhpcywgdGhlIG9uU3VjY2Vzc0FjdGlvbnMgYXJyYXkgaG9sZHMgYWxsIGV4ZWN1dGFibGVcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9ucyByZXR1cmVkIGJ5IHZhcmlvdXMgTGFuZXNIYW5kbGVyU2FuYm94IGZ1bmN0aW9ucyBzbyBpdCBjYW4gZXhlY3V0ZSB0aGVtIG9uIHN1Y2Nlc3MuXG4gICAgICAgICAgICB2YXIgb25TdWNjZXNzQWN0aW9ucyA9IFtdO1xuXG4gICAgICAgICAgICB2YXIgY29uZmxpY3RzID0gW107XG5cbiAgICAgICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5jaWRlbnRDb25mbGljdHMgPSBmYWxzZTsgLy8gYSBib29sZWFuIHRoYXQga2VlcHMgdGhlIGluZm9ybWF0aW9uIHdoZXRoZXIgdGhlIGluY2lkZW50IGNvbmZsaWN0cyBvciBub3RcbiAgICAgICAgICAgICAgICB2YXIgbGFuZUl0ZW0gPSBpbmNpZGVudHNbaV07XG4gICAgICAgICAgICAgICAgdmFyIGluY2lkZW50ID0gbGFuZUl0ZW0uaW5jaWRlbnQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgbWNpZCA9IF90aGlzMi5jb250ZXh0LmdldE1DSUQoaW5jaWRlbnQuZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcInRoZSBpbmNpZGVudFwiLGluY2lkZW50KVxuICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBfdGhpczIuZml4ZWRBdHRyaWJ1dGVOYW1lO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpczIuX2luY2lkZW50SGFzQW5pbWF0ZWRBdHRycyhpbmNpZGVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlID0gT2JqZWN0LmtleXMoaW5jaWRlbnQuYXR0cnMuYW5pbWF0ZWRBdHRycylbMF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgTGFuZXNIYW5kbGVyU2FuZGJveC5sYW5lRXhpc3RzKG1jaWQsIGF0dHJpYnV0ZSk7IC8vIGNyZWF0ZSB0aGUgbGFuZSBpZiBpdCBkb2Vzbid0IGV4aXN0IGFscmVhZHlcblxuICAgICAgICAgICAgICAgIGFmZmVjdGVkTGFuZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG1jaWQ6IG1jaWQsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZTogYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoTGFuZXNIYW5kbGVyU2FuZGJveC5hbmltYXRpb25JREV4aXN0cyhtY2lkLCBhdHRyaWJ1dGUsIGluY2lkZW50LmlkKSkge1xuICAgICAgICAgICAgICAgICAgICBpbmNpZGVudENvbmZsaWN0cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZsaWN0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkdXBsaWNhdGUgQW5pbWF0aW9uIGlkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogaW5jaWRlbnQuaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gKioqKiBpZiB0aGUgbGFuZSBkaWQgZXhpc3QgYmVmb3JlIHRoZSBuZXcgYWRkaXRpb24gY2hlY2sgZm9yIGNvbmZsaWN0c1xuICAgICAgICAgICAgICAgIHZhciBvdmVybGFwcGluZ0FuaW1zID0gTGFuZXNIYW5kbGVyU2FuZGJveC5nZXRPdmVybGFwcGluZ0FuaW1zKGxhbmVJdGVtLCBtY2lkLCBhdHRyaWJ1dGUpO1xuXG4gICAgICAgICAgICAgICAgLy8gaGVscGVyLmxvZyhvdmVybGFwcGluZ0FuaW0pXG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXBwaW5nQW5pbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpbmNpZGVudENvbmZsaWN0cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZsaWN0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1bmF1dGhvcmlzZWQsIG92ZXJsYXBwaW5nIGluY2lkZW50cyBvbiB0aGUgc2FtZSBlbGVtZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50X21jaWQ6IG1jaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlOiBhdHRyaWJ1dGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jaWRlbnQ6IGxhbmVJdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXBwaW5nQW5pbXM6IG92ZXJsYXBwaW5nQW5pbXNcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFpbmNpZGVudENvbmZsaWN0cykge1xuICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3NBY3Rpb25zLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgTGFuZXNIYW5kbGVyU2FuZGJveC5hZGRFbGVtZW50VG9MYW5lKG1jaWQsIGF0dHJpYnV0ZSwgbGFuZUl0ZW0ubWlsbGlzZWNvbmQsIGluY2lkZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2lkZW50Ll9vbkdldENvbnRleHRPbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgX2xvb3AoaSk7XG4gICAgICAgICAgICB9IC8vIGVuZCBmb3IgZWFjaCBpbmNpZGVudFxuXG4gICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGNvbmZsaWN0cyBhbmQgdGhlIHR5cGUgPSBcImFsbC1vci1ub3RoaW5nXCJcbiAgICAgICAgICAgIGlmIChjb25mbGljdHMubGVuZ3RoID4gMCAmJiB0eXBlID09PSBcImFsbC1vci1ub3RoaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IGNvbmZsaWN0c1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGFzIHNvb24gYXMgd2Ugd2FudCBhbGwgcGFzc2luZyBhZGRpdGlvbnMgdG8gZ2V0IGFwcGxpZWQgdGhlIExhbmVzIEhhbmRsZXIgd2lsbCBjcmVhdGUgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSByZXN1bHQuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjYWxsYmFjayB3aWxsIGFwcGx5IGFsbCBwYXNzaW5nIGFkZGl0aW9ucy5cblxuICAgICAgICAgICAgICAgIC8vIHN1Y2Nlc3MgbWVzc2FnZVxuICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgZXhlYyA9IGZ1bmN0aW9uIGV4ZWMoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb25TdWNjZXNzQWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzQWN0aW9uc1tpXSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuTGFuZXNIYW5kbGVyLmFwcGx5U2FuZGJveENoYW5nZXMoTGFuZXNIYW5kbGVyU2FuZGJveCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBob3cgZXhhY3RseSBhcmUgd2UgaGFuZGxpbmcgc2xpcHBpbmc/XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhZmZlY3RlZExhbmVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFmZmVjdGVkTGFuZSA9IGFmZmVjdGVkTGFuZXNbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5zbGlwSW50b0xhbmVGb3J3YXJkcyh0aGF0LkxhbmVzSGFuZGxlci5nZXRMYW5lKGFmZmVjdGVkTGFuZS5tY2lkLCBhZmZlY3RlZExhbmUuYXR0cmlidXRlKSwgYWZmZWN0ZWRMYW5lLCAwLCB0aGF0LnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IGNvbmZsaWN0cyxcbiAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZTogZXhlY1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgKiBJdCBpbml0aWFsbHkgY2hlY2tzIGlmIHRoZSBlZGl0IGlzIGFsbG93ZWQgYW5kIGlmIGl0IGlzIGl0IHJldHVucyBhbiBhcnJheSBvZiBleGVjdXRhYmxlIGZ1bmN0aW9uc1xuICAgICAgICAqIHRoYXQgYXBwbHkgdGhlIGNoYW5nZVxuICAgICAgICAqIEBwYXJhbSB7YXJyYXl9IGluY2lkZW50cyAtIHRoZSBsaXN0IG9mIHRoZSBsYW5lIGl0ZW1zIHRvIGVkaXQgaW4gYW4gYXJyYXkgZm9ybWF0IFtvYmplY3QsIG9iamVjdCwgLi4uXVxuICAgICAgICAqIEBwYXJhbSB7aW50fSBtaWxsaXNlY29uZHNEZWx0YSAtIHRoZSBtaWxsaXNlY29uZHMgZGVsdGEgdG8gYXBwbHkgdG8gdGhlIGluY2lkZW50c1xuICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9IC1cbiAgICAgICAgKiBlaXRoZXI6XG4gICAgICAgIHtcbiAgICAgICAgICAgcmVzdWx0OiB0cnVlLFxuICAgICAgICAgICBleGVjdXRlOiAvLyBhcnJheSBvZiBmdW5jdGlvbnMgdG8gYmUgZXhlY3V0ZWQgaW4gb3JkZXIgdG8gYXBwbHkgdGhlIGVkaXRcbiAgICAgICAgfVxuICAgICAgICBvclxuICAgICAgICB7XG4gICAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3JzOiAvLyBhbiBhcnJheSBpbmNsdWRpbmcgYWxsIHRoZSBlcnJvcnMgLyBjb25mbGljdHMgZm91bmQgb24gZWRpdFxuICAgICAgICB9XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NoZWNrRWRpdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0VkaXQoaW5jaWRlbnRzLCBtaWxsaXNlY29uZHNEZWx0YSkge1xuXG4gICAgICAgICAgICB2YXIgYWZmZWN0ZWRJbmNpZGVudElkcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhZmZlY3RlZEluY2lkZW50SWRzLnB1c2goaW5jaWRlbnRzW2ldLmlkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIExhbmVzSGFuZGxlclNhbmRib3ggPSB0aGlzLkxhbmVzSGFuZGxlci5jcmVhdGVUZXN0TGFuZXNTYW5ib3goKTtcblxuICAgICAgICAgICAgdmFyIGNvbmZsaWN0cyA9IFtdO1xuICAgICAgICAgICAgdmFyIGFmZmVjdGVkTGFuZXMgPSBbXTtcblxuICAgICAgICAgICAgLy8gZm9yIGVhY2ggb2YgdGhlIGFmZmVjdGVkQW5pbWF0aW9uc1xuICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgaW5jaWRlbnRzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgX2luY2lkZW50ID0gaW5jaWRlbnRzW19pMl0uaW5jaWRlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGluY2lkZW50SWQgPSBfaW5jaWRlbnQuaWQ7XG4gICAgICAgICAgICAgICAgdmFyIF9tY2lkID0gdGhpcy5jb250ZXh0LmdldE1DSUQoX2luY2lkZW50LmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHZhciBfYXR0cmlidXRlID0gdGhpcy5maXhlZEF0dHJpYnV0ZU5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2luY2lkZW50SGFzQW5pbWF0ZWRBdHRycyhfaW5jaWRlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIF9hdHRyaWJ1dGUgPSBPYmplY3Qua2V5cyhfaW5jaWRlbnQuYXR0cnMuYW5pbWF0ZWRBdHRycylbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBsYW5lID0gTGFuZXNIYW5kbGVyU2FuZGJveC5nZXRMYW5lKF9tY2lkLCBfYXR0cmlidXRlKTtcbiAgICAgICAgICAgICAgICB2YXIgbGFuZUF0dHJzID0ge1xuICAgICAgICAgICAgICAgICAgICBtY2lkOiBfbWNpZCxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlOiBfYXR0cmlidXRlXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGNvbmZsaWN0cyBhbmQgZWRpdCBsYW5lIGl0ZW1zIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgICAgfTtmb3IgKHZhciBrID0gMDsgayA8IGxhbmUubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhbmVba10uaW5jaWRlbnQuaWQgPT09IGluY2lkZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmZmVjdGVkTGFuZXMucHVzaChsYW5lQXR0cnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFmZmVjdGVkQW5pbSA9IGxhbmVba107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVzdExhbmVFbGVtZW50ID0gTGFuZXNIYW5kbGVyU2FuZGJveC5nZXRMYW5lRWxlbWVudHNDbG9uZShhZmZlY3RlZEFuaW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVzdExhbmVFbGVtZW50Lm1pbGxpc2Vjb25kICs9IG1pbGxpc2Vjb25kc0RlbHRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9vdmVybGFwcGluZ0FuaW1zID0gTGFuZXNIYW5kbGVyU2FuZGJveC5nZXRPdmVybGFwcGluZ0FuaW1zKHRlc3RMYW5lRWxlbWVudCwgX21jaWQsIF9hdHRyaWJ1dGUsIGFmZmVjdGVkSW5jaWRlbnRJZHMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX292ZXJsYXBwaW5nQW5pbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZsaWN0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2FuYXV0aG9yaXNlZCwgb3ZlcmxhcHBpbmcgYW5pbWF0aW9ucyBvbiB0aGUgc2FtZSBlbGVtZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudF9tY2lkOiBfbWNpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZTogX2F0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0FuaW1hdGlvbjogdGVzdExhbmVFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcHBpbmdBbmltczogX292ZXJsYXBwaW5nQW5pbXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfSAvLyBlbmQgb2YgaWYgd2UgZm91bmQgdGhlIHNwZWNpZmljIGFuaW1hdGlvbiBvbiB0aGUgbGFuZSdzIHNlcXVlbmNlXG4gICAgICAgICAgICAgICAgfSAvLyBlbmQgb2YgZWFjaCBsYW5lJ3MgaXRlbVxuXG4gICAgICAgICAgICB9IC8vIGVuZCBmb3IgZWFjaCBhZmZlY3RlZCBhbmltYXRpb24ncyBpZFxuXG4gICAgICAgICAgICBpZiAoY29uZmxpY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IGNvbmZsaWN0c1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgZXhlYyA9IGZ1bmN0aW9uIGV4ZWMoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFzIHNvb24gYXMgdGhlcmUgYXJlIG5vIGNvbmZsaWN0cyB0aGUgTGFuZXMgSGFuZGxlciBhcHBsaWVzIHRoZSBjaGFuZ2VzIGJlZm9yZSBzZW5kaW5nIG92ZXIgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHN1Y2Nlc3MgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICB0aGF0LkxhbmVzSGFuZGxlci51cGRhdGVMYW5lKGFmZmVjdGVkSW5jaWRlbnRJZHMsIG1pbGxpc2Vjb25kc0RlbHRhKTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBhZmZlY3RlZExhbmVzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZmZlY3RlZExhbmUgPSBhZmZlY3RlZExhbmVzW19pM107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGhlQWN0dWFsTGFuZSA9IHRoYXQuTGFuZXNIYW5kbGVyLmdldExhbmUoYWZmZWN0ZWRMYW5lLm1jaWQsIGFmZmVjdGVkTGFuZS5hdHRyaWJ1dGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5zbGlwSW50b0xhbmVGb3J3YXJkcyh0aGVBY3R1YWxMYW5lLCBhZmZlY3RlZExhbmUsIDAsIHRoYXQucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGVjdXRlOiBleGVjXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge2FycmF5fSBhZmZlY3RlZEFuaW1hdGlvbnMgLSBbe2lkLCBzdGFydCwgZW5kLCBzdGFydERlbHRhfV1cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBmdWxsQ2hhbm5lbFJlc2l6ZSAtIGlmIHNldCB0byB0cnVlIHRoZW4gdGhlIGZ1bGwgaHRtbCBjaGFubmVsIGlzIHJlc2l6aW5nLiBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlIGFzIGluXG4gICAgICAgICAqICB0aGF0IGNhc2Ugbm8gY2hlY2tzIHNob3VsZCBiZSBhY3R1YWxseSBwZXJmb21lZCBub3IgdGhlIHByb2plY3RlZCBjYW5kaWRhdGUgc2hvdWxkIGJlIGFwcGxpZWQgZGlyZWN0bHlcbiAgICAgICAgKiovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NoZWNrUmVzaXplZEluY2lkZW50cycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja1Jlc2l6ZWRJbmNpZGVudHMoYWZmZWN0ZWRBbmltYXRpb25zKSB7XG4gICAgICAgICAgICB2YXIgZnVsbENoYW5uZWxSZXNpemUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgICAgICAgICB2YXIgZXhjbHVkZUlkc0Zyb21DaGVjayA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhZmZlY3RlZEFuaW1hdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBleGNsdWRlSWRzRnJvbUNoZWNrLnB1c2goYWZmZWN0ZWRBbmltYXRpb25zW2ldLmlkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIExhbmVzSGFuZGxlclNhbmRib3ggPSB0aGlzLkxhbmVzSGFuZGxlci5jcmVhdGVUZXN0TGFuZXNTYW5ib3goKTtcblxuICAgICAgICAgICAgdmFyIGNvbmZsaWN0cyA9IFtdO1xuICAgICAgICAgICAgdmFyIGFmZmVjdGVkTGFuZXMgPSBbXTtcblxuICAgICAgICAgICAgLy8gZm9yIGVhY2ggb2YgdGhlIGFmZmVjdGVkQW5pbWF0aW9uc1xuICAgICAgICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgYWZmZWN0ZWRBbmltYXRpb25zLmxlbmd0aDsgX2k0KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYmVsb25naW5nTGFuZXMgPSBMYW5lc0hhbmRsZXJTYW5kYm94LmJlbG9uZ2luZ0xhbmVLZXlzQnlBbmltYXRpb25JZC5fZ2V0KGFmZmVjdGVkQW5pbWF0aW9uc1tfaTRdLmlkKTtcbiAgICAgICAgICAgICAgICB2YXIgdGVzdER1cmF0aW9uID0gYWZmZWN0ZWRBbmltYXRpb25zW19pNF0uZW5kIC0gYWZmZWN0ZWRBbmltYXRpb25zW19pNF0uc3RhcnQ7XG5cbiAgICAgICAgICAgICAgICAvLyBmb3IgZWFjaCBsYW5lIHRoZSBhZmZlY3RlZCBBbmltYXRpb24gYXBwZWFycyBpblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogaW4gYmVsb25naW5nTGFuZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmUgPSBMYW5lc0hhbmRsZXJTYW5kYm94LmxhbmVzLl9nZXQoYmVsb25naW5nTGFuZXNbal0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFuZURhdGEgPSBoZWxwZXIuZ2V0TUNJRGFuZEF0dHJPdXRPZkxhbmVLZXkoYmVsb25naW5nTGFuZXNbal0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBjb25mbGljdHMgYW5kIGVkaXQgbGFuZSBpdGVtcyBtaWxsaXNlY29uZFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGxhbmUubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYW5lW2tdLmluY2lkZW50LmlkID09PSBhZmZlY3RlZEFuaW1hdGlvbnNbX2k0XS5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmZmVjdGVkTGFuZXMucHVzaChsYW5lRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bGxDaGFubmVsUmVzaXplID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWZmZWN0ZWRBbmltID0gbGFuZVtrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlc3RMYW5lRWxlbWVudCA9IExhbmVzSGFuZGxlclNhbmRib3guZ2V0TGFuZUVsZW1lbnRzQ2xvbmUoYWZmZWN0ZWRBbmltKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVzdExhbmVFbGVtZW50Lm1pbGxpc2Vjb25kICs9IGFmZmVjdGVkQW5pbWF0aW9uc1tfaTRdLnN0YXJ0RGVsdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfb3ZlcmxhcHBpbmdBbmltczIgPSBMYW5lc0hhbmRsZXJTYW5kYm94LmdldE92ZXJsYXBwaW5nQW5pbXModGVzdExhbmVFbGVtZW50LCBsYW5lRGF0YS5tY2lkLCBsYW5lRGF0YS5hdHRyaWJ1dGUsIGV4Y2x1ZGVJZHNGcm9tQ2hlY2ssIHRlc3REdXJhdGlvbik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9vdmVybGFwcGluZ0FuaW1zMi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25mbGljdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2FuYXV0aG9yaXNlZCBvdmVybGFwcGluZyBhbmltYXRpb25zIG9uIHRoZSBzYW1lIGVsZW1lbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudF9tY2lkOiBsYW5lRGF0YS5tY2lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGU6IGxhbmVEYXRhLmF0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3QW5pbWF0aW9uOiB0ZXN0TGFuZUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXBwaW5nQW5pbXM6IF9vdmVybGFwcGluZ0FuaW1zMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IC8vIGVuZCBvZiBpZiB3ZSBmb3VuZCB0aGUgc3BlY2lmaWMgYW5pbWF0aW9uIG9uIHRoZSBsYW5lJ3Mgc2VxdWVuY2VcbiAgICAgICAgICAgICAgICAgICAgfSAvLyBlbmQgb2YgZWFjaCBsYW5lJ3MgaXRlbVxuXG4gICAgICAgICAgICAgICAgfSAvLyBlbmQgb2YgZWFjaCBiZWxvbmdpbmcgbGFuZVxuICAgICAgICAgICAgfSAvLyBlbmQgZm9yIGVhY2ggYWZmZWN0ZWQgYW5pbWF0aW9uJ3MgaWRcblxuICAgICAgICAgICAgaWYgKGNvbmZsaWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmxpY3RzOiBjb25mbGljdHNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB1bmxpa2UgdGhlIGNhc2Ugb2YgZWRpdGluZyB0aGUgc3RhcnQgbWlsbGlzZWNvbmQgb2YgYSBTY2VuZSAvIEluY2lkZW50IG9uIGVkaXRpbmcgdGhlIGR1cmF0aW9uIG9mIGEgU2NlbmVcbiAgICAgICAgICAgICAgICAvLyBvciBhbiBJbmNpZGVudCBzbGlwcGluZyB0byBsYW5lcyBzaG91bGQgb2NjdXIgZGVwZW5kcyBub3Qgb25seSBvbiB0aGUgcG9zaXRpb25pbmcgb2YgdGhlIEFuaW1hdGlvbnMgb25cbiAgICAgICAgICAgICAgICAvLyB0aGUgbGFuZXMgYnV0IGFsc28gb24gdGhlaXIgZHVyYXRpb24uIEVkaXRpbmcgdGhlIGR1cmF0aW9uIG9jY3VycyBvbiB0aGUgU2NlbmUgdGhhdCByZWNlaXZlZCB0aGUgZWRpdER1cmF0aW9uXG4gICAgICAgICAgICAgICAgLy8gY29tbWFuZCBhbmQgdGh1cyBhdCB0aGF0IHBvaW50IHRoZSBIVE1MQ2hhbm5lbCAoYW5kIGl0cyBMYW5lc0hhbGRsZXIpIGlzIG5vdCByZWFkeSB0byBzbGlwIGFzIHRoZSBhZmZlY3RlZFxuICAgICAgICAgICAgICAgIC8vIEFuaW1hdGlvbnMgc3RpbGwgaGF2ZSB0aGUgb2xkICh1bi1lZGl0ZWQpIGR1cmF0aW9uLlxuICAgICAgICAgICAgICAgIC8vIEZvciB0aGlzIHJlYXNvbiBhbmQgb25seSBvbiB0aGUgY2FzZSBvZiBkdXJhdGlvbiBlZGl0IHNsaXAgdG8gbGFuZXMgd2lsbCB0YWtlIHBsYWNlIG5vdCBoZXJlIGFuZCBub3Qgbm93XG4gICAgICAgICAgICAgICAgLy8gYnV0IG9uIHRoZSBzY29wZSBvZiB0aGUgU2NlbmUgdGhhdCBnb3QgdGhlIGNvbW1hbmQsIGF0IHRoZSBwb2ludCBpdCByZWNlaXZlcyB0aGUgc3VjY2VzcyAoe3Jlc3VsdDp0cnVlfSkuXG4gICAgICAgICAgICAgICAgLy8gRm9yIHRoaXMgd2Ugd2lsbCBjcmVhdGUgYSBjYWxsYmFjayBmdW5jdGlvbiB3aGljaCBob2xkcyB0aGUgc2xpcHBpbmcgdG8gbGFuZXMgY29tbWFuZHMgYW5kIHBhc3MgaXQgb24gdGhlXG4gICAgICAgICAgICAgICAgLy8gXCJjYWxsYmFja1wiIGtleSBvZiB0aGUgcmVzdWx0IG9iamVjdCAoe3N1Y2Nlc3M6dHJ1ZSwgY2FsbGJhY2s6ZnVuY3Rpb24oKXt0aGF0IHNsaXBzIGludG8gbGFuZXN9fSlcbiAgICAgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgZXhlYyA9IGZ1bmN0aW9uIGV4ZWMoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzbGlwcGluZ0NvbW1hbmRzID0gW107IC8vIGFuIGFycmF5IHRoYXQgd2lsbCBob2xkIGFsbCBvZiB0aGUgc2xpcHBpbmcgY29tbWFuZHMgaW4gYWxsIG9mIHRoZSBhZmZlY3RlZCBsYW5lc1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZUxhbmVzIChvbmx5IHRoaXMgdGltZSBhbmltYXRpb24gYnkgYW5pbWF0aW9uIGFzIHRoZSBtaWxsaXNlY29uZHMgZGVsdGEgaXMgbm90IHN0YW5kYXJkIGZvciBhbGwpXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzIHNvb24gYXMgdGhlcmUgYXJlIG5vIGNvbmZsaWN0cyB0aGUgTGFuZXMgSGFuZGxlciBhcHBsaWVzIHRoZSBjaGFuZ2VzIGJlZm9yZSBzZW5kaW5nIG92ZXIgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHN1Y2Nlc3MgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBhZmZlY3RlZEFuaW1hdGlvbnMubGVuZ3RoOyBfaTUrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5MYW5lc0hhbmRsZXIudXBkYXRlTGFuZShbYWZmZWN0ZWRBbmltYXRpb25zW19pNV0uaWRdLCBhZmZlY3RlZEFuaW1hdGlvbnNbX2k1XS5zdGFydERlbHRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBfbG9vcDIgPSBmdW5jdGlvbiBfbG9vcDIoX2k2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWZmZWN0ZWRMYW5lID0gYWZmZWN0ZWRMYW5lc1tfaTZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRoZUFjdHVhbExhbmUgPSB0aGF0LkxhbmVzSGFuZGxlci5nZXRMYW5lKGFmZmVjdGVkTGFuZS5tY2lkLCBhZmZlY3RlZExhbmUuYXR0cmlidXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHB1dCB0aGUgc2xpcCBjb21tYW5kIG9uIHRoZSBzbGlwcGluZ0NvbW1hbmRzIGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICBzbGlwcGluZ0NvbW1hbmRzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuc2xpcEludG9MYW5lRm9yd2FyZHModGhlQWN0dWFsTGFuZSwgYWZmZWN0ZWRMYW5lLCAwLCB0aGF0LnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBhZmZlY3RlZExhbmVzLmxlbmd0aDsgX2k2KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9sb29wMihfaTYpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2k3ID0gMDsgX2k3IDwgc2xpcHBpbmdDb21tYW5kcy5sZW5ndGg7IF9pNysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzbGlwcGluZ0NvbW1hbmRzW19pN10oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBleGVjdXRlOiBleGVjLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHRydWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjaGVja0RlbGV0ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0RlbGV0ZShyZW1vdmVkQW5pbWF0aW9ucykge1xuICAgICAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICAgICAgdmFyIHJlbW92ZWRBbmltYXRpb25JZHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVtb3ZlZEFuaW1hdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZW1vdmVkQW5pbWF0aW9uSWRzLnB1c2gocmVtb3ZlZEFuaW1hdGlvbnNbaV0uaWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBubyBzbGlwcGluZyBpcyBuZWVkZWQgYXMgb24gZGVsZXRpb24gdGhlIEFuaW1hdGlvbnMgc2V0IHRoZWlyIGVsZW1lbnRzIHRvIHRoZWlyIGluaXRpYWwgdmFsdWVzXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgZXhlYyA9IGZ1bmN0aW9uIGV4ZWMoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFmZmVjdGVkTGFuZXMgPSB0aGF0LkxhbmVzSGFuZGxlci5kZWxldGVBbmltYXRpb25zKHJlbW92ZWRBbmltYXRpb25JZHMsIHRoYXQucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBsYW5lS2V5IGluIGFmZmVjdGVkTGFuZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hZmZlY3RlZExhbmUgPSBhZmZlY3RlZExhbmVzW2xhbmVLZXldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoZUFjdHVhbExhbmUgPSB0aGF0LkxhbmVzSGFuZGxlci5nZXRMYW5lKF9hZmZlY3RlZExhbmUubWNpZCwgX2FmZmVjdGVkTGFuZS5hdHRyaWJ1dGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcHMucHJldmVudFNsaXAgIT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5zbGlwSW50b0xhbmVGb3J3YXJkcyhfdGhlQWN0dWFsTGFuZSwgX2FmZmVjdGVkTGFuZSwgMCwgdGhhdC5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHRydWUsXG4gICAgICAgICAgICAgICAgZXhlY3V0ZTogZXhlY1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGVja3MgaWYgYSBkdXJhdGlvbiBlZGl0IGlzIGZlYXNpYmxlIGFuZCBkb2Vzbid0IGNhdXNlIGNvbmZsaWN0c1xuICAgICAgICAgKiBAcGFyYW0ge2ludH0gZHVyYXRpb24gLSB0aGUgbmV3IGR1cmF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7YXJyYXl9IGlkcyAtIChvcHRpb25hbCkgaWYgcHJvdmlkZWQgaXQgb25seSBjaGVja3MgcmVzaXplcyBvbiB0aGUgZ2l2ZW4gaWRzIChub3QgYWxsIGluY2lkZW50cyBoYXZlIGJlZW4gcmUpXG4gICAgICAgICoqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjaGVja0R1cmF0aW9uRWRpdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0R1cmF0aW9uRWRpdChkdXJhdGlvbkZyYWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgaWRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcblxuICAgICAgICAgICAgLy8gdXNpbmcgUHJvamVjdGlvbnNIYW5sZGVyIGl0IHdpbGwgY3JlYXRlIHRoZSBjYW5kaWRhdGVzIGFuZCB0aGUgcHJvamVjdGlvbnMgdG8gcGFzcyB1cCB0byB0aGUgcGFyZW50XG4gICAgICAgICAgICAvLyByZXR1cm5lZCBvYmplY3Qga2V5czogY2FuZGlkYXRlT3duUHJvamVjdGVkQW5pbWF0aW9ucywgYWZmZWN0ZWRBbmltYXRpb25zXG4gICAgICAgICAgICB2YXIgcHJvamVjdGVkQW5pbWF0aW9ucyA9IHRoaXMucHJvamVjdGlvbnNIYW5kbGVyLnN5c3RvbGVEaWFzdG9sZVByb2plY3Rpb25zKGR1cmF0aW9uRnJhY3Rpb24sIGlkcyk7XG4gICAgICAgICAgICAvLyBvbmNlIGl0IGdldHMgdGhlIHBvcm9qZWN0ZWRBbmltYXRpb25zIGZyb20gaXRzIHByb2plY3Rpb25zIGhhbmxkZXIgaXQgd2lsbCBwYXNzIGl0IHVwIGZvciBjaGVja1xuXG4gICAgICAgICAgICAvLyBpZiB0aGUgaWRzIGFycmF5IGlzIHByb3ZpZGVkIHRoYXQgbWVhbnMgdGhlIGNoZWNrRHVyYXRpb25FZGl0IGlzIGJlZW4gdXNlZCBieSBhbiBBbmltYXRpb24gZGlyZWN0bHlcbiAgICAgICAgICAgIC8vIGJlbG9uZ2luZyB0byB0aGUgaHRtbCBjaGFubmVsLCBzbyBpdCdzIG5vdCBhIGZ1bGwgY2hhbm5lbCByZXNpemVcbiAgICAgICAgICAgIHZhciBjaGVjayA9IHRoaXMuY2hlY2tSZXNpemVkQW5pbWF0aW9ucyhwcm9qZWN0ZWRBbmltYXRpb25zLmFmZmVjdGVkQW5pbWF0aW9ucywgaWRzLmxlbmd0aCA9PT0gMCA/IHRydWUgOiBmYWxzZSk7XG5cbiAgICAgICAgICAgIHJldHVybiBjaGVjaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdGhhdCBpcyBpbnZva2VkIGJ5IEFuaW1hdGlvbiBvYmplY3RzIHdoZW4gb25lIG9mIHRoZWlyIGF0dHJpYnV0ZXMgdmFsdWUgaXMgZWRpdGVkXG4gICAgICAgICAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGhlcmUgb24gdGhlIEhUTUxDaGFubmVsIGlzIHRvIHVwZGF0ZSB0aGUgbGFuZXMgYWNjb3JkaW5nbHkgYW5kIHNsaXAgaW50byB0aGVcbiAgICAgICAgICogY29ycmVzcG9uZGluZyBsYW5lc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYW5pbWF0aW9uSWQgLSB0aGUgaWQgb2YgdGhlIEFuaW1hdGlvbiBvYmplY3QgdGhhdCBoYXMgYmVlbiBlZGl0ZWRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHIgLSB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHRoYXQgaGFzIGJlZW4gZWRpdGVkXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIHRoZSBuZXcgdmFsdWUgb2YgdGhlIGVkaXRlZCBhdHRyaWJ1dGVcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYW5pbWF0aW9uQXR0cmlidXRlVmFsdWVDaGFuZ2UnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYW5pbWF0aW9uQXR0cmlidXRlVmFsdWVDaGFuZ2UoYW5pbWF0aW9uSWQsIGF0dHIsIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgYWZmZWN0ZWRMYW5lcyA9IHRoaXMuTGFuZXNIYW5kbGVyLnVwZGF0ZUF0dHJpYnV0ZU9uTGFuZXMoYW5pbWF0aW9uSWQsIGF0dHIsIHZhbHVlKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWZmZWN0ZWRMYW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBfYWZmZWN0ZWRMYW5lMiA9IGFmZmVjdGVkTGFuZXNbaV07XG4gICAgICAgICAgICAgICAgdmFyIF90aGVBY3R1YWxMYW5lMiA9IHRoaXMuTGFuZXNIYW5kbGVyLmdldExhbmUoX2FmZmVjdGVkTGFuZTIubWNpZCwgX2FmZmVjdGVkTGFuZTIuYXR0cmlidXRlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNsaXBJbnRvTGFuZUZvcndhcmRzKF90aGVBY3R1YWxMYW5lMiwgX2FmZmVjdGVkTGFuZTIsIDAsIHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTbGlwcyB0byBqdXN0IG9uZSBsYW5lIGZvcndhcmRzXG4gICAgICAgICAqIEBwYXJhbSB7YXJyYXl9IGxhbmUgLSB0aGUgbGFuZSB0byBzbGlwIGludG9cbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGxhbmVEYXRhIC0gYW4gb2JqZWN0IHdpdGgga2V5czogYXR0cmlidXRlICYgbWNpZFxuICAgICAgICAgKiBAcGFyYW0ge2ludH0gY3VycmVudE1pbGxpc2Vjb25kIC0gdGhlIG1pbGxpc2Vjb25kIHRoZSBzbGlwIHN0YXJ0cyBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7aW50fSBtaWxsaXNlY29uZCAtIHRoZSB0YXJnZXQgbWlsbGlzZWNvbmQgb2YgdGhlIHNsaXBcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NsaXBJbnRvTGFuZUZvcndhcmRzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNsaXBJbnRvTGFuZUZvcndhcmRzKGxhbmUsIGxhbmVEYXRhLCBjdXJyZW50TWlsbGlzZWNvbmQsIG1pbGxpc2Vjb25kKSB7XG4gICAgICAgICAgICAvLyBoZWxwZXIubG9nKGxhbmUsIGN1cnJlbnRNaWxsaXNlY29uZCwgbWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgdmFyIHBhcnRpY2lwYXRpbmdBbmltcyA9IF9maWx0ZXIobGFuZSwgZnVuY3Rpb24gKGxhbmVJdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhbmVJdGVtLm1pbGxpc2Vjb25kICsgbGFuZUl0ZW0uaW5jaWRlbnQuZHVyYXRpb24gPj0gY3VycmVudE1pbGxpc2Vjb25kICYmIGxhbmVJdGVtLm1pbGxpc2Vjb25kICsgbGFuZUl0ZW0uaW5jaWRlbnQuZHVyYXRpb24gPD0gbWlsbGlzZWNvbmQgfHwgLy8gaXQgZW5kcyBhZnRlciBjdXJyZW50TWlsbGlzZWNvbmQgYW5kIGJlZm9yZSB0YXJnZXQgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgICBsYW5lSXRlbS5pbmNpZGVudC5kdXJhdGlvbiArIGxhbmVJdGVtLm1pbGxpc2Vjb25kID49IG1pbGxpc2Vjb25kICYmIGxhbmVJdGVtLm1pbGxpc2Vjb25kIDw9IG1pbGxpc2Vjb25kOyAvLyBvciBpdCBlbmRzIGFmdGVyIHRoZSB0YXJnZXQgbWlsbGlzZWNvbmQgYnV0IGFsc28gc3RhcnRzIGJlZm9yZSBpdFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChwYXJ0aWNpcGF0aW5nQW5pbXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGFydGljaXBhdGluZ0FuaW1zID0gX3NvcnRCeShwYXJ0aWNpcGF0aW5nQW5pbXMsIFtmdW5jdGlvbiAobGFuZUl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFuZUl0ZW0ubWlsbGlzZWNvbmQ7XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIC8vIG5vdyB3ZSBoYXZlIGFsbCBwYXJ0aWNpcGF0aW5nQW5pbXMgb2YgdGhlIHNsaXAgYWN0aW9uIGluIGNocm9ub2xvZ2ljYWwgb3JkZXJcbiAgICAgICAgICAgIC8vIG91ciBmaXJzdCBqb2IgaXMgdG8gY3JlYXRlIGEgdmFyaWFibGUgdGhhdCB3aWxsIGhvbGQgdGhlIGxhc3Qga25vd24gdmFsdWUgb2YgdGhlIGxhbmVcbiAgICAgICAgICAgIHZhciBsYXN0VmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0aWNpcGF0aW5nQW5pbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFydGljaXBhdGluZ0FuaW0gPSBwYXJ0aWNpcGF0aW5nQW5pbXNbaV0uaW5jaWRlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0TWlsbGlzZWNvbmQgPSBwYXJ0aWNpcGF0aW5nQW5pbXNbaV0ubWlsbGlzZWNvbmQ7XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgYW5pbWF0aW9uIGhhcyBubyBzdGFydCB2YWx1ZXMgZ28gYWhlYWQgYW5kIGNhbGN1bGF0ZWQgdGhlbSBub3dcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnRpY2lwYXRpbmdBbmltLmhhc0luaXRpYWxWYWx1ZShsYW5lRGF0YS5hdHRyaWJ1dGUpICYmIGxhc3RWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBoZWxwZXIubG9nKCdzZXR0aW5nIGluaXRpYWwgdmFsdWU6ICcsIGxhbmVEYXRhLm1jaWQsIGxhbmVEYXRhLmF0dHJpYnV0ZSwgJ2NhbGN1bGF0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgcGFydGljaXBhdGluZ0FuaW0uc2V0SW5pdGlhbFZhbHVlKGxhbmVEYXRhLm1jaWQsIGxhbmVEYXRhLmF0dHJpYnV0ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghcGFydGljaXBhdGluZ0FuaW0uaGFzSW5pdGlhbFZhbHVlKGxhbmVEYXRhLmF0dHJpYnV0ZSkgJiYgbGFzdFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaGVscGVyLmxvZygnc2V0dGluZyBpbml0aWFsIHZhbHVlOiAnLCBsYW5lRGF0YS5tY2lkLCBsYW5lRGF0YS5hdHRyaWJ1dGUsIGxhc3RWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2lwYXRpbmdBbmltLnNldEluaXRpYWxWYWx1ZShsYW5lRGF0YS5tY2lkLCBsYW5lRGF0YS5hdHRyaWJ1dGUsIGxhc3RWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGFuaW1hdGlvbiBlbmRzIGJlZm9yZSB0aGUgdGFyZ2V0IG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgICAgLy8gaGVscGVyLmxvZygncGFydGljaXBhdGluZ0FuaW0uZHVyYXRpb24gKyBzdGFydE1pbGxpc2Vjb25kJywgcGFydGljaXBhdGluZ0FuaW0uZHVyYXRpb24gKyBzdGFydE1pbGxpc2Vjb25kLCBtaWxsaXNlY29uZCk7XFxcblxuICAgICAgICAgICAgICAgIGlmIChwYXJ0aWNpcGF0aW5nQW5pbS5kdXJhdGlvbiArIHN0YXJ0TWlsbGlzZWNvbmQgPD0gbWlsbGlzZWNvbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaGVscGVyLmxvZygnZW5kcyBiZWZvcmUgdGFyZ2V0JylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRpY2lwYXRpbmdBbmltLmF0dHJzLmhhc093blByb3BlcnR5KCdhbmltYXRlZEF0dHJzJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RWYWx1ZSA9IHBhcnRpY2lwYXRpbmdBbmltLmF0dHJzLmFuaW1hdGVkQXR0cnNbbGFuZURhdGEuYXR0cmlidXRlXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gcGFydGljaXBhdGluZ0FuaW1zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpY2lwYXRpbmdBbmltLnByb2dyZXNzKDEsIHBhcnRpY2lwYXRpbmdBbmltLmR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNsaXAgZm9yIHRoZSBzcGVjaWZpYyBlbGVtZW50IGFuZCB0aGUgc3BlY2lmaWMgYXR0cmlidXRlLiBTZXQgdGhlIEFuaW1hdGlvbiBhcyBwYXVzZWQgb3IgcGxheWluZyBhXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBzdG9yZSB0aGlzIGluZm8gc29tZXdoZXJlXG4gICAgICAgICAgICAgICAgICAgIHZhciBwZXJjZW50YWdlQ29tcGxldGUgPSAobWlsbGlzZWNvbmQgLSBzdGFydE1pbGxpc2Vjb25kKSAvIHBhcnRpY2lwYXRpbmdBbmltLmR1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNpcGF0aW5nQW5pbS5wcm9ncmVzcyhwZXJjZW50YWdlQ29tcGxldGUsIG1pbGxpc2Vjb25kIC0gc3RhcnRNaWxsaXNlY29uZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNsaXBzIHRvIGp1c3Qgb25lIGxhbmUgYmFja3dhcmRzXG4gICAgICAgICAqIEBwYXJhbSB7YXJyYXl9IGxhbmUgLSB0aGUgbGFuZSB0byBzbGlwIGludG9cbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGxhbmVEYXRhIC0gYW4gb2JqZWN0IHdpdGgga2V5czogYXR0cmlidXRlICYgbWNpZFxuICAgICAgICAgKiBAcGFyYW0ge2ludH0gY3VycmVudE1pbGxpc2Vjb25kIC0gdGhlIG1pbGxpc2Vjb25kIHRoZSBzbGlwIHN0YXJ0cyBmcm9tXG4gICAgICAgICAqIEBwYXJhbWEge2ludH0gbWlsbGlzZWNvbmQgLSB0aGUgdGFyZ2V0IG1pbGxpc2Vjb25kIG9mIHRoZSBzbGlwXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzbGlwVG9MYW5lQmFja3dhcmRzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNsaXBUb0xhbmVCYWNrd2FyZHMobGFuZSwgbGFuZURhdGEsIGN1cnJlbnRNaWxsaXNlY29uZCwgbWlsbGlzZWNvbmQpIHtcbiAgICAgICAgICAgIC8vIHdlIHRha2UgYWxsIEFuaW1hdGlvbnMgdGhhdCBhcmUgZWl0aGVyIGN1cnJlbnRseSBydW5uaW5nIG9yXG4gICAgICAgICAgICAvLyB0aGV5IGVuZCBhZnRlciB0aGUgZGVzdGluYXRpb24gcG9pbnRcbiAgICAgICAgICAgIC8vIGhlbHBlci5sb2coJzwtLS0tLS0nKTtcbiAgICAgICAgICAgIHZhciBwYXJ0aWNpcGF0aW5nQW5pbXMgPSBfZmlsdGVyKGxhbmUsIGZ1bmN0aW9uIChsYW5lSXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciBsYW5lSXRlbUVuZCA9IGxhbmVJdGVtLmluY2lkZW50LmR1cmF0aW9uICsgbGFuZUl0ZW0ubWlsbGlzZWNvbmQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhbmVJdGVtRW5kIDw9IG1pbGxpc2Vjb25kICYmIGxhbmVJdGVtRW5kID49IGN1cnJlbnRNaWxsaXNlY29uZCB8fCAvLyB0aGV5IGVuZCBpbiB0aGUgaG90IGFyZWFcbiAgICAgICAgICAgICAgICBsYW5lSXRlbS5taWxsaXNlY29uZCA+PSBjdXJyZW50TWlsbGlzZWNvbmQgJiYgbGFuZUl0ZW0ubWlsbGlzZWNvbmQgPD0gbWlsbGlzZWNvbmQgfHwgLy8gdGhleSBzdGFydCBpbiB0aGUgaG90IGFyZWFcbiAgICAgICAgICAgICAgICBsYW5lSXRlbS5taWxsaXNlY29uZCA8IGN1cnJlbnRNaWxsaXNlY29uZCAmJiBsYW5lSXRlbUVuZCA+IG1pbGxpc2Vjb25kOyAvLyB0aGV5IG92ZXJsYXAgdGhlIGhvdCBhcmVhXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHBhcnRpY2lwYXRpbmdBbmltcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXJ0aWNpcGF0aW5nQW5pbXMgPSBfc29ydEJ5KHBhcnRpY2lwYXRpbmdBbmltcywgW2Z1bmN0aW9uIChsYW5lSXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsYW5lSXRlbS5taWxsaXNlY29uZDtcbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgdmFyIGxhc3RWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gcGFydGljaXBhdGluZ0FuaW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnRpY2lwYXRpbmdBbmltID0gcGFydGljaXBhdGluZ0FuaW1zW2ldLmluY2lkZW50O1xuICAgICAgICAgICAgICAgIHZhciBzdGFydE1pbGxpc2Vjb25kID0gcGFydGljaXBhdGluZ0FuaW1zW2ldLm1pbGxpc2Vjb25kO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydE1pbGxpc2Vjb25kID49IG1pbGxpc2Vjb25kKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2lwYXRpbmdBbmltLnByb2dyZXNzKDAsIDApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwZXJjZW50YWdlQ29tcGxldGUgPSAobWlsbGlzZWNvbmQgLSBzdGFydE1pbGxpc2Vjb25kKSAvIHBhcnRpY2lwYXRpbmdBbmltLmR1cmF0aW9uO1xuXG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2lwYXRpbmdBbmltLnByb2dyZXNzKHBlcmNlbnRhZ2VDb21wbGV0ZSwgbWlsbGlzZWNvbmQgLSBzdGFydE1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgIEBwYXJhbSB7aW50fSBmcm9tIC0gdGhlIG1pbGxpc2Vjb25kIHRvIHN0YXJ0IGZyb21cbiAgICAgICAgIEBwYXJhbSB7aW50fSB0byAtIHRoZSBtaWxsaXNlY29uZCB0byBnbyB0b1xuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbW92ZVRvJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVUbyhmcm9tLCB0bykge1xuICAgICAgICAgICAgLy8gc3RlcCAxOiBpdGVyYXRlIHRocm91Z2ggYWxsIGxhbmVzXG4gICAgICAgICAgICB2YXIgbGFuZUtleXMgPSB0aGlzLmxhbmVzLl9rZXlzKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhbmVLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhbmVpZCA9IGxhbmVLZXlzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBsYW5lID0gdGhpcy5sYW5lcy5fZ2V0KGxhbmVpZCk7XG4gICAgICAgICAgICAgICAgdmFyIGxhbmVEYXRhID0gaGVscGVyLmdldE1DSURhbmRBdHRyT3V0T2ZMYW5lS2V5KGxhbmVpZCk7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPCB0bykge1xuICAgICAgICAgICAgICAgICAgICAvLyBoZWxwZXIubG9nKGxhbmVpZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2xpcEludG9MYW5lRm9yd2FyZHMobGFuZSwgbGFuZURhdGEsIGZyb20sIHRvKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZyb20gPj0gdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zbGlwVG9MYW5lQmFja3dhcmRzKGxhbmUsIGxhbmVEYXRhLCBmcm9tLCB0byk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdsYW5lcycsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuTGFuZXNIYW5kbGVyLmxhbmVzO1xuICAgICAgICB9XG4gICAgfV0sIFt7XG4gICAgICAgIGtleTogJ3R5cGUnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBcImF0dHJpYnV0ZXNcIjtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBBdHRyaWJ1dGVDaGFubmVsO1xufShDaGFubmVsKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBdHRyaWJ1dGVDaGFubmVsOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/AttributeChannel.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/LanesHandler.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/LanesHandler.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _cloneDeep = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.clonedeep/index */ \"./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.clonedeep/index.js\");\nvar _filter = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.filter/index */ \"./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.filter/index.js\");\nvar _sortBy = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.sortby/index */ \"./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.sortby/index.js\");\nvar _findIndex = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.findindex/index */ \"./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.findindex/index.js\");\nvar _find = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.find/index */ \"./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.find/index.js\");\n\nvar Helper = __webpack_require__(/*! ../../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper({ logLevel: 4 });\n\nvar Collection = __webpack_require__(/*! ./helpers/Collection */ \"./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/helpers/Collection.js\");\nvar SandboxLanes = __webpack_require__(/*! ./helpers/SandboxLanes */ \"./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/helpers/SandboxLanes.js\");\nvar SandboxCollection = __webpack_require__(/*! ./helpers/SandboxCollection */ \"./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/helpers/SandboxCollection.js\");\n\nvar LanesHandler = function () {\n    function LanesHandler() {\n        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, LanesHandler);\n\n        /*\n         * Keeps the lanes of the Channel in the form:\n         * {\n         *  <motorcortex-id>_<attribute>: [\n         *      {\n         *          millisecond: the millisecond of the channel this Animation (that affects the selector/attribute pair) runs\n         *          incident: Animation (the animation object that holds the affecting animation\n         *      }\n         *  ]\n         * }\n         /** @type {{}}\n         */\n        this.lanes = new Collection({});\n        if (props.lanes) {\n            this.lanes = props.lanes;\n        }\n\n        this.comboAttributes = {};\n        if (props.comboAttributes != null) {\n            this.comboAttributes = props.comboAttributes;\n        }\n\n        /*\n        Keeps an indexing of the lanes each Animation belongs to. The form is the following:\n        belongingLaneKeysByAnimationId: {\n            <animation_id>: [laneKey1, laneKey2, ...],\n            <animation_id>: [laneKey2, laneKey3, ...],\n            ...\n        }\n         */\n        this.belongingLaneKeysByAnimationId = new Collection({});\n        if (props.belongingLaneKeysByAnimationId) {\n            this.belongingLaneKeysByAnimationId = props.belongingLaneKeysByAnimationId;\n        }\n    }\n\n    /**\n     * This method resizes all the lanes of the Lanes Handler by the durationFraction provided.\n     * No checks are performed. \n     * This method is been invoked in cases where a full Clip gets resized, so no conflict checks need to\n     * run.\n     * @param {float} durationFration: the fraction between the new duration and the current\n    */\n\n\n    _createClass(LanesHandler, [{\n        key: '_resize',\n        value: function _resize(durationFraction) {\n            var keys = this.lanes._keys();\n\n            for (var i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                var theLane = this.lanes._get(key);\n                for (var _i = 0; _i < theLane.length; _i++) {\n                    theLane[_i].millisecond = theLane[_i].millisecond * durationFraction;\n                }\n            }\n        }\n\n        /**\n         * it creates a new LanesHandler that acts as a sanbox for testing changes\n        */\n\n    }, {\n        key: 'createTestLanesSanbox',\n        value: function createTestLanesSanbox() {\n            var props = {\n                lanes: new SandboxLanes(this.lanes._export()),\n                belongingLaneKeysByAnimationId: new SandboxCollection(this.belongingLaneKeysByAnimationId._export()) //JSON.parse(JSON.stringify(this.belongingLaneKeysByAnimationId))\n            };\n\n            if (this.comboAttributes) {\n                props.comboAttributes = this.comboAttributes;\n            }\n\n            return new LanesHandler(props);\n        }\n    }, {\n        key: 'getLanesCopy',\n        value: function getLanesCopy(lane) {\n            var laneToReturn = [];\n            for (var i = 0; i < lane.length; i++) {\n                laneToReturn.push({\n                    id: lane[i].id,\n                    incident: lane[i].incident,\n                    millisecond: lane[i].millisecond * 1\n                });\n            }\n            return laneToReturn;\n        }\n    }, {\n        key: 'getLaneElementsClone',\n        value: function getLaneElementsClone(laneElement) {\n            // return _cloneDeep(laneElement);\n            return {\n                id: laneElement.id,\n                millisecond: laneElement.millisecond * 1,\n                incident: {\n                    duration: laneElement.incident.duration * 1,\n                    id: laneElement.incident.id\n                }\n                // return JSON.parse(JSON.stringify(laneElement));\n            };\n        }\n    }, {\n        key: 'applySandboxChanges',\n        value: function applySandboxChanges(SanboxObject) {\n            this.lanes = new Collection(SanboxObject.lanes._export());\n\n            this.belongingLaneKeysByAnimationId = new Collection(SanboxObject.belongingLaneKeysByAnimationId._export());\n        }\n    }, {\n        key: 'getLane',\n        value: function getLane(mcid, attr) {\n            return this.lanes._get(helper.getLaneKey(mcid, attr));\n        }\n\n        /**\n         * Checks whether the incident has animatedAttrs or not. \n        **/\n\n    }, {\n        key: '_incidentHasAnimatedAttrs',\n        value: function _incidentHasAnimatedAttrs(incident) {\n            if (incident.attrs.hasOwnProperty('animatedAttrs')) {\n                return true;\n            }\n            return false;\n        }\n\n        /**\n         * return true if lane exists or false otherwise\n         * @param {String} mcid\n         * @param {String} attr\n         * @param {boolean} ifNotCreateIt - if is set to true and the lane doesn't exist it creates it but still returning false\n        */\n\n    }, {\n        key: 'laneExists',\n        value: function laneExists(mcid, attr) {\n            var ifNotCreateIt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n            var laneKey = helper.getLaneKey(mcid, attr);\n            if (!this.lanes._hasOwnProperty(laneKey)) {\n                if (ifNotCreateIt) {\n                    this.lanes._set(laneKey, []);\n                }\n                return false;\n            } else {\n                return true;\n            }\n        }\n    }, {\n        key: 'animationIDExists',\n        value: function animationIDExists(mcid, attr, animationID) {\n            if (this.belongingLaneKeysByAnimationId._hasOwnProperty(animationID)) {\n                if (this.belongingLaneKeysByAnimationId._get(animationID).indexOf(helper.getLaneKey(mcid, attr)) >= 0) {\n                    return true;\n                } else {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        }\n\n        /**\n         * @param {Object} newAnim - an object of the form of a lane item (with keys \"millisecond\" and \"incident\"\n         * @param {string} mcid\n         * @param {String} attr\n         * @param {array} excludeIdsFromCheck - optional. If exists it excludes all the ids of this array from check. This\n         *  parameter has been added for the edit checks where an animation might overlap another animation that participates on\n         *  the move, something that should not happen as the edited animations pre-existed without conflicts and the move of all\n         *  of them together guarantees that there is going to be no conflict between them even after the edit\n         * @param {int} testDuration - optional. This parameter is used when the channel needs to addcheck overlaps after duration\n         *  edits, so the testDuration is passed (we don't want to polute the original animation object as it refers to the real one)\n         * @retuns {array} - a list of all overlapping animations of the lane\n        */\n\n    }, {\n        key: 'getOverlappingAnims',\n        value: function getOverlappingAnims(newAnim, mcid, attr) {\n            var excludeIdsFromCheck = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n            var testDuration = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\n            var overlappingAnims = _filter(this.lanes._get(helper.getLaneKey(mcid, attr)), function (existingAnim) {\n                var durationToUseOnChecks = newAnim.incident.duration;\n                if (testDuration != null) {\n                    durationToUseOnChecks = testDuration;\n                }\n\n                return existingAnim.incident.id != newAnim.incident.id && excludeIdsFromCheck.indexOf(existingAnim.incident.id) < 0 && (\n                // existing anim starts within the new anim's extend\n                existingAnim.millisecond >= newAnim.millisecond && existingAnim.millisecond < durationToUseOnChecks + newAnim.millisecond ||\n                // or ends within the new anim's extend\n                existingAnim.millisecond + existingAnim.incident.duration > newAnim.millisecond && existingAnim.millisecond + existingAnim.incident.duration <= durationToUseOnChecks + newAnim.millisecond\n                // or it starts before and ends after the new anim's extend\n                || existingAnim.millisecond < newAnim.millisecond && existingAnim.millisecond + existingAnim.incident.duration > durationToUseOnChecks + newAnim.millisecond);\n            });\n\n            return overlappingAnims;\n        }\n\n        /**\n         * it justs adds the lane item to the lane and adjusts the initial values of the Anims in sequence\n         * No checks are performed, just execution.\n         * @param {String} mcid\n         * @param {String} attr\n         * @param {int} millisecond\n         * @param {Object} incident\n        */\n\n    }, {\n        key: 'addElementToLane',\n        value: function addElementToLane(mcid, attr, millisecond, incident) {\n\n            var laneKey = helper.getLaneKey(mcid, attr);\n\n            var laneElement = {\n                millisecond: millisecond,\n                incident: incident,\n                id: incident.id\n            };\n\n            this.laneExists(mcid, attr, true);\n            var theLane = this.lanes._get(laneKey);\n\n            theLane.push(laneElement);\n            theLane = _sortBy(theLane, ['millisecond']);\n\n            // indexing stuff\n            if (!this.belongingLaneKeysByAnimationId._hasOwnProperty(incident.id)) {\n                this.belongingLaneKeysByAnimationId._set(incident.id, []);\n            }\n            this.belongingLaneKeysByAnimationId._get(incident.id).push(laneKey);\n            // indexing\n            var newAnimsIndex = _findIndex(theLane, function (item) {\n                return item.incident.id === incident.id;\n            });\n\n            /* if the incident has no animated attributes we don't need to work on start and final values */\n            if (!this._incidentHasAnimatedAttrs(incident)) {\n                return { onSuccessAction: function onSuccessAction() {} };\n            }\n\n            // helper.log(newAnimsIndex);\n            // step 1: set the intial values of the new Animation\n            if (newAnimsIndex === 0) {\n                // if the newly entered animation is the first of the lane\n                if (theLane.length > 1) {\n                    // and it has other animations too\n                    if (theLane[1].incident.hasInitialValue(attr)) {\n                        // if the initial value of the following animation\n                        // which used to be first is already calculated \"steal\" it\n                        incident.setInitialValue(attr, theLane[1].incident.getInitialValue(attr));\n                    }\n                } else {\n                    // else take it directly from the dom\n                    incident.setInitialValue(attr, incident.getScratchValue(mcid, attr));\n                }\n            } else {\n                incident.setInitialValue(attr, theLane[newAnimsIndex - 1].incident.attrs.animatedAttrs[attr]);\n            }\n\n            /* if the attribute of the lane is a compo attribute */\n            if (this.comboAttributes.hasOwnProperty(attr)) {\n                var incidentInitialValues = incident.getInitialValue(attr);\n                for (var key in incidentInitialValues) {\n                    if (!incident.attrs.animatedAttrs[attr].hasOwnProperty(key)) {\n                        incident.attrs.animatedAttrs[attr][key] = incidentInitialValues[key];\n                    }\n                }\n            }\n\n            var onSuccessAction = function onSuccessAction() {};\n            // step 2: set the inital values of the following Animation (if any)\n            if (newAnimsIndex + 1 < theLane.length) {\n                onSuccessAction = function onSuccessAction() {\n                    theLane[newAnimsIndex + 1].incident.setInitialValue(attr, incident.attrs.animatedAttrs[attr]);\n                    if (theLane[newAnimsIndex + 1].incident.gotContext) {\n                        theLane[newAnimsIndex + 1].incident.onGetContext();\n                    }\n                };\n            }\n\n            onSuccessAction();\n        }\n\n        /**\n         * it justs updates the lane\n         * No checks are performed, just execution\n         * @param {array} affectedAnimationsIds\n         * @param {String} attr\n         * @param {int} millisecondDelta\n        */\n\n    }, {\n        key: 'updateLane',\n        value: function updateLane(affectedAnimationsIds, millisecondsDelta) {\n            var _this = this;\n\n            // first we group the affected animations by lanes\n            var affectedLanes = {};\n            var that = this;\n            for (var i = 0; i < affectedAnimationsIds.length; i++) {\n                var belongingLanes = this.belongingLaneKeysByAnimationId._get(affectedAnimationsIds[i]);\n                for (var j = 0; j < belongingLanes.length; j++) {\n                    var laneKey = belongingLanes[j];\n                    if (!affectedLanes.hasOwnProperty(laneKey)) {\n                        affectedLanes[laneKey] = {\n                            animations: [],\n                            lane: that.lanes._get(laneKey),\n                            laneData: helper.getMCIDandAttrOutOfLaneKey(belongingLanes[j])\n                        };\n                    }\n                    affectedLanes[laneKey].animations.push(affectedAnimationsIds[i]);\n                }\n            }\n\n            // for each of the affected lanes\n            for (var _laneKey in affectedLanes) {\n                var affectedLane = affectedLanes[_laneKey];\n                var lane = affectedLane.lane;\n                var laneData = affectedLane.laneData;\n                var laneBeforeEdit = _sortBy(this.getLanesCopy(lane), ['millisecond']);\n\n                // edit lane items millisecond\n                for (var k = 0; k < lane.length; k++) {\n                    if (affectedLane.animations.indexOf(lane[k].incident.id) >= 0) {\n                        lane[k].millisecond += millisecondsDelta;\n                    }\n                } // end for searching for the animations within the lane\n\n                var sortedLane = _sortBy(lane, ['millisecond']);\n                this.lanes._set(_laneKey, sortedLane);\n                lane = sortedLane;\n                // console.log(this);\n\n                var _loop = function _loop(_i2) {\n                    var animationToCheck = affectedLane.animations[_i2];\n                    var animationIndexBeforeEdit = _findIndex(laneBeforeEdit, function (item) {\n                        return item.incident.id === animationToCheck;\n                    });\n                    var animationIndexAfterEdit = _findIndex(lane, function (item) {\n                        return item.incident.id === animationToCheck;\n                    });\n                    var animation = lane[animationIndexAfterEdit].incident;\n\n                    /**\n                     * if the first animation doesn't have animated attributes that means no one on this channel has. Brake\n                     * and exit the loop that handles start and end values\n                    */\n                    if (!_this._incidentHasAnimatedAttrs(animation)) {\n                        return 'break';\n                    }\n\n                    if (animationIndexBeforeEdit !== animationIndexAfterEdit || animationIndexAfterEdit > 1) {\n                        if (animationIndexBeforeEdit + 1 < lane.length) {\n                            // if the animation was not the last animation on the lane before the edit\n                            // we should take care of the initial values of the animation's previous successor\n                            if (animationIndexBeforeEdit === 0) {\n                                // if the edited animation was the first one before the edit\n                                // if it has initial values, pass them to its previous successor as its new initial values\n                                if (animation.hasInitialValue(laneData.attribute) !== false) {\n                                    // get the initial value of the edited animation and set it as initial value of the new 0 index\n                                    laneBeforeEdit[1].incident.setInitialValue(laneData.attribute, animation.getInitialValue(laneData.mcid, laneData.attribute));\n                                } else {\n                                    // otherwise calculate the initial value on the fly, out of the dom and set it to the new 0\n                                    laneBeforeEdit[1].incident.setInitialValue(laneData.attribute, laneBeforeEdit[1].incident.getScratchValue(laneData.mcid, laneData.attribute));\n                                }\n                            } else {\n                                // else if the edited animation was not the first one before the edit\n                                // meaning its previous successor is not the first one on the lane after the edit\n                                // just grab the target value of the new previous animation of the animation's previous successor and set it as initial value\n                                laneBeforeEdit[animationIndexBeforeEdit + 1].incident.setInitialValue(laneData.attribute, laneBeforeEdit[animationIndexBeforeEdit - 1].incident.attrs.animatedAttrs[laneData.attribute]);\n                            }\n                        }\n\n                        // for the edited animation itself now:\n                        if (animationIndexAfterEdit === 0) {\n                            // is it the first one (after edit)?\n                            // does the previously zero index animation has initial value?\n                            if (laneBeforeEdit[0].incident.hasInitialValue(laneData.attribute)) {\n                                // get the initial values of the previously 0 indexed animation of the lane\n                                animation.setInitialValue(laneData.attribute, laneBeforeEdit[0].incident.getInitialValue(laneData.mcid, laneData.attribute));\n                            } else {\n                                // otherwise calculate the initial value on the fly, our of the dom\n                                animation.setInitialValue(laneData.mcid, laneData.attribute, animation.getScratchValue(laneData.mcid, laneData.attribute));\n                            }\n                        } else {\n                            // else if it is not the first one after edit\n                            // just grab the target value of the previous animation on the updated lane and set it as its initial value\n                            animation.setInitialValue(laneData.attribute, lane[animationIndexAfterEdit - 1].incident.attrs.animatedAttrs[laneData.attribute]);\n                        }\n\n                        // for its new next animation (if it has one)\n                        if (animationIndexAfterEdit + 1 < lane.length) {\n                            // set its initial value to equal the target value of the edited animation\n                            lane[animationIndexAfterEdit + 1].incident.setInitialValue(laneData.attribute, animation.attrs.animatedAttrs[laneData.attribute]);\n                        }\n                    }\n                };\n\n                for (var _i2 = 0; _i2 < affectedLane.animations.length; _i2++) {\n                    var _ret = _loop(_i2);\n\n                    if (_ret === 'break') break;\n                }\n            } // end for each of the belonging lanes of the animation\n        }\n\n        /**\n         * removes the list of animations as provided\n         * @param {array} removedAnimations - an array with the removed animations' ids\n        */\n\n    }, {\n        key: 'deleteAnimations',\n        value: function deleteAnimations(removedAnimations, currentMillisecond) {\n            var affectedLanes = {};\n\n            for (var i = 0; i < removedAnimations.length; i++) {\n                var id = removedAnimations[i];\n                // for each lane the affected Animation appears in\n                var belongingLanes = this.belongingLaneKeysByAnimationId._get(id);\n                for (var j = 0; j < belongingLanes.length; j++) {\n                    var lane = this.lanes._get(belongingLanes[j]);\n\n                    var _animationIndexBeforeEdit = -1;\n                    for (var k = 0; k < lane.length; k++) {\n                        if (lane[k].incident.id === id) {\n                            _animationIndexBeforeEdit = k;\n                            break;\n                        }\n                    }\n\n                    // helper.log(animationIndexBeforeEdit);\n                    var animationToDelete = Object.assign({}, lane[_animationIndexBeforeEdit]);\n                    var animationObjectToDelete = animationToDelete.incident;\n                    var laneData = helper.getMCIDandAttrOutOfLaneKey(belongingLanes[j]);\n\n                    // gets the lane without the removed animation\n                    var newLane = [];\n                    for (var _k = 0; _k < lane.length; _k++) {\n                        if (lane[_k].incident.id != id) {\n                            newLane.push(lane[_k]);\n                        }\n                    }\n                    this.lanes._set(belongingLanes[j], newLane);\n                    lane = this.lanes._get(belongingLanes[j]);\n\n                    if (lane.length === 0) {\n                        this.lanes._delete(belongingLanes[j]);\n                        if (affectedLanes.hasOwnProperty(belongingLanes[j])) {\n                            delete affectedLanes[belongingLanes[j]];\n                        }\n                    } else {\n                        if (this._incidentHasAnimatedAttrs(animationToDelete.incident)) {\n                            affectedLanes[belongingLanes[j]] = helper.getMCIDandAttrOutOfLaneKey(belongingLanes[j]);\n                            if (_animationIndexBeforeEdit < lane.length && animationToDelete.incident.getInitialValue(laneData.mcid, laneData.attribute) !== false) {\n                                lane[_animationIndexBeforeEdit].incident.setInitialValue(laneData.attribute, animationToDelete.incident.getInitialValue(laneData.mcid, laneData.attribute));\n                            }\n                        }\n                    }\n                }\n                this.belongingLaneKeysByAnimationId._delete(removedAnimations[i]);\n            }\n            return affectedLanes;\n        }\n\n        /**\n         * This method handles edits on the final value of a specific attribute of a specific animation object\n         * @param {string} animationId - the id of the Animation object that has been edited\n         * @param {string} attr - the name of the attribute that has been edited\n         * @param {string} value - the new value of the edited attribute\n        */\n\n    }, {\n        key: 'updateAttributeOnLanes',\n        value: function updateAttributeOnLanes(animationId, attr, value) {\n            var belongingLanes = this.belongingLaneKeysByAnimationId._get(animationId);\n            var affectedLanes = [];\n            for (var i = 0; i < belongingLanes.length; i++) {\n                var lane = this.lanes._get(belongingLanes[i]);\n                var laneData = helper.getMCIDandAttrOutOfLaneKey(belongingLanes[i]);\n\n                // get the index of the animation on the lane\n                var animationIndex = -1;\n                for (var k = 0; k < lane.length; k++) {\n                    if (lane[k].incident.id === animationId) {\n                        animationIndex = k;\n                        break;\n                    }\n                }\n\n                // if the animation is not the last one on the lane\n                if (lane.length - 1 != animationIndex) {\n                    lane[animationIndex + 1].incident.setInitialValue(laneData.mcid, laneData.attribute, value);\n                }\n\n                affectedLanes.push(laneData);\n            }\n\n            return affectedLanes;\n        }\n    }]);\n\n    return LanesHandler;\n}();\n\nmodule.exports = LanesHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DaGFubmVscy9fQXR0cmlidXRlL0xhbmVzSGFuZGxlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2Rpc3QvX0NoYW5uZWxzL19BdHRyaWJ1dGUvTGFuZXNIYW5kbGVyLmpzPzFmMjYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgX2Nsb25lRGVlcCA9IHJlcXVpcmUoJy4uLy4uLy4uL2xvZGFzaC1jdXN0b20tYnVpbGQvbW9kdWxhcml6ZS9sb2Rhc2guY2xvbmVkZWVwL2luZGV4Jyk7XG52YXIgX2ZpbHRlciA9IHJlcXVpcmUoJy4uLy4uLy4uL2xvZGFzaC1jdXN0b20tYnVpbGQvbW9kdWxhcml6ZS9sb2Rhc2guZmlsdGVyL2luZGV4Jyk7XG52YXIgX3NvcnRCeSA9IHJlcXVpcmUoJy4uLy4uLy4uL2xvZGFzaC1jdXN0b20tYnVpbGQvbW9kdWxhcml6ZS9sb2Rhc2guc29ydGJ5L2luZGV4Jyk7XG52YXIgX2ZpbmRJbmRleCA9IHJlcXVpcmUoJy4uLy4uLy4uL2xvZGFzaC1jdXN0b20tYnVpbGQvbW9kdWxhcml6ZS9sb2Rhc2guZmluZGluZGV4L2luZGV4Jyk7XG52YXIgX2ZpbmQgPSByZXF1aXJlKCcuLi8uLi8uLi9sb2Rhc2gtY3VzdG9tLWJ1aWxkL21vZHVsYXJpemUvbG9kYXNoLmZpbmQvaW5kZXgnKTtcblxudmFyIEhlbHBlciA9IHJlcXVpcmUoJy4uLy4uL19jb3JlVXRpbHMvSGVscGVyJyk7XG52YXIgaGVscGVyID0gbmV3IEhlbHBlcih7IGxvZ0xldmVsOiA0IH0pO1xuXG52YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vaGVscGVycy9Db2xsZWN0aW9uJyk7XG52YXIgU2FuZGJveExhbmVzID0gcmVxdWlyZSgnLi9oZWxwZXJzL1NhbmRib3hMYW5lcycpO1xudmFyIFNhbmRib3hDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi9oZWxwZXJzL1NhbmRib3hDb2xsZWN0aW9uJyk7XG5cbnZhciBMYW5lc0hhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGFuZXNIYW5kbGVyKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMYW5lc0hhbmRsZXIpO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIEtlZXBzIHRoZSBsYW5lcyBvZiB0aGUgQ2hhbm5lbCBpbiB0aGUgZm9ybTpcbiAgICAgICAgICoge1xuICAgICAgICAgKiAgPG1vdG9yY29ydGV4LWlkPl88YXR0cmlidXRlPjogW1xuICAgICAgICAgKiAgICAgIHtcbiAgICAgICAgICogICAgICAgICAgbWlsbGlzZWNvbmQ6IHRoZSBtaWxsaXNlY29uZCBvZiB0aGUgY2hhbm5lbCB0aGlzIEFuaW1hdGlvbiAodGhhdCBhZmZlY3RzIHRoZSBzZWxlY3Rvci9hdHRyaWJ1dGUgcGFpcikgcnVuc1xuICAgICAgICAgKiAgICAgICAgICBpbmNpZGVudDogQW5pbWF0aW9uICh0aGUgYW5pbWF0aW9uIG9iamVjdCB0aGF0IGhvbGRzIHRoZSBhZmZlY3RpbmcgYW5pbWF0aW9uXG4gICAgICAgICAqICAgICAgfVxuICAgICAgICAgKiAgXVxuICAgICAgICAgKiB9XG4gICAgICAgICAvKiogQHR5cGUge3t9fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYW5lcyA9IG5ldyBDb2xsZWN0aW9uKHt9KTtcbiAgICAgICAgaWYgKHByb3BzLmxhbmVzKSB7XG4gICAgICAgICAgICB0aGlzLmxhbmVzID0gcHJvcHMubGFuZXM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbWJvQXR0cmlidXRlcyA9IHt9O1xuICAgICAgICBpZiAocHJvcHMuY29tYm9BdHRyaWJ1dGVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY29tYm9BdHRyaWJ1dGVzID0gcHJvcHMuY29tYm9BdHRyaWJ1dGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgLypcbiAgICAgICAgS2VlcHMgYW4gaW5kZXhpbmcgb2YgdGhlIGxhbmVzIGVhY2ggQW5pbWF0aW9uIGJlbG9uZ3MgdG8uIFRoZSBmb3JtIGlzIHRoZSBmb2xsb3dpbmc6XG4gICAgICAgIGJlbG9uZ2luZ0xhbmVLZXlzQnlBbmltYXRpb25JZDoge1xuICAgICAgICAgICAgPGFuaW1hdGlvbl9pZD46IFtsYW5lS2V5MSwgbGFuZUtleTIsIC4uLl0sXG4gICAgICAgICAgICA8YW5pbWF0aW9uX2lkPjogW2xhbmVLZXkyLCBsYW5lS2V5MywgLi4uXSxcbiAgICAgICAgICAgIC4uLlxuICAgICAgICB9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJlbG9uZ2luZ0xhbmVLZXlzQnlBbmltYXRpb25JZCA9IG5ldyBDb2xsZWN0aW9uKHt9KTtcbiAgICAgICAgaWYgKHByb3BzLmJlbG9uZ2luZ0xhbmVLZXlzQnlBbmltYXRpb25JZCkge1xuICAgICAgICAgICAgdGhpcy5iZWxvbmdpbmdMYW5lS2V5c0J5QW5pbWF0aW9uSWQgPSBwcm9wcy5iZWxvbmdpbmdMYW5lS2V5c0J5QW5pbWF0aW9uSWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXNpemVzIGFsbCB0aGUgbGFuZXMgb2YgdGhlIExhbmVzIEhhbmRsZXIgYnkgdGhlIGR1cmF0aW9uRnJhY3Rpb24gcHJvdmlkZWQuXG4gICAgICogTm8gY2hlY2tzIGFyZSBwZXJmb3JtZWQuIFxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGJlZW4gaW52b2tlZCBpbiBjYXNlcyB3aGVyZSBhIGZ1bGwgQ2xpcCBnZXRzIHJlc2l6ZWQsIHNvIG5vIGNvbmZsaWN0IGNoZWNrcyBuZWVkIHRvXG4gICAgICogcnVuLlxuICAgICAqIEBwYXJhbSB7ZmxvYXR9IGR1cmF0aW9uRnJhdGlvbjogdGhlIGZyYWN0aW9uIGJldHdlZW4gdGhlIG5ldyBkdXJhdGlvbiBhbmQgdGhlIGN1cnJlbnRcbiAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoTGFuZXNIYW5kbGVyLCBbe1xuICAgICAgICBrZXk6ICdfcmVzaXplJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNpemUoZHVyYXRpb25GcmFjdGlvbikge1xuICAgICAgICAgICAgdmFyIGtleXMgPSB0aGlzLmxhbmVzLl9rZXlzKCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIHZhciB0aGVMYW5lID0gdGhpcy5sYW5lcy5fZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRoZUxhbmUubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoZUxhbmVbX2ldLm1pbGxpc2Vjb25kID0gdGhlTGFuZVtfaV0ubWlsbGlzZWNvbmQgKiBkdXJhdGlvbkZyYWN0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpdCBjcmVhdGVzIGEgbmV3IExhbmVzSGFuZGxlciB0aGF0IGFjdHMgYXMgYSBzYW5ib3ggZm9yIHRlc3RpbmcgY2hhbmdlc1xuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjcmVhdGVUZXN0TGFuZXNTYW5ib3gnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlVGVzdExhbmVzU2FuYm94KCkge1xuICAgICAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgICAgICAgIGxhbmVzOiBuZXcgU2FuZGJveExhbmVzKHRoaXMubGFuZXMuX2V4cG9ydCgpKSxcbiAgICAgICAgICAgICAgICBiZWxvbmdpbmdMYW5lS2V5c0J5QW5pbWF0aW9uSWQ6IG5ldyBTYW5kYm94Q29sbGVjdGlvbih0aGlzLmJlbG9uZ2luZ0xhbmVLZXlzQnlBbmltYXRpb25JZC5fZXhwb3J0KCkpIC8vSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLmJlbG9uZ2luZ0xhbmVLZXlzQnlBbmltYXRpb25JZCkpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5jb21ib0F0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBwcm9wcy5jb21ib0F0dHJpYnV0ZXMgPSB0aGlzLmNvbWJvQXR0cmlidXRlcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMYW5lc0hhbmRsZXIocHJvcHMpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRMYW5lc0NvcHknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGFuZXNDb3B5KGxhbmUpIHtcbiAgICAgICAgICAgIHZhciBsYW5lVG9SZXR1cm4gPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFuZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxhbmVUb1JldHVybi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGxhbmVbaV0uaWQsXG4gICAgICAgICAgICAgICAgICAgIGluY2lkZW50OiBsYW5lW2ldLmluY2lkZW50LFxuICAgICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZDogbGFuZVtpXS5taWxsaXNlY29uZCAqIDFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsYW5lVG9SZXR1cm47XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldExhbmVFbGVtZW50c0Nsb25lJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldExhbmVFbGVtZW50c0Nsb25lKGxhbmVFbGVtZW50KSB7XG4gICAgICAgICAgICAvLyByZXR1cm4gX2Nsb25lRGVlcChsYW5lRWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkOiBsYW5lRWxlbWVudC5pZCxcbiAgICAgICAgICAgICAgICBtaWxsaXNlY29uZDogbGFuZUVsZW1lbnQubWlsbGlzZWNvbmQgKiAxLFxuICAgICAgICAgICAgICAgIGluY2lkZW50OiB7XG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBsYW5lRWxlbWVudC5pbmNpZGVudC5kdXJhdGlvbiAqIDEsXG4gICAgICAgICAgICAgICAgICAgIGlkOiBsYW5lRWxlbWVudC5pbmNpZGVudC5pZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShsYW5lRWxlbWVudCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYXBwbHlTYW5kYm94Q2hhbmdlcycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseVNhbmRib3hDaGFuZ2VzKFNhbmJveE9iamVjdCkge1xuICAgICAgICAgICAgdGhpcy5sYW5lcyA9IG5ldyBDb2xsZWN0aW9uKFNhbmJveE9iamVjdC5sYW5lcy5fZXhwb3J0KCkpO1xuXG4gICAgICAgICAgICB0aGlzLmJlbG9uZ2luZ0xhbmVLZXlzQnlBbmltYXRpb25JZCA9IG5ldyBDb2xsZWN0aW9uKFNhbmJveE9iamVjdC5iZWxvbmdpbmdMYW5lS2V5c0J5QW5pbWF0aW9uSWQuX2V4cG9ydCgpKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0TGFuZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMYW5lKG1jaWQsIGF0dHIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhbmVzLl9nZXQoaGVscGVyLmdldExhbmVLZXkobWNpZCwgYXR0cikpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBpbmNpZGVudCBoYXMgYW5pbWF0ZWRBdHRycyBvciBub3QuIFxuICAgICAgICAqKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2luY2lkZW50SGFzQW5pbWF0ZWRBdHRycycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5jaWRlbnRIYXNBbmltYXRlZEF0dHJzKGluY2lkZW50KSB7XG4gICAgICAgICAgICBpZiAoaW5jaWRlbnQuYXR0cnMuaGFzT3duUHJvcGVydHkoJ2FuaW1hdGVkQXR0cnMnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJldHVybiB0cnVlIGlmIGxhbmUgZXhpc3RzIG9yIGZhbHNlIG90aGVyd2lzZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWNpZFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0clxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlmTm90Q3JlYXRlSXQgLSBpZiBpcyBzZXQgdG8gdHJ1ZSBhbmQgdGhlIGxhbmUgZG9lc24ndCBleGlzdCBpdCBjcmVhdGVzIGl0IGJ1dCBzdGlsbCByZXR1cm5pbmcgZmFsc2VcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbGFuZUV4aXN0cycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBsYW5lRXhpc3RzKG1jaWQsIGF0dHIpIHtcbiAgICAgICAgICAgIHZhciBpZk5vdENyZWF0ZUl0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICAgICAgICAgICAgdmFyIGxhbmVLZXkgPSBoZWxwZXIuZ2V0TGFuZUtleShtY2lkLCBhdHRyKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5sYW5lcy5faGFzT3duUHJvcGVydHkobGFuZUtleSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaWZOb3RDcmVhdGVJdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhbmVzLl9zZXQobGFuZUtleSwgW10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdhbmltYXRpb25JREV4aXN0cycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhbmltYXRpb25JREV4aXN0cyhtY2lkLCBhdHRyLCBhbmltYXRpb25JRCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYmVsb25naW5nTGFuZUtleXNCeUFuaW1hdGlvbklkLl9oYXNPd25Qcm9wZXJ0eShhbmltYXRpb25JRCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5iZWxvbmdpbmdMYW5lS2V5c0J5QW5pbWF0aW9uSWQuX2dldChhbmltYXRpb25JRCkuaW5kZXhPZihoZWxwZXIuZ2V0TGFuZUtleShtY2lkLCBhdHRyKSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5ld0FuaW0gLSBhbiBvYmplY3Qgb2YgdGhlIGZvcm0gb2YgYSBsYW5lIGl0ZW0gKHdpdGgga2V5cyBcIm1pbGxpc2Vjb25kXCIgYW5kIFwiaW5jaWRlbnRcIlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWNpZFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0clxuICAgICAgICAgKiBAcGFyYW0ge2FycmF5fSBleGNsdWRlSWRzRnJvbUNoZWNrIC0gb3B0aW9uYWwuIElmIGV4aXN0cyBpdCBleGNsdWRlcyBhbGwgdGhlIGlkcyBvZiB0aGlzIGFycmF5IGZyb20gY2hlY2suIFRoaXNcbiAgICAgICAgICogIHBhcmFtZXRlciBoYXMgYmVlbiBhZGRlZCBmb3IgdGhlIGVkaXQgY2hlY2tzIHdoZXJlIGFuIGFuaW1hdGlvbiBtaWdodCBvdmVybGFwIGFub3RoZXIgYW5pbWF0aW9uIHRoYXQgcGFydGljaXBhdGVzIG9uXG4gICAgICAgICAqICB0aGUgbW92ZSwgc29tZXRoaW5nIHRoYXQgc2hvdWxkIG5vdCBoYXBwZW4gYXMgdGhlIGVkaXRlZCBhbmltYXRpb25zIHByZS1leGlzdGVkIHdpdGhvdXQgY29uZmxpY3RzIGFuZCB0aGUgbW92ZSBvZiBhbGxcbiAgICAgICAgICogIG9mIHRoZW0gdG9nZXRoZXIgZ3VhcmFudGVlcyB0aGF0IHRoZXJlIGlzIGdvaW5nIHRvIGJlIG5vIGNvbmZsaWN0IGJldHdlZW4gdGhlbSBldmVuIGFmdGVyIHRoZSBlZGl0XG4gICAgICAgICAqIEBwYXJhbSB7aW50fSB0ZXN0RHVyYXRpb24gLSBvcHRpb25hbC4gVGhpcyBwYXJhbWV0ZXIgaXMgdXNlZCB3aGVuIHRoZSBjaGFubmVsIG5lZWRzIHRvIGFkZGNoZWNrIG92ZXJsYXBzIGFmdGVyIGR1cmF0aW9uXG4gICAgICAgICAqICBlZGl0cywgc28gdGhlIHRlc3REdXJhdGlvbiBpcyBwYXNzZWQgKHdlIGRvbid0IHdhbnQgdG8gcG9sdXRlIHRoZSBvcmlnaW5hbCBhbmltYXRpb24gb2JqZWN0IGFzIGl0IHJlZmVycyB0byB0aGUgcmVhbCBvbmUpXG4gICAgICAgICAqIEByZXR1bnMge2FycmF5fSAtIGEgbGlzdCBvZiBhbGwgb3ZlcmxhcHBpbmcgYW5pbWF0aW9ucyBvZiB0aGUgbGFuZVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRPdmVybGFwcGluZ0FuaW1zJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE92ZXJsYXBwaW5nQW5pbXMobmV3QW5pbSwgbWNpZCwgYXR0cikge1xuICAgICAgICAgICAgdmFyIGV4Y2x1ZGVJZHNGcm9tQ2hlY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IFtdO1xuICAgICAgICAgICAgdmFyIHRlc3REdXJhdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogbnVsbDtcblxuICAgICAgICAgICAgdmFyIG92ZXJsYXBwaW5nQW5pbXMgPSBfZmlsdGVyKHRoaXMubGFuZXMuX2dldChoZWxwZXIuZ2V0TGFuZUtleShtY2lkLCBhdHRyKSksIGZ1bmN0aW9uIChleGlzdGluZ0FuaW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZHVyYXRpb25Ub1VzZU9uQ2hlY2tzID0gbmV3QW5pbS5pbmNpZGVudC5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAodGVzdER1cmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb25Ub1VzZU9uQ2hlY2tzID0gdGVzdER1cmF0aW9uO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGluZ0FuaW0uaW5jaWRlbnQuaWQgIT0gbmV3QW5pbS5pbmNpZGVudC5pZCAmJiBleGNsdWRlSWRzRnJvbUNoZWNrLmluZGV4T2YoZXhpc3RpbmdBbmltLmluY2lkZW50LmlkKSA8IDAgJiYgKFxuICAgICAgICAgICAgICAgIC8vIGV4aXN0aW5nIGFuaW0gc3RhcnRzIHdpdGhpbiB0aGUgbmV3IGFuaW0ncyBleHRlbmRcbiAgICAgICAgICAgICAgICBleGlzdGluZ0FuaW0ubWlsbGlzZWNvbmQgPj0gbmV3QW5pbS5taWxsaXNlY29uZCAmJiBleGlzdGluZ0FuaW0ubWlsbGlzZWNvbmQgPCBkdXJhdGlvblRvVXNlT25DaGVja3MgKyBuZXdBbmltLm1pbGxpc2Vjb25kIHx8XG4gICAgICAgICAgICAgICAgLy8gb3IgZW5kcyB3aXRoaW4gdGhlIG5ldyBhbmltJ3MgZXh0ZW5kXG4gICAgICAgICAgICAgICAgZXhpc3RpbmdBbmltLm1pbGxpc2Vjb25kICsgZXhpc3RpbmdBbmltLmluY2lkZW50LmR1cmF0aW9uID4gbmV3QW5pbS5taWxsaXNlY29uZCAmJiBleGlzdGluZ0FuaW0ubWlsbGlzZWNvbmQgKyBleGlzdGluZ0FuaW0uaW5jaWRlbnQuZHVyYXRpb24gPD0gZHVyYXRpb25Ub1VzZU9uQ2hlY2tzICsgbmV3QW5pbS5taWxsaXNlY29uZFxuICAgICAgICAgICAgICAgIC8vIG9yIGl0IHN0YXJ0cyBiZWZvcmUgYW5kIGVuZHMgYWZ0ZXIgdGhlIG5ldyBhbmltJ3MgZXh0ZW5kXG4gICAgICAgICAgICAgICAgfHwgZXhpc3RpbmdBbmltLm1pbGxpc2Vjb25kIDwgbmV3QW5pbS5taWxsaXNlY29uZCAmJiBleGlzdGluZ0FuaW0ubWlsbGlzZWNvbmQgKyBleGlzdGluZ0FuaW0uaW5jaWRlbnQuZHVyYXRpb24gPiBkdXJhdGlvblRvVXNlT25DaGVja3MgKyBuZXdBbmltLm1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gb3ZlcmxhcHBpbmdBbmltcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpdCBqdXN0cyBhZGRzIHRoZSBsYW5lIGl0ZW0gdG8gdGhlIGxhbmUgYW5kIGFkanVzdHMgdGhlIGluaXRpYWwgdmFsdWVzIG9mIHRoZSBBbmltcyBpbiBzZXF1ZW5jZVxuICAgICAgICAgKiBObyBjaGVja3MgYXJlIHBlcmZvcm1lZCwganVzdCBleGVjdXRpb24uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtY2lkXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyXG4gICAgICAgICAqIEBwYXJhbSB7aW50fSBtaWxsaXNlY29uZFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5jaWRlbnRcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYWRkRWxlbWVudFRvTGFuZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFbGVtZW50VG9MYW5lKG1jaWQsIGF0dHIsIG1pbGxpc2Vjb25kLCBpbmNpZGVudCkge1xuXG4gICAgICAgICAgICB2YXIgbGFuZUtleSA9IGhlbHBlci5nZXRMYW5lS2V5KG1jaWQsIGF0dHIpO1xuXG4gICAgICAgICAgICB2YXIgbGFuZUVsZW1lbnQgPSB7XG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmQ6IG1pbGxpc2Vjb25kLFxuICAgICAgICAgICAgICAgIGluY2lkZW50OiBpbmNpZGVudCxcbiAgICAgICAgICAgICAgICBpZDogaW5jaWRlbnQuaWRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMubGFuZUV4aXN0cyhtY2lkLCBhdHRyLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB0aGVMYW5lID0gdGhpcy5sYW5lcy5fZ2V0KGxhbmVLZXkpO1xuXG4gICAgICAgICAgICB0aGVMYW5lLnB1c2gobGFuZUVsZW1lbnQpO1xuICAgICAgICAgICAgdGhlTGFuZSA9IF9zb3J0QnkodGhlTGFuZSwgWydtaWxsaXNlY29uZCddKTtcblxuICAgICAgICAgICAgLy8gaW5kZXhpbmcgc3R1ZmZcbiAgICAgICAgICAgIGlmICghdGhpcy5iZWxvbmdpbmdMYW5lS2V5c0J5QW5pbWF0aW9uSWQuX2hhc093blByb3BlcnR5KGluY2lkZW50LmlkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYmVsb25naW5nTGFuZUtleXNCeUFuaW1hdGlvbklkLl9zZXQoaW5jaWRlbnQuaWQsIFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYmVsb25naW5nTGFuZUtleXNCeUFuaW1hdGlvbklkLl9nZXQoaW5jaWRlbnQuaWQpLnB1c2gobGFuZUtleSk7XG4gICAgICAgICAgICAvLyBpbmRleGluZ1xuICAgICAgICAgICAgdmFyIG5ld0FuaW1zSW5kZXggPSBfZmluZEluZGV4KHRoZUxhbmUsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uaW5jaWRlbnQuaWQgPT09IGluY2lkZW50LmlkO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8qIGlmIHRoZSBpbmNpZGVudCBoYXMgbm8gYW5pbWF0ZWQgYXR0cmlidXRlcyB3ZSBkb24ndCBuZWVkIHRvIHdvcmsgb24gc3RhcnQgYW5kIGZpbmFsIHZhbHVlcyAqL1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pbmNpZGVudEhhc0FuaW1hdGVkQXR0cnMoaW5jaWRlbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgb25TdWNjZXNzQWN0aW9uOiBmdW5jdGlvbiBvblN1Y2Nlc3NBY3Rpb24oKSB7fSB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBoZWxwZXIubG9nKG5ld0FuaW1zSW5kZXgpO1xuICAgICAgICAgICAgLy8gc3RlcCAxOiBzZXQgdGhlIGludGlhbCB2YWx1ZXMgb2YgdGhlIG5ldyBBbmltYXRpb25cbiAgICAgICAgICAgIGlmIChuZXdBbmltc0luZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIG5ld2x5IGVudGVyZWQgYW5pbWF0aW9uIGlzIHRoZSBmaXJzdCBvZiB0aGUgbGFuZVxuICAgICAgICAgICAgICAgIGlmICh0aGVMYW5lLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGl0IGhhcyBvdGhlciBhbmltYXRpb25zIHRvb1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhlTGFuZVsxXS5pbmNpZGVudC5oYXNJbml0aWFsVmFsdWUoYXR0cikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBmb2xsb3dpbmcgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCB1c2VkIHRvIGJlIGZpcnN0IGlzIGFscmVhZHkgY2FsY3VsYXRlZCBcInN0ZWFsXCIgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2lkZW50LnNldEluaXRpYWxWYWx1ZShhdHRyLCB0aGVMYW5lWzFdLmluY2lkZW50LmdldEluaXRpYWxWYWx1ZShhdHRyKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIHRha2UgaXQgZGlyZWN0bHkgZnJvbSB0aGUgZG9tXG4gICAgICAgICAgICAgICAgICAgIGluY2lkZW50LnNldEluaXRpYWxWYWx1ZShhdHRyLCBpbmNpZGVudC5nZXRTY3JhdGNoVmFsdWUobWNpZCwgYXR0cikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5jaWRlbnQuc2V0SW5pdGlhbFZhbHVlKGF0dHIsIHRoZUxhbmVbbmV3QW5pbXNJbmRleCAtIDFdLmluY2lkZW50LmF0dHJzLmFuaW1hdGVkQXR0cnNbYXR0cl0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKiBpZiB0aGUgYXR0cmlidXRlIG9mIHRoZSBsYW5lIGlzIGEgY29tcG8gYXR0cmlidXRlICovXG4gICAgICAgICAgICBpZiAodGhpcy5jb21ib0F0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoYXR0cikpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5jaWRlbnRJbml0aWFsVmFsdWVzID0gaW5jaWRlbnQuZ2V0SW5pdGlhbFZhbHVlKGF0dHIpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBpbmNpZGVudEluaXRpYWxWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbmNpZGVudC5hdHRycy5hbmltYXRlZEF0dHJzW2F0dHJdLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2lkZW50LmF0dHJzLmFuaW1hdGVkQXR0cnNbYXR0cl1ba2V5XSA9IGluY2lkZW50SW5pdGlhbFZhbHVlc1trZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb25TdWNjZXNzQWN0aW9uID0gZnVuY3Rpb24gb25TdWNjZXNzQWN0aW9uKCkge307XG4gICAgICAgICAgICAvLyBzdGVwIDI6IHNldCB0aGUgaW5pdGFsIHZhbHVlcyBvZiB0aGUgZm9sbG93aW5nIEFuaW1hdGlvbiAoaWYgYW55KVxuICAgICAgICAgICAgaWYgKG5ld0FuaW1zSW5kZXggKyAxIDwgdGhlTGFuZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvblN1Y2Nlc3NBY3Rpb24gPSBmdW5jdGlvbiBvblN1Y2Nlc3NBY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoZUxhbmVbbmV3QW5pbXNJbmRleCArIDFdLmluY2lkZW50LnNldEluaXRpYWxWYWx1ZShhdHRyLCBpbmNpZGVudC5hdHRycy5hbmltYXRlZEF0dHJzW2F0dHJdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoZUxhbmVbbmV3QW5pbXNJbmRleCArIDFdLmluY2lkZW50LmdvdENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZUxhbmVbbmV3QW5pbXNJbmRleCArIDFdLmluY2lkZW50Lm9uR2V0Q29udGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb25TdWNjZXNzQWN0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogaXQganVzdHMgdXBkYXRlcyB0aGUgbGFuZVxuICAgICAgICAgKiBObyBjaGVja3MgYXJlIHBlcmZvcm1lZCwganVzdCBleGVjdXRpb25cbiAgICAgICAgICogQHBhcmFtIHthcnJheX0gYWZmZWN0ZWRBbmltYXRpb25zSWRzXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyXG4gICAgICAgICAqIEBwYXJhbSB7aW50fSBtaWxsaXNlY29uZERlbHRhXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3VwZGF0ZUxhbmUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlTGFuZShhZmZlY3RlZEFuaW1hdGlvbnNJZHMsIG1pbGxpc2Vjb25kc0RlbHRhKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyBmaXJzdCB3ZSBncm91cCB0aGUgYWZmZWN0ZWQgYW5pbWF0aW9ucyBieSBsYW5lc1xuICAgICAgICAgICAgdmFyIGFmZmVjdGVkTGFuZXMgPSB7fTtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWZmZWN0ZWRBbmltYXRpb25zSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJlbG9uZ2luZ0xhbmVzID0gdGhpcy5iZWxvbmdpbmdMYW5lS2V5c0J5QW5pbWF0aW9uSWQuX2dldChhZmZlY3RlZEFuaW1hdGlvbnNJZHNbaV0pO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYmVsb25naW5nTGFuZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmVLZXkgPSBiZWxvbmdpbmdMYW5lc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhZmZlY3RlZExhbmVzLmhhc093blByb3BlcnR5KGxhbmVLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZmZlY3RlZExhbmVzW2xhbmVLZXldID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbnM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhbmU6IHRoYXQubGFuZXMuX2dldChsYW5lS2V5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYW5lRGF0YTogaGVscGVyLmdldE1DSURhbmRBdHRyT3V0T2ZMYW5lS2V5KGJlbG9uZ2luZ0xhbmVzW2pdKVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhZmZlY3RlZExhbmVzW2xhbmVLZXldLmFuaW1hdGlvbnMucHVzaChhZmZlY3RlZEFuaW1hdGlvbnNJZHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZm9yIGVhY2ggb2YgdGhlIGFmZmVjdGVkIGxhbmVzXG4gICAgICAgICAgICBmb3IgKHZhciBfbGFuZUtleSBpbiBhZmZlY3RlZExhbmVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFmZmVjdGVkTGFuZSA9IGFmZmVjdGVkTGFuZXNbX2xhbmVLZXldO1xuICAgICAgICAgICAgICAgIHZhciBsYW5lID0gYWZmZWN0ZWRMYW5lLmxhbmU7XG4gICAgICAgICAgICAgICAgdmFyIGxhbmVEYXRhID0gYWZmZWN0ZWRMYW5lLmxhbmVEYXRhO1xuICAgICAgICAgICAgICAgIHZhciBsYW5lQmVmb3JlRWRpdCA9IF9zb3J0QnkodGhpcy5nZXRMYW5lc0NvcHkobGFuZSksIFsnbWlsbGlzZWNvbmQnXSk7XG5cbiAgICAgICAgICAgICAgICAvLyBlZGl0IGxhbmUgaXRlbXMgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGxhbmUubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFmZmVjdGVkTGFuZS5hbmltYXRpb25zLmluZGV4T2YobGFuZVtrXS5pbmNpZGVudC5pZCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFuZVtrXS5taWxsaXNlY29uZCArPSBtaWxsaXNlY29uZHNEZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gZW5kIGZvciBzZWFyY2hpbmcgZm9yIHRoZSBhbmltYXRpb25zIHdpdGhpbiB0aGUgbGFuZVxuXG4gICAgICAgICAgICAgICAgdmFyIHNvcnRlZExhbmUgPSBfc29ydEJ5KGxhbmUsIFsnbWlsbGlzZWNvbmQnXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5sYW5lcy5fc2V0KF9sYW5lS2V5LCBzb3J0ZWRMYW5lKTtcbiAgICAgICAgICAgICAgICBsYW5lID0gc29ydGVkTGFuZTtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzKTtcblxuICAgICAgICAgICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKF9pMikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uVG9DaGVjayA9IGFmZmVjdGVkTGFuZS5hbmltYXRpb25zW19pMl07XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25JbmRleEJlZm9yZUVkaXQgPSBfZmluZEluZGV4KGxhbmVCZWZvcmVFZGl0LCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uaW5jaWRlbnQuaWQgPT09IGFuaW1hdGlvblRvQ2hlY2s7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uSW5kZXhBZnRlckVkaXQgPSBfZmluZEluZGV4KGxhbmUsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5pbmNpZGVudC5pZCA9PT0gYW5pbWF0aW9uVG9DaGVjaztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb24gPSBsYW5lW2FuaW1hdGlvbkluZGV4QWZ0ZXJFZGl0XS5pbmNpZGVudDtcblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogaWYgdGhlIGZpcnN0IGFuaW1hdGlvbiBkb2Vzbid0IGhhdmUgYW5pbWF0ZWQgYXR0cmlidXRlcyB0aGF0IG1lYW5zIG5vIG9uZSBvbiB0aGlzIGNoYW5uZWwgaGFzLiBCcmFrZVxuICAgICAgICAgICAgICAgICAgICAgKiBhbmQgZXhpdCB0aGUgbG9vcCB0aGF0IGhhbmRsZXMgc3RhcnQgYW5kIGVuZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5faW5jaWRlbnRIYXNBbmltYXRlZEF0dHJzKGFuaW1hdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnYnJlYWsnO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkluZGV4QmVmb3JlRWRpdCAhPT0gYW5pbWF0aW9uSW5kZXhBZnRlckVkaXQgfHwgYW5pbWF0aW9uSW5kZXhBZnRlckVkaXQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uSW5kZXhCZWZvcmVFZGl0ICsgMSA8IGxhbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGFuaW1hdGlvbiB3YXMgbm90IHRoZSBsYXN0IGFuaW1hdGlvbiBvbiB0aGUgbGFuZSBiZWZvcmUgdGhlIGVkaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBzaG91bGQgdGFrZSBjYXJlIG9mIHRoZSBpbml0aWFsIHZhbHVlcyBvZiB0aGUgYW5pbWF0aW9uJ3MgcHJldmlvdXMgc3VjY2Vzc29yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkluZGV4QmVmb3JlRWRpdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZWRpdGVkIGFuaW1hdGlvbiB3YXMgdGhlIGZpcnN0IG9uZSBiZWZvcmUgdGhlIGVkaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgaXQgaGFzIGluaXRpYWwgdmFsdWVzLCBwYXNzIHRoZW0gdG8gaXRzIHByZXZpb3VzIHN1Y2Nlc3NvciBhcyBpdHMgbmV3IGluaXRpYWwgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb24uaGFzSW5pdGlhbFZhbHVlKGxhbmVEYXRhLmF0dHJpYnV0ZSkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGluaXRpYWwgdmFsdWUgb2YgdGhlIGVkaXRlZCBhbmltYXRpb24gYW5kIHNldCBpdCBhcyBpbml0aWFsIHZhbHVlIG9mIHRoZSBuZXcgMCBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFuZUJlZm9yZUVkaXRbMV0uaW5jaWRlbnQuc2V0SW5pdGlhbFZhbHVlKGxhbmVEYXRhLmF0dHJpYnV0ZSwgYW5pbWF0aW9uLmdldEluaXRpYWxWYWx1ZShsYW5lRGF0YS5tY2lkLCBsYW5lRGF0YS5hdHRyaWJ1dGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBjYWxjdWxhdGUgdGhlIGluaXRpYWwgdmFsdWUgb24gdGhlIGZseSwgb3V0IG9mIHRoZSBkb20gYW5kIHNldCBpdCB0byB0aGUgbmV3IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhbmVCZWZvcmVFZGl0WzFdLmluY2lkZW50LnNldEluaXRpYWxWYWx1ZShsYW5lRGF0YS5hdHRyaWJ1dGUsIGxhbmVCZWZvcmVFZGl0WzFdLmluY2lkZW50LmdldFNjcmF0Y2hWYWx1ZShsYW5lRGF0YS5tY2lkLCBsYW5lRGF0YS5hdHRyaWJ1dGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgaWYgdGhlIGVkaXRlZCBhbmltYXRpb24gd2FzIG5vdCB0aGUgZmlyc3Qgb25lIGJlZm9yZSB0aGUgZWRpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtZWFuaW5nIGl0cyBwcmV2aW91cyBzdWNjZXNzb3IgaXMgbm90IHRoZSBmaXJzdCBvbmUgb24gdGhlIGxhbmUgYWZ0ZXIgdGhlIGVkaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8ganVzdCBncmFiIHRoZSB0YXJnZXQgdmFsdWUgb2YgdGhlIG5ldyBwcmV2aW91cyBhbmltYXRpb24gb2YgdGhlIGFuaW1hdGlvbidzIHByZXZpb3VzIHN1Y2Nlc3NvciBhbmQgc2V0IGl0IGFzIGluaXRpYWwgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFuZUJlZm9yZUVkaXRbYW5pbWF0aW9uSW5kZXhCZWZvcmVFZGl0ICsgMV0uaW5jaWRlbnQuc2V0SW5pdGlhbFZhbHVlKGxhbmVEYXRhLmF0dHJpYnV0ZSwgbGFuZUJlZm9yZUVkaXRbYW5pbWF0aW9uSW5kZXhCZWZvcmVFZGl0IC0gMV0uaW5jaWRlbnQuYXR0cnMuYW5pbWF0ZWRBdHRyc1tsYW5lRGF0YS5hdHRyaWJ1dGVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciB0aGUgZWRpdGVkIGFuaW1hdGlvbiBpdHNlbGYgbm93OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkluZGV4QWZ0ZXJFZGl0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgaXQgdGhlIGZpcnN0IG9uZSAoYWZ0ZXIgZWRpdCk/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9lcyB0aGUgcHJldmlvdXNseSB6ZXJvIGluZGV4IGFuaW1hdGlvbiBoYXMgaW5pdGlhbCB2YWx1ZT9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFuZUJlZm9yZUVkaXRbMF0uaW5jaWRlbnQuaGFzSW5pdGlhbFZhbHVlKGxhbmVEYXRhLmF0dHJpYnV0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBpbml0aWFsIHZhbHVlcyBvZiB0aGUgcHJldmlvdXNseSAwIGluZGV4ZWQgYW5pbWF0aW9uIG9mIHRoZSBsYW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5zZXRJbml0aWFsVmFsdWUobGFuZURhdGEuYXR0cmlidXRlLCBsYW5lQmVmb3JlRWRpdFswXS5pbmNpZGVudC5nZXRJbml0aWFsVmFsdWUobGFuZURhdGEubWNpZCwgbGFuZURhdGEuYXR0cmlidXRlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGNhbGN1bGF0ZSB0aGUgaW5pdGlhbCB2YWx1ZSBvbiB0aGUgZmx5LCBvdXIgb2YgdGhlIGRvbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24uc2V0SW5pdGlhbFZhbHVlKGxhbmVEYXRhLm1jaWQsIGxhbmVEYXRhLmF0dHJpYnV0ZSwgYW5pbWF0aW9uLmdldFNjcmF0Y2hWYWx1ZShsYW5lRGF0YS5tY2lkLCBsYW5lRGF0YS5hdHRyaWJ1dGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgaWYgaXQgaXMgbm90IHRoZSBmaXJzdCBvbmUgYWZ0ZXIgZWRpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgZ3JhYiB0aGUgdGFyZ2V0IHZhbHVlIG9mIHRoZSBwcmV2aW91cyBhbmltYXRpb24gb24gdGhlIHVwZGF0ZWQgbGFuZSBhbmQgc2V0IGl0IGFzIGl0cyBpbml0aWFsIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLnNldEluaXRpYWxWYWx1ZShsYW5lRGF0YS5hdHRyaWJ1dGUsIGxhbmVbYW5pbWF0aW9uSW5kZXhBZnRlckVkaXQgLSAxXS5pbmNpZGVudC5hdHRycy5hbmltYXRlZEF0dHJzW2xhbmVEYXRhLmF0dHJpYnV0ZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgaXRzIG5ldyBuZXh0IGFuaW1hdGlvbiAoaWYgaXQgaGFzIG9uZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb25JbmRleEFmdGVyRWRpdCArIDEgPCBsYW5lLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldCBpdHMgaW5pdGlhbCB2YWx1ZSB0byBlcXVhbCB0aGUgdGFyZ2V0IHZhbHVlIG9mIHRoZSBlZGl0ZWQgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFuZVthbmltYXRpb25JbmRleEFmdGVyRWRpdCArIDFdLmluY2lkZW50LnNldEluaXRpYWxWYWx1ZShsYW5lRGF0YS5hdHRyaWJ1dGUsIGFuaW1hdGlvbi5hdHRycy5hbmltYXRlZEF0dHJzW2xhbmVEYXRhLmF0dHJpYnV0ZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGFmZmVjdGVkTGFuZS5hbmltYXRpb25zLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9yZXQgPSBfbG9vcChfaTIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChfcmV0ID09PSAnYnJlYWsnKSBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIGVuZCBmb3IgZWFjaCBvZiB0aGUgYmVsb25naW5nIGxhbmVzIG9mIHRoZSBhbmltYXRpb25cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZW1vdmVzIHRoZSBsaXN0IG9mIGFuaW1hdGlvbnMgYXMgcHJvdmlkZWRcbiAgICAgICAgICogQHBhcmFtIHthcnJheX0gcmVtb3ZlZEFuaW1hdGlvbnMgLSBhbiBhcnJheSB3aXRoIHRoZSByZW1vdmVkIGFuaW1hdGlvbnMnIGlkc1xuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdkZWxldGVBbmltYXRpb25zJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZUFuaW1hdGlvbnMocmVtb3ZlZEFuaW1hdGlvbnMsIGN1cnJlbnRNaWxsaXNlY29uZCkge1xuICAgICAgICAgICAgdmFyIGFmZmVjdGVkTGFuZXMgPSB7fTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZW1vdmVkQW5pbWF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IHJlbW92ZWRBbmltYXRpb25zW2ldO1xuICAgICAgICAgICAgICAgIC8vIGZvciBlYWNoIGxhbmUgdGhlIGFmZmVjdGVkIEFuaW1hdGlvbiBhcHBlYXJzIGluXG4gICAgICAgICAgICAgICAgdmFyIGJlbG9uZ2luZ0xhbmVzID0gdGhpcy5iZWxvbmdpbmdMYW5lS2V5c0J5QW5pbWF0aW9uSWQuX2dldChpZCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBiZWxvbmdpbmdMYW5lcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFuZSA9IHRoaXMubGFuZXMuX2dldChiZWxvbmdpbmdMYW5lc1tqXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hbmltYXRpb25JbmRleEJlZm9yZUVkaXQgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBsYW5lLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFuZVtrXS5pbmNpZGVudC5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYW5pbWF0aW9uSW5kZXhCZWZvcmVFZGl0ID0gaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGhlbHBlci5sb2coYW5pbWF0aW9uSW5kZXhCZWZvcmVFZGl0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvblRvRGVsZXRlID0gT2JqZWN0LmFzc2lnbih7fSwgbGFuZVtfYW5pbWF0aW9uSW5kZXhCZWZvcmVFZGl0XSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25PYmplY3RUb0RlbGV0ZSA9IGFuaW1hdGlvblRvRGVsZXRlLmluY2lkZW50O1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFuZURhdGEgPSBoZWxwZXIuZ2V0TUNJRGFuZEF0dHJPdXRPZkxhbmVLZXkoYmVsb25naW5nTGFuZXNbal0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGdldHMgdGhlIGxhbmUgd2l0aG91dCB0aGUgcmVtb3ZlZCBhbmltYXRpb25cbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0xhbmUgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2sgPSAwOyBfayA8IGxhbmUubGVuZ3RoOyBfaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFuZVtfa10uaW5jaWRlbnQuaWQgIT0gaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdMYW5lLnB1c2gobGFuZVtfa10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFuZXMuX3NldChiZWxvbmdpbmdMYW5lc1tqXSwgbmV3TGFuZSk7XG4gICAgICAgICAgICAgICAgICAgIGxhbmUgPSB0aGlzLmxhbmVzLl9nZXQoYmVsb25naW5nTGFuZXNbal0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYW5lLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYW5lcy5fZGVsZXRlKGJlbG9uZ2luZ0xhbmVzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZmZlY3RlZExhbmVzLmhhc093blByb3BlcnR5KGJlbG9uZ2luZ0xhbmVzW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhZmZlY3RlZExhbmVzW2JlbG9uZ2luZ0xhbmVzW2pdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbmNpZGVudEhhc0FuaW1hdGVkQXR0cnMoYW5pbWF0aW9uVG9EZWxldGUuaW5jaWRlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZmZWN0ZWRMYW5lc1tiZWxvbmdpbmdMYW5lc1tqXV0gPSBoZWxwZXIuZ2V0TUNJRGFuZEF0dHJPdXRPZkxhbmVLZXkoYmVsb25naW5nTGFuZXNbal0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfYW5pbWF0aW9uSW5kZXhCZWZvcmVFZGl0IDwgbGFuZS5sZW5ndGggJiYgYW5pbWF0aW9uVG9EZWxldGUuaW5jaWRlbnQuZ2V0SW5pdGlhbFZhbHVlKGxhbmVEYXRhLm1jaWQsIGxhbmVEYXRhLmF0dHJpYnV0ZSkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhbmVbX2FuaW1hdGlvbkluZGV4QmVmb3JlRWRpdF0uaW5jaWRlbnQuc2V0SW5pdGlhbFZhbHVlKGxhbmVEYXRhLmF0dHJpYnV0ZSwgYW5pbWF0aW9uVG9EZWxldGUuaW5jaWRlbnQuZ2V0SW5pdGlhbFZhbHVlKGxhbmVEYXRhLm1jaWQsIGxhbmVEYXRhLmF0dHJpYnV0ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmJlbG9uZ2luZ0xhbmVLZXlzQnlBbmltYXRpb25JZC5fZGVsZXRlKHJlbW92ZWRBbmltYXRpb25zW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhZmZlY3RlZExhbmVzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGhhbmRsZXMgZWRpdHMgb24gdGhlIGZpbmFsIHZhbHVlIG9mIGEgc3BlY2lmaWMgYXR0cmlidXRlIG9mIGEgc3BlY2lmaWMgYW5pbWF0aW9uIG9iamVjdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYW5pbWF0aW9uSWQgLSB0aGUgaWQgb2YgdGhlIEFuaW1hdGlvbiBvYmplY3QgdGhhdCBoYXMgYmVlbiBlZGl0ZWRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHIgLSB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHRoYXQgaGFzIGJlZW4gZWRpdGVkXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIHRoZSBuZXcgdmFsdWUgb2YgdGhlIGVkaXRlZCBhdHRyaWJ1dGVcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndXBkYXRlQXR0cmlidXRlT25MYW5lcycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVBdHRyaWJ1dGVPbkxhbmVzKGFuaW1hdGlvbklkLCBhdHRyLCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGJlbG9uZ2luZ0xhbmVzID0gdGhpcy5iZWxvbmdpbmdMYW5lS2V5c0J5QW5pbWF0aW9uSWQuX2dldChhbmltYXRpb25JZCk7XG4gICAgICAgICAgICB2YXIgYWZmZWN0ZWRMYW5lcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiZWxvbmdpbmdMYW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBsYW5lID0gdGhpcy5sYW5lcy5fZ2V0KGJlbG9uZ2luZ0xhbmVzW2ldKTtcbiAgICAgICAgICAgICAgICB2YXIgbGFuZURhdGEgPSBoZWxwZXIuZ2V0TUNJRGFuZEF0dHJPdXRPZkxhbmVLZXkoYmVsb25naW5nTGFuZXNbaV0pO1xuXG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgYW5pbWF0aW9uIG9uIHRoZSBsYW5lXG4gICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvbkluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBsYW5lLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYW5lW2tdLmluY2lkZW50LmlkID09PSBhbmltYXRpb25JZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uSW5kZXggPSBrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgYW5pbWF0aW9uIGlzIG5vdCB0aGUgbGFzdCBvbmUgb24gdGhlIGxhbmVcbiAgICAgICAgICAgICAgICBpZiAobGFuZS5sZW5ndGggLSAxICE9IGFuaW1hdGlvbkluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGxhbmVbYW5pbWF0aW9uSW5kZXggKyAxXS5pbmNpZGVudC5zZXRJbml0aWFsVmFsdWUobGFuZURhdGEubWNpZCwgbGFuZURhdGEuYXR0cmlidXRlLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYWZmZWN0ZWRMYW5lcy5wdXNoKGxhbmVEYXRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFmZmVjdGVkTGFuZXM7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gTGFuZXNIYW5kbGVyO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExhbmVzSGFuZGxlcjsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/LanesHandler.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/helpers/Collection.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/helpers/Collection.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Collection = function () {\n    function Collection() {\n        var initialArray = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n        _classCallCheck(this, Collection);\n\n        this.realArray = [];\n        if (initialArray != null) {\n            this.realArray = initialArray;\n        }\n    }\n\n    _createClass(Collection, [{\n        key: \"_hasOwnProperty\",\n        value: function _hasOwnProperty(key) {\n            return this.realArray.hasOwnProperty(key);\n        }\n    }, {\n        key: \"_get\",\n        value: function _get(key) {\n            return this.realArray[key];\n        }\n    }, {\n        key: \"_set\",\n        value: function _set(key, value) {\n            this.realArray[key] = value;\n        }\n    }, {\n        key: \"_keys\",\n        value: function _keys() {\n            return Object.keys(this.realArray);\n        }\n    }, {\n        key: \"_delete\",\n        value: function _delete(key) {\n            return delete this.realArray[key];\n        }\n\n        /**\n         * exports a Collection object \n        */\n\n    }, {\n        key: \"_export\",\n        value: function _export() {\n            return this.realArray;\n        }\n    }]);\n\n    return Collection;\n}();\n\nmodule.exports = Collection;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DaGFubmVscy9fQXR0cmlidXRlL2hlbHBlcnMvQ29sbGVjdGlvbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2Rpc3QvX0NoYW5uZWxzL19BdHRyaWJ1dGUvaGVscGVycy9Db2xsZWN0aW9uLmpzP2UzNzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBDb2xsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbGxlY3Rpb24oKSB7XG4gICAgICAgIHZhciBpbml0aWFsQXJyYXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG5cbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbGxlY3Rpb24pO1xuXG4gICAgICAgIHRoaXMucmVhbEFycmF5ID0gW107XG4gICAgICAgIGlmIChpbml0aWFsQXJyYXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5yZWFsQXJyYXkgPSBpbml0aWFsQXJyYXk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQ29sbGVjdGlvbiwgW3tcbiAgICAgICAga2V5OiBcIl9oYXNPd25Qcm9wZXJ0eVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhc093blByb3BlcnR5KGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhbEFycmF5Lmhhc093blByb3BlcnR5KGtleSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJfZ2V0XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0KGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhbEFycmF5W2tleV07XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJfc2V0XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMucmVhbEFycmF5W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcIl9rZXlzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfa2V5cygpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnJlYWxBcnJheSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJfZGVsZXRlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVsZXRlKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZSB0aGlzLnJlYWxBcnJheVtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGV4cG9ydHMgYSBDb2xsZWN0aW9uIG9iamVjdCBcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcIl9leHBvcnRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9leHBvcnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFsQXJyYXk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQ29sbGVjdGlvbjtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2xsZWN0aW9uOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/helpers/Collection.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/helpers/SandboxCollection.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/helpers/SandboxCollection.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * The goal of this class is to get an original array, provide all the functionality\n * of the Collection class but by keeping the originalArray clean as it was provided.\n*/\n\nvar SandboxCollection = function () {\n    function SandboxCollection(originalArray) {\n        _classCallCheck(this, SandboxCollection);\n\n        this.originalArray = originalArray;\n        this.extraArray = {};\n        this.addedKeys = [];\n        this.removedKeys = [];\n    }\n\n    _createClass(SandboxCollection, [{\n        key: \"_hasOwnProperty\",\n        value: function _hasOwnProperty(key) {\n            return this.originalArray.hasOwnProperty(key) || this.extraArray.hasOwnProperty(key);\n        }\n    }, {\n        key: \"_get\",\n        value: function _get(key) {\n            if (this.extraArray.hasOwnProperty(key)) {\n                return this.extraArray[key];\n            } else if (!this.originalArray.hasOwnProperty(key)) {\n                return undefined;\n            } else {\n                this.extraArray[key] = Object.assign({}, this.originalArray[key]);\n                return this.extraArray[key];\n            }\n        }\n    }, {\n        key: \"_set\",\n        value: function _set(key, value) {\n            this.extraArray[key] = value;\n            if (!this.originalArray.hasOwnProperty(key)) {\n                this.addedKeys.push(key);\n            }\n            var indexOnRemovedKeys = this.removedKeys.indexOf(key);\n            if (indexOnRemovedKeys > -1) {\n                this.removedKeys.splice(indexOnRemovedKeys, 1);\n            }\n        }\n    }, {\n        key: \"_keys\",\n        value: function _keys() {\n            var allKeys = Object.keys(this.originalArray).concat(this.addedKeys);\n            for (var i = 0; i < this.removedKeys.length; i++) {\n                var indexOnArray = this.removedKeys.indexOf(this.removedKeys[i]);\n                allKeys.splice(indexOnArray, 1);\n            }\n            return allKeys;\n        }\n    }, {\n        key: \"_delete\",\n        value: function _delete(key) {\n            var indexOnAddedKeys = this.addedKeys.indexOf(key);\n            if (indexOnAddedKeys > -1) {\n                this.addedKeys.splice(indexOnAddedKeys);\n                return delete this.extraArray[key];\n            } else {\n                return this.removedKeys.push(key);\n            }\n        }\n    }, {\n        key: \"_export\",\n        value: function _export() {\n            for (var key in this.extraArray) {\n                this.originalArray[key] = this.extraArray[key];\n            }\n\n            for (var i = 0; i < this.removedKeys.length; i++) {\n                delete this.originalArray[this.removedKeys[i]];\n            }\n\n            return this.originalArray;\n        }\n    }]);\n\n    return SandboxCollection;\n}();\n\nmodule.exports = SandboxCollection;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DaGFubmVscy9fQXR0cmlidXRlL2hlbHBlcnMvU2FuZGJveENvbGxlY3Rpb24uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DaGFubmVscy9fQXR0cmlidXRlL2hlbHBlcnMvU2FuZGJveENvbGxlY3Rpb24uanM/ZWU4YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBUaGUgZ29hbCBvZiB0aGlzIGNsYXNzIGlzIHRvIGdldCBhbiBvcmlnaW5hbCBhcnJheSwgcHJvdmlkZSBhbGwgdGhlIGZ1bmN0aW9uYWxpdHlcbiAqIG9mIHRoZSBDb2xsZWN0aW9uIGNsYXNzIGJ1dCBieSBrZWVwaW5nIHRoZSBvcmlnaW5hbEFycmF5IGNsZWFuIGFzIGl0IHdhcyBwcm92aWRlZC5cbiovXG5cbnZhciBTYW5kYm94Q29sbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTYW5kYm94Q29sbGVjdGlvbihvcmlnaW5hbEFycmF5KSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTYW5kYm94Q29sbGVjdGlvbik7XG5cbiAgICAgICAgdGhpcy5vcmlnaW5hbEFycmF5ID0gb3JpZ2luYWxBcnJheTtcbiAgICAgICAgdGhpcy5leHRyYUFycmF5ID0ge307XG4gICAgICAgIHRoaXMuYWRkZWRLZXlzID0gW107XG4gICAgICAgIHRoaXMucmVtb3ZlZEtleXMgPSBbXTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoU2FuZGJveENvbGxlY3Rpb24sIFt7XG4gICAgICAgIGtleTogXCJfaGFzT3duUHJvcGVydHlcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYXNPd25Qcm9wZXJ0eShrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9yaWdpbmFsQXJyYXkuaGFzT3duUHJvcGVydHkoa2V5KSB8fCB0aGlzLmV4dHJhQXJyYXkuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcIl9nZXRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXQoa2V5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5leHRyYUFycmF5Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5leHRyYUFycmF5W2tleV07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLm9yaWdpbmFsQXJyYXkuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZXh0cmFBcnJheVtrZXldID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcmlnaW5hbEFycmF5W2tleV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmV4dHJhQXJyYXlba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcIl9zZXRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5leHRyYUFycmF5W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5vcmlnaW5hbEFycmF5Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZGVkS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW5kZXhPblJlbW92ZWRLZXlzID0gdGhpcy5yZW1vdmVkS2V5cy5pbmRleE9mKGtleSk7XG4gICAgICAgICAgICBpZiAoaW5kZXhPblJlbW92ZWRLZXlzID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZWRLZXlzLnNwbGljZShpbmRleE9uUmVtb3ZlZEtleXMsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiX2tleXNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9rZXlzKCkge1xuICAgICAgICAgICAgdmFyIGFsbEtleXMgPSBPYmplY3Qua2V5cyh0aGlzLm9yaWdpbmFsQXJyYXkpLmNvbmNhdCh0aGlzLmFkZGVkS2V5cyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVtb3ZlZEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhPbkFycmF5ID0gdGhpcy5yZW1vdmVkS2V5cy5pbmRleE9mKHRoaXMucmVtb3ZlZEtleXNbaV0pO1xuICAgICAgICAgICAgICAgIGFsbEtleXMuc3BsaWNlKGluZGV4T25BcnJheSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWxsS2V5cztcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcIl9kZWxldGVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWxldGUoa2V5KSB7XG4gICAgICAgICAgICB2YXIgaW5kZXhPbkFkZGVkS2V5cyA9IHRoaXMuYWRkZWRLZXlzLmluZGV4T2Yoa2V5KTtcbiAgICAgICAgICAgIGlmIChpbmRleE9uQWRkZWRLZXlzID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZGVkS2V5cy5zcGxpY2UoaW5kZXhPbkFkZGVkS2V5cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZSB0aGlzLmV4dHJhQXJyYXlba2V5XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlZEtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiX2V4cG9ydFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2V4cG9ydCgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmV4dHJhQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9yaWdpbmFsQXJyYXlba2V5XSA9IHRoaXMuZXh0cmFBcnJheVtrZXldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVtb3ZlZEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5vcmlnaW5hbEFycmF5W3RoaXMucmVtb3ZlZEtleXNbaV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbEFycmF5O1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFNhbmRib3hDb2xsZWN0aW9uO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNhbmRib3hDb2xsZWN0aW9uOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/helpers/SandboxCollection.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/helpers/SandboxLanes.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/helpers/SandboxLanes.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar SandboxCollection = __webpack_require__(/*! ./SandboxCollection */ \"./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/helpers/SandboxCollection.js\");\n\nvar SandboxLanes = function (_SandboxCollection) {\n    _inherits(SandboxLanes, _SandboxCollection);\n\n    function SandboxLanes() {\n        _classCallCheck(this, SandboxLanes);\n\n        return _possibleConstructorReturn(this, (SandboxLanes.__proto__ || Object.getPrototypeOf(SandboxLanes)).apply(this, arguments));\n    }\n\n    _createClass(SandboxLanes, [{\n        key: '_get',\n        value: function _get(key) {\n            if (this.extraArray.hasOwnProperty(key)) {\n                return this.extraArray[key];\n            } else if (!this.originalArray.hasOwnProperty(key)) {\n                return undefined;\n            } else {\n                this.extraArray[key] = [];\n                for (var i = 0; i < this.originalArray[key].length; i++) {\n                    this.extraArray[key].push({\n                        id: this.originalArray[key][i].id,\n                        incident: this.originalArray[key][i].incident,\n                        millisecond: this.originalArray[key][i].millisecond * 1\n                    });\n                }\n                return this.extraArray[key];\n            }\n        }\n    }]);\n\n    return SandboxLanes;\n}(SandboxCollection);\n\nmodule.exports = SandboxLanes;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DaGFubmVscy9fQXR0cmlidXRlL2hlbHBlcnMvU2FuZGJveExhbmVzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fQ2hhbm5lbHMvX0F0dHJpYnV0ZS9oZWxwZXJzL1NhbmRib3hMYW5lcy5qcz9lZGM4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgU2FuZGJveENvbGxlY3Rpb24gPSByZXF1aXJlKCcuL1NhbmRib3hDb2xsZWN0aW9uJyk7XG5cbnZhciBTYW5kYm94TGFuZXMgPSBmdW5jdGlvbiAoX1NhbmRib3hDb2xsZWN0aW9uKSB7XG4gICAgX2luaGVyaXRzKFNhbmRib3hMYW5lcywgX1NhbmRib3hDb2xsZWN0aW9uKTtcblxuICAgIGZ1bmN0aW9uIFNhbmRib3hMYW5lcygpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNhbmRib3hMYW5lcyk7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChTYW5kYm94TGFuZXMuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTYW5kYm94TGFuZXMpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoU2FuZGJveExhbmVzLCBbe1xuICAgICAgICBrZXk6ICdfZ2V0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXQoa2V5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5leHRyYUFycmF5Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5leHRyYUFycmF5W2tleV07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLm9yaWdpbmFsQXJyYXkuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZXh0cmFBcnJheVtrZXldID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9yaWdpbmFsQXJyYXlba2V5XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4dHJhQXJyYXlba2V5XS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB0aGlzLm9yaWdpbmFsQXJyYXlba2V5XVtpXS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2lkZW50OiB0aGlzLm9yaWdpbmFsQXJyYXlba2V5XVtpXS5pbmNpZGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kOiB0aGlzLm9yaWdpbmFsQXJyYXlba2V5XVtpXS5taWxsaXNlY29uZCAqIDFcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmV4dHJhQXJyYXlba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBTYW5kYm94TGFuZXM7XG59KFNhbmRib3hDb2xsZWN0aW9uKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTYW5kYm94TGFuZXM7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/helpers/SandboxLanes.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/** @classdesc Helper maintains a number of helpful functions in a single point  */\nvar conf = __webpack_require__(/*! ../configuration/generalConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\n\nvar Helper = function () {\n    function Helper(configuration) {\n        _classCallCheck(this, Helper);\n\n        var logLevel = 2;\n        if (configuration) {\n            if (configuration.hasOwnProperty('logLevel')) {\n                logLevel = configuration.logLevel;\n            }\n        }\n\n        this.lanesMCIDattrsSeperator = '___';\n\n        for (var i = 0; i < conf.logTypes.length; i++) {\n            var logType = conf.logTypes[i];\n            if (logLevel >= logType.level) this[logType.key] = window.console.log.bind(window.console, \"MotorCortex - %c%s\", logType.style);else this[logType.key] = function () {};\n        }\n\n        if (logLevel >= 3) this.log = window.console.log.bind(window.console, \"MotorCortex - \");else this.log = function () {};\n    }\n\n    _createClass(Helper, [{\n        key: 'renderTemplate',\n        value: function renderTemplate(templateString, templateVars) {\n            return new Function(\"return `\" + templateString + \"`;\").call(templateVars);\n        }\n\n        /**\n         * @returns {string} in the form \"1bc45f78-ab23-jl59\"\n         */\n\n    }, {\n        key: 'getAnId',\n        value: function getAnId() {\n            var underscore = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            var specialChar = '-';\n            if (underscore) {\n                specialChar = '_';\n            }\n            function s4() {\n                return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n            }\n            return s4() + s4() + specialChar + s4() + specialChar + s4();\n        }\n    }, {\n        key: 'getLaneKey',\n        value: function getLaneKey(mcid, attribute) {\n            return mcid + this.lanesMCIDattrsSeperator + attribute;\n        }\n    }, {\n        key: 'getMCIDandAttrOutOfLaneKey',\n        value: function getMCIDandAttrOutOfLaneKey(laneKey) {\n            var laneArray = laneKey.split(this.lanesMCIDattrsSeperator);\n            return {\n                mcid: laneArray[0],\n                attribute: laneArray[1]\n            };\n        }\n    }, {\n        key: 'getElementByMCID',\n        value: function getElementByMCID(context, mcid) {\n            return context.document.querySelectorAll('[' + conf.elements_data_attribute_name + '=\"' + mcid + '\"]')[0];\n        }\n    }, {\n        key: 'getMCIDOfElement',\n        value: function getMCIDOfElement(element) {\n            return element.getAttribute(conf.elements_data_attribute_name);\n        }\n\n        /**\n        subdivision might be rounding the number to its:\n        - units (subdivision = 1)\n        - tenths (subdivision = 10)\n        - hundreds (subdivision = 100)\n        - thousands (subdivision = 1000)\n         @param {string} int\n         @param {subdivision} int\n         @returns {int} the rounded number\n        */\n\n    }, {\n        key: 'roundNumberTo',\n        value: function roundNumberTo(number, subdivision) {\n            return Math.round(number / subdivision) * subdivision;\n        }\n    }, {\n        key: 'isInteger',\n        value: function isInteger(number) {\n            if (number === parseInt(number, 10)) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n    }, {\n        key: 'isString',\n        value: function isString(test) {\n            if (typeof test === 'string' || test instanceof String) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n    }, {\n        key: 'isObject',\n        value: function isObject(test) {\n            return (typeof test === 'undefined' ? 'undefined' : _typeof(test)) === \"object\";\n        }\n    }, {\n        key: 'isArray',\n        value: function isArray(test) {\n            return Array.isArray(test);\n        }\n    }, {\n        key: 'isFunction',\n        value: function isFunction(functionToCheck) {\n            return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';\n        }\n    }, {\n        key: 'addClass',\n        value: function addClass(el, className) {\n            if (el.classList) el.classList.add(className);else el.className += ' ' + className;\n        }\n    }, {\n        key: 'removeClass',\n        value: function removeClass(el, className) {\n            if (el.classList) el.classList.remove(className);else el.className = el.className.replace(new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ');\n        }\n    }, {\n        key: 'addStyle',\n        value: function addStyle(el, style) {\n            for (var key in style) {\n                el.style[key] = style[key];\n            }\n        }\n\n        /**\n         * systole / diastole of the projections\n         * @param {float} fraction - the duration fraction of the parent Scene\n         * @returns {array} - collection of objects with keys: {id, start, end, startDelta}\n        **/\n\n    }, {\n        key: 'systoleDiastoleProjections',\n        value: function systoleDiastoleProjections(projections, durationFraction, adjustMillisecond) {\n            var alteredProjections = [];\n\n            for (var i = 0; i < projections.length; i++) {\n                var projectedIncident = projections[i];\n\n                if (durationFraction != 1) {\n                    alteredProjections.push({\n                        id: projectedIncident.incident.id,\n                        start: projectedIncident.millisecond * durationFraction + adjustMillisecond,\n                        end: projectedIncident.millisecond * durationFraction + projectedIncident.incident.duration * durationFraction + adjustMillisecond,\n                        startDelta: projectedIncident.millisecond * durationFraction - projectedIncident.millisecond\n                    });\n                }\n            }\n\n            return alteredProjections;\n        }\n    }]);\n\n    return Helper;\n}();\n\nmodule.exports = Helper;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19jb3JlVXRpbHMvSGVscGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fY29yZVV0aWxzL0hlbHBlci5qcz85ZDBiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKiogQGNsYXNzZGVzYyBIZWxwZXIgbWFpbnRhaW5zIGEgbnVtYmVyIG9mIGhlbHBmdWwgZnVuY3Rpb25zIGluIGEgc2luZ2xlIHBvaW50ICAqL1xudmFyIGNvbmYgPSByZXF1aXJlKCcuLi9jb25maWd1cmF0aW9uL2dlbmVyYWxDb25mJyk7XG5cbnZhciBIZWxwZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSGVscGVyKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhlbHBlcik7XG5cbiAgICAgICAgdmFyIGxvZ0xldmVsID0gMjtcbiAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uLmhhc093blByb3BlcnR5KCdsb2dMZXZlbCcpKSB7XG4gICAgICAgICAgICAgICAgbG9nTGV2ZWwgPSBjb25maWd1cmF0aW9uLmxvZ0xldmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sYW5lc01DSURhdHRyc1NlcGVyYXRvciA9ICdfX18nO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29uZi5sb2dUeXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxvZ1R5cGUgPSBjb25mLmxvZ1R5cGVzW2ldO1xuICAgICAgICAgICAgaWYgKGxvZ0xldmVsID49IGxvZ1R5cGUubGV2ZWwpIHRoaXNbbG9nVHlwZS5rZXldID0gd2luZG93LmNvbnNvbGUubG9nLmJpbmQod2luZG93LmNvbnNvbGUsIFwiTW90b3JDb3J0ZXggLSAlYyVzXCIsIGxvZ1R5cGUuc3R5bGUpO2Vsc2UgdGhpc1tsb2dUeXBlLmtleV0gPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsb2dMZXZlbCA+PSAzKSB0aGlzLmxvZyA9IHdpbmRvdy5jb25zb2xlLmxvZy5iaW5kKHdpbmRvdy5jb25zb2xlLCBcIk1vdG9yQ29ydGV4IC0gXCIpO2Vsc2UgdGhpcy5sb2cgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoSGVscGVyLCBbe1xuICAgICAgICBrZXk6ICdyZW5kZXJUZW1wbGF0ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJUZW1wbGF0ZSh0ZW1wbGF0ZVN0cmluZywgdGVtcGxhdGVWYXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwicmV0dXJuIGBcIiArIHRlbXBsYXRlU3RyaW5nICsgXCJgO1wiKS5jYWxsKHRlbXBsYXRlVmFycyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gaW4gdGhlIGZvcm0gXCIxYmM0NWY3OC1hYjIzLWpsNTlcIlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0QW5JZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBbklkKCkge1xuICAgICAgICAgICAgdmFyIHVuZGVyc2NvcmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuXG4gICAgICAgICAgICB2YXIgc3BlY2lhbENoYXIgPSAnLSc7XG4gICAgICAgICAgICBpZiAodW5kZXJzY29yZSkge1xuICAgICAgICAgICAgICAgIHNwZWNpYWxDaGFyID0gJ18nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gczQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKDEgKyBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDApLnRvU3RyaW5nKDE2KS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gczQoKSArIHM0KCkgKyBzcGVjaWFsQ2hhciArIHM0KCkgKyBzcGVjaWFsQ2hhciArIHM0KCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldExhbmVLZXknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGFuZUtleShtY2lkLCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIHJldHVybiBtY2lkICsgdGhpcy5sYW5lc01DSURhdHRyc1NlcGVyYXRvciArIGF0dHJpYnV0ZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0TUNJRGFuZEF0dHJPdXRPZkxhbmVLZXknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TUNJRGFuZEF0dHJPdXRPZkxhbmVLZXkobGFuZUtleSkge1xuICAgICAgICAgICAgdmFyIGxhbmVBcnJheSA9IGxhbmVLZXkuc3BsaXQodGhpcy5sYW5lc01DSURhdHRyc1NlcGVyYXRvcik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1jaWQ6IGxhbmVBcnJheVswXSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGU6IGxhbmVBcnJheVsxXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0RWxlbWVudEJ5TUNJRCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbGVtZW50QnlNQ0lEKGNvbnRleHQsIG1jaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1snICsgY29uZi5lbGVtZW50c19kYXRhX2F0dHJpYnV0ZV9uYW1lICsgJz1cIicgKyBtY2lkICsgJ1wiXScpWzBdO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRNQ0lET2ZFbGVtZW50JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1DSURPZkVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKGNvbmYuZWxlbWVudHNfZGF0YV9hdHRyaWJ1dGVfbmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgc3ViZGl2aXNpb24gbWlnaHQgYmUgcm91bmRpbmcgdGhlIG51bWJlciB0byBpdHM6XG4gICAgICAgIC0gdW5pdHMgKHN1YmRpdmlzaW9uID0gMSlcbiAgICAgICAgLSB0ZW50aHMgKHN1YmRpdmlzaW9uID0gMTApXG4gICAgICAgIC0gaHVuZHJlZHMgKHN1YmRpdmlzaW9uID0gMTAwKVxuICAgICAgICAtIHRob3VzYW5kcyAoc3ViZGl2aXNpb24gPSAxMDAwKVxuICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IGludFxuICAgICAgICAgQHBhcmFtIHtzdWJkaXZpc2lvbn0gaW50XG4gICAgICAgICBAcmV0dXJucyB7aW50fSB0aGUgcm91bmRlZCBudW1iZXJcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncm91bmROdW1iZXJUbycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByb3VuZE51bWJlclRvKG51bWJlciwgc3ViZGl2aXNpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKG51bWJlciAvIHN1YmRpdmlzaW9uKSAqIHN1YmRpdmlzaW9uO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdpc0ludGVnZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNJbnRlZ2VyKG51bWJlcikge1xuICAgICAgICAgICAgaWYgKG51bWJlciA9PT0gcGFyc2VJbnQobnVtYmVyLCAxMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdpc1N0cmluZycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc1N0cmluZyh0ZXN0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRlc3QgPT09ICdzdHJpbmcnIHx8IHRlc3QgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdpc09iamVjdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc09iamVjdCh0ZXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gKHR5cGVvZiB0ZXN0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih0ZXN0KSkgPT09IFwib2JqZWN0XCI7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2lzQXJyYXknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNBcnJheSh0ZXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0ZXN0KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaXNGdW5jdGlvbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0Z1bmN0aW9uKGZ1bmN0aW9uVG9DaGVjaykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uVG9DaGVjayAmJiB7fS50b1N0cmluZy5jYWxsKGZ1bmN0aW9uVG9DaGVjaykgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2FkZENsYXNzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZENsYXNzKGVsLCBjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIGlmIChlbC5jbGFzc0xpc3QpIGVsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtlbHNlIGVsLmNsYXNzTmFtZSArPSAnICcgKyBjbGFzc05hbWU7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3JlbW92ZUNsYXNzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIGlmIChlbC5jbGFzc0xpc3QpIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtlbHNlIGVsLmNsYXNzTmFtZSA9IGVsLmNsYXNzTmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAoJyhefFxcXFxiKScgKyBjbGFzc05hbWUuc3BsaXQoJyAnKS5qb2luKCd8JykgKyAnKFxcXFxifCQpJywgJ2dpJyksICcgJyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2FkZFN0eWxlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFN0eWxlKGVsLCBzdHlsZSkge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgZWwuc3R5bGVba2V5XSA9IHN0eWxlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogc3lzdG9sZSAvIGRpYXN0b2xlIG9mIHRoZSBwcm9qZWN0aW9uc1xuICAgICAgICAgKiBAcGFyYW0ge2Zsb2F0fSBmcmFjdGlvbiAtIHRoZSBkdXJhdGlvbiBmcmFjdGlvbiBvZiB0aGUgcGFyZW50IFNjZW5lXG4gICAgICAgICAqIEByZXR1cm5zIHthcnJheX0gLSBjb2xsZWN0aW9uIG9mIG9iamVjdHMgd2l0aCBrZXlzOiB7aWQsIHN0YXJ0LCBlbmQsIHN0YXJ0RGVsdGF9XG4gICAgICAgICoqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzeXN0b2xlRGlhc3RvbGVQcm9qZWN0aW9ucycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzeXN0b2xlRGlhc3RvbGVQcm9qZWN0aW9ucyhwcm9qZWN0aW9ucywgZHVyYXRpb25GcmFjdGlvbiwgYWRqdXN0TWlsbGlzZWNvbmQpIHtcbiAgICAgICAgICAgIHZhciBhbHRlcmVkUHJvamVjdGlvbnMgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9qZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwcm9qZWN0ZWRJbmNpZGVudCA9IHByb2plY3Rpb25zW2ldO1xuXG4gICAgICAgICAgICAgICAgaWYgKGR1cmF0aW9uRnJhY3Rpb24gIT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBhbHRlcmVkUHJvamVjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogcHJvamVjdGVkSW5jaWRlbnQuaW5jaWRlbnQuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogcHJvamVjdGVkSW5jaWRlbnQubWlsbGlzZWNvbmQgKiBkdXJhdGlvbkZyYWN0aW9uICsgYWRqdXN0TWlsbGlzZWNvbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHByb2plY3RlZEluY2lkZW50Lm1pbGxpc2Vjb25kICogZHVyYXRpb25GcmFjdGlvbiArIHByb2plY3RlZEluY2lkZW50LmluY2lkZW50LmR1cmF0aW9uICogZHVyYXRpb25GcmFjdGlvbiArIGFkanVzdE1pbGxpc2Vjb25kLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnREZWx0YTogcHJvamVjdGVkSW5jaWRlbnQubWlsbGlzZWNvbmQgKiBkdXJhdGlvbkZyYWN0aW9uIC0gcHJvamVjdGVkSW5jaWRlbnQubWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYWx0ZXJlZFByb2plY3Rpb25zO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEhlbHBlcjtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBIZWxwZXI7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/TimeCapsule.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/TimeCapsule.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Helper = __webpack_require__(/*! ../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\n\nvar Journey = function () {\n    function Journey(props) {\n        _classCallCheck(this, Journey);\n\n        if (!props.hasOwnProperty('incident')) {\n            helper.error('Journey constructor expects an Incident on its properties on the key \"incident\"');\n            return false;\n        }\n\n        this.memory = props.calpuleMemory;\n        this.stations = [];\n\n        this.incident = props.incident;\n        this.startMillisecond = this.incident.runTimeInfo.currentMillisecond * 1;\n        this.startState = this.incident.state + \"\";\n        this.incident.stop();\n    }\n\n    _createClass(Journey, [{\n        key: 'station',\n        value: function station(millisecond) {\n            var props = {};\n            if (this.stations.length > 0) {\n                props.previousStop = this.stations[this.stations.length - 1];\n            }\n            this.stations.push(millisecond);\n            // helper.log(`CAPSULE passes as previousStop: ${props.previousStop}`);\n            // helper.log(this.stations);\n            this.incident.goTo(millisecond, props);\n        }\n    }, {\n        key: 'destination',\n        value: function destination() {\n            var millisecond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            if (millisecond != null) {\n                this.station(millisecond);\n            } else {\n                millisecond = this.stations[this.stations.length - 1];\n            }\n            this.incident.beOn(millisecond, false);\n            if (this.startState === 'playing' || this.startState === 'blocked') {\n                this.incident.resume();\n            }\n            this.memory.push(this.exportJourneyLog);\n        }\n    }, {\n        key: 'exportJourneyLog',\n        value: function exportJourneyLog() {\n            return {\n                startMillisecond: this.startMillisecond,\n                startState: this.startState,\n                incident: this.incident.exportState(),\n                stations: this.stations\n            };\n        }\n    }]);\n\n    return Journey;\n}();\n\nvar TimeCapsule = function () {\n    function TimeCapsule() {\n        _classCallCheck(this, TimeCapsule);\n\n        this.memory = [];\n    }\n\n    _createClass(TimeCapsule, [{\n        key: 'startJourney',\n        value: function startJourney(incident) {\n            if (!incident) {\n                helper.error('startJourney expects an Incident as an argument');\n                return false;\n            }\n\n            return new Journey({ incident: incident, calpuleMemory: this.memory });\n        }\n    }]);\n\n    return TimeCapsule;\n}();\n\nmodule.exports = TimeCapsule;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19jb3JlVXRpbHMvVGltZUNhcHN1bGUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19jb3JlVXRpbHMvVGltZUNhcHN1bGUuanM/YmIyMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBIZWxwZXIgPSByZXF1aXJlKCcuLi9fY29yZVV0aWxzL0hlbHBlcicpO1xudmFyIGhlbHBlciA9IG5ldyBIZWxwZXIoKTtcblxudmFyIEpvdXJuZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSm91cm5leShwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSm91cm5leSk7XG5cbiAgICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnaW5jaWRlbnQnKSkge1xuICAgICAgICAgICAgaGVscGVyLmVycm9yKCdKb3VybmV5IGNvbnN0cnVjdG9yIGV4cGVjdHMgYW4gSW5jaWRlbnQgb24gaXRzIHByb3BlcnRpZXMgb24gdGhlIGtleSBcImluY2lkZW50XCInKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWVtb3J5ID0gcHJvcHMuY2FscHVsZU1lbW9yeTtcbiAgICAgICAgdGhpcy5zdGF0aW9ucyA9IFtdO1xuXG4gICAgICAgIHRoaXMuaW5jaWRlbnQgPSBwcm9wcy5pbmNpZGVudDtcbiAgICAgICAgdGhpcy5zdGFydE1pbGxpc2Vjb25kID0gdGhpcy5pbmNpZGVudC5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQgKiAxO1xuICAgICAgICB0aGlzLnN0YXJ0U3RhdGUgPSB0aGlzLmluY2lkZW50LnN0YXRlICsgXCJcIjtcbiAgICAgICAgdGhpcy5pbmNpZGVudC5zdG9wKCk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEpvdXJuZXksIFt7XG4gICAgICAgIGtleTogJ3N0YXRpb24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3RhdGlvbihtaWxsaXNlY29uZCkge1xuICAgICAgICAgICAgdmFyIHByb3BzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcHJvcHMucHJldmlvdXNTdG9wID0gdGhpcy5zdGF0aW9uc1t0aGlzLnN0YXRpb25zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0aW9ucy5wdXNoKG1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgIC8vIGhlbHBlci5sb2coYENBUFNVTEUgcGFzc2VzIGFzIHByZXZpb3VzU3RvcDogJHtwcm9wcy5wcmV2aW91c1N0b3B9YCk7XG4gICAgICAgICAgICAvLyBoZWxwZXIubG9nKHRoaXMuc3RhdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5pbmNpZGVudC5nb1RvKG1pbGxpc2Vjb25kLCBwcm9wcyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Rlc3RpbmF0aW9uJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3RpbmF0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG1pbGxpc2Vjb25kID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuXG4gICAgICAgICAgICBpZiAobWlsbGlzZWNvbmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGlvbihtaWxsaXNlY29uZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kID0gdGhpcy5zdGF0aW9uc1t0aGlzLnN0YXRpb25zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbmNpZGVudC5iZU9uKG1pbGxpc2Vjb25kLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFydFN0YXRlID09PSAncGxheWluZycgfHwgdGhpcy5zdGFydFN0YXRlID09PSAnYmxvY2tlZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluY2lkZW50LnJlc3VtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tZW1vcnkucHVzaCh0aGlzLmV4cG9ydEpvdXJuZXlMb2cpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdleHBvcnRKb3VybmV5TG9nJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGV4cG9ydEpvdXJuZXlMb2coKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXJ0TWlsbGlzZWNvbmQ6IHRoaXMuc3RhcnRNaWxsaXNlY29uZCxcbiAgICAgICAgICAgICAgICBzdGFydFN0YXRlOiB0aGlzLnN0YXJ0U3RhdGUsXG4gICAgICAgICAgICAgICAgaW5jaWRlbnQ6IHRoaXMuaW5jaWRlbnQuZXhwb3J0U3RhdGUoKSxcbiAgICAgICAgICAgICAgICBzdGF0aW9uczogdGhpcy5zdGF0aW9uc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBKb3VybmV5O1xufSgpO1xuXG52YXIgVGltZUNhcHN1bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGltZUNhcHN1bGUoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUaW1lQ2Fwc3VsZSk7XG5cbiAgICAgICAgdGhpcy5tZW1vcnkgPSBbXTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoVGltZUNhcHN1bGUsIFt7XG4gICAgICAgIGtleTogJ3N0YXJ0Sm91cm5leScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydEpvdXJuZXkoaW5jaWRlbnQpIHtcbiAgICAgICAgICAgIGlmICghaW5jaWRlbnQpIHtcbiAgICAgICAgICAgICAgICBoZWxwZXIuZXJyb3IoJ3N0YXJ0Sm91cm5leSBleHBlY3RzIGFuIEluY2lkZW50IGFzIGFuIGFyZ3VtZW50Jyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IEpvdXJuZXkoeyBpbmNpZGVudDogaW5jaWRlbnQsIGNhbHB1bGVNZW1vcnk6IHRoaXMubWVtb3J5IH0pO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFRpbWVDYXBzdWxlO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbWVDYXBzdWxlOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/TimeCapsule.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_responsiveness/AttributeAwareIncident.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_responsiveness/AttributeAwareIncident.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Group = __webpack_require__(/*! ../_BaseClasses/Group */ \"./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Group.js\");\nvar conf = __webpack_require__(/*! ../configuration/generalConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\nvar Helper = __webpack_require__(/*! ../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\n\nvar AttributesAwareIncident = function (_Group) {\n    _inherits(AttributesAwareIncident, _Group);\n\n    function AttributesAwareIncident(incident) {\n        _classCallCheck(this, AttributesAwareIncident);\n\n        var _this = _possibleConstructorReturn(this, (AttributesAwareIncident.__proto__ || Object.getPrototypeOf(AttributesAwareIncident)).call(this, incident.attrs, incident.props));\n\n        _this.setUp(incident);\n        return _this;\n    }\n\n    _createClass(AttributesAwareIncident, [{\n        key: 'setUp',\n        value: function setUp(incident) {\n            this.IncidentClass = incident.constructor;\n            this.toPassToElementIncidents = {\n                plugin_channel_class: incident.plugin_channel_class,\n                mc_plugin_npm_name: incident.mc_plugin_npm_name\n            };\n            this.attributeIncidentsByAttribute = {};\n            this.cleanProps = Object.assign({}, this.props);\n            this.cleanAttrs = Object.assign({}, this.attrs);\n            delete this.cleanProps.id;\n            this.cleanAttrs.animatedAttrs = {};\n\n            for (var attr in this.attrs.animatedAttrs) {\n                this._createAttributeIncident(attr);\n            }\n        }\n\n        /**\n        * attribute groups\n        Can have on their timeline:\n        - An incident\n        Cant have on their timeline:\n        - A plain group\n        - A dom group\n        - Another attribute group\n        */\n\n    }, {\n        key: '_prepareInicdentForAddition',\n        value: function _prepareInicdentForAddition(incident) {\n            if (!incident.hasIncidents) {\n                // if it is not a group\n                return incident;\n            } else {\n                helper.error(\"attribute groups can not accept groups on their timeline\");\n                return null;\n            }\n        }\n    }, {\n        key: '_createAttributeIncident',\n        value: function _createAttributeIncident(attribute) {\n            var propsToPass = Object.assign({}, this.cleanProps);\n            var attrsToPass = Object.assign({}, this.cleanAttrs);\n            attrsToPass.animatedAttrs = {};\n            if (_typeof(this.attrs.animatedAttrs[attribute]) === 'object' && !Array.isArray(this.attrs.animatedAttrs[attribute])) {\n                attrsToPass.animatedAttrs[attribute] = Object.assign({}, this.attrs.animatedAttrs[attribute]);\n            } else if (_typeof(this.attrs.animatedAttrs[attribute]) === 'object' && Array.isArray(this.attrs.animatedAttrs[attribute])) {\n                attrsToPass.animatedAttrs[attribute] = this.attrs.animatedAttrs[attribute].splice(0);\n            } else {\n                attrsToPass.animatedAttrs[attribute] = this.attrs.animatedAttrs[attribute];\n            }\n\n            propsToPass.id = this.id + '_' + attribute;\n            propsToPass.autogeneratedID = true;\n\n            var attributeIncident = new this.IncidentClass(attrsToPass, propsToPass);\n            attributeIncident.plugin_channel_class = this.toPassToElementIncidents.plugin_channel_class;\n            attributeIncident.mc_plugin_npm_name = this.toPassToElementIncidents.mc_plugin_npm_name;\n            this.addIncident(attributeIncident, 0);\n            this.attributeIncidentsByAttribute[attribute] = attributeIncident;\n        }\n    }, {\n        key: 'attributesChange',\n        value: function attributesChange(newAttrs) {\n            for (var i = 0; i < this.incidents; i++) {\n                // TODO execute attribute change by passing down the command\n            }\n        }\n    }, {\n        key: 'groupType',\n        get: function get() {\n            return \"attribute\";\n        }\n    }]);\n\n    return AttributesAwareIncident;\n}(Group);\n\nmodule.exports = AttributesAwareIncident;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19yZXNwb25zaXZlbmVzcy9BdHRyaWJ1dGVBd2FyZUluY2lkZW50LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fcmVzcG9uc2l2ZW5lc3MvQXR0cmlidXRlQXdhcmVJbmNpZGVudC5qcz81MjQ1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBHcm91cCA9IHJlcXVpcmUoJy4uL19CYXNlQ2xhc3Nlcy9Hcm91cCcpO1xudmFyIGNvbmYgPSByZXF1aXJlKCcuLi9jb25maWd1cmF0aW9uL2dlbmVyYWxDb25mJyk7XG52YXIgSGVscGVyID0gcmVxdWlyZSgnLi4vX2NvcmVVdGlscy9IZWxwZXInKTtcbnZhciBoZWxwZXIgPSBuZXcgSGVscGVyKCk7XG5cbnZhciBBdHRyaWJ1dGVzQXdhcmVJbmNpZGVudCA9IGZ1bmN0aW9uIChfR3JvdXApIHtcbiAgICBfaW5oZXJpdHMoQXR0cmlidXRlc0F3YXJlSW5jaWRlbnQsIF9Hcm91cCk7XG5cbiAgICBmdW5jdGlvbiBBdHRyaWJ1dGVzQXdhcmVJbmNpZGVudChpbmNpZGVudCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXR0cmlidXRlc0F3YXJlSW5jaWRlbnQpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChBdHRyaWJ1dGVzQXdhcmVJbmNpZGVudC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEF0dHJpYnV0ZXNBd2FyZUluY2lkZW50KSkuY2FsbCh0aGlzLCBpbmNpZGVudC5hdHRycywgaW5jaWRlbnQucHJvcHMpKTtcblxuICAgICAgICBfdGhpcy5zZXRVcChpbmNpZGVudCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQXR0cmlidXRlc0F3YXJlSW5jaWRlbnQsIFt7XG4gICAgICAgIGtleTogJ3NldFVwJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFVwKGluY2lkZW50KSB7XG4gICAgICAgICAgICB0aGlzLkluY2lkZW50Q2xhc3MgPSBpbmNpZGVudC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHRoaXMudG9QYXNzVG9FbGVtZW50SW5jaWRlbnRzID0ge1xuICAgICAgICAgICAgICAgIHBsdWdpbl9jaGFubmVsX2NsYXNzOiBpbmNpZGVudC5wbHVnaW5fY2hhbm5lbF9jbGFzcyxcbiAgICAgICAgICAgICAgICBtY19wbHVnaW5fbnBtX25hbWU6IGluY2lkZW50Lm1jX3BsdWdpbl9ucG1fbmFtZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlSW5jaWRlbnRzQnlBdHRyaWJ1dGUgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuY2xlYW5Qcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMpO1xuICAgICAgICAgICAgdGhpcy5jbGVhbkF0dHJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5hdHRycyk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jbGVhblByb3BzLmlkO1xuICAgICAgICAgICAgdGhpcy5jbGVhbkF0dHJzLmFuaW1hdGVkQXR0cnMgPSB7fTtcblxuICAgICAgICAgICAgZm9yICh2YXIgYXR0ciBpbiB0aGlzLmF0dHJzLmFuaW1hdGVkQXR0cnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVBdHRyaWJ1dGVJbmNpZGVudChhdHRyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAqIGF0dHJpYnV0ZSBncm91cHNcbiAgICAgICAgQ2FuIGhhdmUgb24gdGhlaXIgdGltZWxpbmU6XG4gICAgICAgIC0gQW4gaW5jaWRlbnRcbiAgICAgICAgQ2Fu4oCZdCBoYXZlIG9uIHRoZWlyIHRpbWVsaW5lOlxuICAgICAgICAtIEEgcGxhaW4gZ3JvdXBcbiAgICAgICAgLSBBIGRvbSBncm91cFxuICAgICAgICAtIEFub3RoZXIgYXR0cmlidXRlIGdyb3VwXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19wcmVwYXJlSW5pY2RlbnRGb3JBZGRpdGlvbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcHJlcGFyZUluaWNkZW50Rm9yQWRkaXRpb24oaW5jaWRlbnQpIHtcbiAgICAgICAgICAgIGlmICghaW5jaWRlbnQuaGFzSW5jaWRlbnRzKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgaXQgaXMgbm90IGEgZ3JvdXBcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5jaWRlbnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhlbHBlci5lcnJvcihcImF0dHJpYnV0ZSBncm91cHMgY2FuIG5vdCBhY2NlcHQgZ3JvdXBzIG9uIHRoZWlyIHRpbWVsaW5lXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfY3JlYXRlQXR0cmlidXRlSW5jaWRlbnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUF0dHJpYnV0ZUluY2lkZW50KGF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgdmFyIHByb3BzVG9QYXNzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jbGVhblByb3BzKTtcbiAgICAgICAgICAgIHZhciBhdHRyc1RvUGFzcyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY2xlYW5BdHRycyk7XG4gICAgICAgICAgICBhdHRyc1RvUGFzcy5hbmltYXRlZEF0dHJzID0ge307XG4gICAgICAgICAgICBpZiAoX3R5cGVvZih0aGlzLmF0dHJzLmFuaW1hdGVkQXR0cnNbYXR0cmlidXRlXSkgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHRoaXMuYXR0cnMuYW5pbWF0ZWRBdHRyc1thdHRyaWJ1dGVdKSkge1xuICAgICAgICAgICAgICAgIGF0dHJzVG9QYXNzLmFuaW1hdGVkQXR0cnNbYXR0cmlidXRlXSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYXR0cnMuYW5pbWF0ZWRBdHRyc1thdHRyaWJ1dGVdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZih0aGlzLmF0dHJzLmFuaW1hdGVkQXR0cnNbYXR0cmlidXRlXSkgPT09ICdvYmplY3QnICYmIEFycmF5LmlzQXJyYXkodGhpcy5hdHRycy5hbmltYXRlZEF0dHJzW2F0dHJpYnV0ZV0pKSB7XG4gICAgICAgICAgICAgICAgYXR0cnNUb1Bhc3MuYW5pbWF0ZWRBdHRyc1thdHRyaWJ1dGVdID0gdGhpcy5hdHRycy5hbmltYXRlZEF0dHJzW2F0dHJpYnV0ZV0uc3BsaWNlKDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhdHRyc1RvUGFzcy5hbmltYXRlZEF0dHJzW2F0dHJpYnV0ZV0gPSB0aGlzLmF0dHJzLmFuaW1hdGVkQXR0cnNbYXR0cmlidXRlXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvcHNUb1Bhc3MuaWQgPSB0aGlzLmlkICsgJ18nICsgYXR0cmlidXRlO1xuICAgICAgICAgICAgcHJvcHNUb1Bhc3MuYXV0b2dlbmVyYXRlZElEID0gdHJ1ZTtcblxuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZUluY2lkZW50ID0gbmV3IHRoaXMuSW5jaWRlbnRDbGFzcyhhdHRyc1RvUGFzcywgcHJvcHNUb1Bhc3MpO1xuICAgICAgICAgICAgYXR0cmlidXRlSW5jaWRlbnQucGx1Z2luX2NoYW5uZWxfY2xhc3MgPSB0aGlzLnRvUGFzc1RvRWxlbWVudEluY2lkZW50cy5wbHVnaW5fY2hhbm5lbF9jbGFzcztcbiAgICAgICAgICAgIGF0dHJpYnV0ZUluY2lkZW50Lm1jX3BsdWdpbl9ucG1fbmFtZSA9IHRoaXMudG9QYXNzVG9FbGVtZW50SW5jaWRlbnRzLm1jX3BsdWdpbl9ucG1fbmFtZTtcbiAgICAgICAgICAgIHRoaXMuYWRkSW5jaWRlbnQoYXR0cmlidXRlSW5jaWRlbnQsIDApO1xuICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVJbmNpZGVudHNCeUF0dHJpYnV0ZVthdHRyaWJ1dGVdID0gYXR0cmlidXRlSW5jaWRlbnQ7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2F0dHJpYnV0ZXNDaGFuZ2UnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXR0cmlidXRlc0NoYW5nZShuZXdBdHRycykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluY2lkZW50czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBleGVjdXRlIGF0dHJpYnV0ZSBjaGFuZ2UgYnkgcGFzc2luZyBkb3duIHRoZSBjb21tYW5kXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dyb3VwVHlwZScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiYXR0cmlidXRlXCI7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQXR0cmlidXRlc0F3YXJlSW5jaWRlbnQ7XG59KEdyb3VwKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBdHRyaWJ1dGVzQXdhcmVJbmNpZGVudDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_responsiveness/AttributeAwareIncident.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_responsiveness/DOMAwareIncident.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_responsiveness/DOMAwareIncident.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Group = __webpack_require__(/*! ../_BaseClasses/Group */ \"./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Group.js\");\nvar conf = __webpack_require__(/*! ../configuration/generalConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\nvar Helper = __webpack_require__(/*! ../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\n\nvar DOMAwareIncident = function (_Group) {\n    _inherits(DOMAwareIncident, _Group);\n\n    function DOMAwareIncident(incident) {\n        _classCallCheck(this, DOMAwareIncident);\n\n        var _this = _possibleConstructorReturn(this, (DOMAwareIncident.__proto__ || Object.getPrototypeOf(DOMAwareIncident)).call(this, incident.attrs, incident.props));\n\n        _this.setUp(incident);\n        return _this;\n    }\n\n    _createClass(DOMAwareIncident, [{\n        key: 'setUp',\n\n\n        // props must have the elements collection and the millisecond\n        // id is also mandatory\n        value: function setUp(incident) {\n            this.originalIncident = incident;\n            this.IncidentClass = incident.constructor;\n            this.toPassToElementIncidents = {\n                plugin_channel_class: incident.plugin_channel_class,\n                mc_plugin_npm_name: incident.mc_plugin_npm_name\n            };\n            this.elementIncidentsByMCID = {};\n            this.cleanProps = Object.assign({}, this.props);\n            delete this.cleanProps.id;\n\n            if (this.context) {\n                var elements = Array.from(this.context.document.querySelectorAll(this.props.selector));\n                for (var i = 0; i < elements.length; i++) {\n                    var element = elements[i];\n                    this._createElementIncident(element);\n                }\n            }\n        }\n    }, {\n        key: 'systolDiastole',\n        value: function systolDiastole(durationFraction) {\n            _get(DOMAwareIncident.prototype.__proto__ || Object.getPrototypeOf(DOMAwareIncident.prototype), 'systolDiastole', this).call(this, durationFraction);\n            this.originalIncident.props.duration *= durationFraction;\n        }\n\n        /**\n         * dom groups\n            Can have on their timeline:\n            - An incident with no animatedAttrs \n            - An attribute group (this method should actually turn any incident with animatedAttrs to one)\n            Cant have on their timeline:\n            - A plain group\n            - Another dom group\n         */\n\n    }, {\n        key: '_prepareInicdentForAddition',\n        value: function _prepareInicdentForAddition(incident) {\n            if (!incident.attrs.hasOwnProperty('animatedAttrs') && !incident.hasIncidents) {\n                // if the incident is not a group and it has no animatedAttrs proceed normally\n                return incident;\n            } else if (incident.groupType === \"plain\") {\n                // if the Incident is a plain group proceed normally\n                helper.error(\"dom groups can not accept plain groups on their timeline\");\n                return null;\n            } else if (incident.groupType === \"dom\") {\n                helper.error(\"dom groups can not accept other dom groups on their timeline\");\n                return null;\n            }\n\n            // We need to turn the Incident to an AttrsAwareIncident\n            // before adding it to the group\n            var AttrsAwareIncident = __webpack_require__(/*! ./AttributeAwareIncident */ \"./node_modules/@kissmybutton/motorcortex/dist/_responsiveness/AttributeAwareIncident.js\");\n            var theAttrsAwareIncident = new AttrsAwareIncident(incident);\n            return theAttrsAwareIncident;\n        }\n    }, {\n        key: '_createElementIncident',\n        value: function _createElementIncident(element) {\n            var mcid = this.context.getMCID(element);\n            if (!mcid) {\n                mcid = helper.getAnId(true);\n                this.context.setMCID(element, mcid);\n            }\n\n            var propsToPass = Object.assign({}, this.cleanProps);\n            propsToPass.selector = this.context.getElementSelectorByMCID(mcid); // '[data-motorocortext2-id=\"mcid1\"]' querySelectorAll()\n            propsToPass.mcid = mcid;\n            propsToPass.id = this.id + '_' + mcid;\n            propsToPass.autogeneratedID = true;\n            var elementIncident = new this.IncidentClass(this.attrs, propsToPass);\n            elementIncident.plugin_channel_class = this.toPassToElementIncidents.plugin_channel_class;\n            elementIncident.mc_plugin_npm_name = this.toPassToElementIncidents.mc_plugin_npm_name;\n            var result = this.addIncident(elementIncident, 0);\n            if (result.result === true) {\n                this.elementIncidentsByMCID[mcid] = elementIncident;\n            }\n            return result;\n        }\n\n        /**\n         * flashDOM method expects the new elements collection and:\n         * 1. Identifies which of the existing elementIncidents should go (the dom element does not participate on the DOMAwareGroup any more)\n         * 2. Identifies which elements are new and add their elementIncident on the DOMAwareGroup\n         * @returns {object} - with keys additions and deletions each of which hold an array of functions that must be\n         *  executed for adding the new element incidents and deleting the element incidents that do not apply any more\n        */\n\n    }, {\n        key: 'flashDOM',\n        value: function flashDOM() {\n            var _this2 = this;\n\n            var elements = this.context.getElements(this.props.selector);\n\n            // deletions and additions of elementIncidents that should take place according to the new elements\n            var deletions = [];\n            var additions = [];\n\n            var that = this;\n\n            // an array that will keep all new elements' keys to be used later for identifying deletions\n            var stayingElementIncidents = [];\n            // first identify additions\n\n            var _loop = function _loop(i) {\n                // for each of the new elements\n                var element = elements[i];\n                var mcid = _this2.context.getMCID(element); // take its mcid\n\n                if (!mcid) {\n                    // if the element does not have an mcid yet that means it's a new one\n                    var addition = function addition() {\n                        return that._createElementIncident(element);\n                    };\n                    additions.push(addition);\n                } else if (!_this2.elementIncidentsByMCID.hasOwnProperty(mcid)) {\n                    // else if the element has an mcid that doesn't already exist on the elementIncidents\n                    var _addition = function _addition() {\n                        return that._createElementIncident(element);\n                    };\n                    additions.push(_addition);\n                } else {\n                    stayingElementIncidents.push(mcid);\n                }\n            };\n\n            for (var i = 0; i < elements.length; i++) {\n                _loop(i);\n            }\n\n            // next step is to compare the elementIncidents with the existing elements key to see which \n            // are missing from the new set and put them for delete\n            var alreadyExistingElementsKeys = Object.keys(this.elementIncidentsByMCID);\n            var underDeletion = alreadyExistingElementsKeys.filter(function (key) {\n                return stayingElementIncidents.indexOf(key) < 0;\n            });\n\n            var _loop2 = function _loop2(i) {\n                var deletion = function deletion() {\n                    that.removeIncident(that.elementIncidentsByMCID[underDeletion[i]].id, { preventSlip: true });\n                    delete that.elementIncidentsByMCID[that.elementIncidentsByMCID[underDeletion[i]].id];\n                };\n                deletions.push(deletion);\n            };\n\n            for (var i = 0; i < underDeletion.length; i++) {\n                _loop2(i);\n            }\n\n            var failedAdditions = [];\n            for (var i = 0; i < additions.length; i++) {\n                var additionResult = additions[i]();\n                if (additionResult.result === false) {\n                    failedAdditions.push(additionResult);\n                }\n            }\n\n            for (var _i = 0; _i < deletions.length; _i++) {\n                deletions[_i]();\n            }\n\n            return {\n                failedAdditions: failedAdditions\n\n                // return {\n                //     additions: additions,\n                //     deletions: deletions\n                // }\n            };\n        }\n    }, {\n        key: 'attributesChange',\n        value: function attributesChange(newAttrs) {\n            for (var i = 0; i < this.incidents; i++) {\n                // TODO execute attribute change by passing down the command\n            }\n        }\n    }, {\n        key: 'exportState',\n        value: function exportState() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            if (props.hasOwnProperty('unprocessed')) {\n                if (props.unprocessed === false) {\n                    return _get(DOMAwareIncident.prototype.__proto__ || Object.getPrototypeOf(DOMAwareIncident.prototype), 'exportState', this).call(this, props);\n                } else {\n                    return this.originalIncident.exportState();\n                }\n            }\n            return this.originalIncident.exportState();\n        }\n    }, {\n        key: 'groupType',\n        get: function get() {\n            return \"dom\";\n        }\n    }]);\n\n    return DOMAwareIncident;\n}(Group);\n\nmodule.exports = DOMAwareIncident;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19yZXNwb25zaXZlbmVzcy9ET01Bd2FyZUluY2lkZW50LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fcmVzcG9uc2l2ZW5lc3MvRE9NQXdhcmVJbmNpZGVudC5qcz84MDY1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBHcm91cCA9IHJlcXVpcmUoJy4uL19CYXNlQ2xhc3Nlcy9Hcm91cCcpO1xudmFyIGNvbmYgPSByZXF1aXJlKCcuLi9jb25maWd1cmF0aW9uL2dlbmVyYWxDb25mJyk7XG52YXIgSGVscGVyID0gcmVxdWlyZSgnLi4vX2NvcmVVdGlscy9IZWxwZXInKTtcbnZhciBoZWxwZXIgPSBuZXcgSGVscGVyKCk7XG5cbnZhciBET01Bd2FyZUluY2lkZW50ID0gZnVuY3Rpb24gKF9Hcm91cCkge1xuICAgIF9pbmhlcml0cyhET01Bd2FyZUluY2lkZW50LCBfR3JvdXApO1xuXG4gICAgZnVuY3Rpb24gRE9NQXdhcmVJbmNpZGVudChpbmNpZGVudCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRE9NQXdhcmVJbmNpZGVudCk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKERPTUF3YXJlSW5jaWRlbnQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihET01Bd2FyZUluY2lkZW50KSkuY2FsbCh0aGlzLCBpbmNpZGVudC5hdHRycywgaW5jaWRlbnQucHJvcHMpKTtcblxuICAgICAgICBfdGhpcy5zZXRVcChpbmNpZGVudCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoRE9NQXdhcmVJbmNpZGVudCwgW3tcbiAgICAgICAga2V5OiAnc2V0VXAnLFxuXG5cbiAgICAgICAgLy8gcHJvcHMgbXVzdCBoYXZlIHRoZSBlbGVtZW50cyBjb2xsZWN0aW9uIGFuZCB0aGUgbWlsbGlzZWNvbmRcbiAgICAgICAgLy8gaWQgaXMgYWxzbyBtYW5kYXRvcnlcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFVwKGluY2lkZW50KSB7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbmFsSW5jaWRlbnQgPSBpbmNpZGVudDtcbiAgICAgICAgICAgIHRoaXMuSW5jaWRlbnRDbGFzcyA9IGluY2lkZW50LmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgdGhpcy50b1Bhc3NUb0VsZW1lbnRJbmNpZGVudHMgPSB7XG4gICAgICAgICAgICAgICAgcGx1Z2luX2NoYW5uZWxfY2xhc3M6IGluY2lkZW50LnBsdWdpbl9jaGFubmVsX2NsYXNzLFxuICAgICAgICAgICAgICAgIG1jX3BsdWdpbl9ucG1fbmFtZTogaW5jaWRlbnQubWNfcGx1Z2luX25wbV9uYW1lXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50SW5jaWRlbnRzQnlNQ0lEID0ge307XG4gICAgICAgICAgICB0aGlzLmNsZWFuUHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNsZWFuUHJvcHMuaWQ7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudHMgPSBBcnJheS5mcm9tKHRoaXMuY29udGV4dC5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRoaXMucHJvcHMuc2VsZWN0b3IpKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUVsZW1lbnRJbmNpZGVudChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3N5c3RvbERpYXN0b2xlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN5c3RvbERpYXN0b2xlKGR1cmF0aW9uRnJhY3Rpb24pIHtcbiAgICAgICAgICAgIF9nZXQoRE9NQXdhcmVJbmNpZGVudC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihET01Bd2FyZUluY2lkZW50LnByb3RvdHlwZSksICdzeXN0b2xEaWFzdG9sZScsIHRoaXMpLmNhbGwodGhpcywgZHVyYXRpb25GcmFjdGlvbik7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbmFsSW5jaWRlbnQucHJvcHMuZHVyYXRpb24gKj0gZHVyYXRpb25GcmFjdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkb20gZ3JvdXBzXG4gICAgICAgICAgICBDYW4gaGF2ZSBvbiB0aGVpciB0aW1lbGluZTpcbiAgICAgICAgICAgIC0gQW4gaW5jaWRlbnQgd2l0aCBubyBhbmltYXRlZEF0dHJzIFxuICAgICAgICAgICAgLSBBbiBhdHRyaWJ1dGUgZ3JvdXAgKHRoaXMgbWV0aG9kIHNob3VsZCBhY3R1YWxseSB0dXJuIGFueSBpbmNpZGVudCB3aXRoIGFuaW1hdGVkQXR0cnMgdG8gb25lKVxuICAgICAgICAgICAgQ2Fu4oCZdCBoYXZlIG9uIHRoZWlyIHRpbWVsaW5lOlxuICAgICAgICAgICAgLSBBIHBsYWluIGdyb3VwXG4gICAgICAgICAgICAtIEFub3RoZXIgZG9tIGdyb3VwXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfcHJlcGFyZUluaWNkZW50Rm9yQWRkaXRpb24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3ByZXBhcmVJbmljZGVudEZvckFkZGl0aW9uKGluY2lkZW50KSB7XG4gICAgICAgICAgICBpZiAoIWluY2lkZW50LmF0dHJzLmhhc093blByb3BlcnR5KCdhbmltYXRlZEF0dHJzJykgJiYgIWluY2lkZW50Lmhhc0luY2lkZW50cykge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBpbmNpZGVudCBpcyBub3QgYSBncm91cCBhbmQgaXQgaGFzIG5vIGFuaW1hdGVkQXR0cnMgcHJvY2VlZCBub3JtYWxseVxuICAgICAgICAgICAgICAgIHJldHVybiBpbmNpZGVudDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5jaWRlbnQuZ3JvdXBUeXBlID09PSBcInBsYWluXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgSW5jaWRlbnQgaXMgYSBwbGFpbiBncm91cCBwcm9jZWVkIG5vcm1hbGx5XG4gICAgICAgICAgICAgICAgaGVscGVyLmVycm9yKFwiZG9tIGdyb3VwcyBjYW4gbm90IGFjY2VwdCBwbGFpbiBncm91cHMgb24gdGhlaXIgdGltZWxpbmVcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluY2lkZW50Lmdyb3VwVHlwZSA9PT0gXCJkb21cIikge1xuICAgICAgICAgICAgICAgIGhlbHBlci5lcnJvcihcImRvbSBncm91cHMgY2FuIG5vdCBhY2NlcHQgb3RoZXIgZG9tIGdyb3VwcyBvbiB0aGVpciB0aW1lbGluZVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byB0dXJuIHRoZSBJbmNpZGVudCB0byBhbiBBdHRyc0F3YXJlSW5jaWRlbnRcbiAgICAgICAgICAgIC8vIGJlZm9yZSBhZGRpbmcgaXQgdG8gdGhlIGdyb3VwXG4gICAgICAgICAgICB2YXIgQXR0cnNBd2FyZUluY2lkZW50ID0gcmVxdWlyZSgnLi9BdHRyaWJ1dGVBd2FyZUluY2lkZW50Jyk7XG4gICAgICAgICAgICB2YXIgdGhlQXR0cnNBd2FyZUluY2lkZW50ID0gbmV3IEF0dHJzQXdhcmVJbmNpZGVudChpbmNpZGVudCk7XG4gICAgICAgICAgICByZXR1cm4gdGhlQXR0cnNBd2FyZUluY2lkZW50O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfY3JlYXRlRWxlbWVudEluY2lkZW50JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50SW5jaWRlbnQoZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIG1jaWQgPSB0aGlzLmNvbnRleHQuZ2V0TUNJRChlbGVtZW50KTtcbiAgICAgICAgICAgIGlmICghbWNpZCkge1xuICAgICAgICAgICAgICAgIG1jaWQgPSBoZWxwZXIuZ2V0QW5JZCh0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuc2V0TUNJRChlbGVtZW50LCBtY2lkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHByb3BzVG9QYXNzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jbGVhblByb3BzKTtcbiAgICAgICAgICAgIHByb3BzVG9QYXNzLnNlbGVjdG9yID0gdGhpcy5jb250ZXh0LmdldEVsZW1lbnRTZWxlY3RvckJ5TUNJRChtY2lkKTsgLy8gJ1tkYXRhLW1vdG9yb2NvcnRleHQyLWlkPVwibWNpZDFcIl0nIHF1ZXJ5U2VsZWN0b3JBbGwoKVxuICAgICAgICAgICAgcHJvcHNUb1Bhc3MubWNpZCA9IG1jaWQ7XG4gICAgICAgICAgICBwcm9wc1RvUGFzcy5pZCA9IHRoaXMuaWQgKyAnXycgKyBtY2lkO1xuICAgICAgICAgICAgcHJvcHNUb1Bhc3MuYXV0b2dlbmVyYXRlZElEID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBlbGVtZW50SW5jaWRlbnQgPSBuZXcgdGhpcy5JbmNpZGVudENsYXNzKHRoaXMuYXR0cnMsIHByb3BzVG9QYXNzKTtcbiAgICAgICAgICAgIGVsZW1lbnRJbmNpZGVudC5wbHVnaW5fY2hhbm5lbF9jbGFzcyA9IHRoaXMudG9QYXNzVG9FbGVtZW50SW5jaWRlbnRzLnBsdWdpbl9jaGFubmVsX2NsYXNzO1xuICAgICAgICAgICAgZWxlbWVudEluY2lkZW50Lm1jX3BsdWdpbl9ucG1fbmFtZSA9IHRoaXMudG9QYXNzVG9FbGVtZW50SW5jaWRlbnRzLm1jX3BsdWdpbl9ucG1fbmFtZTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmFkZEluY2lkZW50KGVsZW1lbnRJbmNpZGVudCwgMCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudEluY2lkZW50c0J5TUNJRFttY2lkXSA9IGVsZW1lbnRJbmNpZGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogZmxhc2hET00gbWV0aG9kIGV4cGVjdHMgdGhlIG5ldyBlbGVtZW50cyBjb2xsZWN0aW9uIGFuZDpcbiAgICAgICAgICogMS4gSWRlbnRpZmllcyB3aGljaCBvZiB0aGUgZXhpc3RpbmcgZWxlbWVudEluY2lkZW50cyBzaG91bGQgZ28gKHRoZSBkb20gZWxlbWVudCBkb2VzIG5vdCBwYXJ0aWNpcGF0ZSBvbiB0aGUgRE9NQXdhcmVHcm91cCBhbnkgbW9yZSlcbiAgICAgICAgICogMi4gSWRlbnRpZmllcyB3aGljaCBlbGVtZW50cyBhcmUgbmV3IGFuZCBhZGQgdGhlaXIgZWxlbWVudEluY2lkZW50IG9uIHRoZSBET01Bd2FyZUdyb3VwXG4gICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9IC0gd2l0aCBrZXlzIGFkZGl0aW9ucyBhbmQgZGVsZXRpb25zIGVhY2ggb2Ygd2hpY2ggaG9sZCBhbiBhcnJheSBvZiBmdW5jdGlvbnMgdGhhdCBtdXN0IGJlXG4gICAgICAgICAqICBleGVjdXRlZCBmb3IgYWRkaW5nIHRoZSBuZXcgZWxlbWVudCBpbmNpZGVudHMgYW5kIGRlbGV0aW5nIHRoZSBlbGVtZW50IGluY2lkZW50cyB0aGF0IGRvIG5vdCBhcHBseSBhbnkgbW9yZVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmbGFzaERPTScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmbGFzaERPTSgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmNvbnRleHQuZ2V0RWxlbWVudHModGhpcy5wcm9wcy5zZWxlY3Rvcik7XG5cbiAgICAgICAgICAgIC8vIGRlbGV0aW9ucyBhbmQgYWRkaXRpb25zIG9mIGVsZW1lbnRJbmNpZGVudHMgdGhhdCBzaG91bGQgdGFrZSBwbGFjZSBhY2NvcmRpbmcgdG8gdGhlIG5ldyBlbGVtZW50c1xuICAgICAgICAgICAgdmFyIGRlbGV0aW9ucyA9IFtdO1xuICAgICAgICAgICAgdmFyIGFkZGl0aW9ucyA9IFtdO1xuXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIGFuIGFycmF5IHRoYXQgd2lsbCBrZWVwIGFsbCBuZXcgZWxlbWVudHMnIGtleXMgdG8gYmUgdXNlZCBsYXRlciBmb3IgaWRlbnRpZnlpbmcgZGVsZXRpb25zXG4gICAgICAgICAgICB2YXIgc3RheWluZ0VsZW1lbnRJbmNpZGVudHMgPSBbXTtcbiAgICAgICAgICAgIC8vIGZpcnN0IGlkZW50aWZ5IGFkZGl0aW9uc1xuXG4gICAgICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChpKSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yIGVhY2ggb2YgdGhlIG5ldyBlbGVtZW50c1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgICAgICAgdmFyIG1jaWQgPSBfdGhpczIuY29udGV4dC5nZXRNQ0lEKGVsZW1lbnQpOyAvLyB0YWtlIGl0cyBtY2lkXG5cbiAgICAgICAgICAgICAgICBpZiAoIW1jaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGVsZW1lbnQgZG9lcyBub3QgaGF2ZSBhbiBtY2lkIHlldCB0aGF0IG1lYW5zIGl0J3MgYSBuZXcgb25lXG4gICAgICAgICAgICAgICAgICAgIHZhciBhZGRpdGlvbiA9IGZ1bmN0aW9uIGFkZGl0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuX2NyZWF0ZUVsZW1lbnRJbmNpZGVudChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25zLnB1c2goYWRkaXRpb24pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIV90aGlzMi5lbGVtZW50SW5jaWRlbnRzQnlNQ0lELmhhc093blByb3BlcnR5KG1jaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgaWYgdGhlIGVsZW1lbnQgaGFzIGFuIG1jaWQgdGhhdCBkb2Vzbid0IGFscmVhZHkgZXhpc3Qgb24gdGhlIGVsZW1lbnRJbmNpZGVudHNcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hZGRpdGlvbiA9IGZ1bmN0aW9uIF9hZGRpdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0Ll9jcmVhdGVFbGVtZW50SW5jaWRlbnQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9ucy5wdXNoKF9hZGRpdGlvbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RheWluZ0VsZW1lbnRJbmNpZGVudHMucHVzaChtY2lkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgX2xvb3AoaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG5leHQgc3RlcCBpcyB0byBjb21wYXJlIHRoZSBlbGVtZW50SW5jaWRlbnRzIHdpdGggdGhlIGV4aXN0aW5nIGVsZW1lbnRzIGtleSB0byBzZWUgd2hpY2ggXG4gICAgICAgICAgICAvLyBhcmUgbWlzc2luZyBmcm9tIHRoZSBuZXcgc2V0IGFuZCBwdXQgdGhlbSBmb3IgZGVsZXRlXG4gICAgICAgICAgICB2YXIgYWxyZWFkeUV4aXN0aW5nRWxlbWVudHNLZXlzID0gT2JqZWN0LmtleXModGhpcy5lbGVtZW50SW5jaWRlbnRzQnlNQ0lEKTtcbiAgICAgICAgICAgIHZhciB1bmRlckRlbGV0aW9uID0gYWxyZWFkeUV4aXN0aW5nRWxlbWVudHNLZXlzLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXlpbmdFbGVtZW50SW5jaWRlbnRzLmluZGV4T2Yoa2V5KSA8IDA7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMihpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlbGV0aW9uID0gZnVuY3Rpb24gZGVsZXRpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQucmVtb3ZlSW5jaWRlbnQodGhhdC5lbGVtZW50SW5jaWRlbnRzQnlNQ0lEW3VuZGVyRGVsZXRpb25baV1dLmlkLCB7IHByZXZlbnRTbGlwOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhhdC5lbGVtZW50SW5jaWRlbnRzQnlNQ0lEW3RoYXQuZWxlbWVudEluY2lkZW50c0J5TUNJRFt1bmRlckRlbGV0aW9uW2ldXS5pZF07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBkZWxldGlvbnMucHVzaChkZWxldGlvbik7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVuZGVyRGVsZXRpb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBfbG9vcDIoaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmYWlsZWRBZGRpdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWRkaXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFkZGl0aW9uUmVzdWx0ID0gYWRkaXRpb25zW2ldKCk7XG4gICAgICAgICAgICAgICAgaWYgKGFkZGl0aW9uUmVzdWx0LnJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZmFpbGVkQWRkaXRpb25zLnB1c2goYWRkaXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGRlbGV0aW9ucy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBkZWxldGlvbnNbX2ldKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZmFpbGVkQWRkaXRpb25zOiBmYWlsZWRBZGRpdGlvbnNcblxuICAgICAgICAgICAgICAgIC8vIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLy8gICAgIGFkZGl0aW9uczogYWRkaXRpb25zLFxuICAgICAgICAgICAgICAgIC8vICAgICBkZWxldGlvbnM6IGRlbGV0aW9uc1xuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2F0dHJpYnV0ZXNDaGFuZ2UnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXR0cmlidXRlc0NoYW5nZShuZXdBdHRycykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluY2lkZW50czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBleGVjdXRlIGF0dHJpYnV0ZSBjaGFuZ2UgYnkgcGFzc2luZyBkb3duIHRoZSBjb21tYW5kXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2V4cG9ydFN0YXRlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGV4cG9ydFN0YXRlKCkge1xuICAgICAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KCd1bnByb2Nlc3NlZCcpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzLnVucHJvY2Vzc2VkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2dldChET01Bd2FyZUluY2lkZW50LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKERPTUF3YXJlSW5jaWRlbnQucHJvdG90eXBlKSwgJ2V4cG9ydFN0YXRlJywgdGhpcykuY2FsbCh0aGlzLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxJbmNpZGVudC5leHBvcnRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9yaWdpbmFsSW5jaWRlbnQuZXhwb3J0U3RhdGUoKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ3JvdXBUeXBlJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJkb21cIjtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBET01Bd2FyZUluY2lkZW50O1xufShHcm91cCk7XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NQXdhcmVJbmNpZGVudDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_responsiveness/DOMAwareIncident.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/configuration/_CONST.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/configuration/_CONST.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = {\n    'atTheEndOfTheGroup': {\n        value: 'end',\n        purpose: 'It\\'s used on Groups and more specifically on the addIncident (and thus also on addPassiveIncident) methods. It \\n            implies that the millisecond for the new incident to be added should be at the end of the Group'\n    }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvbmZpZ3VyYXRpb24vX0NPTlNULmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9jb25maWd1cmF0aW9uL19DT05TVC5qcz9hMDY2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgJ2F0VGhlRW5kT2ZUaGVHcm91cCc6IHtcbiAgICAgICAgdmFsdWU6ICdlbmQnLFxuICAgICAgICBwdXJwb3NlOiAnSXRcXCdzIHVzZWQgb24gR3JvdXBzIGFuZCBtb3JlIHNwZWNpZmljYWxseSBvbiB0aGUgYWRkSW5jaWRlbnQgKGFuZCB0aHVzIGFsc28gb24gYWRkUGFzc2l2ZUluY2lkZW50KSBtZXRob2RzLiBJdCBcXG4gICAgICAgICAgICBpbXBsaWVzIHRoYXQgdGhlIG1pbGxpc2Vjb25kIGZvciB0aGUgbmV3IGluY2lkZW50IHRvIGJlIGFkZGVkIHNob3VsZCBiZSBhdCB0aGUgZW5kIG9mIHRoZSBHcm91cCdcbiAgICB9XG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/configuration/_CONST.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/configuration/allowedStateChanges.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/configuration/allowedStateChanges.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Helper = __webpack_require__(/*! ../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\n\nvar allowedStateChanges = {\n    // from which states an Incident can become one of the:\n\n    idle: {\n        forwards: ['transitional'], // only from transitional\n        backwards: ['transitional', 'playing']\n    },\n    transitional: {\n        forwards: ['idle', 'playing', 'waiting', 'sceneBlockingWaiting', 'clipBlockingWaiting', 'completed', 'blocked'],\n        backwards: ['idle', 'playing', 'waiting', 'sceneBlockingWaiting', 'clipBlockingWaiting', 'completed', 'blocked']\n    },\n    playing: {\n        forwards: ['idle', 'waiting', 'sceneBlockingWaiting', 'clipBlockingWaiting', 'blocked'],\n        backwards: ['completed', 'waiting', 'sceneBlockingWaiting', 'clipBlockingWaiting', 'blocked']\n    },\n    waiting: {\n        forwards: ['playing', 'blocked', 'transitional'],\n        backwards: ['playing', 'blocked', 'transitional']\n    },\n    sceneBlockingWaiting: {\n        forwards: ['playing', 'waiting', 'blocked'],\n        backwards: ['playing', 'waiting', 'blocked']\n    },\n    clipBlockingWaiting: {\n        forwards: ['playing', 'waiting', 'blocked'],\n        backwards: ['playing', 'waiting', 'blocked']\n    },\n    completed: {\n        forwards: ['transitional', 'playing'],\n        backwards: ['transitional']\n    },\n    blocked: {\n        forwards: ['transitional', 'playing', 'waiting', 'sceneBlockingWaiting'],\n        backwards: ['transitional', 'playing', 'waiting', 'sceneBlockingWaiting']\n    }\n};\n\nvar timePausingStates = ['blocked', 'waiting', 'sceneBlockingWaiting', 'clipBlockingWaiting'];\n\nvar checkTransition = function checkTransition(oldState, newState, direction) {\n    if (!allowedStateChanges.hasOwnProperty(oldState)) {\n        helper.error('The state ' + oldState + ' is not recognised as one of the supported Incident states');\n        return false;\n    } else if (!allowedStateChanges.hasOwnProperty(newState)) {\n        helper.error('The state ' + newState + ' is not recognised as one of the supported Incident states');\n        return false;\n    }\n\n    if (allowedStateChanges[newState][direction].indexOf(oldState) >= 0) {\n        return true;\n    } else {\n        // helper.error('The transition from ' + oldState + ' to ' + newState + ' is not allowed');\n        return false;\n    }\n};\n\nvar isTimePausingState = function isTimePausingState(state) {\n    return timePausingStates.indexOf(state) >= 0;\n};\n\nmodule.exports = { checkTransition: checkTransition, isTimePausingState: isTimePausingState };//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvbmZpZ3VyYXRpb24vYWxsb3dlZFN0YXRlQ2hhbmdlcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2Rpc3QvY29uZmlndXJhdGlvbi9hbGxvd2VkU3RhdGVDaGFuZ2VzLmpzPzNhNjUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgSGVscGVyID0gcmVxdWlyZSgnLi4vX2NvcmVVdGlscy9IZWxwZXInKTtcbnZhciBoZWxwZXIgPSBuZXcgSGVscGVyKCk7XG5cbnZhciBhbGxvd2VkU3RhdGVDaGFuZ2VzID0ge1xuICAgIC8vIGZyb20gd2hpY2ggc3RhdGVzIGFuIEluY2lkZW50IGNhbiBiZWNvbWUgb25lIG9mIHRoZTpcblxuICAgIGlkbGU6IHtcbiAgICAgICAgZm9yd2FyZHM6IFsndHJhbnNpdGlvbmFsJ10sIC8vIG9ubHkgZnJvbSB0cmFuc2l0aW9uYWxcbiAgICAgICAgYmFja3dhcmRzOiBbJ3RyYW5zaXRpb25hbCcsICdwbGF5aW5nJ11cbiAgICB9LFxuICAgIHRyYW5zaXRpb25hbDoge1xuICAgICAgICBmb3J3YXJkczogWydpZGxlJywgJ3BsYXlpbmcnLCAnd2FpdGluZycsICdzY2VuZUJsb2NraW5nV2FpdGluZycsICdjbGlwQmxvY2tpbmdXYWl0aW5nJywgJ2NvbXBsZXRlZCcsICdibG9ja2VkJ10sXG4gICAgICAgIGJhY2t3YXJkczogWydpZGxlJywgJ3BsYXlpbmcnLCAnd2FpdGluZycsICdzY2VuZUJsb2NraW5nV2FpdGluZycsICdjbGlwQmxvY2tpbmdXYWl0aW5nJywgJ2NvbXBsZXRlZCcsICdibG9ja2VkJ11cbiAgICB9LFxuICAgIHBsYXlpbmc6IHtcbiAgICAgICAgZm9yd2FyZHM6IFsnaWRsZScsICd3YWl0aW5nJywgJ3NjZW5lQmxvY2tpbmdXYWl0aW5nJywgJ2NsaXBCbG9ja2luZ1dhaXRpbmcnLCAnYmxvY2tlZCddLFxuICAgICAgICBiYWNrd2FyZHM6IFsnY29tcGxldGVkJywgJ3dhaXRpbmcnLCAnc2NlbmVCbG9ja2luZ1dhaXRpbmcnLCAnY2xpcEJsb2NraW5nV2FpdGluZycsICdibG9ja2VkJ11cbiAgICB9LFxuICAgIHdhaXRpbmc6IHtcbiAgICAgICAgZm9yd2FyZHM6IFsncGxheWluZycsICdibG9ja2VkJywgJ3RyYW5zaXRpb25hbCddLFxuICAgICAgICBiYWNrd2FyZHM6IFsncGxheWluZycsICdibG9ja2VkJywgJ3RyYW5zaXRpb25hbCddXG4gICAgfSxcbiAgICBzY2VuZUJsb2NraW5nV2FpdGluZzoge1xuICAgICAgICBmb3J3YXJkczogWydwbGF5aW5nJywgJ3dhaXRpbmcnLCAnYmxvY2tlZCddLFxuICAgICAgICBiYWNrd2FyZHM6IFsncGxheWluZycsICd3YWl0aW5nJywgJ2Jsb2NrZWQnXVxuICAgIH0sXG4gICAgY2xpcEJsb2NraW5nV2FpdGluZzoge1xuICAgICAgICBmb3J3YXJkczogWydwbGF5aW5nJywgJ3dhaXRpbmcnLCAnYmxvY2tlZCddLFxuICAgICAgICBiYWNrd2FyZHM6IFsncGxheWluZycsICd3YWl0aW5nJywgJ2Jsb2NrZWQnXVxuICAgIH0sXG4gICAgY29tcGxldGVkOiB7XG4gICAgICAgIGZvcndhcmRzOiBbJ3RyYW5zaXRpb25hbCcsICdwbGF5aW5nJ10sXG4gICAgICAgIGJhY2t3YXJkczogWyd0cmFuc2l0aW9uYWwnXVxuICAgIH0sXG4gICAgYmxvY2tlZDoge1xuICAgICAgICBmb3J3YXJkczogWyd0cmFuc2l0aW9uYWwnLCAncGxheWluZycsICd3YWl0aW5nJywgJ3NjZW5lQmxvY2tpbmdXYWl0aW5nJ10sXG4gICAgICAgIGJhY2t3YXJkczogWyd0cmFuc2l0aW9uYWwnLCAncGxheWluZycsICd3YWl0aW5nJywgJ3NjZW5lQmxvY2tpbmdXYWl0aW5nJ11cbiAgICB9XG59O1xuXG52YXIgdGltZVBhdXNpbmdTdGF0ZXMgPSBbJ2Jsb2NrZWQnLCAnd2FpdGluZycsICdzY2VuZUJsb2NraW5nV2FpdGluZycsICdjbGlwQmxvY2tpbmdXYWl0aW5nJ107XG5cbnZhciBjaGVja1RyYW5zaXRpb24gPSBmdW5jdGlvbiBjaGVja1RyYW5zaXRpb24ob2xkU3RhdGUsIG5ld1N0YXRlLCBkaXJlY3Rpb24pIHtcbiAgICBpZiAoIWFsbG93ZWRTdGF0ZUNoYW5nZXMuaGFzT3duUHJvcGVydHkob2xkU3RhdGUpKSB7XG4gICAgICAgIGhlbHBlci5lcnJvcignVGhlIHN0YXRlICcgKyBvbGRTdGF0ZSArICcgaXMgbm90IHJlY29nbmlzZWQgYXMgb25lIG9mIHRoZSBzdXBwb3J0ZWQgSW5jaWRlbnQgc3RhdGVzJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKCFhbGxvd2VkU3RhdGVDaGFuZ2VzLmhhc093blByb3BlcnR5KG5ld1N0YXRlKSkge1xuICAgICAgICBoZWxwZXIuZXJyb3IoJ1RoZSBzdGF0ZSAnICsgbmV3U3RhdGUgKyAnIGlzIG5vdCByZWNvZ25pc2VkIGFzIG9uZSBvZiB0aGUgc3VwcG9ydGVkIEluY2lkZW50IHN0YXRlcycpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGFsbG93ZWRTdGF0ZUNoYW5nZXNbbmV3U3RhdGVdW2RpcmVjdGlvbl0uaW5kZXhPZihvbGRTdGF0ZSkgPj0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBoZWxwZXIuZXJyb3IoJ1RoZSB0cmFuc2l0aW9uIGZyb20gJyArIG9sZFN0YXRlICsgJyB0byAnICsgbmV3U3RhdGUgKyAnIGlzIG5vdCBhbGxvd2VkJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuXG52YXIgaXNUaW1lUGF1c2luZ1N0YXRlID0gZnVuY3Rpb24gaXNUaW1lUGF1c2luZ1N0YXRlKHN0YXRlKSB7XG4gICAgcmV0dXJuIHRpbWVQYXVzaW5nU3RhdGVzLmluZGV4T2Yoc3RhdGUpID49IDA7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHsgY2hlY2tUcmFuc2l0aW9uOiBjaGVja1RyYW5zaXRpb24sIGlzVGltZVBhdXNpbmdTdGF0ZTogaXNUaW1lUGF1c2luZ1N0YXRlIH07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/configuration/allowedStateChanges.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/*\nknown events:\n- state-change / meta: the name of the new state\n- attribute-rejection / meta: animationID, attributes\n- animation-rejection / meta: animationID\n- conflicts-on-edit\n*/\n\nvar conf = {\n    keyframe_sec_key: 'sec_',\n    elements_data_attribute_name: 'data-motorcortex2-id',\n    selfContainedContextHandler: 'closed',\n    getMillisecondFromKeyframeKey: function getMillisecondFromKeyframeKey(keyframeKey) {\n        return parseInt(keyframeKey.slice(conf.keyframe_sec_key.length));\n    },\n    logTypes: [{\n        key: 'info',\n        style: 'color: #666;',\n        level: 5\n    }, {\n        key: 'notice',\n        style: 'background: rgba(0, 0, 0, 0.8); color:white; padding:8px;',\n        level: 4\n    }, {\n        key: 'warning',\n        style: 'color: black; background: orange;',\n        level: 2\n    }, {\n        key: 'error',\n        style: 'color: black; background: red;',\n        level: 1\n    }]\n};\n\nmodule.exports = conf;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvbmZpZ3VyYXRpb24vZ2VuZXJhbENvbmYuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvbmZpZ3VyYXRpb24vZ2VuZXJhbENvbmYuanM/MWUzOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qXG5rbm93biBldmVudHM6XG4tIHN0YXRlLWNoYW5nZSAvIG1ldGE6IHRoZSBuYW1lIG9mIHRoZSBuZXcgc3RhdGVcbi0gYXR0cmlidXRlLXJlamVjdGlvbiAvIG1ldGE6IGFuaW1hdGlvbklELCBhdHRyaWJ1dGVzXG4tIGFuaW1hdGlvbi1yZWplY3Rpb24gLyBtZXRhOiBhbmltYXRpb25JRFxuLSBjb25mbGljdHMtb24tZWRpdFxuKi9cblxudmFyIGNvbmYgPSB7XG4gICAga2V5ZnJhbWVfc2VjX2tleTogJ3NlY18nLFxuICAgIGVsZW1lbnRzX2RhdGFfYXR0cmlidXRlX25hbWU6ICdkYXRhLW1vdG9yY29ydGV4Mi1pZCcsXG4gICAgc2VsZkNvbnRhaW5lZENvbnRleHRIYW5kbGVyOiAnY2xvc2VkJyxcbiAgICBnZXRNaWxsaXNlY29uZEZyb21LZXlmcmFtZUtleTogZnVuY3Rpb24gZ2V0TWlsbGlzZWNvbmRGcm9tS2V5ZnJhbWVLZXkoa2V5ZnJhbWVLZXkpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGtleWZyYW1lS2V5LnNsaWNlKGNvbmYua2V5ZnJhbWVfc2VjX2tleS5sZW5ndGgpKTtcbiAgICB9LFxuICAgIGxvZ1R5cGVzOiBbe1xuICAgICAgICBrZXk6ICdpbmZvJyxcbiAgICAgICAgc3R5bGU6ICdjb2xvcjogIzY2NjsnLFxuICAgICAgICBsZXZlbDogNVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbm90aWNlJyxcbiAgICAgICAgc3R5bGU6ICdiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuOCk7IGNvbG9yOndoaXRlOyBwYWRkaW5nOjhweDsnLFxuICAgICAgICBsZXZlbDogNFxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnd2FybmluZycsXG4gICAgICAgIHN0eWxlOiAnY29sb3I6IGJsYWNrOyBiYWNrZ3JvdW5kOiBvcmFuZ2U7JyxcbiAgICAgICAgbGV2ZWw6IDJcbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Vycm9yJyxcbiAgICAgICAgc3R5bGU6ICdjb2xvcjogYmxhY2s7IGJhY2tncm91bmQ6IHJlZDsnLFxuICAgICAgICBsZXZlbDogMVxuICAgIH1dXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbmY7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/configuration/pipesConf.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/configuration/pipesConf.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = {\n    _BLOCKING_WAITING: \"motor-cortex-js.blocking-waiting\",\n    _UNBLOCK_WAITING: \"motor-cortex-js.unblock-waiting\",\n    _GAIN_CHANGE: \"motor-cortex-js.gain-change\",\n    _CLIP_EDITING_STATUS: \"motor-cortex.js.clip-editing-status\"\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvbmZpZ3VyYXRpb24vcGlwZXNDb25mLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9jb25maWd1cmF0aW9uL3BpcGVzQ29uZi5qcz84OTM3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBfQkxPQ0tJTkdfV0FJVElORzogXCJtb3Rvci1jb3J0ZXgtanMuYmxvY2tpbmctd2FpdGluZ1wiLFxuICAgIF9VTkJMT0NLX1dBSVRJTkc6IFwibW90b3ItY29ydGV4LWpzLnVuYmxvY2std2FpdGluZ1wiLFxuICAgIF9HQUlOX0NIQU5HRTogXCJtb3Rvci1jb3J0ZXgtanMuZ2Fpbi1jaGFuZ2VcIixcbiAgICBfQ0xJUF9FRElUSU5HX1NUQVRVUzogXCJtb3Rvci1jb3J0ZXguanMuY2xpcC1lZGl0aW5nLXN0YXR1c1wiXG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/configuration/pipesConf.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/Channel.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/Channel.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Helper = __webpack_require__(/*! ../../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar conf = __webpack_require__(/*! ../../configuration/generalConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\nvar Channel = __webpack_require__(/*! ../../_Channels/Channel */ \"./node_modules/@kissmybutton/motorcortex/dist/_Channels/Channel.js\");\nvar _sortBy = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.sortby/index.js */ \"./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.sortby/index.js\");\nvar _filter = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.filter/index.js */ \"./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.filter/index.js\");\n\nvar PIChannel = function (_Channel) {\n    _inherits(PIChannel, _Channel);\n\n    function PIChannel() {\n        _classCallCheck(this, PIChannel);\n\n        return _possibleConstructorReturn(this, (PIChannel.__proto__ || Object.getPrototypeOf(PIChannel)).apply(this, arguments));\n    }\n\n    _createClass(PIChannel, [{\n        key: 'onInitialise',\n\n        /*\n        this.incidents is a collection of {incident, id, millisecond} objects always kept in order\n            from lower to higher millisecond\n        this.incidetnsById is an index of the incidents kept by id (this.incidents[incident-id] = Incident)\n        */\n        value: function onInitialise() {\n            this.incidents = [];\n            this.incidentsById = {};\n        }\n    }, {\n        key: 'slipToLaneForwards',\n        value: function slipToLaneForwards(currentMillisecond, millisecond) {\n            var participatinIncidents = _filter(this.incidents, function (laneItem) {\n                return laneItem.millisecond > currentMillisecond && laneItem.millisecond <= millisecond;\n            });\n            // helper.log(`participating incidents: `, participatinIncidents);\n\n            for (var i = 0; i < participatinIncidents.length; i++) {\n                participatinIncidents[i].incident.command.forwards();\n            }\n\n            // this.runTimeInfo.currentMillisecond = millisecond;\n        }\n    }, {\n        key: 'slipToLaneBackwards',\n        value: function slipToLaneBackwards(currentMillisecond, millisecond) {\n            // helper.log(`participating incidents: `, participatinIncidents);\n            var participatinIncidents = _filter(this.incidents, function (laneItem) {\n                return laneItem.millisecond > millisecond && laneItem.millisecond <= currentMillisecond;\n            });\n\n            for (var i = participatinIncidents.length - 1; i >= 0; i--) {\n                participatinIncidents[i].incident.command.backwards();\n            }\n\n            // this.runTimeInfo.currentMillisecond = millisecond;\n        }\n\n        /**\n         * On this method the user defines the specific rules that apply on the plugin itself and on the Incidents of the plugin itself\n         * The method should either return {result: true} or {result: false, errors:[{error-object}]}, where error-object has the structure:\n         *  {\n                incident: // reference to the Incident object that has bee discarded\n                error: // text\n            }\n        * @param {array} incidents - a colleciton of all incidents to be added on the form:\n        *\n            {\n                id\n                millisecond\n                incident\n            }\n        * @returns {object} -\n        * either:\n            {\n                result:true,\n                execute: // a function that when executed it will add the Incidents on the Channels\n            }\n            or\n            {\n                result: false,\n                errors\n            }\n        */\n\n    }, {\n        key: 'checkAddition',\n        value: function checkAddition(incidents) {\n            var errors = [];\n            var candidateIncidentsById = {};\n\n            for (var i = 0; i < incidents.length; i++) {\n                candidateIncidentsById[incidents[i].id] = incidents[i].incident;\n                if (this.incidentsById.hasOwnProperty(incidents[i].id)) {\n                    helper.error('Incident with the id ' + incidents[i].id + ' already exists. Addition is rejected.');\n                    errors.push({\n                        type: 'Already existing id',\n                        meta: {\n                            id: incidents[i].id\n                        }\n                    });\n                }\n            }\n\n            if (errors.length > 0) {\n                return {\n                    result: false,\n                    errors: errors\n                };\n            }\n\n            var that = this;\n            var exec = function exec() {\n                that.incidentsById = Object.assign(that.incidentsById, candidateIncidentsById);\n                that.incidents = that.incidents.concat(incidents);\n                that.incidents = _sortBy(that.incidents, [function (laneItem) {\n                    return laneItem.millisecond;\n                }]);\n                that.slipToLaneForwards(0, that.runTimeInfo.currentMillisecond);\n            };\n\n            return { result: true, execute: exec };\n        }\n\n        /**\n        @param {array} incidentsArray - A collection of the Incidetns to get edited in the form:\n        {\n            id\n            millisecond\n            incident\n        }\n        @param {int} millisecondsDelta- the delta of the star point of the provided incidents\n        */\n\n    }, {\n        key: 'checkEdit',\n        value: function checkEdit(incidentsArray, millisecondsDelta) {\n            var that = this;\n            var exec = function exec() {\n                for (var i = 0; i < incidentsArray.length; i++) {\n                    for (var j = 0; j < that.incidents.length; j++) {\n                        if (that.incidents[j].id === incidentsArray[i].id) {\n                            that.incidents[j].millisecond += millisecondsDelta;\n                            break;\n                        }\n                    }\n                }\n\n                that.incidents = _sortBy(that.incidents, [function (laneItem) {\n                    return laneItem.millisecond;\n                }]);\n\n                that.slipToLaneForwards(0, that.runTimeInfo.currentMillisecond);\n            };\n\n            return { result: true, execute: exec };\n        }\n    }, {\n        key: 'checkDelete',\n        value: function checkDelete(incidentsArray) {\n            var that = this;\n            var incidentIds = [];\n            for (var i = 0; i < incidentsArray.length; i++) {\n                incidentIds.push(incidentsArray[i].id);\n            }\n\n            var exec = function exec() {\n                var newIncidents = _filter(that.incidents, function (incident) {\n                    return incidentIds.indexOf(incident.id) === -1;\n                });\n\n                that.incidents = newIncidents;\n                for (var _i = 0; _i < incidentIds.length; _i++) {\n                    delete that.incidentsById[incidentIds[_i]];\n                }\n\n                that.slipToLaneForwards(0, that.runTimeInfo.currentMillisecond);\n            };\n\n            return { result: true, execute: exec };\n        }\n\n        /**\n        * @param {array} incidents - [{id, start, end, startDelta}]\n        */\n\n    }, {\n        key: 'checkResizedIncidents',\n        value: function checkResizedIncidents(incidents) {\n            var that = this;\n            var exec = function exec() {\n                for (var i = 0; i < incidents.length; i++) {\n                    for (var j = 0; j < that.incidents.length; j++) {\n                        if (that.incidents[j].id === incidents[i].id) {\n                            that.incidents[j].millisecond += incidents[i].startDelta;\n                            break;\n                        }\n                    }\n                }\n\n                that.incidents = _sortBy(that.incidents, [function (laneItem) {\n                    return laneItem.millisecond;\n                }]);\n\n                that.slipToLaneForwards(0, that.runTimeInfo.currentMillisecond);\n            };\n\n            return { result: true, execute: exec };\n        }\n\n        /**\n         @param {int} from - the millisecond to start from\n         @param {int} to - the millisecond to go to\n         */\n\n    }, {\n        key: 'moveTo',\n        value: function moveTo(from, to) {\n            if (from < to) {\n                // helper.log(`slipping to lane frowards from ${from} to ${to}`);\n                this.slipToLaneForwards(from, to);\n            } else if (from >= to) {\n                // helper.log(`slipping to lane backwards from ${from} to ${to}`);\n                this.slipToLaneBackwards(from, to);\n            }\n        }\n    }]);\n\n    return PIChannel;\n}(Channel);\n\nmodule.exports = PIChannel;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvcmVQbHVnaW5zL1Byb2dyYW1tYXRpY0luY2lkZW50cy9DaGFubmVsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9jb3JlUGx1Z2lucy9Qcm9ncmFtbWF0aWNJbmNpZGVudHMvQ2hhbm5lbC5qcz9mZmFmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgSGVscGVyID0gcmVxdWlyZSgnLi4vLi4vX2NvcmVVdGlscy9IZWxwZXInKTtcbnZhciBoZWxwZXIgPSBuZXcgSGVscGVyKCk7XG52YXIgY29uZiA9IHJlcXVpcmUoJy4uLy4uL2NvbmZpZ3VyYXRpb24vZ2VuZXJhbENvbmYnKTtcbnZhciBDaGFubmVsID0gcmVxdWlyZSgnLi4vLi4vX0NoYW5uZWxzL0NoYW5uZWwnKTtcbnZhciBfc29ydEJ5ID0gcmVxdWlyZSgnLi4vLi4vLi4vbG9kYXNoLWN1c3RvbS1idWlsZC9tb2R1bGFyaXplL2xvZGFzaC5zb3J0YnkvaW5kZXguanMnKTtcbnZhciBfZmlsdGVyID0gcmVxdWlyZSgnLi4vLi4vLi4vbG9kYXNoLWN1c3RvbS1idWlsZC9tb2R1bGFyaXplL2xvZGFzaC5maWx0ZXIvaW5kZXguanMnKTtcblxudmFyIFBJQ2hhbm5lbCA9IGZ1bmN0aW9uIChfQ2hhbm5lbCkge1xuICAgIF9pbmhlcml0cyhQSUNoYW5uZWwsIF9DaGFubmVsKTtcblxuICAgIGZ1bmN0aW9uIFBJQ2hhbm5lbCgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBJQ2hhbm5lbCk7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChQSUNoYW5uZWwuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihQSUNoYW5uZWwpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoUElDaGFubmVsLCBbe1xuICAgICAgICBrZXk6ICdvbkluaXRpYWxpc2UnLFxuXG4gICAgICAgIC8qXG4gICAgICAgIHRoaXMuaW5jaWRlbnRzIGlzIGEgY29sbGVjdGlvbiBvZiB7aW5jaWRlbnQsIGlkLCBtaWxsaXNlY29uZH0gb2JqZWN0cyBhbHdheXMga2VwdCBpbiBvcmRlclxuICAgICAgICAgICAgZnJvbSBsb3dlciB0byBoaWdoZXIgbWlsbGlzZWNvbmRcbiAgICAgICAgdGhpcy5pbmNpZGV0bnNCeUlkIGlzIGFuIGluZGV4IG9mIHRoZSBpbmNpZGVudHMga2VwdCBieSBpZCAodGhpcy5pbmNpZGVudHNbaW5jaWRlbnQtaWRdID0gSW5jaWRlbnQpXG4gICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkluaXRpYWxpc2UoKSB7XG4gICAgICAgICAgICB0aGlzLmluY2lkZW50cyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5pbmNpZGVudHNCeUlkID0ge307XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NsaXBUb0xhbmVGb3J3YXJkcycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzbGlwVG9MYW5lRm9yd2FyZHMoY3VycmVudE1pbGxpc2Vjb25kLCBtaWxsaXNlY29uZCkge1xuICAgICAgICAgICAgdmFyIHBhcnRpY2lwYXRpbkluY2lkZW50cyA9IF9maWx0ZXIodGhpcy5pbmNpZGVudHMsIGZ1bmN0aW9uIChsYW5lSXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsYW5lSXRlbS5taWxsaXNlY29uZCA+IGN1cnJlbnRNaWxsaXNlY29uZCAmJiBsYW5lSXRlbS5taWxsaXNlY29uZCA8PSBtaWxsaXNlY29uZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gaGVscGVyLmxvZyhgcGFydGljaXBhdGluZyBpbmNpZGVudHM6IGAsIHBhcnRpY2lwYXRpbkluY2lkZW50cyk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydGljaXBhdGluSW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGFydGljaXBhdGluSW5jaWRlbnRzW2ldLmluY2lkZW50LmNvbW1hbmQuZm9yd2FyZHMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQgPSBtaWxsaXNlY29uZDtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2xpcFRvTGFuZUJhY2t3YXJkcycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzbGlwVG9MYW5lQmFja3dhcmRzKGN1cnJlbnRNaWxsaXNlY29uZCwgbWlsbGlzZWNvbmQpIHtcbiAgICAgICAgICAgIC8vIGhlbHBlci5sb2coYHBhcnRpY2lwYXRpbmcgaW5jaWRlbnRzOiBgLCBwYXJ0aWNpcGF0aW5JbmNpZGVudHMpO1xuICAgICAgICAgICAgdmFyIHBhcnRpY2lwYXRpbkluY2lkZW50cyA9IF9maWx0ZXIodGhpcy5pbmNpZGVudHMsIGZ1bmN0aW9uIChsYW5lSXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsYW5lSXRlbS5taWxsaXNlY29uZCA+IG1pbGxpc2Vjb25kICYmIGxhbmVJdGVtLm1pbGxpc2Vjb25kIDw9IGN1cnJlbnRNaWxsaXNlY29uZDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gcGFydGljaXBhdGluSW5jaWRlbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgcGFydGljaXBhdGluSW5jaWRlbnRzW2ldLmluY2lkZW50LmNvbW1hbmQuYmFja3dhcmRzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kID0gbWlsbGlzZWNvbmQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogT24gdGhpcyBtZXRob2QgdGhlIHVzZXIgZGVmaW5lcyB0aGUgc3BlY2lmaWMgcnVsZXMgdGhhdCBhcHBseSBvbiB0aGUgcGx1Z2luIGl0c2VsZiBhbmQgb24gdGhlIEluY2lkZW50cyBvZiB0aGUgcGx1Z2luIGl0c2VsZlxuICAgICAgICAgKiBUaGUgbWV0aG9kIHNob3VsZCBlaXRoZXIgcmV0dXJuIHtyZXN1bHQ6IHRydWV9IG9yIHtyZXN1bHQ6IGZhbHNlLCBlcnJvcnM6W3tlcnJvci1vYmplY3R9XX0sIHdoZXJlIGVycm9yLW9iamVjdCBoYXMgdGhlIHN0cnVjdHVyZTpcbiAgICAgICAgICogIHtcbiAgICAgICAgICAgICAgICBpbmNpZGVudDogLy8gcmVmZXJlbmNlIHRvIHRoZSBJbmNpZGVudCBvYmplY3QgdGhhdCBoYXMgYmVlIGRpc2NhcmRlZFxuICAgICAgICAgICAgICAgIGVycm9yOiAvLyB0ZXh0XG4gICAgICAgICAgICB9XG4gICAgICAgICogQHBhcmFtIHthcnJheX0gaW5jaWRlbnRzIC0gYSBjb2xsZWNpdG9uIG9mIGFsbCBpbmNpZGVudHMgdG8gYmUgYWRkZWQgb24gdGhlIGZvcm06XG4gICAgICAgICpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZFxuICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgICAgaW5jaWRlbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSAtXG4gICAgICAgICogZWl0aGVyOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlc3VsdDp0cnVlLFxuICAgICAgICAgICAgICAgIGV4ZWN1dGU6IC8vIGEgZnVuY3Rpb24gdGhhdCB3aGVuIGV4ZWN1dGVkIGl0IHdpbGwgYWRkIHRoZSBJbmNpZGVudHMgb24gdGhlIENoYW5uZWxzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvclxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3JzXG4gICAgICAgICAgICB9XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NoZWNrQWRkaXRpb24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tBZGRpdGlvbihpbmNpZGVudHMpIHtcbiAgICAgICAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIHZhciBjYW5kaWRhdGVJbmNpZGVudHNCeUlkID0ge307XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlSW5jaWRlbnRzQnlJZFtpbmNpZGVudHNbaV0uaWRdID0gaW5jaWRlbnRzW2ldLmluY2lkZW50O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluY2lkZW50c0J5SWQuaGFzT3duUHJvcGVydHkoaW5jaWRlbnRzW2ldLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICBoZWxwZXIuZXJyb3IoJ0luY2lkZW50IHdpdGggdGhlIGlkICcgKyBpbmNpZGVudHNbaV0uaWQgKyAnIGFscmVhZHkgZXhpc3RzLiBBZGRpdGlvbiBpcyByZWplY3RlZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0FscmVhZHkgZXhpc3RpbmcgaWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpbmNpZGVudHNbaV0uaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IGVycm9yc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHZhciBleGVjID0gZnVuY3Rpb24gZXhlYygpIHtcbiAgICAgICAgICAgICAgICB0aGF0LmluY2lkZW50c0J5SWQgPSBPYmplY3QuYXNzaWduKHRoYXQuaW5jaWRlbnRzQnlJZCwgY2FuZGlkYXRlSW5jaWRlbnRzQnlJZCk7XG4gICAgICAgICAgICAgICAgdGhhdC5pbmNpZGVudHMgPSB0aGF0LmluY2lkZW50cy5jb25jYXQoaW5jaWRlbnRzKTtcbiAgICAgICAgICAgICAgICB0aGF0LmluY2lkZW50cyA9IF9zb3J0QnkodGhhdC5pbmNpZGVudHMsIFtmdW5jdGlvbiAobGFuZUl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhbmVJdGVtLm1pbGxpc2Vjb25kO1xuICAgICAgICAgICAgICAgIH1dKTtcbiAgICAgICAgICAgICAgICB0aGF0LnNsaXBUb0xhbmVGb3J3YXJkcygwLCB0aGF0LnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IHRydWUsIGV4ZWN1dGU6IGV4ZWMgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICBAcGFyYW0ge2FycmF5fSBpbmNpZGVudHNBcnJheSAtIEEgY29sbGVjdGlvbiBvZiB0aGUgSW5jaWRldG5zIHRvIGdldCBlZGl0ZWQgaW4gdGhlIGZvcm06XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlkXG4gICAgICAgICAgICBtaWxsaXNlY29uZFxuICAgICAgICAgICAgaW5jaWRlbnRcbiAgICAgICAgfVxuICAgICAgICBAcGFyYW0ge2ludH0gbWlsbGlzZWNvbmRzRGVsdGEtIHRoZSBkZWx0YSBvZiB0aGUgc3RhciBwb2ludCBvZiB0aGUgcHJvdmlkZWQgaW5jaWRlbnRzXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NoZWNrRWRpdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0VkaXQoaW5jaWRlbnRzQXJyYXksIG1pbGxpc2Vjb25kc0RlbHRhKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgZXhlYyA9IGZ1bmN0aW9uIGV4ZWMoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmNpZGVudHNBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoYXQuaW5jaWRlbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5pbmNpZGVudHNbal0uaWQgPT09IGluY2lkZW50c0FycmF5W2ldLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5pbmNpZGVudHNbal0ubWlsbGlzZWNvbmQgKz0gbWlsbGlzZWNvbmRzRGVsdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGF0LmluY2lkZW50cyA9IF9zb3J0QnkodGhhdC5pbmNpZGVudHMsIFtmdW5jdGlvbiAobGFuZUl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhbmVJdGVtLm1pbGxpc2Vjb25kO1xuICAgICAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgICAgIHRoYXQuc2xpcFRvTGFuZUZvcndhcmRzKDAsIHRoYXQucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogdHJ1ZSwgZXhlY3V0ZTogZXhlYyB9O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjaGVja0RlbGV0ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0RlbGV0ZShpbmNpZGVudHNBcnJheSkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGluY2lkZW50SWRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluY2lkZW50c0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaW5jaWRlbnRJZHMucHVzaChpbmNpZGVudHNBcnJheVtpXS5pZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBleGVjID0gZnVuY3Rpb24gZXhlYygpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3SW5jaWRlbnRzID0gX2ZpbHRlcih0aGF0LmluY2lkZW50cywgZnVuY3Rpb24gKGluY2lkZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmNpZGVudElkcy5pbmRleE9mKGluY2lkZW50LmlkKSA9PT0gLTE7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0aGF0LmluY2lkZW50cyA9IG5ld0luY2lkZW50cztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgaW5jaWRlbnRJZHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGF0LmluY2lkZW50c0J5SWRbaW5jaWRlbnRJZHNbX2ldXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGF0LnNsaXBUb0xhbmVGb3J3YXJkcygwLCB0aGF0LnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IHRydWUsIGV4ZWN1dGU6IGV4ZWMgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7YXJyYXl9IGluY2lkZW50cyAtIFt7aWQsIHN0YXJ0LCBlbmQsIHN0YXJ0RGVsdGF9XVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjaGVja1Jlc2l6ZWRJbmNpZGVudHMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tSZXNpemVkSW5jaWRlbnRzKGluY2lkZW50cykge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGV4ZWMgPSBmdW5jdGlvbiBleGVjKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhhdC5pbmNpZGVudHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LmluY2lkZW50c1tqXS5pZCA9PT0gaW5jaWRlbnRzW2ldLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5pbmNpZGVudHNbal0ubWlsbGlzZWNvbmQgKz0gaW5jaWRlbnRzW2ldLnN0YXJ0RGVsdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGF0LmluY2lkZW50cyA9IF9zb3J0QnkodGhhdC5pbmNpZGVudHMsIFtmdW5jdGlvbiAobGFuZUl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhbmVJdGVtLm1pbGxpc2Vjb25kO1xuICAgICAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgICAgIHRoYXQuc2xpcFRvTGFuZUZvcndhcmRzKDAsIHRoYXQucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogdHJ1ZSwgZXhlY3V0ZTogZXhlYyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICBAcGFyYW0ge2ludH0gZnJvbSAtIHRoZSBtaWxsaXNlY29uZCB0byBzdGFydCBmcm9tXG4gICAgICAgICBAcGFyYW0ge2ludH0gdG8gLSB0aGUgbWlsbGlzZWNvbmQgdG8gZ28gdG9cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ21vdmVUbycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlVG8oZnJvbSwgdG8pIHtcbiAgICAgICAgICAgIGlmIChmcm9tIDwgdG8pIHtcbiAgICAgICAgICAgICAgICAvLyBoZWxwZXIubG9nKGBzbGlwcGluZyB0byBsYW5lIGZyb3dhcmRzIGZyb20gJHtmcm9tfSB0byAke3RvfWApO1xuICAgICAgICAgICAgICAgIHRoaXMuc2xpcFRvTGFuZUZvcndhcmRzKGZyb20sIHRvKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZnJvbSA+PSB0bykge1xuICAgICAgICAgICAgICAgIC8vIGhlbHBlci5sb2coYHNsaXBwaW5nIHRvIGxhbmUgYmFja3dhcmRzIGZyb20gJHtmcm9tfSB0byAke3RvfWApO1xuICAgICAgICAgICAgICAgIHRoaXMuc2xpcFRvTGFuZUJhY2t3YXJkcyhmcm9tLCB0byk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUElDaGFubmVsO1xufShDaGFubmVsKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQSUNoYW5uZWw7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/Channel.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/DummyIncident.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/DummyIncident.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ProgrammaticIncident = __webpack_require__(/*! ./ProgrammaticIncident */ \"./node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/ProgrammaticIncident.js\");\n\nvar DummyIncident = function (_ProgrammaticIncident) {\n    _inherits(DummyIncident, _ProgrammaticIncident);\n\n    function DummyIncident() {\n        var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        _classCallCheck(this, DummyIncident);\n\n        return _possibleConstructorReturn(this, (DummyIncident.__proto__ || Object.getPrototypeOf(DummyIncident)).call(this, {\n            command: function command() {} }, {\n            id: props.id\n        }));\n    }\n\n    return DummyIncident;\n}(ProgrammaticIncident);\n\nmodule.exports = DummyIncident;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvcmVQbHVnaW5zL1Byb2dyYW1tYXRpY0luY2lkZW50cy9EdW1teUluY2lkZW50LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9jb3JlUGx1Z2lucy9Qcm9ncmFtbWF0aWNJbmNpZGVudHMvRHVtbXlJbmNpZGVudC5qcz8xZTJjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgUHJvZ3JhbW1hdGljSW5jaWRlbnQgPSByZXF1aXJlKCcuL1Byb2dyYW1tYXRpY0luY2lkZW50Jyk7XG5cbnZhciBEdW1teUluY2lkZW50ID0gZnVuY3Rpb24gKF9Qcm9ncmFtbWF0aWNJbmNpZGVudCkge1xuICAgIF9pbmhlcml0cyhEdW1teUluY2lkZW50LCBfUHJvZ3JhbW1hdGljSW5jaWRlbnQpO1xuXG4gICAgZnVuY3Rpb24gRHVtbXlJbmNpZGVudCgpIHtcbiAgICAgICAgdmFyIGF0dHJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHVtbXlJbmNpZGVudCk7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChEdW1teUluY2lkZW50Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRHVtbXlJbmNpZGVudCkpLmNhbGwodGhpcywge1xuICAgICAgICAgICAgY29tbWFuZDogZnVuY3Rpb24gY29tbWFuZCgpIHt9IH0sIHtcbiAgICAgICAgICAgIGlkOiBwcm9wcy5pZFxuICAgICAgICB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIER1bW15SW5jaWRlbnQ7XG59KFByb2dyYW1tYXRpY0luY2lkZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBEdW1teUluY2lkZW50OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/DummyIncident.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/ProgrammaticIncident.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/ProgrammaticIncident.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Helper = __webpack_require__(/*! ../../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar Incident = __webpack_require__(/*! ../../_BaseClasses/Incident */ \"./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Incident.js\");\n\nvar ProgrammaticIncident = function (_Incident) {\n    _inherits(ProgrammaticIncident, _Incident);\n\n    function ProgrammaticIncident() {\n        var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        _classCallCheck(this, ProgrammaticIncident);\n\n        var _this = _possibleConstructorReturn(this, (ProgrammaticIncident.__proto__ || Object.getPrototypeOf(ProgrammaticIncident)).call(this, attrs, props));\n\n        _this.command = {\n            forwards: function forwards() {},\n            backwards: function backwards() {}\n        };\n\n        if (!attrs.hasOwnProperty('command')) {\n            var _ret;\n\n            helper.error('Programmatic Incidents must have the \"command\" included on the properties');\n            return _ret = false, _possibleConstructorReturn(_this, _ret);\n        } else {\n            // if the user passed an object as the command\n            if (helper.isObject(attrs.command)) {\n                // we expect to find two functions residing on the \"forwards\" and \"backwards\" keys\n                if (attrs.command.hasOwnProperty('forwards')) {\n                    if (helper.isFunction(attrs.command.forwards)) {\n                        _this.command.forwards = attrs.command.forwards;\n                    } else {\n                        var _ret2;\n\n                        helper.error('ProgrammaticIncident\\'s command.forwards key should hold a function. ' + _typeof(attrs.command.forwards) + ' passed');\n                        return _ret2 = false, _possibleConstructorReturn(_this, _ret2);\n                    }\n                }\n                if (attrs.command.hasOwnProperty('backwards')) {\n                    if (helper.isFunction(attrs.command.backwards)) {\n                        _this.command.backwards = attrs.command.backwards;\n                    } else {\n                        var _ret3;\n\n                        helper.error('ProgrammaticIncident\\'s command.backwards key should hold a function. ' + _typeof(attrs.command.backwards) + ' passed');\n                        return _ret3 = false, _possibleConstructorReturn(_this, _ret3);\n                    }\n                }\n            } else if (helper.isFunction(attrs.command)) {\n                // else if the passed argument is a function we only hold this as the forwards command\n                _this.command.forwards = attrs.command;\n            } else {\n                var _ret4;\n\n                // else if the passed argument is neither function nor object return false\n                helper.error('command key of ProgrammaticIncidents\\' construction properties must be either an object or a function. ' + _typeof(attrs.command) + ' passed');\n                return _ret4 = false, _possibleConstructorReturn(_this, _ret4);\n            }\n        }\n        return _this;\n    }\n\n    _createClass(ProgrammaticIncident, [{\n        key: 'onPlay',\n        value: function onPlay(props) {\n            if (this.speed > 0) {\n                this.command.forwards(props);\n            } else {\n                this.command.backwards(props);\n            }\n        }\n    }]);\n\n    return ProgrammaticIncident;\n}(Incident);\n\nmodule.exports = ProgrammaticIncident;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvcmVQbHVnaW5zL1Byb2dyYW1tYXRpY0luY2lkZW50cy9Qcm9ncmFtbWF0aWNJbmNpZGVudC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2Rpc3QvY29yZVBsdWdpbnMvUHJvZ3JhbW1hdGljSW5jaWRlbnRzL1Byb2dyYW1tYXRpY0luY2lkZW50LmpzPzdiZDkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEhlbHBlciA9IHJlcXVpcmUoJy4uLy4uL19jb3JlVXRpbHMvSGVscGVyJyk7XG52YXIgaGVscGVyID0gbmV3IEhlbHBlcigpO1xudmFyIEluY2lkZW50ID0gcmVxdWlyZSgnLi4vLi4vX0Jhc2VDbGFzc2VzL0luY2lkZW50Jyk7XG5cbnZhciBQcm9ncmFtbWF0aWNJbmNpZGVudCA9IGZ1bmN0aW9uIChfSW5jaWRlbnQpIHtcbiAgICBfaW5oZXJpdHMoUHJvZ3JhbW1hdGljSW5jaWRlbnQsIF9JbmNpZGVudCk7XG5cbiAgICBmdW5jdGlvbiBQcm9ncmFtbWF0aWNJbmNpZGVudCgpIHtcbiAgICAgICAgdmFyIGF0dHJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUHJvZ3JhbW1hdGljSW5jaWRlbnQpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChQcm9ncmFtbWF0aWNJbmNpZGVudC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFByb2dyYW1tYXRpY0luY2lkZW50KSkuY2FsbCh0aGlzLCBhdHRycywgcHJvcHMpKTtcblxuICAgICAgICBfdGhpcy5jb21tYW5kID0ge1xuICAgICAgICAgICAgZm9yd2FyZHM6IGZ1bmN0aW9uIGZvcndhcmRzKCkge30sXG4gICAgICAgICAgICBiYWNrd2FyZHM6IGZ1bmN0aW9uIGJhY2t3YXJkcygpIHt9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFhdHRycy5oYXNPd25Qcm9wZXJ0eSgnY29tbWFuZCcpKSB7XG4gICAgICAgICAgICB2YXIgX3JldDtcblxuICAgICAgICAgICAgaGVscGVyLmVycm9yKCdQcm9ncmFtbWF0aWMgSW5jaWRlbnRzIG11c3QgaGF2ZSB0aGUgXCJjb21tYW5kXCIgaW5jbHVkZWQgb24gdGhlIHByb3BlcnRpZXMnKTtcbiAgICAgICAgICAgIHJldHVybiBfcmV0ID0gZmFsc2UsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSB1c2VyIHBhc3NlZCBhbiBvYmplY3QgYXMgdGhlIGNvbW1hbmRcbiAgICAgICAgICAgIGlmIChoZWxwZXIuaXNPYmplY3QoYXR0cnMuY29tbWFuZCkpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBleHBlY3QgdG8gZmluZCB0d28gZnVuY3Rpb25zIHJlc2lkaW5nIG9uIHRoZSBcImZvcndhcmRzXCIgYW5kIFwiYmFja3dhcmRzXCIga2V5c1xuICAgICAgICAgICAgICAgIGlmIChhdHRycy5jb21tYW5kLmhhc093blByb3BlcnR5KCdmb3J3YXJkcycpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoZWxwZXIuaXNGdW5jdGlvbihhdHRycy5jb21tYW5kLmZvcndhcmRzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29tbWFuZC5mb3J3YXJkcyA9IGF0dHJzLmNvbW1hbmQuZm9yd2FyZHM7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JldDI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGhlbHBlci5lcnJvcignUHJvZ3JhbW1hdGljSW5jaWRlbnRcXCdzIGNvbW1hbmQuZm9yd2FyZHMga2V5IHNob3VsZCBob2xkIGEgZnVuY3Rpb24uICcgKyBfdHlwZW9mKGF0dHJzLmNvbW1hbmQuZm9yd2FyZHMpICsgJyBwYXNzZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmV0MiA9IGZhbHNlLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldDIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhdHRycy5jb21tYW5kLmhhc093blByb3BlcnR5KCdiYWNrd2FyZHMnKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGVscGVyLmlzRnVuY3Rpb24oYXR0cnMuY29tbWFuZC5iYWNrd2FyZHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb21tYW5kLmJhY2t3YXJkcyA9IGF0dHJzLmNvbW1hbmQuYmFja3dhcmRzO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZXQzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWxwZXIuZXJyb3IoJ1Byb2dyYW1tYXRpY0luY2lkZW50XFwncyBjb21tYW5kLmJhY2t3YXJkcyBrZXkgc2hvdWxkIGhvbGQgYSBmdW5jdGlvbi4gJyArIF90eXBlb2YoYXR0cnMuY29tbWFuZC5iYWNrd2FyZHMpICsgJyBwYXNzZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmV0MyA9IGZhbHNlLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldDMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChoZWxwZXIuaXNGdW5jdGlvbihhdHRycy5jb21tYW5kKSkge1xuICAgICAgICAgICAgICAgIC8vIGVsc2UgaWYgdGhlIHBhc3NlZCBhcmd1bWVudCBpcyBhIGZ1bmN0aW9uIHdlIG9ubHkgaG9sZCB0aGlzIGFzIHRoZSBmb3J3YXJkcyBjb21tYW5kXG4gICAgICAgICAgICAgICAgX3RoaXMuY29tbWFuZC5mb3J3YXJkcyA9IGF0dHJzLmNvbW1hbmQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBfcmV0NDtcblxuICAgICAgICAgICAgICAgIC8vIGVsc2UgaWYgdGhlIHBhc3NlZCBhcmd1bWVudCBpcyBuZWl0aGVyIGZ1bmN0aW9uIG5vciBvYmplY3QgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgaGVscGVyLmVycm9yKCdjb21tYW5kIGtleSBvZiBQcm9ncmFtbWF0aWNJbmNpZGVudHNcXCcgY29uc3RydWN0aW9uIHByb3BlcnRpZXMgbXVzdCBiZSBlaXRoZXIgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb24uICcgKyBfdHlwZW9mKGF0dHJzLmNvbW1hbmQpICsgJyBwYXNzZWQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3JldDQgPSBmYWxzZSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFByb2dyYW1tYXRpY0luY2lkZW50LCBbe1xuICAgICAgICBrZXk6ICdvblBsYXknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25QbGF5KHByb3BzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zcGVlZCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmQuZm9yd2FyZHMocHJvcHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmQuYmFja3dhcmRzKHByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBQcm9ncmFtbWF0aWNJbmNpZGVudDtcbn0oSW5jaWRlbnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb2dyYW1tYXRpY0luY2lkZW50OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/ProgrammaticIncident.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/main.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/main.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar ProgrammaticIncident = __webpack_require__(/*! ./ProgrammaticIncident */ \"./node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/ProgrammaticIncident.js\");\nvar DummyIncident = __webpack_require__(/*! ./DummyIncident */ \"./node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/DummyIncident.js\");\nvar PIChannel = __webpack_require__(/*! ./Channel */ \"./node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/Channel.js\");\n\nmodule.exports = {\n    npm_name: \"@kissmybutton/programmatic-incidents\",\n    incidents: [{\n        exportable: ProgrammaticIncident,\n        name: \"ProgrammaticIncident\"\n    }, {\n        exportable: DummyIncident,\n        name: \"DummyIncident\"\n    }],\n    channel: PIChannel\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvcmVQbHVnaW5zL1Byb2dyYW1tYXRpY0luY2lkZW50cy9tYWluLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9jb3JlUGx1Z2lucy9Qcm9ncmFtbWF0aWNJbmNpZGVudHMvbWFpbi5qcz8zZjNkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIFByb2dyYW1tYXRpY0luY2lkZW50ID0gcmVxdWlyZSgnLi9Qcm9ncmFtbWF0aWNJbmNpZGVudCcpO1xudmFyIER1bW15SW5jaWRlbnQgPSByZXF1aXJlKCcuL0R1bW15SW5jaWRlbnQnKTtcbnZhciBQSUNoYW5uZWwgPSByZXF1aXJlKCcuL0NoYW5uZWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgbnBtX25hbWU6IFwiQGtpc3NteWJ1dHRvbi9wcm9ncmFtbWF0aWMtaW5jaWRlbnRzXCIsXG4gICAgaW5jaWRlbnRzOiBbe1xuICAgICAgICBleHBvcnRhYmxlOiBQcm9ncmFtbWF0aWNJbmNpZGVudCxcbiAgICAgICAgbmFtZTogXCJQcm9ncmFtbWF0aWNJbmNpZGVudFwiXG4gICAgfSwge1xuICAgICAgICBleHBvcnRhYmxlOiBEdW1teUluY2lkZW50LFxuICAgICAgICBuYW1lOiBcIkR1bW15SW5jaWRlbnRcIlxuICAgIH1dLFxuICAgIGNoYW5uZWw6IFBJQ2hhbm5lbFxufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/main.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/ClipFromDefinition.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/ClipFromDefinition.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Helper = __webpack_require__(/*! ../../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar Clip = __webpack_require__(/*! ./SCGroup */ \"./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/SCGroup.js\");\nvar Channel = __webpack_require__(/*! ./SCIChannel */ \"./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/SCIChannel.js\");\n\nfunction ClipFromDefinition(definition) {\n    var clipClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    if (definition === null) {\n        helper.error('ClipFromDefinition expects the defintion parameter');\n        return false;\n    }\n\n    if (clipClass === null) {\n        clipClass = Clip;\n    }\n\n    var clip = new clipClass(definition.attrs, definition.props);\n    clip.plugin_channel_class = Channel;\n    clip.mc_plugin_npm_name = \"@kissmybutton/self-contained-incidents\";\n    constructIncidents(clip, definition);\n\n    return clip;\n}\n\nfunction constructIncidents(parentIncident, incidentDefinition) {\n    if (parentIncident.hasIncidents) {\n        for (var i = 0; i < incidentDefinition.incidents.length; i++) {\n            var incidentItem = incidentDefinition.incidents[i];\n            // incidentItem is an object:\n            /*\n            {\n                id\n                millisecond\n                incident\n            }\n            */\n\n            var theNewIncident = new incidentItem.incident.Incident(incidentItem.incident.attrs, incidentItem.incident.props);\n            theNewIncident.plugin_channel_class = incidentItem.incident.plugin_channel_class;\n            theNewIncident.mc_plugin_npm_name = incidentItem.incident.mc_plugin_npm_name;\n            parentIncident.addIncident(theNewIncident, incidentItem.millisecond);\n            constructIncidents(theNewIncident, incidentItem.incident);\n        }\n    }\n}\n\nmodule.exports = ClipFromDefinition;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvcmVQbHVnaW5zL1NlbGZDb250YWluZWRJbmNpZGVudHMvQ2xpcEZyb21EZWZpbml0aW9uLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9jb3JlUGx1Z2lucy9TZWxmQ29udGFpbmVkSW5jaWRlbnRzL0NsaXBGcm9tRGVmaW5pdGlvbi5qcz82ODYzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIEhlbHBlciA9IHJlcXVpcmUoJy4uLy4uL19jb3JlVXRpbHMvSGVscGVyJyk7XG52YXIgaGVscGVyID0gbmV3IEhlbHBlcigpO1xudmFyIENsaXAgPSByZXF1aXJlKCcuL1NDR3JvdXAnKTtcbnZhciBDaGFubmVsID0gcmVxdWlyZSgnLi9TQ0lDaGFubmVsJyk7XG5cbmZ1bmN0aW9uIENsaXBGcm9tRGVmaW5pdGlvbihkZWZpbml0aW9uKSB7XG4gICAgdmFyIGNsaXBDbGFzcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcblxuICAgIGlmIChkZWZpbml0aW9uID09PSBudWxsKSB7XG4gICAgICAgIGhlbHBlci5lcnJvcignQ2xpcEZyb21EZWZpbml0aW9uIGV4cGVjdHMgdGhlIGRlZmludGlvbiBwYXJhbWV0ZXInKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChjbGlwQ2xhc3MgPT09IG51bGwpIHtcbiAgICAgICAgY2xpcENsYXNzID0gQ2xpcDtcbiAgICB9XG5cbiAgICB2YXIgY2xpcCA9IG5ldyBjbGlwQ2xhc3MoZGVmaW5pdGlvbi5hdHRycywgZGVmaW5pdGlvbi5wcm9wcyk7XG4gICAgY2xpcC5wbHVnaW5fY2hhbm5lbF9jbGFzcyA9IENoYW5uZWw7XG4gICAgY2xpcC5tY19wbHVnaW5fbnBtX25hbWUgPSBcIkBraXNzbXlidXR0b24vc2VsZi1jb250YWluZWQtaW5jaWRlbnRzXCI7XG4gICAgY29uc3RydWN0SW5jaWRlbnRzKGNsaXAsIGRlZmluaXRpb24pO1xuXG4gICAgcmV0dXJuIGNsaXA7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdEluY2lkZW50cyhwYXJlbnRJbmNpZGVudCwgaW5jaWRlbnREZWZpbml0aW9uKSB7XG4gICAgaWYgKHBhcmVudEluY2lkZW50Lmhhc0luY2lkZW50cykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluY2lkZW50RGVmaW5pdGlvbi5pbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpbmNpZGVudEl0ZW0gPSBpbmNpZGVudERlZmluaXRpb24uaW5jaWRlbnRzW2ldO1xuICAgICAgICAgICAgLy8gaW5jaWRlbnRJdGVtIGlzIGFuIG9iamVjdDpcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWRcbiAgICAgICAgICAgICAgICBtaWxsaXNlY29uZFxuICAgICAgICAgICAgICAgIGluY2lkZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB2YXIgdGhlTmV3SW5jaWRlbnQgPSBuZXcgaW5jaWRlbnRJdGVtLmluY2lkZW50LkluY2lkZW50KGluY2lkZW50SXRlbS5pbmNpZGVudC5hdHRycywgaW5jaWRlbnRJdGVtLmluY2lkZW50LnByb3BzKTtcbiAgICAgICAgICAgIHRoZU5ld0luY2lkZW50LnBsdWdpbl9jaGFubmVsX2NsYXNzID0gaW5jaWRlbnRJdGVtLmluY2lkZW50LnBsdWdpbl9jaGFubmVsX2NsYXNzO1xuICAgICAgICAgICAgdGhlTmV3SW5jaWRlbnQubWNfcGx1Z2luX25wbV9uYW1lID0gaW5jaWRlbnRJdGVtLmluY2lkZW50Lm1jX3BsdWdpbl9ucG1fbmFtZTtcbiAgICAgICAgICAgIHBhcmVudEluY2lkZW50LmFkZEluY2lkZW50KHRoZU5ld0luY2lkZW50LCBpbmNpZGVudEl0ZW0ubWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgY29uc3RydWN0SW5jaWRlbnRzKHRoZU5ld0luY2lkZW50LCBpbmNpZGVudEl0ZW0uaW5jaWRlbnQpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENsaXBGcm9tRGVmaW5pdGlvbjsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/ClipFromDefinition.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/ExtendableClip.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/ExtendableClip.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Helper = __webpack_require__(/*! ../../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar Group = __webpack_require__(/*! ../../_BaseClasses/Group */ \"./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Group.js\");\nvar conf = __webpack_require__(/*! ../../configuration/generalConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\nvar pipeMessages = __webpack_require__(/*! ../../configuration/pipesConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/pipesConf.js\");\nvar ClipChannel = __webpack_require__(/*! ./SCIChannel */ \"./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/SCIChannel.js\");\nvar selfContainedIncidentsNpmName = '@kissmybutton/self-contained-incidents';\n\nvar ExtendableClip = function (_Group) {\n    _inherits(ExtendableClip, _Group);\n\n    /**\n     * @param {object} props - an object that should contain all of the following keys:\n     * - html (the html template to render)\n     * - css (the css template of the isolated tree)\n     * - initParams (optional / the initialisation parameteres that will be passed both on the css and the html templates in order to render)\n     * - host (an Element object that will host the isolated tree)\n     * - containerParams (an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc)\n     * - type (optional, defaults to \"iframe\") the type of the Clip. It can be one of the:\n     *  - iframe \n     *  - plain\n    */\n    function ExtendableClip() {\n        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var oldProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n        _classCallCheck(this, ExtendableClip);\n\n        var attrsToPass = void 0,\n            propsToUse = void 0;\n\n        /*\n        backwards compatibility. If the user doesn't pass a second argument on the constructor then this is \n        the new way of initialising a Group (only props).\n        */\n        if (oldProps === null) {\n            attrsToPass = {};\n            propsToUse = props;\n        } else {\n            // else, in case the user has passed two arguments then both should be used\n            attrsToPass = props;\n            propsToUse = oldProps;\n        }\n\n        if (!helper.isObject(propsToUse)) {\n            var _ret;\n\n            helper.error('Self Contained Incident expects an object on its second argument on the constructor. ' + (typeof propsToUse === 'undefined' ? 'undefined' : _typeof(propsToUse)) + ' passed');\n            return _ret = false, _possibleConstructorReturn(_this, _ret);\n        }\n\n        var _this = _possibleConstructorReturn(this, (ExtendableClip.__proto__ || Object.getPrototypeOf(ExtendableClip)).call(this, attrsToPass, propsToUse));\n\n        _this.mc_plugin_npm_name = \"@kissmybutton/self-contained-incidents\";\n        _this.plugin_channel_class = ClipChannel;\n\n        _this.isTheClip = true;\n\n        _this.volume = 1;\n\n        _this.editingStatus = 'editing'; // either normal or editing\n\n        _this.blockingWaitings = {};\n\n        _this.onClipInitialise();\n        return _this;\n    }\n\n    _createClass(ExtendableClip, [{\n        key: 'onClipInitialise',\n        value: function onClipInitialise() {\n            // called when group gets initialised\n        }\n    }, {\n        key: '_getChannel',\n        value: function _getChannel(channelId) {\n            if (!this.instantiatedChannels.hasOwnProperty(channelId)) {\n                return null;\n            } else {\n                return this.instantiatedChannels[channelId];\n            }\n        }\n    }, {\n        key: 'lastWish',\n        value: function lastWish() {\n            this.ownContext.unmount();\n        }\n    }, {\n        key: 'startEditing',\n        value: function startEditing() {\n            this.editingStatus = \"editing\";\n        }\n    }, {\n        key: 'doneEditing',\n        value: function doneEditing() {\n            this.stop();\n            this.setCurrentMillisecond(this.runTimeInfo.currentMillisecond);\n            this.recalcState(this.runTimeInfo.currentMillisecond);\n            this.restore();\n            this.editingStatus = \"editing\";\n        }\n\n        /**************************************************************************\n         * methods inheritied from Group\n        **************************************************************************/\n        // *******************************************************\n        // INCIDENTS MANAGEMENT METHODS\n        // POLYMORPHISM APPLIED. IF THE GROUP HAS NO PARENT IT ACTS AS A SCENE. IF THE GROUP HAS PARENT IT ACTS AS\n        // A \"TRANSPARENT GROUP\"\n\n        /**\n         * The checkAddition method serves exactly what its name implies. To check if the addition of an Incident\n         * is valid and accepted, according to the rules defined on the channels.\n         * The method boobles up until it reaches the Clip by carrying adjusting the millisecond.\n         * The method takes as input the management type. On error / conflict:\n         *  - on type === 'all-or-nothing' completely discard addition of all incidents\n         *  - on type === 'keep-passing' it will only add the passing incidents no matter if some other incidents of the addition failed\n         * @param {object} incident - the incident to add\n         * @param {int} millisecond - the millisecond to add the Incident to\n         * @param {string} type - as explained above\n         * The method returns either:\n            {\n                result:true,\n                execute: // an array of functions that when executed it will add the Incidents on the Channels\n            }\n            or\n            {\n                result: false,\n                errors\n            }\n        */\n\n    }, {\n        key: 'checkAddition',\n        value: function checkAddition(incident, millisecond) {\n            var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"all-or-nothing\";\n\n            if (incident.props.autoGeneratedID === false) {\n                var existingIncidentWithTheSameId = this.getIncidentById(incident.id);\n                if (existingIncidentWithTheSameId != null) {\n                    return { result: false, errors: [{ reason: 'Already existing Incident with id ' + incident.id, incident: existingIncidentWithTheSameId }] };\n                }\n            }\n\n            // get all incidents separated by plugin\n            var incidentsById = incident.getIncidentsByChannel(millisecond);\n\n            // prepare the return payload\n            var toReturnResult = true;\n            var toReturnErrors = [];\n            var toReturnExecutables = [];\n\n            // for each key of the incidentsById object perform the check\n            for (var key in incidentsById) {\n                // if the clip had no channel instantiated for the specific key (plugin id) yet create it\n                if (!this.instantiatedChannels.hasOwnProperty(key)) {\n                    // intstantiate the channel of the plugin by using the reference to the class definition stored on\n                    // the very first incident of the array\n                    this.instantiatedChannels[key] = new incidentsById[key][0].incident.plugin_channel_class({\n                        runTimeInfo: this.runTimeInfo,\n                        context: this.context\n                    });\n                }\n\n                // perform the check\n                var pluginResult = this.instantiatedChannels[key].addIncidents(incidentsById[key], type);\n                toReturnResult = toReturnResult && pluginResult.result;\n                if (pluginResult.result === false) {\n                    toReturnErrors = toReturnErrors.concat(pluginResult.errors);\n                } else {\n                    toReturnExecutables.push(pluginResult.execute);\n                }\n            } // enf of iteration on the incidentsById keys\n\n            var toReturnExecute = function toReturnExecute() {\n                for (var i = 0; i < toReturnExecutables.length; i++) {\n                    toReturnExecutables[i]();\n                }\n            };\n\n            var additionResult = {\n                result: toReturnResult,\n                errors: toReturnErrors,\n                execute: toReturnExecute\n            };\n            return additionResult;\n        }\n\n        /**\n         * The checkEdit method serves exactly what its name implies. To check if the edit of an Incident (edit of Incident's position given in milliseconds delta)\n         * is valid and accepted, according to the rules defined on the channels.\n         * The method boobles up until it reaches the Clip.\n         * @param {object} incident - the incident to edit\n         * @param {int} millisecondsDelta - the milliseconds delta of the Incident's start time\n         The method should return either:\n            {\n                result:true,\n                execute: // an array of functions that when executed it will edit the Incidents on the Channels\n            }\n            or\n            {\n                result: false,\n                errors\n            }\n        */\n\n    }, {\n        key: 'checkEdit',\n        value: function checkEdit(incident, millisecondsDelta) {\n            // get all incidents separated by plugin\n            var incidentsById = incident.getIncidentsByChannel();\n\n            // prepare the return payload\n            var toReturnResult = true;\n            var toReturnErrors = [];\n            var toReturnExecutables = [];\n\n            // for each key of the incidentsById object perform the check\n            for (var key in incidentsById) {\n                // perform the check\n                var pluginResult = this.instantiatedChannels[key].editIncidents(incidentsById[key], millisecondsDelta);\n                toReturnResult = toReturnResult && pluginResult.result;\n                if (pluginResult.result === false) {\n                    toReturnErrors = toReturnErrors.concat(pluginResult.errors);\n                } else {\n                    toReturnExecutables.push(pluginResult.execute);\n                }\n            } // enf of iteration on the incidentsById keys\n\n            var toReturnExecute = function toReturnExecute() {\n                for (var i = 0; i < toReturnExecutables.length; i++) {\n                    toReturnExecutables[i]();\n                }\n            };\n\n            var editResult = {\n                result: toReturnResult,\n                errors: toReturnErrors,\n                execute: toReturnExecute\n            };\n            return editResult;\n        }\n\n        /**\n         * The checkDelete method serves exactly what its name implies. To check if the deletion of an Incident\n         * is valid and accepted, according to the rules defined on the channels.\n         * The method boobles up until it reaches the Clip.\n         * @param {object} incident - the incident to edit\n         * @param {object} props - if passed it supports the preventSlip key which if false the channel should not slip. This case is for \n            flashDOM of DOMAwareIncidents where we have elements deleted so slipping on their lanes is not valid nor necessary\n          The result might be either:\n            {\n                result:true,\n                execute: // an array of functions that when executed it will remove the Incident on the Channels\n            }\n            or\n            {\n                result: false,\n                errors\n            }\n        */\n\n    }, {\n        key: 'checkDelete',\n        value: function checkDelete(incidentId) {\n            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n            var incident = this.getIncidentById(incidentId);\n            // get all incidents separated by plugin\n            var incidentsById = incident.getIncidentsByChannel();\n\n            // prepare the return payload\n            var toReturnResult = true;\n            var toReturnErrors = [];\n            var toReturnExecutables = [];\n\n            // for each key of the incidentsById object perform the check\n            for (var key in incidentsById) {\n                // perform the check\n                var pluginResult = this.instantiatedChannels[key].removeIncidents(incidentsById[key], props);\n                toReturnResult = toReturnResult && pluginResult.result;\n                if (pluginResult.result === false) {\n                    toReturnErrors = toReturnErrors.concat(pluginResult.errors);\n                } else {\n                    toReturnExecutables.push(pluginResult.execute);\n                }\n            } // enf of iteration on the incidentsById keys\n\n            var toReturnExecute = function toReturnExecute() {\n                for (var i = 0; i < toReturnExecutables.length; i++) {\n                    toReturnExecutables[i]();\n                }\n            };\n\n            var editResult = {\n                result: toReturnResult,\n                errors: toReturnErrors,\n                execute: toReturnExecute\n            };\n            return editResult;\n        }\n\n        /**\n         * checks if a duration edit is feasible and doesn't cause conflicts\n         * @param {int} duration - the new duration\n        **/\n\n    }, {\n        key: 'checkResizedIncident',\n        value: function checkResizedIncident(durationFraction, incident) {\n            var adjustMillisecond = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n            // IF THE GROUP HAS NO PARENTS (IS A CLIP)\n            if (incident.id != this.id) {\n                // get all incidents separated by plugin\n                var incidentsById = incident.getIncidentsByChannel();\n\n                // prepare the return payload\n                var toReturnResult = true;\n                var toReturnErrors = [];\n                var toReturnExecutables = [];\n                // for each key of the incidentsById object perform the check\n\n                for (var key in incidentsById) {\n                    // perform the check\n                    var adjustedIncidents = helper.systoleDiastoleProjections(incidentsById[key], durationFraction, adjustMillisecond);\n                    var pluginResult = this.instantiatedChannels[key].checkResizedIncidents(adjustedIncidents);\n                    toReturnResult = toReturnResult && pluginResult.result;\n                    if (pluginResult.result === false) {\n                        toReturnErrors = toReturnErrors.concat(pluginResult.errors);\n                    } else {\n                        toReturnExecutables.push(pluginResult.execute);\n                    }\n                } // enf of iteration on the incidentsById keys\n\n                var toReturnExecute = function toReturnExecute() {\n                    for (var i = 0; i < toReturnExecutables.length; i++) {\n                        toReturnExecutables[i]();\n                    }\n                };\n\n                var editResult = {\n                    result: toReturnResult,\n                    errors: toReturnErrors,\n                    execute: toReturnExecute\n                };\n                return editResult;\n            } else {\n                return { result: true, execute: function execute() {} };\n                // the resizing of the internal Channels occurs on the systolDiastole method of the Groups when they identify that the Groups is actually a Clip\n            }\n        }\n\n        /**\n         * Starting from itself and going all the way down to each and every leaf of its tree it systols/diastoles the\n         * Incidents\n         * @param {float} durationFraction the fraction of the new duration to the existing duration\n        **/\n\n    }, {\n        key: 'systolDiastole',\n        value: function systolDiastole(durationFraction) {\n            _get(ExtendableClip.prototype.__proto__ || Object.getPrototypeOf(ExtendableClip.prototype), 'systolDiastole', this).call(this, durationFraction);\n\n            for (var key in this.instantiatedChannels) {\n                this.instantiatedChannels[key]._resize(durationFraction);\n            }\n        }\n    }, {\n        key: 'getIncidentsByChannel',\n\n\n        /**\n         * Returns an object with keys the keys of all the plugins Incidents of which appear in the\n         * tree of the Group. All Incidents are projected to the Group's timeline.\n         * The array includes the Group's projection too\n        */\n        value: function getIncidentsByChannel() {\n            var adjustMillisecond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n            var incidentsByPlugin = {};\n            incidentsByPlugin[selfContainedIncidentsNpmName] = [{\n                millisecond: adjustMillisecond,\n                incident: this,\n                id: this.id\n            }];\n\n            return incidentsByPlugin;\n        }\n\n        /**\n         * goTo method should always be handled by the Clip. No other Group nor Incident can handle goTo alone.\n         * Thus, if the Group is not the Clip it passes the command up. If the Group is the Clip then it handles goTo\n         * by passing the command to its Channels.\n        **/\n\n    }, {\n        key: 'goTo',\n        value: function goTo(millisecond) {\n            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n            // first decide the millisecond we want to goTo\n            if (millisecond === null || millisecond === undefined) {\n                millisecond = this.runTimeInfo.currentMillisecond;\n            }\n            if (props.hasOwnProperty('relativeTo')) {\n                millisecond += this.getIncidentMillisecond(props.relativeTo);\n            }\n\n            if (millisecond > this.duration) {\n                millisecond = this.duration;\n            } else if (millisecond < 0) {\n                millisecond = 0;\n            }\n\n            for (var key in this.instantiatedChannels) {\n                this.instantiatedChannels[key].goTo(millisecond, props);\n            }\n            return true;\n        }\n\n        /**************************************************************************\n        **************************************************************************/\n\n    }, {\n        key: 'handlePipeMessage',\n        value: function handlePipeMessage(name, params) {\n            var waitingID = params.blockingWaitingID;\n            switch (name) {\n                case pipeMessages._BLOCKING_WAITING:\n                    if (this.blockingWaitings.hasOwnProperty(waitingID)) {\n                        helper.error('Blocking waiting with id=' + waitingID + ' already exists. Blocking waiting is going to be discarded');\n                        return;\n                    }\n                    helper.notice('adding blocking waiting with id: ' + waitingID);\n                    this.blockingWaitings[waitingID] = params;\n                    this.block();\n                    break;\n                case pipeMessages._UNBLOCK_WAITING:\n                    if (!this.blockingWaitings.hasOwnProperty(waitingID)) {\n                        helper.error('Blocking waiting with id=' + waitingID + ' does not exist and thus unblocking can not be performed');\n                        return;\n                    }\n                    delete this.blockingWaitings[waitingID];\n\n                    helper.notice('removing blocking waiting with id: ' + waitingID);\n                    // If after the unblocking there are no other blocking waitings:\n                    if (Object.keys(this.blockingWaitings).length === 0) {\n                        // if the Clip is on blocked state play\n                        this.unblock();\n                    }\n                    break;\n                case pipeMessages._CLIP_EDITING_STATUS:\n                    return this.editingStatus;\n            }\n        }\n    }, {\n        key: 'setVolume',\n        value: function setVolume(newVal) {\n            this.volume = parseFloat(newVal);\n            this.putMessageOnPipe(pipeMessages._GAIN_CHANGE, { gain: newVal }, false, \"down\");\n        }\n    }, {\n        key: 'onArm',\n        value: function onArm() {\n            this.blockingWaitings = {};\n        }\n    }, {\n        key: '_onGetContextOnce',\n        value: function _onGetContextOnce() {\n            return; // Clips do not get context from noone\n        }\n    }, {\n        key: 'exportState',\n        value: function exportState() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            var state = _get(ExtendableClip.prototype.__proto__ || Object.getPrototypeOf(ExtendableClip.prototype), 'exportState', this).call(this, props);\n\n            if (props.hasOwnProperty('exportChannels')) {\n                if (props.exportChannels === true) {\n                    var channelsToExport = [];\n                    for (var channel in this.instantiatedChannels) {\n                        var _state = this.instantiatedChannels[channel].exportState(props);\n                        _state.mc_plugin_npm_name = channel;\n                        channelsToExport.push(_state);\n                    }\n\n                    state.channels = channelsToExport;\n                }\n            }\n\n            return state;\n        }\n    }, {\n        key: 'isHeadlessClip',\n        get: function get() {\n            return false;\n        }\n    }, {\n        key: 'context',\n        get: function get() {\n            return this.ownContext;\n        }\n    }]);\n\n    return ExtendableClip;\n}(Group);\n\nmodule.exports = ExtendableClip;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvcmVQbHVnaW5zL1NlbGZDb250YWluZWRJbmNpZGVudHMvRXh0ZW5kYWJsZUNsaXAuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvcmVQbHVnaW5zL1NlbGZDb250YWluZWRJbmNpZGVudHMvRXh0ZW5kYWJsZUNsaXAuanM/ZDdiMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBIZWxwZXIgPSByZXF1aXJlKCcuLi8uLi9fY29yZVV0aWxzL0hlbHBlcicpO1xudmFyIGhlbHBlciA9IG5ldyBIZWxwZXIoKTtcbnZhciBHcm91cCA9IHJlcXVpcmUoJy4uLy4uL19CYXNlQ2xhc3Nlcy9Hcm91cCcpO1xudmFyIGNvbmYgPSByZXF1aXJlKCcuLi8uLi9jb25maWd1cmF0aW9uL2dlbmVyYWxDb25mJyk7XG52YXIgcGlwZU1lc3NhZ2VzID0gcmVxdWlyZSgnLi4vLi4vY29uZmlndXJhdGlvbi9waXBlc0NvbmYnKTtcbnZhciBDbGlwQ2hhbm5lbCA9IHJlcXVpcmUoJy4vU0NJQ2hhbm5lbCcpO1xudmFyIHNlbGZDb250YWluZWRJbmNpZGVudHNOcG1OYW1lID0gJ0BraXNzbXlidXR0b24vc2VsZi1jb250YWluZWQtaW5jaWRlbnRzJztcblxudmFyIEV4dGVuZGFibGVDbGlwID0gZnVuY3Rpb24gKF9Hcm91cCkge1xuICAgIF9pbmhlcml0cyhFeHRlbmRhYmxlQ2xpcCwgX0dyb3VwKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyAtIGFuIG9iamVjdCB0aGF0IHNob3VsZCBjb250YWluIGFsbCBvZiB0aGUgZm9sbG93aW5nIGtleXM6XG4gICAgICogLSBodG1sICh0aGUgaHRtbCB0ZW1wbGF0ZSB0byByZW5kZXIpXG4gICAgICogLSBjc3MgKHRoZSBjc3MgdGVtcGxhdGUgb2YgdGhlIGlzb2xhdGVkIHRyZWUpXG4gICAgICogLSBpbml0UGFyYW1zIChvcHRpb25hbCAvIHRoZSBpbml0aWFsaXNhdGlvbiBwYXJhbWV0ZXJlcyB0aGF0IHdpbGwgYmUgcGFzc2VkIGJvdGggb24gdGhlIGNzcyBhbmQgdGhlIGh0bWwgdGVtcGxhdGVzIGluIG9yZGVyIHRvIHJlbmRlcilcbiAgICAgKiAtIGhvc3QgKGFuIEVsZW1lbnQgb2JqZWN0IHRoYXQgd2lsbCBob3N0IHRoZSBpc29sYXRlZCB0cmVlKVxuICAgICAqIC0gY29udGFpbmVyUGFyYW1zIChhbiBvYmplY3QgdGhhdCBob2xkcyBwYXJhbWV0ZXJzIHRvIGFmZmVjdCB0aGUgY29udGFpbmVyIG9mIHRoZSBpc29sYXRlZCB0cmVlLCBlLmcuIHdpZHRoLCBoZWlnaHQgZXRjKVxuICAgICAqIC0gdHlwZSAob3B0aW9uYWwsIGRlZmF1bHRzIHRvIFwiaWZyYW1lXCIpIHRoZSB0eXBlIG9mIHRoZSBDbGlwLiBJdCBjYW4gYmUgb25lIG9mIHRoZTpcbiAgICAgKiAgLSBpZnJhbWUgXG4gICAgICogIC0gcGxhaW5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIEV4dGVuZGFibGVDbGlwKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgICB2YXIgb2xkUHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG5cbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEV4dGVuZGFibGVDbGlwKTtcblxuICAgICAgICB2YXIgYXR0cnNUb1Bhc3MgPSB2b2lkIDAsXG4gICAgICAgICAgICBwcm9wc1RvVXNlID0gdm9pZCAwO1xuXG4gICAgICAgIC8qXG4gICAgICAgIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBJZiB0aGUgdXNlciBkb2Vzbid0IHBhc3MgYSBzZWNvbmQgYXJndW1lbnQgb24gdGhlIGNvbnN0cnVjdG9yIHRoZW4gdGhpcyBpcyBcbiAgICAgICAgdGhlIG5ldyB3YXkgb2YgaW5pdGlhbGlzaW5nIGEgR3JvdXAgKG9ubHkgcHJvcHMpLlxuICAgICAgICAqL1xuICAgICAgICBpZiAob2xkUHJvcHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGF0dHJzVG9QYXNzID0ge307XG4gICAgICAgICAgICBwcm9wc1RvVXNlID0gcHJvcHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBlbHNlLCBpbiBjYXNlIHRoZSB1c2VyIGhhcyBwYXNzZWQgdHdvIGFyZ3VtZW50cyB0aGVuIGJvdGggc2hvdWxkIGJlIHVzZWRcbiAgICAgICAgICAgIGF0dHJzVG9QYXNzID0gcHJvcHM7XG4gICAgICAgICAgICBwcm9wc1RvVXNlID0gb2xkUHJvcHM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhlbHBlci5pc09iamVjdChwcm9wc1RvVXNlKSkge1xuICAgICAgICAgICAgdmFyIF9yZXQ7XG5cbiAgICAgICAgICAgIGhlbHBlci5lcnJvcignU2VsZiBDb250YWluZWQgSW5jaWRlbnQgZXhwZWN0cyBhbiBvYmplY3Qgb24gaXRzIHNlY29uZCBhcmd1bWVudCBvbiB0aGUgY29uc3RydWN0b3IuICcgKyAodHlwZW9mIHByb3BzVG9Vc2UgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHByb3BzVG9Vc2UpKSArICcgcGFzc2VkJyk7XG4gICAgICAgICAgICByZXR1cm4gX3JldCA9IGZhbHNlLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoRXh0ZW5kYWJsZUNsaXAuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihFeHRlbmRhYmxlQ2xpcCkpLmNhbGwodGhpcywgYXR0cnNUb1Bhc3MsIHByb3BzVG9Vc2UpKTtcblxuICAgICAgICBfdGhpcy5tY19wbHVnaW5fbnBtX25hbWUgPSBcIkBraXNzbXlidXR0b24vc2VsZi1jb250YWluZWQtaW5jaWRlbnRzXCI7XG4gICAgICAgIF90aGlzLnBsdWdpbl9jaGFubmVsX2NsYXNzID0gQ2xpcENoYW5uZWw7XG5cbiAgICAgICAgX3RoaXMuaXNUaGVDbGlwID0gdHJ1ZTtcblxuICAgICAgICBfdGhpcy52b2x1bWUgPSAxO1xuXG4gICAgICAgIF90aGlzLmVkaXRpbmdTdGF0dXMgPSAnZWRpdGluZyc7IC8vIGVpdGhlciBub3JtYWwgb3IgZWRpdGluZ1xuXG4gICAgICAgIF90aGlzLmJsb2NraW5nV2FpdGluZ3MgPSB7fTtcblxuICAgICAgICBfdGhpcy5vbkNsaXBJbml0aWFsaXNlKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoRXh0ZW5kYWJsZUNsaXAsIFt7XG4gICAgICAgIGtleTogJ29uQ2xpcEluaXRpYWxpc2UnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25DbGlwSW5pdGlhbGlzZSgpIHtcbiAgICAgICAgICAgIC8vIGNhbGxlZCB3aGVuIGdyb3VwIGdldHMgaW5pdGlhbGlzZWRcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2dldENoYW5uZWwnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENoYW5uZWwoY2hhbm5lbElkKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaW5zdGFudGlhdGVkQ2hhbm5lbHMuaGFzT3duUHJvcGVydHkoY2hhbm5lbElkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW50aWF0ZWRDaGFubmVsc1tjaGFubmVsSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdsYXN0V2lzaCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBsYXN0V2lzaCgpIHtcbiAgICAgICAgICAgIHRoaXMub3duQ29udGV4dC51bm1vdW50KCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3N0YXJ0RWRpdGluZycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydEVkaXRpbmcoKSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRpbmdTdGF0dXMgPSBcImVkaXRpbmdcIjtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZG9uZUVkaXRpbmcnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZG9uZUVkaXRpbmcoKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudE1pbGxpc2Vjb25kKHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgIHRoaXMucmVjYWxjU3RhdGUodGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgICAgICAgICB0aGlzLmVkaXRpbmdTdGF0dXMgPSBcImVkaXRpbmdcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAgKiBtZXRob2RzIGluaGVyaXRpZWQgZnJvbSBHcm91cFxuICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAvLyBJTkNJREVOVFMgTUFOQUdFTUVOVCBNRVRIT0RTXG4gICAgICAgIC8vIFBPTFlNT1JQSElTTSBBUFBMSUVELiBJRiBUSEUgR1JPVVAgSEFTIE5PIFBBUkVOVCBJVCBBQ1RTIEFTIEEgU0NFTkUuIElGIFRIRSBHUk9VUCBIQVMgUEFSRU5UIElUIEFDVFMgQVNcbiAgICAgICAgLy8gQSBcIlRSQU5TUEFSRU5UIEdST1VQXCJcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNoZWNrQWRkaXRpb24gbWV0aG9kIHNlcnZlcyBleGFjdGx5IHdoYXQgaXRzIG5hbWUgaW1wbGllcy4gVG8gY2hlY2sgaWYgdGhlIGFkZGl0aW9uIG9mIGFuIEluY2lkZW50XG4gICAgICAgICAqIGlzIHZhbGlkIGFuZCBhY2NlcHRlZCwgYWNjb3JkaW5nIHRvIHRoZSBydWxlcyBkZWZpbmVkIG9uIHRoZSBjaGFubmVscy5cbiAgICAgICAgICogVGhlIG1ldGhvZCBib29ibGVzIHVwIHVudGlsIGl0IHJlYWNoZXMgdGhlIENsaXAgYnkgY2FycnlpbmcgYWRqdXN0aW5nIHRoZSBtaWxsaXNlY29uZC5cbiAgICAgICAgICogVGhlIG1ldGhvZCB0YWtlcyBhcyBpbnB1dCB0aGUgbWFuYWdlbWVudCB0eXBlLiBPbiBlcnJvciAvIGNvbmZsaWN0OlxuICAgICAgICAgKiAgLSBvbiB0eXBlID09PSAnYWxsLW9yLW5vdGhpbmcnIGNvbXBsZXRlbHkgZGlzY2FyZCBhZGRpdGlvbiBvZiBhbGwgaW5jaWRlbnRzXG4gICAgICAgICAqICAtIG9uIHR5cGUgPT09ICdrZWVwLXBhc3NpbmcnIGl0IHdpbGwgb25seSBhZGQgdGhlIHBhc3NpbmcgaW5jaWRlbnRzIG5vIG1hdHRlciBpZiBzb21lIG90aGVyIGluY2lkZW50cyBvZiB0aGUgYWRkaXRpb24gZmFpbGVkXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpbmNpZGVudCAtIHRoZSBpbmNpZGVudCB0byBhZGRcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IG1pbGxpc2Vjb25kIC0gdGhlIG1pbGxpc2Vjb25kIHRvIGFkZCB0aGUgSW5jaWRlbnQgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBhcyBleHBsYWluZWQgYWJvdmVcbiAgICAgICAgICogVGhlIG1ldGhvZCByZXR1cm5zIGVpdGhlcjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6dHJ1ZSxcbiAgICAgICAgICAgICAgICBleGVjdXRlOiAvLyBhbiBhcnJheSBvZiBmdW5jdGlvbnMgdGhhdCB3aGVuIGV4ZWN1dGVkIGl0IHdpbGwgYWRkIHRoZSBJbmNpZGVudHMgb24gdGhlIENoYW5uZWxzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvclxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3JzXG4gICAgICAgICAgICB9XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NoZWNrQWRkaXRpb24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tBZGRpdGlvbihpbmNpZGVudCwgbWlsbGlzZWNvbmQpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBcImFsbC1vci1ub3RoaW5nXCI7XG5cbiAgICAgICAgICAgIGlmIChpbmNpZGVudC5wcm9wcy5hdXRvR2VuZXJhdGVkSUQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nSW5jaWRlbnRXaXRoVGhlU2FtZUlkID0gdGhpcy5nZXRJbmNpZGVudEJ5SWQoaW5jaWRlbnQuaWQpO1xuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0luY2lkZW50V2l0aFRoZVNhbWVJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogZmFsc2UsIGVycm9yczogW3sgcmVhc29uOiAnQWxyZWFkeSBleGlzdGluZyBJbmNpZGVudCB3aXRoIGlkICcgKyBpbmNpZGVudC5pZCwgaW5jaWRlbnQ6IGV4aXN0aW5nSW5jaWRlbnRXaXRoVGhlU2FtZUlkIH1dIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBnZXQgYWxsIGluY2lkZW50cyBzZXBhcmF0ZWQgYnkgcGx1Z2luXG4gICAgICAgICAgICB2YXIgaW5jaWRlbnRzQnlJZCA9IGluY2lkZW50LmdldEluY2lkZW50c0J5Q2hhbm5lbChtaWxsaXNlY29uZCk7XG5cbiAgICAgICAgICAgIC8vIHByZXBhcmUgdGhlIHJldHVybiBwYXlsb2FkXG4gICAgICAgICAgICB2YXIgdG9SZXR1cm5SZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIHRvUmV0dXJuRXJyb3JzID0gW107XG4gICAgICAgICAgICB2YXIgdG9SZXR1cm5FeGVjdXRhYmxlcyA9IFtdO1xuXG4gICAgICAgICAgICAvLyBmb3IgZWFjaCBrZXkgb2YgdGhlIGluY2lkZW50c0J5SWQgb2JqZWN0IHBlcmZvcm0gdGhlIGNoZWNrXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gaW5jaWRlbnRzQnlJZCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjbGlwIGhhZCBubyBjaGFubmVsIGluc3RhbnRpYXRlZCBmb3IgdGhlIHNwZWNpZmljIGtleSAocGx1Z2luIGlkKSB5ZXQgY3JlYXRlIGl0XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmluc3RhbnRpYXRlZENoYW5uZWxzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW50c3RhbnRpYXRlIHRoZSBjaGFubmVsIG9mIHRoZSBwbHVnaW4gYnkgdXNpbmcgdGhlIHJlZmVyZW5jZSB0byB0aGUgY2xhc3MgZGVmaW5pdGlvbiBzdG9yZWQgb25cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHZlcnkgZmlyc3QgaW5jaWRlbnQgb2YgdGhlIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5zdGFudGlhdGVkQ2hhbm5lbHNba2V5XSA9IG5ldyBpbmNpZGVudHNCeUlkW2tleV1bMF0uaW5jaWRlbnQucGx1Z2luX2NoYW5uZWxfY2xhc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVuVGltZUluZm86IHRoaXMucnVuVGltZUluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gcGVyZm9ybSB0aGUgY2hlY2tcbiAgICAgICAgICAgICAgICB2YXIgcGx1Z2luUmVzdWx0ID0gdGhpcy5pbnN0YW50aWF0ZWRDaGFubmVsc1trZXldLmFkZEluY2lkZW50cyhpbmNpZGVudHNCeUlkW2tleV0sIHR5cGUpO1xuICAgICAgICAgICAgICAgIHRvUmV0dXJuUmVzdWx0ID0gdG9SZXR1cm5SZXN1bHQgJiYgcGx1Z2luUmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luUmVzdWx0LnJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9SZXR1cm5FcnJvcnMgPSB0b1JldHVybkVycm9ycy5jb25jYXQocGx1Z2luUmVzdWx0LmVycm9ycyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9SZXR1cm5FeGVjdXRhYmxlcy5wdXNoKHBsdWdpblJlc3VsdC5leGVjdXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIGVuZiBvZiBpdGVyYXRpb24gb24gdGhlIGluY2lkZW50c0J5SWQga2V5c1xuXG4gICAgICAgICAgICB2YXIgdG9SZXR1cm5FeGVjdXRlID0gZnVuY3Rpb24gdG9SZXR1cm5FeGVjdXRlKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9SZXR1cm5FeGVjdXRhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0b1JldHVybkV4ZWN1dGFibGVzW2ldKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGFkZGl0aW9uUmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIHJlc3VsdDogdG9SZXR1cm5SZXN1bHQsXG4gICAgICAgICAgICAgICAgZXJyb3JzOiB0b1JldHVybkVycm9ycyxcbiAgICAgICAgICAgICAgICBleGVjdXRlOiB0b1JldHVybkV4ZWN1dGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gYWRkaXRpb25SZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNoZWNrRWRpdCBtZXRob2Qgc2VydmVzIGV4YWN0bHkgd2hhdCBpdHMgbmFtZSBpbXBsaWVzLiBUbyBjaGVjayBpZiB0aGUgZWRpdCBvZiBhbiBJbmNpZGVudCAoZWRpdCBvZiBJbmNpZGVudCdzIHBvc2l0aW9uIGdpdmVuIGluIG1pbGxpc2Vjb25kcyBkZWx0YSlcbiAgICAgICAgICogaXMgdmFsaWQgYW5kIGFjY2VwdGVkLCBhY2NvcmRpbmcgdG8gdGhlIHJ1bGVzIGRlZmluZWQgb24gdGhlIGNoYW5uZWxzLlxuICAgICAgICAgKiBUaGUgbWV0aG9kIGJvb2JsZXMgdXAgdW50aWwgaXQgcmVhY2hlcyB0aGUgQ2xpcC5cbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGluY2lkZW50IC0gdGhlIGluY2lkZW50IHRvIGVkaXRcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IG1pbGxpc2Vjb25kc0RlbHRhIC0gdGhlIG1pbGxpc2Vjb25kcyBkZWx0YSBvZiB0aGUgSW5jaWRlbnQncyBzdGFydCB0aW1lXG4gICAgICAgICBUaGUgbWV0aG9kIHNob3VsZCByZXR1cm4gZWl0aGVyOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlc3VsdDp0cnVlLFxuICAgICAgICAgICAgICAgIGV4ZWN1dGU6IC8vIGFuIGFycmF5IG9mIGZ1bmN0aW9ucyB0aGF0IHdoZW4gZXhlY3V0ZWQgaXQgd2lsbCBlZGl0IHRoZSBJbmNpZGVudHMgb24gdGhlIENoYW5uZWxzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvclxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3JzXG4gICAgICAgICAgICB9XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NoZWNrRWRpdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0VkaXQoaW5jaWRlbnQsIG1pbGxpc2Vjb25kc0RlbHRhKSB7XG4gICAgICAgICAgICAvLyBnZXQgYWxsIGluY2lkZW50cyBzZXBhcmF0ZWQgYnkgcGx1Z2luXG4gICAgICAgICAgICB2YXIgaW5jaWRlbnRzQnlJZCA9IGluY2lkZW50LmdldEluY2lkZW50c0J5Q2hhbm5lbCgpO1xuXG4gICAgICAgICAgICAvLyBwcmVwYXJlIHRoZSByZXR1cm4gcGF5bG9hZFxuICAgICAgICAgICAgdmFyIHRvUmV0dXJuUmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciB0b1JldHVybkVycm9ycyA9IFtdO1xuICAgICAgICAgICAgdmFyIHRvUmV0dXJuRXhlY3V0YWJsZXMgPSBbXTtcblxuICAgICAgICAgICAgLy8gZm9yIGVhY2gga2V5IG9mIHRoZSBpbmNpZGVudHNCeUlkIG9iamVjdCBwZXJmb3JtIHRoZSBjaGVja1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGluY2lkZW50c0J5SWQpIHtcbiAgICAgICAgICAgICAgICAvLyBwZXJmb3JtIHRoZSBjaGVja1xuICAgICAgICAgICAgICAgIHZhciBwbHVnaW5SZXN1bHQgPSB0aGlzLmluc3RhbnRpYXRlZENoYW5uZWxzW2tleV0uZWRpdEluY2lkZW50cyhpbmNpZGVudHNCeUlkW2tleV0sIG1pbGxpc2Vjb25kc0RlbHRhKTtcbiAgICAgICAgICAgICAgICB0b1JldHVyblJlc3VsdCA9IHRvUmV0dXJuUmVzdWx0ICYmIHBsdWdpblJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpblJlc3VsdC5yZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvUmV0dXJuRXJyb3JzID0gdG9SZXR1cm5FcnJvcnMuY29uY2F0KHBsdWdpblJlc3VsdC5lcnJvcnMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRvUmV0dXJuRXhlY3V0YWJsZXMucHVzaChwbHVnaW5SZXN1bHQuZXhlY3V0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBlbmYgb2YgaXRlcmF0aW9uIG9uIHRoZSBpbmNpZGVudHNCeUlkIGtleXNcblxuICAgICAgICAgICAgdmFyIHRvUmV0dXJuRXhlY3V0ZSA9IGZ1bmN0aW9uIHRvUmV0dXJuRXhlY3V0ZSgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvUmV0dXJuRXhlY3V0YWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdG9SZXR1cm5FeGVjdXRhYmxlc1tpXSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBlZGl0UmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIHJlc3VsdDogdG9SZXR1cm5SZXN1bHQsXG4gICAgICAgICAgICAgICAgZXJyb3JzOiB0b1JldHVybkVycm9ycyxcbiAgICAgICAgICAgICAgICBleGVjdXRlOiB0b1JldHVybkV4ZWN1dGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZWRpdFJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2hlY2tEZWxldGUgbWV0aG9kIHNlcnZlcyBleGFjdGx5IHdoYXQgaXRzIG5hbWUgaW1wbGllcy4gVG8gY2hlY2sgaWYgdGhlIGRlbGV0aW9uIG9mIGFuIEluY2lkZW50XG4gICAgICAgICAqIGlzIHZhbGlkIGFuZCBhY2NlcHRlZCwgYWNjb3JkaW5nIHRvIHRoZSBydWxlcyBkZWZpbmVkIG9uIHRoZSBjaGFubmVscy5cbiAgICAgICAgICogVGhlIG1ldGhvZCBib29ibGVzIHVwIHVudGlsIGl0IHJlYWNoZXMgdGhlIENsaXAuXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpbmNpZGVudCAtIHRoZSBpbmNpZGVudCB0byBlZGl0XG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyAtIGlmIHBhc3NlZCBpdCBzdXBwb3J0cyB0aGUgcHJldmVudFNsaXAga2V5IHdoaWNoIGlmIGZhbHNlIHRoZSBjaGFubmVsIHNob3VsZCBub3Qgc2xpcC4gVGhpcyBjYXNlIGlzIGZvciBcbiAgICAgICAgICAgIGZsYXNoRE9NIG9mIERPTUF3YXJlSW5jaWRlbnRzIHdoZXJlIHdlIGhhdmUgZWxlbWVudHMgZGVsZXRlZCBzbyBzbGlwcGluZyBvbiB0aGVpciBsYW5lcyBpcyBub3QgdmFsaWQgbm9yIG5lY2Vzc2FyeVxuICAgICAgICAgIFRoZSByZXN1bHQgbWlnaHQgYmUgZWl0aGVyOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlc3VsdDp0cnVlLFxuICAgICAgICAgICAgICAgIGV4ZWN1dGU6IC8vIGFuIGFycmF5IG9mIGZ1bmN0aW9ucyB0aGF0IHdoZW4gZXhlY3V0ZWQgaXQgd2lsbCByZW1vdmUgdGhlIEluY2lkZW50IG9uIHRoZSBDaGFubmVsc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3JcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yc1xuICAgICAgICAgICAgfVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjaGVja0RlbGV0ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0RlbGV0ZShpbmNpZGVudElkKSB7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgICAgICB2YXIgaW5jaWRlbnQgPSB0aGlzLmdldEluY2lkZW50QnlJZChpbmNpZGVudElkKTtcbiAgICAgICAgICAgIC8vIGdldCBhbGwgaW5jaWRlbnRzIHNlcGFyYXRlZCBieSBwbHVnaW5cbiAgICAgICAgICAgIHZhciBpbmNpZGVudHNCeUlkID0gaW5jaWRlbnQuZ2V0SW5jaWRlbnRzQnlDaGFubmVsKCk7XG5cbiAgICAgICAgICAgIC8vIHByZXBhcmUgdGhlIHJldHVybiBwYXlsb2FkXG4gICAgICAgICAgICB2YXIgdG9SZXR1cm5SZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIHRvUmV0dXJuRXJyb3JzID0gW107XG4gICAgICAgICAgICB2YXIgdG9SZXR1cm5FeGVjdXRhYmxlcyA9IFtdO1xuXG4gICAgICAgICAgICAvLyBmb3IgZWFjaCBrZXkgb2YgdGhlIGluY2lkZW50c0J5SWQgb2JqZWN0IHBlcmZvcm0gdGhlIGNoZWNrXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gaW5jaWRlbnRzQnlJZCkge1xuICAgICAgICAgICAgICAgIC8vIHBlcmZvcm0gdGhlIGNoZWNrXG4gICAgICAgICAgICAgICAgdmFyIHBsdWdpblJlc3VsdCA9IHRoaXMuaW5zdGFudGlhdGVkQ2hhbm5lbHNba2V5XS5yZW1vdmVJbmNpZGVudHMoaW5jaWRlbnRzQnlJZFtrZXldLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgdG9SZXR1cm5SZXN1bHQgPSB0b1JldHVyblJlc3VsdCAmJiBwbHVnaW5SZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW5SZXN1bHQucmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICB0b1JldHVybkVycm9ycyA9IHRvUmV0dXJuRXJyb3JzLmNvbmNhdChwbHVnaW5SZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b1JldHVybkV4ZWN1dGFibGVzLnB1c2gocGx1Z2luUmVzdWx0LmV4ZWN1dGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy8gZW5mIG9mIGl0ZXJhdGlvbiBvbiB0aGUgaW5jaWRlbnRzQnlJZCBrZXlzXG5cbiAgICAgICAgICAgIHZhciB0b1JldHVybkV4ZWN1dGUgPSBmdW5jdGlvbiB0b1JldHVybkV4ZWN1dGUoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b1JldHVybkV4ZWN1dGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvUmV0dXJuRXhlY3V0YWJsZXNbaV0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgZWRpdFJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHRvUmV0dXJuUmVzdWx0LFxuICAgICAgICAgICAgICAgIGVycm9yczogdG9SZXR1cm5FcnJvcnMsXG4gICAgICAgICAgICAgICAgZXhlY3V0ZTogdG9SZXR1cm5FeGVjdXRlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGVkaXRSZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogY2hlY2tzIGlmIGEgZHVyYXRpb24gZWRpdCBpcyBmZWFzaWJsZSBhbmQgZG9lc24ndCBjYXVzZSBjb25mbGljdHNcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IGR1cmF0aW9uIC0gdGhlIG5ldyBkdXJhdGlvblxuICAgICAgICAqKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2hlY2tSZXNpemVkSW5jaWRlbnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tSZXNpemVkSW5jaWRlbnQoZHVyYXRpb25GcmFjdGlvbiwgaW5jaWRlbnQpIHtcbiAgICAgICAgICAgIHZhciBhZGp1c3RNaWxsaXNlY29uZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcblxuICAgICAgICAgICAgLy8gSUYgVEhFIEdST1VQIEhBUyBOTyBQQVJFTlRTIChJUyBBIENMSVApXG4gICAgICAgICAgICBpZiAoaW5jaWRlbnQuaWQgIT0gdGhpcy5pZCkge1xuICAgICAgICAgICAgICAgIC8vIGdldCBhbGwgaW5jaWRlbnRzIHNlcGFyYXRlZCBieSBwbHVnaW5cbiAgICAgICAgICAgICAgICB2YXIgaW5jaWRlbnRzQnlJZCA9IGluY2lkZW50LmdldEluY2lkZW50c0J5Q2hhbm5lbCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gcHJlcGFyZSB0aGUgcmV0dXJuIHBheWxvYWRcbiAgICAgICAgICAgICAgICB2YXIgdG9SZXR1cm5SZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciB0b1JldHVybkVycm9ycyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciB0b1JldHVybkV4ZWN1dGFibGVzID0gW107XG4gICAgICAgICAgICAgICAgLy8gZm9yIGVhY2gga2V5IG9mIHRoZSBpbmNpZGVudHNCeUlkIG9iamVjdCBwZXJmb3JtIHRoZSBjaGVja1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGluY2lkZW50c0J5SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcGVyZm9ybSB0aGUgY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFkanVzdGVkSW5jaWRlbnRzID0gaGVscGVyLnN5c3RvbGVEaWFzdG9sZVByb2plY3Rpb25zKGluY2lkZW50c0J5SWRba2V5XSwgZHVyYXRpb25GcmFjdGlvbiwgYWRqdXN0TWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGx1Z2luUmVzdWx0ID0gdGhpcy5pbnN0YW50aWF0ZWRDaGFubmVsc1trZXldLmNoZWNrUmVzaXplZEluY2lkZW50cyhhZGp1c3RlZEluY2lkZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIHRvUmV0dXJuUmVzdWx0ID0gdG9SZXR1cm5SZXN1bHQgJiYgcGx1Z2luUmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBsdWdpblJlc3VsdC5yZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1JldHVybkVycm9ycyA9IHRvUmV0dXJuRXJyb3JzLmNvbmNhdChwbHVnaW5SZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvUmV0dXJuRXhlY3V0YWJsZXMucHVzaChwbHVnaW5SZXN1bHQuZXhlY3V0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIGVuZiBvZiBpdGVyYXRpb24gb24gdGhlIGluY2lkZW50c0J5SWQga2V5c1xuXG4gICAgICAgICAgICAgICAgdmFyIHRvUmV0dXJuRXhlY3V0ZSA9IGZ1bmN0aW9uIHRvUmV0dXJuRXhlY3V0ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b1JldHVybkV4ZWN1dGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1JldHVybkV4ZWN1dGFibGVzW2ldKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIGVkaXRSZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogdG9SZXR1cm5SZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yczogdG9SZXR1cm5FcnJvcnMsXG4gICAgICAgICAgICAgICAgICAgIGV4ZWN1dGU6IHRvUmV0dXJuRXhlY3V0ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVkaXRSZXN1bHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogdHJ1ZSwgZXhlY3V0ZTogZnVuY3Rpb24gZXhlY3V0ZSgpIHt9IH07XG4gICAgICAgICAgICAgICAgLy8gdGhlIHJlc2l6aW5nIG9mIHRoZSBpbnRlcm5hbCBDaGFubmVscyBvY2N1cnMgb24gdGhlIHN5c3RvbERpYXN0b2xlIG1ldGhvZCBvZiB0aGUgR3JvdXBzIHdoZW4gdGhleSBpZGVudGlmeSB0aGF0IHRoZSBHcm91cHMgaXMgYWN0dWFsbHkgYSBDbGlwXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU3RhcnRpbmcgZnJvbSBpdHNlbGYgYW5kIGdvaW5nIGFsbCB0aGUgd2F5IGRvd24gdG8gZWFjaCBhbmQgZXZlcnkgbGVhZiBvZiBpdHMgdHJlZSBpdCBzeXN0b2xzL2RpYXN0b2xlcyB0aGVcbiAgICAgICAgICogSW5jaWRlbnRzXG4gICAgICAgICAqIEBwYXJhbSB7ZmxvYXR9IGR1cmF0aW9uRnJhY3Rpb24gdGhlIGZyYWN0aW9uIG9mIHRoZSBuZXcgZHVyYXRpb24gdG8gdGhlIGV4aXN0aW5nIGR1cmF0aW9uXG4gICAgICAgICoqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzeXN0b2xEaWFzdG9sZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzeXN0b2xEaWFzdG9sZShkdXJhdGlvbkZyYWN0aW9uKSB7XG4gICAgICAgICAgICBfZ2V0KEV4dGVuZGFibGVDbGlwLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEV4dGVuZGFibGVDbGlwLnByb3RvdHlwZSksICdzeXN0b2xEaWFzdG9sZScsIHRoaXMpLmNhbGwodGhpcywgZHVyYXRpb25GcmFjdGlvbik7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmluc3RhbnRpYXRlZENoYW5uZWxzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnN0YW50aWF0ZWRDaGFubmVsc1trZXldLl9yZXNpemUoZHVyYXRpb25GcmFjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldEluY2lkZW50c0J5Q2hhbm5lbCcsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBrZXlzIHRoZSBrZXlzIG9mIGFsbCB0aGUgcGx1Z2lucyBJbmNpZGVudHMgb2Ygd2hpY2ggYXBwZWFyIGluIHRoZVxuICAgICAgICAgKiB0cmVlIG9mIHRoZSBHcm91cC4gQWxsIEluY2lkZW50cyBhcmUgcHJvamVjdGVkIHRvIHRoZSBHcm91cCdzIHRpbWVsaW5lLlxuICAgICAgICAgKiBUaGUgYXJyYXkgaW5jbHVkZXMgdGhlIEdyb3VwJ3MgcHJvamVjdGlvbiB0b29cbiAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluY2lkZW50c0J5Q2hhbm5lbCgpIHtcbiAgICAgICAgICAgIHZhciBhZGp1c3RNaWxsaXNlY29uZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcblxuICAgICAgICAgICAgdmFyIGluY2lkZW50c0J5UGx1Z2luID0ge307XG4gICAgICAgICAgICBpbmNpZGVudHNCeVBsdWdpbltzZWxmQ29udGFpbmVkSW5jaWRlbnRzTnBtTmFtZV0gPSBbe1xuICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kOiBhZGp1c3RNaWxsaXNlY29uZCxcbiAgICAgICAgICAgICAgICBpbmNpZGVudDogdGhpcyxcbiAgICAgICAgICAgICAgICBpZDogdGhpcy5pZFxuICAgICAgICAgICAgfV07XG5cbiAgICAgICAgICAgIHJldHVybiBpbmNpZGVudHNCeVBsdWdpbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnb1RvIG1ldGhvZCBzaG91bGQgYWx3YXlzIGJlIGhhbmRsZWQgYnkgdGhlIENsaXAuIE5vIG90aGVyIEdyb3VwIG5vciBJbmNpZGVudCBjYW4gaGFuZGxlIGdvVG8gYWxvbmUuXG4gICAgICAgICAqIFRodXMsIGlmIHRoZSBHcm91cCBpcyBub3QgdGhlIENsaXAgaXQgcGFzc2VzIHRoZSBjb21tYW5kIHVwLiBJZiB0aGUgR3JvdXAgaXMgdGhlIENsaXAgdGhlbiBpdCBoYW5kbGVzIGdvVG9cbiAgICAgICAgICogYnkgcGFzc2luZyB0aGUgY29tbWFuZCB0byBpdHMgQ2hhbm5lbHMuXG4gICAgICAgICoqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnb1RvJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdvVG8obWlsbGlzZWNvbmQpIHtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgICAgIC8vIGZpcnN0IGRlY2lkZSB0aGUgbWlsbGlzZWNvbmQgd2Ugd2FudCB0byBnb1RvXG4gICAgICAgICAgICBpZiAobWlsbGlzZWNvbmQgPT09IG51bGwgfHwgbWlsbGlzZWNvbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kID0gdGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoJ3JlbGF0aXZlVG8nKSkge1xuICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kICs9IHRoaXMuZ2V0SW5jaWRlbnRNaWxsaXNlY29uZChwcm9wcy5yZWxhdGl2ZVRvKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1pbGxpc2Vjb25kID4gdGhpcy5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kID0gdGhpcy5kdXJhdGlvbjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWlsbGlzZWNvbmQgPCAwKSB7XG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmQgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5pbnN0YW50aWF0ZWRDaGFubmVscykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5zdGFudGlhdGVkQ2hhbm5lbHNba2V5XS5nb1RvKG1pbGxpc2Vjb25kLCBwcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaGFuZGxlUGlwZU1lc3NhZ2UnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlUGlwZU1lc3NhZ2UobmFtZSwgcGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgd2FpdGluZ0lEID0gcGFyYW1zLmJsb2NraW5nV2FpdGluZ0lEO1xuICAgICAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBwaXBlTWVzc2FnZXMuX0JMT0NLSU5HX1dBSVRJTkc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJsb2NraW5nV2FpdGluZ3MuaGFzT3duUHJvcGVydHkod2FpdGluZ0lEKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVscGVyLmVycm9yKCdCbG9ja2luZyB3YWl0aW5nIHdpdGggaWQ9JyArIHdhaXRpbmdJRCArICcgYWxyZWFkeSBleGlzdHMuIEJsb2NraW5nIHdhaXRpbmcgaXMgZ29pbmcgdG8gYmUgZGlzY2FyZGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaGVscGVyLm5vdGljZSgnYWRkaW5nIGJsb2NraW5nIHdhaXRpbmcgd2l0aCBpZDogJyArIHdhaXRpbmdJRCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tpbmdXYWl0aW5nc1t3YWl0aW5nSURdID0gcGFyYW1zO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJsb2NrKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgcGlwZU1lc3NhZ2VzLl9VTkJMT0NLX1dBSVRJTkc6XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5ibG9ja2luZ1dhaXRpbmdzLmhhc093blByb3BlcnR5KHdhaXRpbmdJRCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlbHBlci5lcnJvcignQmxvY2tpbmcgd2FpdGluZyB3aXRoIGlkPScgKyB3YWl0aW5nSUQgKyAnIGRvZXMgbm90IGV4aXN0IGFuZCB0aHVzIHVuYmxvY2tpbmcgY2FuIG5vdCBiZSBwZXJmb3JtZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5ibG9ja2luZ1dhaXRpbmdzW3dhaXRpbmdJRF07XG5cbiAgICAgICAgICAgICAgICAgICAgaGVscGVyLm5vdGljZSgncmVtb3ZpbmcgYmxvY2tpbmcgd2FpdGluZyB3aXRoIGlkOiAnICsgd2FpdGluZ0lEKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYWZ0ZXIgdGhlIHVuYmxvY2tpbmcgdGhlcmUgYXJlIG5vIG90aGVyIGJsb2NraW5nIHdhaXRpbmdzOlxuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5ibG9ja2luZ1dhaXRpbmdzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBDbGlwIGlzIG9uIGJsb2NrZWQgc3RhdGUgcGxheVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51bmJsb2NrKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBwaXBlTWVzc2FnZXMuX0NMSVBfRURJVElOR19TVEFUVVM6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVkaXRpbmdTdGF0dXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NldFZvbHVtZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWb2x1bWUobmV3VmFsKSB7XG4gICAgICAgICAgICB0aGlzLnZvbHVtZSA9IHBhcnNlRmxvYXQobmV3VmFsKTtcbiAgICAgICAgICAgIHRoaXMucHV0TWVzc2FnZU9uUGlwZShwaXBlTWVzc2FnZXMuX0dBSU5fQ0hBTkdFLCB7IGdhaW46IG5ld1ZhbCB9LCBmYWxzZSwgXCJkb3duXCIpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdvbkFybScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkFybSgpIHtcbiAgICAgICAgICAgIHRoaXMuYmxvY2tpbmdXYWl0aW5ncyA9IHt9O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfb25HZXRDb250ZXh0T25jZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25HZXRDb250ZXh0T25jZSgpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gQ2xpcHMgZG8gbm90IGdldCBjb250ZXh0IGZyb20gbm9vbmVcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZXhwb3J0U3RhdGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZXhwb3J0U3RhdGUoKSB7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBfZ2V0KEV4dGVuZGFibGVDbGlwLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEV4dGVuZGFibGVDbGlwLnByb3RvdHlwZSksICdleHBvcnRTdGF0ZScsIHRoaXMpLmNhbGwodGhpcywgcHJvcHMpO1xuXG4gICAgICAgICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoJ2V4cG9ydENoYW5uZWxzJykpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMuZXhwb3J0Q2hhbm5lbHMgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5uZWxzVG9FeHBvcnQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgY2hhbm5lbCBpbiB0aGlzLmluc3RhbnRpYXRlZENoYW5uZWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3N0YXRlID0gdGhpcy5pbnN0YW50aWF0ZWRDaGFubmVsc1tjaGFubmVsXS5leHBvcnRTdGF0ZShwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUubWNfcGx1Z2luX25wbV9uYW1lID0gY2hhbm5lbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxzVG9FeHBvcnQucHVzaChfc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2hhbm5lbHMgPSBjaGFubmVsc1RvRXhwb3J0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdpc0hlYWRsZXNzQ2xpcCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjb250ZXh0JyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vd25Db250ZXh0O1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEV4dGVuZGFibGVDbGlwO1xufShHcm91cCk7XG5cbm1vZHVsZS5leHBvcnRzID0gRXh0ZW5kYWJsZUNsaXA7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/ExtendableClip.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/SCGroup.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/SCGroup.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Helper = __webpack_require__(/*! ../../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar conf = __webpack_require__(/*! ../../configuration/generalConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\n\n// context handlers\nvar IframeContextHandler = __webpack_require__(/*! ./helpers/IframeContextHandler */ \"./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/IframeContextHandler.js\");\nvar PlainContextHandler = __webpack_require__(/*! ./helpers/PlainContextHandler */ \"./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/PlainContextHandler.js\");\nvar WebComponentContextHandler = __webpack_require__(/*! ./helpers/WebComponentContextHandler */ \"./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/WebComponentContextHandler.js\");\n\nvar ExtendableClip = __webpack_require__(/*! ./ExtendableClip */ \"./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/ExtendableClip.js\");\n\nvar Clip = function (_ExtendableClip) {\n    _inherits(Clip, _ExtendableClip);\n\n    /**\n     * @param {object} props - an object that should contain all of the following keys:\n     * - html (the html template to render)\n     * - css (the css template of the isolated tree)\n     * - initParams (optional / the initialisation parameteres that will be passed both on the css and the html templates in order to render)\n     * - host (an Element object that will host the isolated tree)\n     * - containerParams (an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc)\n     * - type (optional, defaults to \"closed\") the type of the Clip. It can be one of the:\n     *  - closed (if closed then if shadow dom is supported by the browser it renders a shadow dom component else it falls back to iframe) \n     *  - plain (if plain it just uses the existing content of the host)\n     *  - iframe (if iframe then it renders as an iframe component)\n    */\n    function Clip() {\n        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var oldProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n        _classCallCheck(this, Clip);\n\n        var attrsToPass = void 0,\n            propsToUse = void 0;\n\n        /*\n        backwards compatibility. If the user doesn't pass a second argument on the constructor then this is \n        the new way of initialising a Group (only props).\n        */\n        if (oldProps === null) {\n            attrsToPass = {};\n            propsToUse = props;\n        } else {\n            // else, in case the user has passed two arguments then both should be used\n            attrsToPass = props;\n            propsToUse = oldProps;\n        }\n\n        var clipType = conf.selfContainedContextHandler;\n        if (propsToUse.hasOwnProperty(\"type\")) {\n            clipType = propsToUse.type;\n        }\n\n        if (!propsToUse.hasOwnProperty('html') && (clipType === \"iframe\" || clipType === \"openiframe\")) {\n            var _ret;\n\n            helper.error('Self Contained Incident expects the html key on its constructor properties which is missing');\n            return _ret = false, _possibleConstructorReturn(_this, _ret);\n        }\n\n        if (!propsToUse.hasOwnProperty('css') && clipType === \"iframe\") {\n            var _ret2;\n\n            helper.error('Self Contained Incident expects the css key on its constructor properties which is missing');\n            return _ret2 = false, _possibleConstructorReturn(_this, _ret2);\n        }\n\n        if (!propsToUse.hasOwnProperty('host')) {\n            var _ret3;\n\n            helper.error('Self Contained Incident expects the host key on its constructor properties which is missing');\n            return _ret3 = false, _possibleConstructorReturn(_this, _ret3);\n        }\n\n        var ContextHanlder = null;\n        if (clipType === 'closed') {\n            if (document.head.createShadowRoot || document.head.attachShadow) {\n                ContextHanlder = WebComponentContextHandler;\n            } else {\n                ContextHanlder = IframeContextHandler;\n            }\n        } else if (clipType === \"plain\") {\n            ContextHanlder = PlainContextHandler;\n        } else if (clipType === 'iframe') {\n            ContextHanlder = IframeContextHandler;\n        } else {\n            var _ret4;\n\n            helper.error('Clip type ' + clipType + ' is not supported');\n            return _ret4 = false, _possibleConstructorReturn(_this, _ret4);\n        }\n\n        var contextHanlder = new ContextHanlder(propsToUse);\n\n        var _this = _possibleConstructorReturn(this, (Clip.__proto__ || Object.getPrototypeOf(Clip)).call(this, attrsToPass, propsToUse));\n\n        _this.ownContext = contextHanlder.context;\n        _this.iframe = contextHanlder.iframeElement;\n\n        _this.forceExportIncidents = true;\n        return _this;\n    }\n\n    _createClass(Clip, [{\n        key: 'renderHTML',\n        value: function renderHTML() {}\n    }, {\n        key: 'renderCSS',\n        value: function renderCSS() {}\n    }, {\n        key: 'ready',\n        value: function ready() {\n            this.stop();\n            this.setCurrentMillisecond(0);\n            this.recalcState(0);\n            this.restore();\n        }\n    }, {\n        key: 'rootElement',\n        get: function get() {\n            return this.ownContext.clipContainer;\n        }\n    }]);\n\n    return Clip;\n}(ExtendableClip);\n\nmodule.exports = Clip;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvcmVQbHVnaW5zL1NlbGZDb250YWluZWRJbmNpZGVudHMvU0NHcm91cC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2Rpc3QvY29yZVBsdWdpbnMvU2VsZkNvbnRhaW5lZEluY2lkZW50cy9TQ0dyb3VwLmpzP2I2M2IiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBIZWxwZXIgPSByZXF1aXJlKCcuLi8uLi9fY29yZVV0aWxzL0hlbHBlcicpO1xudmFyIGhlbHBlciA9IG5ldyBIZWxwZXIoKTtcbnZhciBjb25mID0gcmVxdWlyZSgnLi4vLi4vY29uZmlndXJhdGlvbi9nZW5lcmFsQ29uZicpO1xuXG4vLyBjb250ZXh0IGhhbmRsZXJzXG52YXIgSWZyYW1lQ29udGV4dEhhbmRsZXIgPSByZXF1aXJlKCcuL2hlbHBlcnMvSWZyYW1lQ29udGV4dEhhbmRsZXInKTtcbnZhciBQbGFpbkNvbnRleHRIYW5kbGVyID0gcmVxdWlyZSgnLi9oZWxwZXJzL1BsYWluQ29udGV4dEhhbmRsZXInKTtcbnZhciBXZWJDb21wb25lbnRDb250ZXh0SGFuZGxlciA9IHJlcXVpcmUoJy4vaGVscGVycy9XZWJDb21wb25lbnRDb250ZXh0SGFuZGxlcicpO1xuXG52YXIgRXh0ZW5kYWJsZUNsaXAgPSByZXF1aXJlKCcuL0V4dGVuZGFibGVDbGlwJyk7XG5cbnZhciBDbGlwID0gZnVuY3Rpb24gKF9FeHRlbmRhYmxlQ2xpcCkge1xuICAgIF9pbmhlcml0cyhDbGlwLCBfRXh0ZW5kYWJsZUNsaXApO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzIC0gYW4gb2JqZWN0IHRoYXQgc2hvdWxkIGNvbnRhaW4gYWxsIG9mIHRoZSBmb2xsb3dpbmcga2V5czpcbiAgICAgKiAtIGh0bWwgKHRoZSBodG1sIHRlbXBsYXRlIHRvIHJlbmRlcilcbiAgICAgKiAtIGNzcyAodGhlIGNzcyB0ZW1wbGF0ZSBvZiB0aGUgaXNvbGF0ZWQgdHJlZSlcbiAgICAgKiAtIGluaXRQYXJhbXMgKG9wdGlvbmFsIC8gdGhlIGluaXRpYWxpc2F0aW9uIHBhcmFtZXRlcmVzIHRoYXQgd2lsbCBiZSBwYXNzZWQgYm90aCBvbiB0aGUgY3NzIGFuZCB0aGUgaHRtbCB0ZW1wbGF0ZXMgaW4gb3JkZXIgdG8gcmVuZGVyKVxuICAgICAqIC0gaG9zdCAoYW4gRWxlbWVudCBvYmplY3QgdGhhdCB3aWxsIGhvc3QgdGhlIGlzb2xhdGVkIHRyZWUpXG4gICAgICogLSBjb250YWluZXJQYXJhbXMgKGFuIG9iamVjdCB0aGF0IGhvbGRzIHBhcmFtZXRlcnMgdG8gYWZmZWN0IHRoZSBjb250YWluZXIgb2YgdGhlIGlzb2xhdGVkIHRyZWUsIGUuZy4gd2lkdGgsIGhlaWdodCBldGMpXG4gICAgICogLSB0eXBlIChvcHRpb25hbCwgZGVmYXVsdHMgdG8gXCJjbG9zZWRcIikgdGhlIHR5cGUgb2YgdGhlIENsaXAuIEl0IGNhbiBiZSBvbmUgb2YgdGhlOlxuICAgICAqICAtIGNsb3NlZCAoaWYgY2xvc2VkIHRoZW4gaWYgc2hhZG93IGRvbSBpcyBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIgaXQgcmVuZGVycyBhIHNoYWRvdyBkb20gY29tcG9uZW50IGVsc2UgaXQgZmFsbHMgYmFjayB0byBpZnJhbWUpIFxuICAgICAqICAtIHBsYWluIChpZiBwbGFpbiBpdCBqdXN0IHVzZXMgdGhlIGV4aXN0aW5nIGNvbnRlbnQgb2YgdGhlIGhvc3QpXG4gICAgICogIC0gaWZyYW1lIChpZiBpZnJhbWUgdGhlbiBpdCByZW5kZXJzIGFzIGFuIGlmcmFtZSBjb21wb25lbnQpXG4gICAgKi9cbiAgICBmdW5jdGlvbiBDbGlwKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgICB2YXIgb2xkUHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG5cbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENsaXApO1xuXG4gICAgICAgIHZhciBhdHRyc1RvUGFzcyA9IHZvaWQgMCxcbiAgICAgICAgICAgIHByb3BzVG9Vc2UgPSB2b2lkIDA7XG5cbiAgICAgICAgLypcbiAgICAgICAgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIElmIHRoZSB1c2VyIGRvZXNuJ3QgcGFzcyBhIHNlY29uZCBhcmd1bWVudCBvbiB0aGUgY29uc3RydWN0b3IgdGhlbiB0aGlzIGlzIFxuICAgICAgICB0aGUgbmV3IHdheSBvZiBpbml0aWFsaXNpbmcgYSBHcm91cCAob25seSBwcm9wcykuXG4gICAgICAgICovXG4gICAgICAgIGlmIChvbGRQcm9wcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgYXR0cnNUb1Bhc3MgPSB7fTtcbiAgICAgICAgICAgIHByb3BzVG9Vc2UgPSBwcm9wcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVsc2UsIGluIGNhc2UgdGhlIHVzZXIgaGFzIHBhc3NlZCB0d28gYXJndW1lbnRzIHRoZW4gYm90aCBzaG91bGQgYmUgdXNlZFxuICAgICAgICAgICAgYXR0cnNUb1Bhc3MgPSBwcm9wcztcbiAgICAgICAgICAgIHByb3BzVG9Vc2UgPSBvbGRQcm9wcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjbGlwVHlwZSA9IGNvbmYuc2VsZkNvbnRhaW5lZENvbnRleHRIYW5kbGVyO1xuICAgICAgICBpZiAocHJvcHNUb1VzZS5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikpIHtcbiAgICAgICAgICAgIGNsaXBUeXBlID0gcHJvcHNUb1VzZS50eXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwcm9wc1RvVXNlLmhhc093blByb3BlcnR5KCdodG1sJykgJiYgKGNsaXBUeXBlID09PSBcImlmcmFtZVwiIHx8IGNsaXBUeXBlID09PSBcIm9wZW5pZnJhbWVcIikpIHtcbiAgICAgICAgICAgIHZhciBfcmV0O1xuXG4gICAgICAgICAgICBoZWxwZXIuZXJyb3IoJ1NlbGYgQ29udGFpbmVkIEluY2lkZW50IGV4cGVjdHMgdGhlIGh0bWwga2V5IG9uIGl0cyBjb25zdHJ1Y3RvciBwcm9wZXJ0aWVzIHdoaWNoIGlzIG1pc3NpbmcnKTtcbiAgICAgICAgICAgIHJldHVybiBfcmV0ID0gZmFsc2UsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcHJvcHNUb1VzZS5oYXNPd25Qcm9wZXJ0eSgnY3NzJykgJiYgY2xpcFR5cGUgPT09IFwiaWZyYW1lXCIpIHtcbiAgICAgICAgICAgIHZhciBfcmV0MjtcblxuICAgICAgICAgICAgaGVscGVyLmVycm9yKCdTZWxmIENvbnRhaW5lZCBJbmNpZGVudCBleHBlY3RzIHRoZSBjc3Mga2V5IG9uIGl0cyBjb25zdHJ1Y3RvciBwcm9wZXJ0aWVzIHdoaWNoIGlzIG1pc3NpbmcnKTtcbiAgICAgICAgICAgIHJldHVybiBfcmV0MiA9IGZhbHNlLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwcm9wc1RvVXNlLmhhc093blByb3BlcnR5KCdob3N0JykpIHtcbiAgICAgICAgICAgIHZhciBfcmV0MztcblxuICAgICAgICAgICAgaGVscGVyLmVycm9yKCdTZWxmIENvbnRhaW5lZCBJbmNpZGVudCBleHBlY3RzIHRoZSBob3N0IGtleSBvbiBpdHMgY29uc3RydWN0b3IgcHJvcGVydGllcyB3aGljaCBpcyBtaXNzaW5nJyk7XG4gICAgICAgICAgICByZXR1cm4gX3JldDMgPSBmYWxzZSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBDb250ZXh0SGFubGRlciA9IG51bGw7XG4gICAgICAgIGlmIChjbGlwVHlwZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5oZWFkLmNyZWF0ZVNoYWRvd1Jvb3QgfHwgZG9jdW1lbnQuaGVhZC5hdHRhY2hTaGFkb3cpIHtcbiAgICAgICAgICAgICAgICBDb250ZXh0SGFubGRlciA9IFdlYkNvbXBvbmVudENvbnRleHRIYW5kbGVyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBDb250ZXh0SGFubGRlciA9IElmcmFtZUNvbnRleHRIYW5kbGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNsaXBUeXBlID09PSBcInBsYWluXCIpIHtcbiAgICAgICAgICAgIENvbnRleHRIYW5sZGVyID0gUGxhaW5Db250ZXh0SGFuZGxlcjtcbiAgICAgICAgfSBlbHNlIGlmIChjbGlwVHlwZSA9PT0gJ2lmcmFtZScpIHtcbiAgICAgICAgICAgIENvbnRleHRIYW5sZGVyID0gSWZyYW1lQ29udGV4dEhhbmRsZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgX3JldDQ7XG5cbiAgICAgICAgICAgIGhlbHBlci5lcnJvcignQ2xpcCB0eXBlICcgKyBjbGlwVHlwZSArICcgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgcmV0dXJuIF9yZXQ0ID0gZmFsc2UsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0NCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29udGV4dEhhbmxkZXIgPSBuZXcgQ29udGV4dEhhbmxkZXIocHJvcHNUb1VzZSk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKENsaXAuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDbGlwKSkuY2FsbCh0aGlzLCBhdHRyc1RvUGFzcywgcHJvcHNUb1VzZSkpO1xuXG4gICAgICAgIF90aGlzLm93bkNvbnRleHQgPSBjb250ZXh0SGFubGRlci5jb250ZXh0O1xuICAgICAgICBfdGhpcy5pZnJhbWUgPSBjb250ZXh0SGFubGRlci5pZnJhbWVFbGVtZW50O1xuXG4gICAgICAgIF90aGlzLmZvcmNlRXhwb3J0SW5jaWRlbnRzID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhDbGlwLCBbe1xuICAgICAgICBrZXk6ICdyZW5kZXJIVE1MJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckhUTUwoKSB7fVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVuZGVyQ1NTJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckNTUygpIHt9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZWFkeScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkeSgpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50TWlsbGlzZWNvbmQoMCk7XG4gICAgICAgICAgICB0aGlzLnJlY2FsY1N0YXRlKDApO1xuICAgICAgICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3Jvb3RFbGVtZW50JyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vd25Db250ZXh0LmNsaXBDb250YWluZXI7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQ2xpcDtcbn0oRXh0ZW5kYWJsZUNsaXApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENsaXA7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/SCGroup.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/SCIChannel.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/SCIChannel.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Helper = __webpack_require__(/*! ../../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar conf = __webpack_require__(/*! ../../configuration/generalConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\nvar Channel = __webpack_require__(/*! ../../_Channels/Channel */ \"./node_modules/@kissmybutton/motorcortex/dist/_Channels/Channel.js\");\nvar _sortBy = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.sortby/index.js */ \"./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.sortby/index.js\");\nvar _filter = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.filter/index.js */ \"./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.filter/index.js\");\n\nvar SCIChannel = function (_Channel) {\n    _inherits(SCIChannel, _Channel);\n\n    function SCIChannel() {\n        _classCallCheck(this, SCIChannel);\n\n        return _possibleConstructorReturn(this, (SCIChannel.__proto__ || Object.getPrototypeOf(SCIChannel)).apply(this, arguments));\n    }\n\n    _createClass(SCIChannel, [{\n        key: 'onInitialise',\n\n        /*\n        this.incidents is a collection of {incident, id, millisecond} objects always kept in order\n            from lower to higher millisecond\n        this.incidetnsById is an index of the incidents kept by id (this.incidents[incident-id] = Incident)\n        */\n        value: function onInitialise() {\n            this.incidents = [];\n            this.incidentsById = {};\n        }\n    }, {\n        key: '_resize',\n        value: function _resize(durationFraction) {\n            for (var i = 0; i < this.incidents.length; i++) {\n                this.incidents[i].millisecond = this.incidents[i].millisecond * durationFraction;\n            }\n        }\n\n        /**\n         * On this method the user defines the specific rules that apply on the plugin itself and on the Incidents of the plugin itself\n         * The method should either return {result: true} or {result: false, errors:[{error-object}]}, where error-object has the structure:\n         *  {\n                incident: // reference to the Incident object that has bee discarded\n                error: // text\n            }\n        * @param {array} incidents - a colleciton of all incidents to be added on the form:\n        * \n            {\n                id\n                millisecond\n                incident\n            }\n        * @returns {object} - \n        * either:\n            {\n                result:true,\n                execute: // a function that when executed it will add the Incidents on the Channels\n            }\n            or\n            {\n                result: false,\n                errors\n            }\n        */\n\n    }, {\n        key: 'checkAddition',\n        value: function checkAddition(incidents) {\n            var errors = [];\n            var candidateIncidentsById = {};\n\n            for (var i = 0; i < incidents.length; i++) {\n                candidateIncidentsById[incidents[i].id] = incidents[i].incident;\n                if (this.incidentsById.hasOwnProperty(incidents[i].id)) {\n                    helper.error('Incident with the id ' + incidents[i].id + ' already exists. Addition is rejected.');\n                    errors.push({\n                        type: 'Already existing id',\n                        meta: {\n                            id: incidents[i].id\n                        }\n                    });\n                }\n            }\n\n            if (errors.length > 0) {\n                return {\n                    result: false,\n                    errors: errors\n                };\n            }\n\n            var that = this;\n            var exec = function exec() {\n                that.incidentsById = Object.assign(that.incidentsById, candidateIncidentsById);\n                that.incidents = that.incidents.concat(incidents);\n                that.incidents = _sortBy(that.incidents, [function (laneItem) {\n                    return laneItem.millisecond;\n                }]);\n                for (var _i = 0; _i < incidents.length; _i++) {\n                    incidents[_i].incident.goTo(that.runTimeInfo.currentMillisecond - incidents[_i].millisecond);\n                }\n            };\n\n            return { result: true, execute: exec };\n        }\n\n        /**\n        @param {array} incidentsArray - A collection of the Incidetns to get edited in the form:\n        {\n            id\n            millisecond\n            incident\n        }\n        @param {int} millisecondsDelta- the delta of the star point of the provided incidents\n        */\n\n    }, {\n        key: 'checkEdit',\n        value: function checkEdit(incidentsArray, millisecondsDelta) {\n            var that = this;\n            var exec = function exec() {\n                for (var i = 0; i < incidentsArray.length; i++) {\n                    for (var j = 0; j < that.incidents.length; j++) {\n                        if (that.incidents[j].id === incidentsArray[i].id) {\n                            that.incidents[j].millisecond += millisecondsDelta;\n                            that.incidents[i].incident.goTo(that.runTimeInfo.currentMillisecond - that.incidents[i].millisecond);\n                            break;\n                        }\n                    }\n                }\n\n                that.incidents = _sortBy(that.incidents, [function (laneItem) {\n                    return laneItem.millisecond;\n                }]);\n            };\n\n            return { result: true, execute: exec };\n        }\n    }, {\n        key: 'checkDelete',\n        value: function checkDelete(incidentsArray) {\n            var that = this;\n            var incidentIds = [];\n            for (var i = 0; i < incidentsArray.length; i++) {\n                incidentIds.push(incidentsArray[i].id);\n            }\n\n            var exec = function exec() {\n                var newIncidents = _filter(that.incidents, function (incident) {\n                    return incidentIds.indexOf(incident.id) === -1;\n                });\n\n                that.incidents = newIncidents;\n                for (var _i2 = 0; _i2 < incidentIds.length; _i2++) {\n                    delete that.incidentsById[incidentIds[_i2]];\n                }\n            };\n\n            return { result: true, execute: exec };\n        }\n\n        /**\n        * @param {array} incidents - [{id, start, end, startDelta}] \n        */\n\n    }, {\n        key: 'checkResizedIncidents',\n        value: function checkResizedIncidents(incidents) {\n            var that = this;\n            var exec = function exec() {\n                for (var i = 0; i < incidents.length; i++) {\n                    for (var j = 0; j < that.incidents.length; j++) {\n                        if (that.incidents[j].id === incidents[i].id) {\n                            that.incidents[j].millisecond += incidents[i].startDelta;\n                            that.incidents[i].incident.goTo(that.runTimeInfo.currentMillisecond - that.incidents[i].millisecond);\n                            break;\n                        }\n                    }\n                }\n\n                that.incidents = _sortBy(that.incidents, [function (laneItem) {\n                    return laneItem.millisecond;\n                }]);\n            };\n\n            return { result: true, execute: exec };\n        }\n\n        /**\n         @param {int} from - the millisecond to start from\n         @param {int} to - the millisecond to go to\n         */\n\n    }, {\n        key: 'moveTo',\n        value: function moveTo(from, to) {\n            for (var i = 0; i < this.incidents.length; i++) {\n                this.incidents[i].incident.goTo(to - this.incidents[i].millisecond, { previousStop: from - this.incidents[i].millisecond });\n            }\n        }\n    }]);\n\n    return SCIChannel;\n}(Channel);\n\nmodule.exports = SCIChannel;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvcmVQbHVnaW5zL1NlbGZDb250YWluZWRJbmNpZGVudHMvU0NJQ2hhbm5lbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2Rpc3QvY29yZVBsdWdpbnMvU2VsZkNvbnRhaW5lZEluY2lkZW50cy9TQ0lDaGFubmVsLmpzP2I4ODEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBIZWxwZXIgPSByZXF1aXJlKCcuLi8uLi9fY29yZVV0aWxzL0hlbHBlcicpO1xudmFyIGhlbHBlciA9IG5ldyBIZWxwZXIoKTtcbnZhciBjb25mID0gcmVxdWlyZSgnLi4vLi4vY29uZmlndXJhdGlvbi9nZW5lcmFsQ29uZicpO1xudmFyIENoYW5uZWwgPSByZXF1aXJlKCcuLi8uLi9fQ2hhbm5lbHMvQ2hhbm5lbCcpO1xudmFyIF9zb3J0QnkgPSByZXF1aXJlKCcuLi8uLi8uLi9sb2Rhc2gtY3VzdG9tLWJ1aWxkL21vZHVsYXJpemUvbG9kYXNoLnNvcnRieS9pbmRleC5qcycpO1xudmFyIF9maWx0ZXIgPSByZXF1aXJlKCcuLi8uLi8uLi9sb2Rhc2gtY3VzdG9tLWJ1aWxkL21vZHVsYXJpemUvbG9kYXNoLmZpbHRlci9pbmRleC5qcycpO1xuXG52YXIgU0NJQ2hhbm5lbCA9IGZ1bmN0aW9uIChfQ2hhbm5lbCkge1xuICAgIF9pbmhlcml0cyhTQ0lDaGFubmVsLCBfQ2hhbm5lbCk7XG5cbiAgICBmdW5jdGlvbiBTQ0lDaGFubmVsKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU0NJQ2hhbm5lbCk7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChTQ0lDaGFubmVsLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU0NJQ2hhbm5lbCkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhTQ0lDaGFubmVsLCBbe1xuICAgICAgICBrZXk6ICdvbkluaXRpYWxpc2UnLFxuXG4gICAgICAgIC8qXG4gICAgICAgIHRoaXMuaW5jaWRlbnRzIGlzIGEgY29sbGVjdGlvbiBvZiB7aW5jaWRlbnQsIGlkLCBtaWxsaXNlY29uZH0gb2JqZWN0cyBhbHdheXMga2VwdCBpbiBvcmRlclxuICAgICAgICAgICAgZnJvbSBsb3dlciB0byBoaWdoZXIgbWlsbGlzZWNvbmRcbiAgICAgICAgdGhpcy5pbmNpZGV0bnNCeUlkIGlzIGFuIGluZGV4IG9mIHRoZSBpbmNpZGVudHMga2VwdCBieSBpZCAodGhpcy5pbmNpZGVudHNbaW5jaWRlbnQtaWRdID0gSW5jaWRlbnQpXG4gICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkluaXRpYWxpc2UoKSB7XG4gICAgICAgICAgICB0aGlzLmluY2lkZW50cyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5pbmNpZGVudHNCeUlkID0ge307XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19yZXNpemUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc2l6ZShkdXJhdGlvbkZyYWN0aW9uKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmNpZGVudHNbaV0ubWlsbGlzZWNvbmQgPSB0aGlzLmluY2lkZW50c1tpXS5taWxsaXNlY29uZCAqIGR1cmF0aW9uRnJhY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogT24gdGhpcyBtZXRob2QgdGhlIHVzZXIgZGVmaW5lcyB0aGUgc3BlY2lmaWMgcnVsZXMgdGhhdCBhcHBseSBvbiB0aGUgcGx1Z2luIGl0c2VsZiBhbmQgb24gdGhlIEluY2lkZW50cyBvZiB0aGUgcGx1Z2luIGl0c2VsZlxuICAgICAgICAgKiBUaGUgbWV0aG9kIHNob3VsZCBlaXRoZXIgcmV0dXJuIHtyZXN1bHQ6IHRydWV9IG9yIHtyZXN1bHQ6IGZhbHNlLCBlcnJvcnM6W3tlcnJvci1vYmplY3R9XX0sIHdoZXJlIGVycm9yLW9iamVjdCBoYXMgdGhlIHN0cnVjdHVyZTpcbiAgICAgICAgICogIHtcbiAgICAgICAgICAgICAgICBpbmNpZGVudDogLy8gcmVmZXJlbmNlIHRvIHRoZSBJbmNpZGVudCBvYmplY3QgdGhhdCBoYXMgYmVlIGRpc2NhcmRlZFxuICAgICAgICAgICAgICAgIGVycm9yOiAvLyB0ZXh0XG4gICAgICAgICAgICB9XG4gICAgICAgICogQHBhcmFtIHthcnJheX0gaW5jaWRlbnRzIC0gYSBjb2xsZWNpdG9uIG9mIGFsbCBpbmNpZGVudHMgdG8gYmUgYWRkZWQgb24gdGhlIGZvcm06XG4gICAgICAgICogXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWRcbiAgICAgICAgICAgICAgICBtaWxsaXNlY29uZFxuICAgICAgICAgICAgICAgIGluY2lkZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICogQHJldHVybnMge29iamVjdH0gLSBcbiAgICAgICAgKiBlaXRoZXI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVzdWx0OnRydWUsXG4gICAgICAgICAgICAgICAgZXhlY3V0ZTogLy8gYSBmdW5jdGlvbiB0aGF0IHdoZW4gZXhlY3V0ZWQgaXQgd2lsbCBhZGQgdGhlIEluY2lkZW50cyBvbiB0aGUgQ2hhbm5lbHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9yXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2hlY2tBZGRpdGlvbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0FkZGl0aW9uKGluY2lkZW50cykge1xuICAgICAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZUluY2lkZW50c0J5SWQgPSB7fTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVJbmNpZGVudHNCeUlkW2luY2lkZW50c1tpXS5pZF0gPSBpbmNpZGVudHNbaV0uaW5jaWRlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5jaWRlbnRzQnlJZC5oYXNPd25Qcm9wZXJ0eShpbmNpZGVudHNbaV0uaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlbHBlci5lcnJvcignSW5jaWRlbnQgd2l0aCB0aGUgaWQgJyArIGluY2lkZW50c1tpXS5pZCArICcgYWxyZWFkeSBleGlzdHMuIEFkZGl0aW9uIGlzIHJlamVjdGVkLicpO1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQWxyZWFkeSBleGlzdGluZyBpZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGluY2lkZW50c1tpXS5pZFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yczogZXJyb3JzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGV4ZWMgPSBmdW5jdGlvbiBleGVjKCkge1xuICAgICAgICAgICAgICAgIHRoYXQuaW5jaWRlbnRzQnlJZCA9IE9iamVjdC5hc3NpZ24odGhhdC5pbmNpZGVudHNCeUlkLCBjYW5kaWRhdGVJbmNpZGVudHNCeUlkKTtcbiAgICAgICAgICAgICAgICB0aGF0LmluY2lkZW50cyA9IHRoYXQuaW5jaWRlbnRzLmNvbmNhdChpbmNpZGVudHMpO1xuICAgICAgICAgICAgICAgIHRoYXQuaW5jaWRlbnRzID0gX3NvcnRCeSh0aGF0LmluY2lkZW50cywgW2Z1bmN0aW9uIChsYW5lSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFuZUl0ZW0ubWlsbGlzZWNvbmQ7XG4gICAgICAgICAgICAgICAgfV0pO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBpbmNpZGVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGluY2lkZW50c1tfaV0uaW5jaWRlbnQuZ29Ubyh0aGF0LnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCAtIGluY2lkZW50c1tfaV0ubWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogdHJ1ZSwgZXhlY3V0ZTogZXhlYyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgIEBwYXJhbSB7YXJyYXl9IGluY2lkZW50c0FycmF5IC0gQSBjb2xsZWN0aW9uIG9mIHRoZSBJbmNpZGV0bnMgdG8gZ2V0IGVkaXRlZCBpbiB0aGUgZm9ybTpcbiAgICAgICAge1xuICAgICAgICAgICAgaWRcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICBpbmNpZGVudFxuICAgICAgICB9XG4gICAgICAgIEBwYXJhbSB7aW50fSBtaWxsaXNlY29uZHNEZWx0YS0gdGhlIGRlbHRhIG9mIHRoZSBzdGFyIHBvaW50IG9mIHRoZSBwcm92aWRlZCBpbmNpZGVudHNcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2hlY2tFZGl0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrRWRpdChpbmNpZGVudHNBcnJheSwgbWlsbGlzZWNvbmRzRGVsdGEpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHZhciBleGVjID0gZnVuY3Rpb24gZXhlYygpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluY2lkZW50c0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhhdC5pbmNpZGVudHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LmluY2lkZW50c1tqXS5pZCA9PT0gaW5jaWRlbnRzQXJyYXlbaV0uaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmluY2lkZW50c1tqXS5taWxsaXNlY29uZCArPSBtaWxsaXNlY29uZHNEZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmluY2lkZW50c1tpXS5pbmNpZGVudC5nb1RvKHRoYXQucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kIC0gdGhhdC5pbmNpZGVudHNbaV0ubWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhhdC5pbmNpZGVudHMgPSBfc29ydEJ5KHRoYXQuaW5jaWRlbnRzLCBbZnVuY3Rpb24gKGxhbmVJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsYW5lSXRlbS5taWxsaXNlY29uZDtcbiAgICAgICAgICAgICAgICB9XSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IHRydWUsIGV4ZWN1dGU6IGV4ZWMgfTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2hlY2tEZWxldGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tEZWxldGUoaW5jaWRlbnRzQXJyYXkpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHZhciBpbmNpZGVudElkcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmNpZGVudHNBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGluY2lkZW50SWRzLnB1c2goaW5jaWRlbnRzQXJyYXlbaV0uaWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZXhlYyA9IGZ1bmN0aW9uIGV4ZWMoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0luY2lkZW50cyA9IF9maWx0ZXIodGhhdC5pbmNpZGVudHMsIGZ1bmN0aW9uIChpbmNpZGVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5jaWRlbnRJZHMuaW5kZXhPZihpbmNpZGVudC5pZCkgPT09IC0xO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGhhdC5pbmNpZGVudHMgPSBuZXdJbmNpZGVudHM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgaW5jaWRlbnRJZHMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhhdC5pbmNpZGVudHNCeUlkW2luY2lkZW50SWRzW19pMl1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogdHJ1ZSwgZXhlY3V0ZTogZXhlYyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHthcnJheX0gaW5jaWRlbnRzIC0gW3tpZCwgc3RhcnQsIGVuZCwgc3RhcnREZWx0YX1dIFxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjaGVja1Jlc2l6ZWRJbmNpZGVudHMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tSZXNpemVkSW5jaWRlbnRzKGluY2lkZW50cykge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGV4ZWMgPSBmdW5jdGlvbiBleGVjKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhhdC5pbmNpZGVudHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LmluY2lkZW50c1tqXS5pZCA9PT0gaW5jaWRlbnRzW2ldLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5pbmNpZGVudHNbal0ubWlsbGlzZWNvbmQgKz0gaW5jaWRlbnRzW2ldLnN0YXJ0RGVsdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5pbmNpZGVudHNbaV0uaW5jaWRlbnQuZ29Ubyh0aGF0LnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCAtIHRoYXQuaW5jaWRlbnRzW2ldLm1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoYXQuaW5jaWRlbnRzID0gX3NvcnRCeSh0aGF0LmluY2lkZW50cywgW2Z1bmN0aW9uIChsYW5lSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFuZUl0ZW0ubWlsbGlzZWNvbmQ7XG4gICAgICAgICAgICAgICAgfV0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB0cnVlLCBleGVjdXRlOiBleGVjIH07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgIEBwYXJhbSB7aW50fSBmcm9tIC0gdGhlIG1pbGxpc2Vjb25kIHRvIHN0YXJ0IGZyb21cbiAgICAgICAgIEBwYXJhbSB7aW50fSB0byAtIHRoZSBtaWxsaXNlY29uZCB0byBnbyB0b1xuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbW92ZVRvJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVUbyhmcm9tLCB0bykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5jaWRlbnRzW2ldLmluY2lkZW50LmdvVG8odG8gLSB0aGlzLmluY2lkZW50c1tpXS5taWxsaXNlY29uZCwgeyBwcmV2aW91c1N0b3A6IGZyb20gLSB0aGlzLmluY2lkZW50c1tpXS5taWxsaXNlY29uZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBTQ0lDaGFubmVsO1xufShDaGFubmVsKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTQ0lDaGFubmVsOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/SCIChannel.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/IframeContextHandler.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/IframeContextHandler.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*\niframe[seamless]{\n    background-color: transparent;\n    border: 0px none transparent;\n    padding: 0px;\n    overflow: hidden;\n}\n\nmight need more work for IE. See here: https://stackoverflow.com/a/29209248\n*/\n\nvar Helper = __webpack_require__(/*! ../../../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar conf = __webpack_require__(/*! ../../../configuration/generalConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\n\nvar IframeContextHandler = function () {\n    /**\n     * @param {object} props - an object that should contain all of the following keys:\n     * - html (the html template to render)\n     * - css (the css template of the isolated tree)\n     * - initParams (optional / the initialisation parameteres that will be passed both on the css and the html templates in order to render)\n     * - host (an Element object that will host the isolated tree)\n     * - containerParams (an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc)\n    */\n    function IframeContextHandler() {\n        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, IframeContextHandler);\n\n        if (!helper.isObject(props)) {\n            helper.error('ContextHandler expects an object on its constructor. ' + (typeof props === 'undefined' ? 'undefined' : _typeof(props)) + ' passed');\n            return false;\n        }\n\n        if (!props.hasOwnProperty('html')) {\n            helper.error('ContextHandler expects the html key on its constructor properties which is missing');\n            return false;\n        }\n\n        if (!props.hasOwnProperty('css')) {\n            helper.error('ContextHandler expects the css key on its constructor properties which is missing');\n            return false;\n        }\n\n        var initParams = props.initParams;\n        if (!props.hasOwnProperty('initParams')) {\n            helper.info('ContextHandler got null initParams');\n            initParams = {};\n        }\n\n        if (!props.hasOwnProperty('host')) {\n            helper.error('ContextHandler expects the host key on its constructor properties which is missing');\n            return false;\n        }\n\n        this.isDOM = true;\n\n        var ownerDocument = props.host.ownerDocument;\n\n        if (!ownerDocument.getElementById(\"@kissmybutton/motorcortex/iframeContextHandler/css\")) {\n            var seamlessCSS = '\\n            iframe[seamless]{\\n                background-color: transparent;\\n                border: 0px none transparent;\\n                padding: 0px;\\n                overflow: hidden;\\n            }\\n            ';\n            var iframesCSS = ownerDocument.createElement('style');\n            iframesCSS.id = \"@kissmybutton/motorcortex/iframeContextHandler/css\";\n            iframesCSS.type = 'text/css';\n            var Head = ownerDocument.head || ownerDocument.getElementsByTagName('head')[0];\n            if (iframesCSS.styleSheet) {\n                iframesCSS.styleSheet.cssText = seamlessCSS;\n            } else {\n                iframesCSS.appendChild(ownerDocument.createTextNode(seamlessCSS));\n            }\n\n            Head.appendChild(iframesCSS);\n        }\n\n        // Create an iframe:\n        var iframe = ownerDocument.createElement('iframe');\n        props.host.appendChild(iframe);\n        iframe.setAttribute(\"seamless\", \"seamless\");\n        if (props.hasOwnProperty('containerParams')) {\n            if (props.containerParams.hasOwnProperty('width')) {\n                iframe.setAttribute('width', props.containerParams.width);\n            }\n            if (props.containerParams.hasOwnProperty('height')) {\n                iframe.setAttribute('height', props.containerParams.height);\n            }\n        }\n        // Initialise the iframe\n        iframe.src = '';\n        // Put it in the document (but hidden):\n        var iframeDocument = iframe.contentWindow || iframe.contentDocument;\n        if (iframeDocument.document) {\n            iframeDocument = iframeDocument.document;\n        }\n\n        iframeDocument.write(helper.renderTemplate(props.html, { params: props.initParams }));\n\n        var bodyFixCSS = '\\n        body{\\n            padding:0;\\n            margin:0;\\n        }\\n        ';\n\n        var styleTag = iframeDocument.createElement('style');\n        styleTag.type = 'text/css';\n        if (styleTag.styleSheet) {\n            styleTag.styleSheet.cssText = helper.renderTemplate(props.css, { params: props.initParams }) + bodyFixCSS;\n        } else {\n            styleTag.appendChild(ownerDocument.createTextNode(props.css + bodyFixCSS));\n        }\n\n        var head = iframeDocument.head || iframeDocument.getElementsByTagName('head')[0];\n        head.appendChild(styleTag);\n\n        if (props.hasOwnProperty('fonts')) {\n            for (var i = 0; i < props.fonts.length; i++) {\n                var theFont = props.fonts[i];\n                if (theFont.type === \"google-font\") {\n                    var fontTag = iframeDocument.createElement('link');\n                    fontTag.setAttribute('rel', 'stylesheet');\n                    fontTag.setAttribute('src', theFont.src);\n                    head.appendChild(fontTag);\n                }\n            }\n        }\n\n        this.rootElement = iframe;\n\n        this.context = {\n            document: iframeDocument,\n            window: iframe.contentWindow || iframe,\n            clipContainer: iframe,\n            rootElement: iframeDocument.body,\n            unmount: function unmount() {\n                props.host.removeChild(iframe);\n            },\n            getElements: this.getElements.bind(this),\n            getMCID: this.getMCID.bind(this),\n            setMCID: this.setMCID.bind(this),\n            getElementSelectorByMCID: this.getElementSelectorByMCID.bind(this),\n            getElementByMCID: this.getElementByMCID.bind(this)\n        };\n\n        iframeDocument.close();\n\n        this.elementsByMCID = {};\n    }\n\n    _createClass(IframeContextHandler, [{\n        key: 'getElementByMCID',\n        value: function getElementByMCID(mcid) {\n            if (this.elementsByMCID.hasOwnProperty(mcid)) {\n                return this.elementsByMCID[mcid];\n            } else {\n                var element = this.context.document.querySelector(this.getElementSelectorByMCID(mcid));\n                this.elementsByMCID[mcid] = element;\n                return element;\n            }\n        }\n    }, {\n        key: 'getElements',\n        value: function getElements(selector) {\n            return Array.from(this.context.document.querySelectorAll(selector));\n        }\n    }, {\n        key: 'getMCID',\n        value: function getMCID(element) {\n            return element.getAttribute(conf.elements_data_attribute_name);\n        }\n    }, {\n        key: 'setMCID',\n        value: function setMCID(element, mcid) {\n            element.setAttribute(conf.elements_data_attribute_name, mcid);\n        }\n    }, {\n        key: 'getElementSelectorByMCID',\n        value: function getElementSelectorByMCID(mcid) {\n            return '[' + conf.elements_data_attribute_name + '=\"' + mcid + '\"]';\n        }\n    }]);\n\n    return IframeContextHandler;\n}();\n\nmodule.exports = IframeContextHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvcmVQbHVnaW5zL1NlbGZDb250YWluZWRJbmNpZGVudHMvaGVscGVycy9JZnJhbWVDb250ZXh0SGFuZGxlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2Rpc3QvY29yZVBsdWdpbnMvU2VsZkNvbnRhaW5lZEluY2lkZW50cy9oZWxwZXJzL0lmcmFtZUNvbnRleHRIYW5kbGVyLmpzPzE5NzYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qXG5pZnJhbWVbc2VhbWxlc3Nde1xuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuICAgIGJvcmRlcjogMHB4IG5vbmUgdHJhbnNwYXJlbnQ7XG4gICAgcGFkZGluZzogMHB4O1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG59XG5cbm1pZ2h0IG5lZWQgbW9yZSB3b3JrIGZvciBJRS4gU2VlIGhlcmU6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yOTIwOTI0OFxuKi9cblxudmFyIEhlbHBlciA9IHJlcXVpcmUoJy4uLy4uLy4uL19jb3JlVXRpbHMvSGVscGVyJyk7XG52YXIgaGVscGVyID0gbmV3IEhlbHBlcigpO1xudmFyIGNvbmYgPSByZXF1aXJlKCcuLi8uLi8uLi9jb25maWd1cmF0aW9uL2dlbmVyYWxDb25mJyk7XG5cbnZhciBJZnJhbWVDb250ZXh0SGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgLSBhbiBvYmplY3QgdGhhdCBzaG91bGQgY29udGFpbiBhbGwgb2YgdGhlIGZvbGxvd2luZyBrZXlzOlxuICAgICAqIC0gaHRtbCAodGhlIGh0bWwgdGVtcGxhdGUgdG8gcmVuZGVyKVxuICAgICAqIC0gY3NzICh0aGUgY3NzIHRlbXBsYXRlIG9mIHRoZSBpc29sYXRlZCB0cmVlKVxuICAgICAqIC0gaW5pdFBhcmFtcyAob3B0aW9uYWwgLyB0aGUgaW5pdGlhbGlzYXRpb24gcGFyYW1ldGVyZXMgdGhhdCB3aWxsIGJlIHBhc3NlZCBib3RoIG9uIHRoZSBjc3MgYW5kIHRoZSBodG1sIHRlbXBsYXRlcyBpbiBvcmRlciB0byByZW5kZXIpXG4gICAgICogLSBob3N0IChhbiBFbGVtZW50IG9iamVjdCB0aGF0IHdpbGwgaG9zdCB0aGUgaXNvbGF0ZWQgdHJlZSlcbiAgICAgKiAtIGNvbnRhaW5lclBhcmFtcyAoYW4gb2JqZWN0IHRoYXQgaG9sZHMgcGFyYW1ldGVycyB0byBhZmZlY3QgdGhlIGNvbnRhaW5lciBvZiB0aGUgaXNvbGF0ZWQgdHJlZSwgZS5nLiB3aWR0aCwgaGVpZ2h0IGV0YylcbiAgICAqL1xuICAgIGZ1bmN0aW9uIElmcmFtZUNvbnRleHRIYW5kbGVyKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJZnJhbWVDb250ZXh0SGFuZGxlcik7XG5cbiAgICAgICAgaWYgKCFoZWxwZXIuaXNPYmplY3QocHJvcHMpKSB7XG4gICAgICAgICAgICBoZWxwZXIuZXJyb3IoJ0NvbnRleHRIYW5kbGVyIGV4cGVjdHMgYW4gb2JqZWN0IG9uIGl0cyBjb25zdHJ1Y3Rvci4gJyArICh0eXBlb2YgcHJvcHMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHByb3BzKSkgKyAnIHBhc3NlZCcpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnaHRtbCcpKSB7XG4gICAgICAgICAgICBoZWxwZXIuZXJyb3IoJ0NvbnRleHRIYW5kbGVyIGV4cGVjdHMgdGhlIGh0bWwga2V5IG9uIGl0cyBjb25zdHJ1Y3RvciBwcm9wZXJ0aWVzIHdoaWNoIGlzIG1pc3NpbmcnKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkoJ2NzcycpKSB7XG4gICAgICAgICAgICBoZWxwZXIuZXJyb3IoJ0NvbnRleHRIYW5kbGVyIGV4cGVjdHMgdGhlIGNzcyBrZXkgb24gaXRzIGNvbnN0cnVjdG9yIHByb3BlcnRpZXMgd2hpY2ggaXMgbWlzc2luZycpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluaXRQYXJhbXMgPSBwcm9wcy5pbml0UGFyYW1zO1xuICAgICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KCdpbml0UGFyYW1zJykpIHtcbiAgICAgICAgICAgIGhlbHBlci5pbmZvKCdDb250ZXh0SGFuZGxlciBnb3QgbnVsbCBpbml0UGFyYW1zJyk7XG4gICAgICAgICAgICBpbml0UGFyYW1zID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KCdob3N0JykpIHtcbiAgICAgICAgICAgIGhlbHBlci5lcnJvcignQ29udGV4dEhhbmRsZXIgZXhwZWN0cyB0aGUgaG9zdCBrZXkgb24gaXRzIGNvbnN0cnVjdG9yIHByb3BlcnRpZXMgd2hpY2ggaXMgbWlzc2luZycpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc0RPTSA9IHRydWU7XG5cbiAgICAgICAgdmFyIG93bmVyRG9jdW1lbnQgPSBwcm9wcy5ob3N0Lm93bmVyRG9jdW1lbnQ7XG5cbiAgICAgICAgaWYgKCFvd25lckRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9pZnJhbWVDb250ZXh0SGFuZGxlci9jc3NcIikpIHtcbiAgICAgICAgICAgIHZhciBzZWFtbGVzc0NTUyA9ICdcXG4gICAgICAgICAgICBpZnJhbWVbc2VhbWxlc3Nde1xcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgICAgICAgICAgICAgYm9yZGVyOiAwcHggbm9uZSB0cmFuc3BhcmVudDtcXG4gICAgICAgICAgICAgICAgcGFkZGluZzogMHB4O1xcbiAgICAgICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAnO1xuICAgICAgICAgICAgdmFyIGlmcmFtZXNDU1MgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgICAgICBpZnJhbWVzQ1NTLmlkID0gXCJAa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2lmcmFtZUNvbnRleHRIYW5kbGVyL2Nzc1wiO1xuICAgICAgICAgICAgaWZyYW1lc0NTUy50eXBlID0gJ3RleHQvY3NzJztcbiAgICAgICAgICAgIHZhciBIZWFkID0gb3duZXJEb2N1bWVudC5oZWFkIHx8IG93bmVyRG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICAgICAgICAgIGlmIChpZnJhbWVzQ1NTLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgICAgICAgICBpZnJhbWVzQ1NTLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHNlYW1sZXNzQ1NTO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZnJhbWVzQ1NTLmFwcGVuZENoaWxkKG93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc2VhbWxlc3NDU1MpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgSGVhZC5hcHBlbmRDaGlsZChpZnJhbWVzQ1NTKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBhbiBpZnJhbWU6XG4gICAgICAgIHZhciBpZnJhbWUgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICBwcm9wcy5ob3N0LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoXCJzZWFtbGVzc1wiLCBcInNlYW1sZXNzXCIpO1xuICAgICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoJ2NvbnRhaW5lclBhcmFtcycpKSB7XG4gICAgICAgICAgICBpZiAocHJvcHMuY29udGFpbmVyUGFyYW1zLmhhc093blByb3BlcnR5KCd3aWR0aCcpKSB7XG4gICAgICAgICAgICAgICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBwcm9wcy5jb250YWluZXJQYXJhbXMud2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3BzLmNvbnRhaW5lclBhcmFtcy5oYXNPd25Qcm9wZXJ0eSgnaGVpZ2h0JykpIHtcbiAgICAgICAgICAgICAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBwcm9wcy5jb250YWluZXJQYXJhbXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJbml0aWFsaXNlIHRoZSBpZnJhbWVcbiAgICAgICAgaWZyYW1lLnNyYyA9ICcnO1xuICAgICAgICAvLyBQdXQgaXQgaW4gdGhlIGRvY3VtZW50IChidXQgaGlkZGVuKTpcbiAgICAgICAgdmFyIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cgfHwgaWZyYW1lLmNvbnRlbnREb2N1bWVudDtcbiAgICAgICAgaWYgKGlmcmFtZURvY3VtZW50LmRvY3VtZW50KSB7XG4gICAgICAgICAgICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZURvY3VtZW50LmRvY3VtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWZyYW1lRG9jdW1lbnQud3JpdGUoaGVscGVyLnJlbmRlclRlbXBsYXRlKHByb3BzLmh0bWwsIHsgcGFyYW1zOiBwcm9wcy5pbml0UGFyYW1zIH0pKTtcblxuICAgICAgICB2YXIgYm9keUZpeENTUyA9ICdcXG4gICAgICAgIGJvZHl7XFxuICAgICAgICAgICAgcGFkZGluZzowO1xcbiAgICAgICAgICAgIG1hcmdpbjowO1xcbiAgICAgICAgfVxcbiAgICAgICAgJztcblxuICAgICAgICB2YXIgc3R5bGVUYWcgPSBpZnJhbWVEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICBzdHlsZVRhZy50eXBlID0gJ3RleHQvY3NzJztcbiAgICAgICAgaWYgKHN0eWxlVGFnLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgICAgIHN0eWxlVGFnLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGhlbHBlci5yZW5kZXJUZW1wbGF0ZShwcm9wcy5jc3MsIHsgcGFyYW1zOiBwcm9wcy5pbml0UGFyYW1zIH0pICsgYm9keUZpeENTUztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlVGFnLmFwcGVuZENoaWxkKG93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocHJvcHMuY3NzICsgYm9keUZpeENTUykpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhlYWQgPSBpZnJhbWVEb2N1bWVudC5oZWFkIHx8IGlmcmFtZURvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVUYWcpO1xuXG4gICAgICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnZm9udHMnKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5mb250cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB0aGVGb250ID0gcHJvcHMuZm9udHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHRoZUZvbnQudHlwZSA9PT0gXCJnb29nbGUtZm9udFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmb250VGFnID0gaWZyYW1lRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuICAgICAgICAgICAgICAgICAgICBmb250VGFnLnNldEF0dHJpYnV0ZSgncmVsJywgJ3N0eWxlc2hlZXQnKTtcbiAgICAgICAgICAgICAgICAgICAgZm9udFRhZy5zZXRBdHRyaWJ1dGUoJ3NyYycsIHRoZUZvbnQuc3JjKTtcbiAgICAgICAgICAgICAgICAgICAgaGVhZC5hcHBlbmRDaGlsZChmb250VGFnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJvb3RFbGVtZW50ID0gaWZyYW1lO1xuXG4gICAgICAgIHRoaXMuY29udGV4dCA9IHtcbiAgICAgICAgICAgIGRvY3VtZW50OiBpZnJhbWVEb2N1bWVudCxcbiAgICAgICAgICAgIHdpbmRvdzogaWZyYW1lLmNvbnRlbnRXaW5kb3cgfHwgaWZyYW1lLFxuICAgICAgICAgICAgY2xpcENvbnRhaW5lcjogaWZyYW1lLFxuICAgICAgICAgICAgcm9vdEVsZW1lbnQ6IGlmcmFtZURvY3VtZW50LmJvZHksXG4gICAgICAgICAgICB1bm1vdW50OiBmdW5jdGlvbiB1bm1vdW50KCkge1xuICAgICAgICAgICAgICAgIHByb3BzLmhvc3QucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRFbGVtZW50czogdGhpcy5nZXRFbGVtZW50cy5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZ2V0TUNJRDogdGhpcy5nZXRNQ0lELmJpbmQodGhpcyksXG4gICAgICAgICAgICBzZXRNQ0lEOiB0aGlzLnNldE1DSUQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGdldEVsZW1lbnRTZWxlY3RvckJ5TUNJRDogdGhpcy5nZXRFbGVtZW50U2VsZWN0b3JCeU1DSUQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGdldEVsZW1lbnRCeU1DSUQ6IHRoaXMuZ2V0RWxlbWVudEJ5TUNJRC5iaW5kKHRoaXMpXG4gICAgICAgIH07XG5cbiAgICAgICAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcblxuICAgICAgICB0aGlzLmVsZW1lbnRzQnlNQ0lEID0ge307XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKElmcmFtZUNvbnRleHRIYW5kbGVyLCBbe1xuICAgICAgICBrZXk6ICdnZXRFbGVtZW50QnlNQ0lEJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVsZW1lbnRCeU1DSUQobWNpZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZWxlbWVudHNCeU1DSUQuaGFzT3duUHJvcGVydHkobWNpZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50c0J5TUNJRFttY2lkXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmNvbnRleHQuZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLmdldEVsZW1lbnRTZWxlY3RvckJ5TUNJRChtY2lkKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50c0J5TUNJRFttY2lkXSA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldEVsZW1lbnRzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVsZW1lbnRzKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmNvbnRleHQuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRNQ0lEJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1DSUQoZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKGNvbmYuZWxlbWVudHNfZGF0YV9hdHRyaWJ1dGVfbmFtZSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NldE1DSUQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TUNJRChlbGVtZW50LCBtY2lkKSB7XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShjb25mLmVsZW1lbnRzX2RhdGFfYXR0cmlidXRlX25hbWUsIG1jaWQpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRFbGVtZW50U2VsZWN0b3JCeU1DSUQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWxlbWVudFNlbGVjdG9yQnlNQ0lEKG1jaWQpIHtcbiAgICAgICAgICAgIHJldHVybiAnWycgKyBjb25mLmVsZW1lbnRzX2RhdGFfYXR0cmlidXRlX25hbWUgKyAnPVwiJyArIG1jaWQgKyAnXCJdJztcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBJZnJhbWVDb250ZXh0SGFuZGxlcjtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBJZnJhbWVDb250ZXh0SGFuZGxlcjsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/IframeContextHandler.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/PlainContextHandler.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/PlainContextHandler.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Helper = __webpack_require__(/*! ../../../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar conf = __webpack_require__(/*! ../../../configuration/generalConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\n\nvar PlainContextHandler = function () {\n    function PlainContextHandler() {\n        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, PlainContextHandler);\n\n        if (!helper.isObject(props)) {\n            helper.error('ContextHandler expects an object on its constructor. ' + (typeof props === 'undefined' ? 'undefined' : _typeof(props)) + ' passed');\n            return false;\n        }\n\n        if (!props.hasOwnProperty('host')) {\n            helper.error('ContextHandler expects the host key on its constructor properties which is missing');\n            return false;\n        }\n\n        var ownerDocument = props.host.ownerDocument;\n        var initParams = props.initParams;\n        if (!props.hasOwnProperty('initParams')) {\n            helper.info('ContextHandler got null initParams');\n            initParams = {};\n        }\n\n        if (props.hasOwnProperty('html')) {\n            props.host.innerHTML = helper.renderTemplate(props.html, { params: initParams });\n        }\n\n        if (props.hasOwnProperty('css')) {\n            var styleTag = ownerDocument.createElement('style');\n            styleTag.type = 'text/css';\n            if (styleTag.styleSheet) {\n                styleTag.styleSheet.cssText = helper.renderTemplate(props.css, { params: initParams });\n            } else {\n                styleTag.appendChild(ownerDocument.createTextNode(props.css));\n            }\n            var head = ownerDocument.head || ownerDocument.getElementsByTagName('head')[0];\n            head.appendChild(styleTag);\n        }\n\n        this.isDOM = true;\n        this.rootElement = props.host;\n\n        this.context = {\n            document: ownerDocument,\n            window: ownerDocument.defaultView,\n            clipContainer: this.rootElement,\n            rootElement: props.host,\n            unmount: function unmount() {\n                props.host.innerHTML = \"\";\n            },\n            getElements: this.getElements.bind(this),\n            getMCID: this.getMCID.bind(this),\n            setMCID: this.setMCID.bind(this),\n            getElementSelectorByMCID: this.getElementSelectorByMCID.bind(this),\n            getElementByMCID: this.getElementByMCID.bind(this)\n        };\n\n        this.elementsByMCID = {};\n    }\n\n    _createClass(PlainContextHandler, [{\n        key: 'getElementByMCID',\n        value: function getElementByMCID(mcid) {\n            if (this.elementsByMCID.hasOwnProperty(mcid)) {\n                return this.elementsByMCID[mcid];\n            } else {\n                var element = this.context.document.querySelector(this.getElementSelectorByMCID(mcid));\n                this.elementsByMCID[mcid] = element;\n                return element;\n            }\n        }\n    }, {\n        key: 'getElements',\n        value: function getElements(selector) {\n            return Array.from(this.context.rootElement.querySelectorAll(selector));\n        }\n    }, {\n        key: 'getMCID',\n        value: function getMCID(element) {\n            return element.getAttribute(conf.elements_data_attribute_name);\n        }\n    }, {\n        key: 'setMCID',\n        value: function setMCID(element, mcid) {\n            element.setAttribute(conf.elements_data_attribute_name, mcid);\n        }\n    }, {\n        key: 'getElementSelectorByMCID',\n        value: function getElementSelectorByMCID(mcid) {\n            return '[' + conf.elements_data_attribute_name + '=\"' + mcid + '\"]';\n        }\n    }]);\n\n    return PlainContextHandler;\n}();\n\nmodule.exports = PlainContextHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvcmVQbHVnaW5zL1NlbGZDb250YWluZWRJbmNpZGVudHMvaGVscGVycy9QbGFpbkNvbnRleHRIYW5kbGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9jb3JlUGx1Z2lucy9TZWxmQ29udGFpbmVkSW5jaWRlbnRzL2hlbHBlcnMvUGxhaW5Db250ZXh0SGFuZGxlci5qcz82MjNlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgSGVscGVyID0gcmVxdWlyZSgnLi4vLi4vLi4vX2NvcmVVdGlscy9IZWxwZXInKTtcbnZhciBoZWxwZXIgPSBuZXcgSGVscGVyKCk7XG52YXIgY29uZiA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbmZpZ3VyYXRpb24vZ2VuZXJhbENvbmYnKTtcblxudmFyIFBsYWluQ29udGV4dEhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGxhaW5Db250ZXh0SGFuZGxlcigpIHtcbiAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGxhaW5Db250ZXh0SGFuZGxlcik7XG5cbiAgICAgICAgaWYgKCFoZWxwZXIuaXNPYmplY3QocHJvcHMpKSB7XG4gICAgICAgICAgICBoZWxwZXIuZXJyb3IoJ0NvbnRleHRIYW5kbGVyIGV4cGVjdHMgYW4gb2JqZWN0IG9uIGl0cyBjb25zdHJ1Y3Rvci4gJyArICh0eXBlb2YgcHJvcHMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHByb3BzKSkgKyAnIHBhc3NlZCcpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnaG9zdCcpKSB7XG4gICAgICAgICAgICBoZWxwZXIuZXJyb3IoJ0NvbnRleHRIYW5kbGVyIGV4cGVjdHMgdGhlIGhvc3Qga2V5IG9uIGl0cyBjb25zdHJ1Y3RvciBwcm9wZXJ0aWVzIHdoaWNoIGlzIG1pc3NpbmcnKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvd25lckRvY3VtZW50ID0gcHJvcHMuaG9zdC5vd25lckRvY3VtZW50O1xuICAgICAgICB2YXIgaW5pdFBhcmFtcyA9IHByb3BzLmluaXRQYXJhbXM7XG4gICAgICAgIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkoJ2luaXRQYXJhbXMnKSkge1xuICAgICAgICAgICAgaGVscGVyLmluZm8oJ0NvbnRleHRIYW5kbGVyIGdvdCBudWxsIGluaXRQYXJhbXMnKTtcbiAgICAgICAgICAgIGluaXRQYXJhbXMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnaHRtbCcpKSB7XG4gICAgICAgICAgICBwcm9wcy5ob3N0LmlubmVySFRNTCA9IGhlbHBlci5yZW5kZXJUZW1wbGF0ZShwcm9wcy5odG1sLCB7IHBhcmFtczogaW5pdFBhcmFtcyB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnY3NzJykpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZVRhZyA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgICAgIHN0eWxlVGFnLnR5cGUgPSAndGV4dC9jc3MnO1xuICAgICAgICAgICAgaWYgKHN0eWxlVGFnLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgICAgICAgICBzdHlsZVRhZy5zdHlsZVNoZWV0LmNzc1RleHQgPSBoZWxwZXIucmVuZGVyVGVtcGxhdGUocHJvcHMuY3NzLCB7IHBhcmFtczogaW5pdFBhcmFtcyB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3R5bGVUYWcuYXBwZW5kQ2hpbGQob3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShwcm9wcy5jc3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBoZWFkID0gb3duZXJEb2N1bWVudC5oZWFkIHx8IG93bmVyRG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICAgICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVUYWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc0RPTSA9IHRydWU7XG4gICAgICAgIHRoaXMucm9vdEVsZW1lbnQgPSBwcm9wcy5ob3N0O1xuXG4gICAgICAgIHRoaXMuY29udGV4dCA9IHtcbiAgICAgICAgICAgIGRvY3VtZW50OiBvd25lckRvY3VtZW50LFxuICAgICAgICAgICAgd2luZG93OiBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LFxuICAgICAgICAgICAgY2xpcENvbnRhaW5lcjogdGhpcy5yb290RWxlbWVudCxcbiAgICAgICAgICAgIHJvb3RFbGVtZW50OiBwcm9wcy5ob3N0LFxuICAgICAgICAgICAgdW5tb3VudDogZnVuY3Rpb24gdW5tb3VudCgpIHtcbiAgICAgICAgICAgICAgICBwcm9wcy5ob3N0LmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0RWxlbWVudHM6IHRoaXMuZ2V0RWxlbWVudHMuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGdldE1DSUQ6IHRoaXMuZ2V0TUNJRC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgc2V0TUNJRDogdGhpcy5zZXRNQ0lELmJpbmQodGhpcyksXG4gICAgICAgICAgICBnZXRFbGVtZW50U2VsZWN0b3JCeU1DSUQ6IHRoaXMuZ2V0RWxlbWVudFNlbGVjdG9yQnlNQ0lELmJpbmQodGhpcyksXG4gICAgICAgICAgICBnZXRFbGVtZW50QnlNQ0lEOiB0aGlzLmdldEVsZW1lbnRCeU1DSUQuYmluZCh0aGlzKVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZWxlbWVudHNCeU1DSUQgPSB7fTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoUGxhaW5Db250ZXh0SGFuZGxlciwgW3tcbiAgICAgICAga2V5OiAnZ2V0RWxlbWVudEJ5TUNJRCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbGVtZW50QnlNQ0lEKG1jaWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnRzQnlNQ0lELmhhc093blByb3BlcnR5KG1jaWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHNCeU1DSURbbWNpZF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5jb250ZXh0LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5nZXRFbGVtZW50U2VsZWN0b3JCeU1DSUQobWNpZCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudHNCeU1DSURbbWNpZF0gPSBlbGVtZW50O1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRFbGVtZW50cycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbGVtZW50cyhzZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jb250ZXh0LnJvb3RFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0TUNJRCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNQ0lEKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZShjb25mLmVsZW1lbnRzX2RhdGFfYXR0cmlidXRlX25hbWUpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzZXRNQ0lEJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE1DSUQoZWxlbWVudCwgbWNpZCkge1xuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoY29uZi5lbGVtZW50c19kYXRhX2F0dHJpYnV0ZV9uYW1lLCBtY2lkKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0RWxlbWVudFNlbGVjdG9yQnlNQ0lEJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVsZW1lbnRTZWxlY3RvckJ5TUNJRChtY2lkKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1snICsgY29uZi5lbGVtZW50c19kYXRhX2F0dHJpYnV0ZV9uYW1lICsgJz1cIicgKyBtY2lkICsgJ1wiXSc7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUGxhaW5Db250ZXh0SGFuZGxlcjtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQbGFpbkNvbnRleHRIYW5kbGVyOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/PlainContextHandler.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/WebComponentContextHandler.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/WebComponentContextHandler.js ***!
  \******************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*\niframe[seamless]{\n    background-color: transparent;\n    border: 0px none transparent;\n    padding: 0px;\n    overflow: hidden;\n}\n\nmight need more work for IE. See here: https://stackoverflow.com/a/29209248\n*/\n\nvar Helper = __webpack_require__(/*! ../../../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar conf = __webpack_require__(/*! ../../../configuration/generalConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\n\nvar WebComponentContextHandler = function () {\n    /**\n     * @param {object} props - an object that should contain all of the following keys:\n     * - html (the html template to render)\n     * - css (the css template of the isolated tree)\n     * - initParams (optional / the initialisation parameteres that will be passed both on the css and the html templates in order to render)\n     * - host (an Element object that will host the isolated tree)\n     * - containerParams (an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc)\n    */\n    function WebComponentContextHandler() {\n        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, WebComponentContextHandler);\n\n        if (!helper.isObject(props)) {\n            helper.error('ContextHandler expects an object on its constructor. ' + (typeof props === 'undefined' ? 'undefined' : _typeof(props)) + ' passed');\n            return false;\n        }\n\n        if (!props.hasOwnProperty('html')) {\n            helper.error('ContextHandler expects the html key on its constructor properties which is missing');\n            return false;\n        }\n\n        if (!props.hasOwnProperty('css')) {\n            helper.error('ContextHandler expects the css key on its constructor properties which is missing');\n            return false;\n        }\n\n        var initParams = props.initParams;\n        if (!props.hasOwnProperty('initParams')) {\n            helper.info('ContextHandler got null initParams');\n            initParams = {};\n        }\n\n        if (!props.hasOwnProperty('host')) {\n            helper.error('ContextHandler expects the host key on its constructor properties which is missing');\n            return false;\n        }\n\n        this.isDOM = true;\n\n        var ownerDocument = props.host.ownerDocument;\n\n        var shadow = props.host.attachShadow({ mode: 'closed' });\n        var wrapper = document.createElement('div');\n        if (props.hasOwnProperty('containerParams')) {\n            if (props.containerParams.hasOwnProperty('width')) {\n                wrapper.style.width = props.containerParams.width;\n            }\n            if (props.containerParams.hasOwnProperty('height')) {\n                wrapper.style.height = props.containerParams.height;\n            }\n        }\n        wrapper.innerHTML = helper.renderTemplate(props.html + '<slot></slot>', { params: props.initParams });\n        shadow.appendChild(wrapper);\n\n        var styleTag = document.createElement('style');\n        styleTag.type = 'text/css';\n        if (styleTag.styleSheet) {\n            styleTag.styleSheet.cssText = helper.renderTemplate(props.css, { params: props.initParams });\n        } else {\n            styleTag.appendChild(document.createTextNode(props.css));\n        }\n        shadow.appendChild(styleTag);\n\n        if (props.hasOwnProperty('fonts')) {\n            for (var i = 0; i < props.fonts.length; i++) {\n                var theFont = props.fonts[i];\n                if (theFont.type === \"google-font\") {\n                    var fontTag = document.createElement('link');\n                    fontTag.setAttribute('rel', 'stylesheet');\n                    fontTag.setAttribute('src', theFont.src);\n                    shadow.appendChild(fontTag);\n                }\n            }\n        }\n\n        wrapper.style.overflow = \"hidden\";\n\n        this.rootElement = wrapper;\n\n        this.context = {\n            document: document,\n            window: window,\n            clipContainer: this.rootElement,\n            rootElement: wrapper,\n            unmount: function unmount() {\n                props.host.removeChild(shadow);\n            },\n            getElements: this.getElements.bind(this),\n            getMCID: this.getMCID.bind(this),\n            setMCID: this.setMCID.bind(this),\n            getElementSelectorByMCID: this.getElementSelectorByMCID.bind(this),\n            getElementByMCID: this.getElementByMCID.bind(this)\n        };\n\n        this.elementsByMCID = {};\n    }\n\n    _createClass(WebComponentContextHandler, [{\n        key: 'getElementByMCID',\n        value: function getElementByMCID(mcid) {\n            if (this.elementsByMCID.hasOwnProperty(mcid)) {\n                return this.elementsByMCID[mcid];\n            } else {\n                var element = this.context.rootElement.querySelector(this.getElementSelectorByMCID(mcid));\n                this.elementsByMCID[mcid] = element;\n                return element;\n            }\n        }\n    }, {\n        key: 'getElements',\n        value: function getElements(selector) {\n            return Array.from(this.context.rootElement.querySelectorAll(selector));\n        }\n    }, {\n        key: 'getMCID',\n        value: function getMCID(element) {\n            return element.getAttribute(conf.elements_data_attribute_name);\n        }\n    }, {\n        key: 'setMCID',\n        value: function setMCID(element, mcid) {\n            element.setAttribute(conf.elements_data_attribute_name, mcid);\n        }\n    }, {\n        key: 'getElementSelectorByMCID',\n        value: function getElementSelectorByMCID(mcid) {\n            return '[' + conf.elements_data_attribute_name + '=\"' + mcid + '\"]';\n        }\n    }]);\n\n    return WebComponentContextHandler;\n}();\n\nmodule.exports = WebComponentContextHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvcmVQbHVnaW5zL1NlbGZDb250YWluZWRJbmNpZGVudHMvaGVscGVycy9XZWJDb21wb25lbnRDb250ZXh0SGFuZGxlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2Rpc3QvY29yZVBsdWdpbnMvU2VsZkNvbnRhaW5lZEluY2lkZW50cy9oZWxwZXJzL1dlYkNvbXBvbmVudENvbnRleHRIYW5kbGVyLmpzPzIzODkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qXG5pZnJhbWVbc2VhbWxlc3Nde1xuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuICAgIGJvcmRlcjogMHB4IG5vbmUgdHJhbnNwYXJlbnQ7XG4gICAgcGFkZGluZzogMHB4O1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG59XG5cbm1pZ2h0IG5lZWQgbW9yZSB3b3JrIGZvciBJRS4gU2VlIGhlcmU6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yOTIwOTI0OFxuKi9cblxudmFyIEhlbHBlciA9IHJlcXVpcmUoJy4uLy4uLy4uL19jb3JlVXRpbHMvSGVscGVyJyk7XG52YXIgaGVscGVyID0gbmV3IEhlbHBlcigpO1xudmFyIGNvbmYgPSByZXF1aXJlKCcuLi8uLi8uLi9jb25maWd1cmF0aW9uL2dlbmVyYWxDb25mJyk7XG5cbnZhciBXZWJDb21wb25lbnRDb250ZXh0SGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgLSBhbiBvYmplY3QgdGhhdCBzaG91bGQgY29udGFpbiBhbGwgb2YgdGhlIGZvbGxvd2luZyBrZXlzOlxuICAgICAqIC0gaHRtbCAodGhlIGh0bWwgdGVtcGxhdGUgdG8gcmVuZGVyKVxuICAgICAqIC0gY3NzICh0aGUgY3NzIHRlbXBsYXRlIG9mIHRoZSBpc29sYXRlZCB0cmVlKVxuICAgICAqIC0gaW5pdFBhcmFtcyAob3B0aW9uYWwgLyB0aGUgaW5pdGlhbGlzYXRpb24gcGFyYW1ldGVyZXMgdGhhdCB3aWxsIGJlIHBhc3NlZCBib3RoIG9uIHRoZSBjc3MgYW5kIHRoZSBodG1sIHRlbXBsYXRlcyBpbiBvcmRlciB0byByZW5kZXIpXG4gICAgICogLSBob3N0IChhbiBFbGVtZW50IG9iamVjdCB0aGF0IHdpbGwgaG9zdCB0aGUgaXNvbGF0ZWQgdHJlZSlcbiAgICAgKiAtIGNvbnRhaW5lclBhcmFtcyAoYW4gb2JqZWN0IHRoYXQgaG9sZHMgcGFyYW1ldGVycyB0byBhZmZlY3QgdGhlIGNvbnRhaW5lciBvZiB0aGUgaXNvbGF0ZWQgdHJlZSwgZS5nLiB3aWR0aCwgaGVpZ2h0IGV0YylcbiAgICAqL1xuICAgIGZ1bmN0aW9uIFdlYkNvbXBvbmVudENvbnRleHRIYW5kbGVyKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXZWJDb21wb25lbnRDb250ZXh0SGFuZGxlcik7XG5cbiAgICAgICAgaWYgKCFoZWxwZXIuaXNPYmplY3QocHJvcHMpKSB7XG4gICAgICAgICAgICBoZWxwZXIuZXJyb3IoJ0NvbnRleHRIYW5kbGVyIGV4cGVjdHMgYW4gb2JqZWN0IG9uIGl0cyBjb25zdHJ1Y3Rvci4gJyArICh0eXBlb2YgcHJvcHMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHByb3BzKSkgKyAnIHBhc3NlZCcpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnaHRtbCcpKSB7XG4gICAgICAgICAgICBoZWxwZXIuZXJyb3IoJ0NvbnRleHRIYW5kbGVyIGV4cGVjdHMgdGhlIGh0bWwga2V5IG9uIGl0cyBjb25zdHJ1Y3RvciBwcm9wZXJ0aWVzIHdoaWNoIGlzIG1pc3NpbmcnKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkoJ2NzcycpKSB7XG4gICAgICAgICAgICBoZWxwZXIuZXJyb3IoJ0NvbnRleHRIYW5kbGVyIGV4cGVjdHMgdGhlIGNzcyBrZXkgb24gaXRzIGNvbnN0cnVjdG9yIHByb3BlcnRpZXMgd2hpY2ggaXMgbWlzc2luZycpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluaXRQYXJhbXMgPSBwcm9wcy5pbml0UGFyYW1zO1xuICAgICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KCdpbml0UGFyYW1zJykpIHtcbiAgICAgICAgICAgIGhlbHBlci5pbmZvKCdDb250ZXh0SGFuZGxlciBnb3QgbnVsbCBpbml0UGFyYW1zJyk7XG4gICAgICAgICAgICBpbml0UGFyYW1zID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KCdob3N0JykpIHtcbiAgICAgICAgICAgIGhlbHBlci5lcnJvcignQ29udGV4dEhhbmRsZXIgZXhwZWN0cyB0aGUgaG9zdCBrZXkgb24gaXRzIGNvbnN0cnVjdG9yIHByb3BlcnRpZXMgd2hpY2ggaXMgbWlzc2luZycpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc0RPTSA9IHRydWU7XG5cbiAgICAgICAgdmFyIG93bmVyRG9jdW1lbnQgPSBwcm9wcy5ob3N0Lm93bmVyRG9jdW1lbnQ7XG5cbiAgICAgICAgdmFyIHNoYWRvdyA9IHByb3BzLmhvc3QuYXR0YWNoU2hhZG93KHsgbW9kZTogJ2Nsb3NlZCcgfSk7XG4gICAgICAgIHZhciB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnY29udGFpbmVyUGFyYW1zJykpIHtcbiAgICAgICAgICAgIGlmIChwcm9wcy5jb250YWluZXJQYXJhbXMuaGFzT3duUHJvcGVydHkoJ3dpZHRoJykpIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVyLnN0eWxlLndpZHRoID0gcHJvcHMuY29udGFpbmVyUGFyYW1zLndpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3BzLmNvbnRhaW5lclBhcmFtcy5oYXNPd25Qcm9wZXJ0eSgnaGVpZ2h0JykpIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVyLnN0eWxlLmhlaWdodCA9IHByb3BzLmNvbnRhaW5lclBhcmFtcy5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd3JhcHBlci5pbm5lckhUTUwgPSBoZWxwZXIucmVuZGVyVGVtcGxhdGUocHJvcHMuaHRtbCArICc8c2xvdD48L3Nsb3Q+JywgeyBwYXJhbXM6IHByb3BzLmluaXRQYXJhbXMgfSk7XG4gICAgICAgIHNoYWRvdy5hcHBlbmRDaGlsZCh3cmFwcGVyKTtcblxuICAgICAgICB2YXIgc3R5bGVUYWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICBzdHlsZVRhZy50eXBlID0gJ3RleHQvY3NzJztcbiAgICAgICAgaWYgKHN0eWxlVGFnLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgICAgIHN0eWxlVGFnLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGhlbHBlci5yZW5kZXJUZW1wbGF0ZShwcm9wcy5jc3MsIHsgcGFyYW1zOiBwcm9wcy5pbml0UGFyYW1zIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3R5bGVUYWcuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocHJvcHMuY3NzKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2hhZG93LmFwcGVuZENoaWxkKHN0eWxlVGFnKTtcblxuICAgICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoJ2ZvbnRzJykpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMuZm9udHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdGhlRm9udCA9IHByb3BzLmZvbnRzW2ldO1xuICAgICAgICAgICAgICAgIGlmICh0aGVGb250LnR5cGUgPT09IFwiZ29vZ2xlLWZvbnRcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm9udFRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKTtcbiAgICAgICAgICAgICAgICAgICAgZm9udFRhZy5zZXRBdHRyaWJ1dGUoJ3JlbCcsICdzdHlsZXNoZWV0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGZvbnRUYWcuc2V0QXR0cmlidXRlKCdzcmMnLCB0aGVGb250LnNyYyk7XG4gICAgICAgICAgICAgICAgICAgIHNoYWRvdy5hcHBlbmRDaGlsZChmb250VGFnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3cmFwcGVyLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblxuICAgICAgICB0aGlzLnJvb3RFbGVtZW50ID0gd3JhcHBlcjtcblxuICAgICAgICB0aGlzLmNvbnRleHQgPSB7XG4gICAgICAgICAgICBkb2N1bWVudDogZG9jdW1lbnQsXG4gICAgICAgICAgICB3aW5kb3c6IHdpbmRvdyxcbiAgICAgICAgICAgIGNsaXBDb250YWluZXI6IHRoaXMucm9vdEVsZW1lbnQsXG4gICAgICAgICAgICByb290RWxlbWVudDogd3JhcHBlcixcbiAgICAgICAgICAgIHVubW91bnQ6IGZ1bmN0aW9uIHVubW91bnQoKSB7XG4gICAgICAgICAgICAgICAgcHJvcHMuaG9zdC5yZW1vdmVDaGlsZChzaGFkb3cpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEVsZW1lbnRzOiB0aGlzLmdldEVsZW1lbnRzLmJpbmQodGhpcyksXG4gICAgICAgICAgICBnZXRNQ0lEOiB0aGlzLmdldE1DSUQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHNldE1DSUQ6IHRoaXMuc2V0TUNJRC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZ2V0RWxlbWVudFNlbGVjdG9yQnlNQ0lEOiB0aGlzLmdldEVsZW1lbnRTZWxlY3RvckJ5TUNJRC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZ2V0RWxlbWVudEJ5TUNJRDogdGhpcy5nZXRFbGVtZW50QnlNQ0lELmJpbmQodGhpcylcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmVsZW1lbnRzQnlNQ0lEID0ge307XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFdlYkNvbXBvbmVudENvbnRleHRIYW5kbGVyLCBbe1xuICAgICAgICBrZXk6ICdnZXRFbGVtZW50QnlNQ0lEJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVsZW1lbnRCeU1DSUQobWNpZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZWxlbWVudHNCeU1DSUQuaGFzT3duUHJvcGVydHkobWNpZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50c0J5TUNJRFttY2lkXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmNvbnRleHQucm9vdEVsZW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLmdldEVsZW1lbnRTZWxlY3RvckJ5TUNJRChtY2lkKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50c0J5TUNJRFttY2lkXSA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldEVsZW1lbnRzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVsZW1lbnRzKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmNvbnRleHQucm9vdEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRNQ0lEJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1DSUQoZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKGNvbmYuZWxlbWVudHNfZGF0YV9hdHRyaWJ1dGVfbmFtZSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NldE1DSUQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TUNJRChlbGVtZW50LCBtY2lkKSB7XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShjb25mLmVsZW1lbnRzX2RhdGFfYXR0cmlidXRlX25hbWUsIG1jaWQpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRFbGVtZW50U2VsZWN0b3JCeU1DSUQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWxlbWVudFNlbGVjdG9yQnlNQ0lEKG1jaWQpIHtcbiAgICAgICAgICAgIHJldHVybiAnWycgKyBjb25mLmVsZW1lbnRzX2RhdGFfYXR0cmlidXRlX25hbWUgKyAnPVwiJyArIG1jaWQgKyAnXCJdJztcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBXZWJDb21wb25lbnRDb250ZXh0SGFuZGxlcjtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJDb21wb25lbnRDb250ZXh0SGFuZGxlcjsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/WebComponentContextHandler.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/main.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/main.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Clip = __webpack_require__(/*! ./SCGroup */ \"./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/SCGroup.js\");\nvar Channel = __webpack_require__(/*! ./SCIChannel */ \"./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/SCIChannel.js\");\nvar ClipFromDefinition = __webpack_require__(/*! ./ClipFromDefinition */ \"./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/ClipFromDefinition.js\");\n\nmodule.exports = {\n    npm_name: \"@kissmybutton/self-contained-incidents\",\n    incidents: [{\n        exportable: Clip,\n        name: \"Clip\"\n    }],\n    channel: Channel\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvcmVQbHVnaW5zL1NlbGZDb250YWluZWRJbmNpZGVudHMvbWFpbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2Rpc3QvY29yZVBsdWdpbnMvU2VsZkNvbnRhaW5lZEluY2lkZW50cy9tYWluLmpzPzc4ZmIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2xpcCA9IHJlcXVpcmUoJy4vU0NHcm91cCcpO1xudmFyIENoYW5uZWwgPSByZXF1aXJlKCcuL1NDSUNoYW5uZWwnKTtcbnZhciBDbGlwRnJvbURlZmluaXRpb24gPSByZXF1aXJlKCcuL0NsaXBGcm9tRGVmaW5pdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBucG1fbmFtZTogXCJAa2lzc215YnV0dG9uL3NlbGYtY29udGFpbmVkLWluY2lkZW50c1wiLFxuICAgIGluY2lkZW50czogW3tcbiAgICAgICAgZXhwb3J0YWJsZTogQ2xpcCxcbiAgICAgICAgbmFtZTogXCJDbGlwXCJcbiAgICB9XSxcbiAgICBjaGFubmVsOiBDaGFubmVsXG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/main.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/main.js":
/*!*************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/main.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Channel = __webpack_require__(/*! ./_Channels/Channel */ \"./node_modules/@kissmybutton/motorcortex/dist/_Channels/Channel.js\");\nvar Group = __webpack_require__(/*! ./_BaseClasses/Group */ \"./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Group.js\");\nvar Incident = __webpack_require__(/*! ./_BaseClasses/Incident */ \"./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Incident.js\");\nvar TimedIncident = __webpack_require__(/*! ./_BaseClasses/TimedIncident */ \"./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/TimedIncident.js\");\nvar Helper = __webpack_require__(/*! ./_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");var helper = new Helper();\nvar AttributeChannel = __webpack_require__(/*! ./_Channels/_Attribute/AttributeChannel */ \"./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/AttributeChannel.js\");\nvar ClipFromDefinition = __webpack_require__(/*! ./corePlugins/SelfContainedIncidents/ClipFromDefinition */ \"./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/ClipFromDefinition.js\");\nvar SelfContainedChannel = __webpack_require__(/*! ./corePlugins/SelfContainedIncidents/SCIChannel */ \"./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/SCIChannel.js\");\nvar pipeMessages = __webpack_require__(/*! ./configuration/pipesConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/pipesConf.js\");\n\nvar conf = __webpack_require__(/*! ./configuration/generalConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\nvar Timer = __webpack_require__(/*! ./utils/Timer */ \"./node_modules/@kissmybutton/motorcortex/dist/utils/Timer.js\");\n\nvar checkPlugin = function checkPlugin(main) {\n    if (main.hasOwnProperty('default')) {\n        main = main.default;\n    }\n\n    var plugin_name = main.npm_name;\n    var check = true;\n\n    if (!main.hasOwnProperty('incidents')) {\n        helper.error('Error on plugin ' + plugin_name + '. A plugin must expose at least one Incident.\\n        Exposed plugin Incidents should be defined on the \"incidents\" key of the main.js file.');\n        check = false;\n    }\n\n    if (!helper.isArray(main.incidents)) {\n        helper.error('Error on plugin ' + plugin_name + '. thePlugin exposed Incidents are defined on the \"incidents\" key of the main.js file in array format.\\n        Please refer to the documentation');\n        check = false;\n    } else {\n        for (var i = 0; i < main.incidents.length; i++) {\n            var exposedIncidentDefinition = main.incidents[i];\n            if (_typeof(exposedIncidentDefinition.exportable) === \"object\") {\n                if (exposedIncidentDefinition.exportable.hasOwnProperty('default')) {\n                    exposedIncidentDefinition.exportable = exposedIncidentDefinition.exportable.default;\n                }\n            }\n            if (!(exposedIncidentDefinition.exportable.prototype instanceof Incident)) {\n                helper.error('Error on plugin ' + plugin_name + '. Exportable Incidents by any plugin must extend one of the base classes provided by MotorCortex.\\n                ' + exposedIncidentDefinition.exportable.constructor.name + ' doesn\\'t.\\n                Please refer to documentation');\n                check = false;\n            }\n\n            if (!exposedIncidentDefinition.hasOwnProperty('name')) {\n                helper.error('Error on plugin ' + plugin_name + '. Exportable Incidents by any plugin must have the \"name\" key which defines the name of the exported Incident.\\n                Please refer to documentation');\n                check = false;\n            }\n\n            if (!exposedIncidentDefinition.hasOwnProperty('propTypes')) {\n                helper.log('Warning on plugin ' + plugin_name + '.\\n                It\\'s always good for plugins to define the supported propTypes of their exposed Incidents\\' supported properties.\\n                ' + exposedIncidentDefinition.exportable.constructor.name + ' doesn\\'t.\\n                Please refer to documentation', 'warning');\n            }\n        }\n    }\n\n    if (!main.hasOwnProperty('channel')) {\n        helper.error('Error on plugin ' + plugin_name + '. A plugin must always define its Channel on the \"channel\" key of the main.js file.\\n        It\\'s missing. Please refer to documentation');\n        check = false;\n    } else {\n        if (_typeof(main.channel) === \"object\") {\n            if (main.channel.hasOwnProperty('default')) {\n                main.channel = main.channel.default;\n            }\n        }\n    }\n\n    return check;\n};\n\n// plugin_name is the unique name of the plugin\nfunction loadPlugin(plugin) {\n    if (plugin.hasOwnProperty('default')) {\n        plugin = plugin.default;\n    }\n\n    if (!plugin.hasOwnProperty('npm_name')) {\n        plugin.npm_name = 'plugin_' + new Date().getTime();\n    }\n\n    if (!plugin.hasOwnProperty('channel')) {\n        plugin.channel = Channel;\n    }\n    if (!checkPlugin(plugin)) {\n        return false;\n    } else {\n        // thePlugin is the plugin object which will hold on its keys\n        // the names of the exposed Incidents of its. The keys of this object\n        // are going to be identical with the names of the classes exposed\n        var thePlugin = {};\n\n        if (plugin.hasOwnProperty('clip')) {\n            if (_typeof(plugin.clip) === \"object\") {\n                if (plugin.clip.hasOwnProperty('default')) {\n                    plugin.clip = plugin.clip.default;\n                }\n            }\n            Object.defineProperty(thePlugin, 'Clip', {\n                get: function get() {\n                    var WrapperClass = function WrapperClass(attrs, props) {\n                        _classCallCheck(this, WrapperClass);\n\n                        var instantiatedIncident = new plugin.clip(attrs, props);\n                        instantiatedIncident.plugin_channel_class = SelfContainedChannel;\n                        // instantiatedIncident.mc_plugin_npm_name = '@kissmybutton/self-contained-incidents';\n\n                        return instantiatedIncident;\n                    };\n\n                    return WrapperClass;\n                }\n            });\n            // thePlugin.Clip = plugin.clip;\n        }\n\n        // for each of the exposed Incidents\n\n        var _loop = function _loop(i) {\n            var incidentClass = plugin.incidents[i].exportable;\n\n            // TODO hanlde the different css style isolation versions through the cssIsolation parameter of the containerParams of the incident\n\n            // dynamically assign getters on the Incident's name key of the thePlugin object\n            Object.defineProperty(thePlugin, plugin.incidents[i].name, {\n                get: function get() {\n                    // the getter will construct a wrapper class which on the constructor will instantiate an object of the\n                    // exposed class, set to it the plugin name and channel class parameters and return\n                    // it from the constructor\n                    var WrapperClass = function WrapperClass(attrs, props) {\n                        _classCallCheck(this, WrapperClass);\n\n                        var instantiatedIncident = new incidentClass(attrs, props);\n\n                        instantiatedIncident.mc_plugin_npm_name = plugin.npm_name;\n                        if (plugin.incidents[i].bypassChannel !== true) {\n                            // if the exportable incident has the flag bypassChannel the incident will be treated as motorcortex incident\n                            instantiatedIncident.plugin_channel_class = plugin.channel;\n                        } else {\n                            instantiatedIncident.bypassChannel = true;\n                        }\n\n                        if (plugin.channel.type === \"attributes\" && (!props.hasOwnProperty('selector') || props.selector === null || props.selector === undefined) && plugin.incidents[i].bypassChannel !== true) {\n                            helper.error('You tried to instantiate an Incident of plugin ' + plugin.npm_name + ' without passing props.selector. This plugin uses the AttributeChannel and thus all of its incidents must \\n                                    be initialised with a valid props.selector.');\n                            return false;\n                        }\n\n                        // it's a good idea to both validate the props here before returning the new object\n                        // also is a good idea to create a Proxy for the instantiated Incident to prevent setting:\n                        // id, plugin_channel_class, mc_plugin_npm_name\n\n                        return instantiatedIncident;\n                    };\n\n                    ;\n\n                    return WrapperClass;\n                }\n            });\n        };\n\n        for (var i = 0; i < plugin.incidents.length; i++) {\n            _loop(i);\n        }\n        return thePlugin;\n    }\n}\n\nvar ProgrammaticIncidentPluginDefinition = __webpack_require__(/*! ./corePlugins/ProgrammaticIncidents/main.js */ \"./node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/main.js\");\nvar ProgrammaticIncidentPlugin = loadPlugin(ProgrammaticIncidentPluginDefinition);\n\nvar SelfContainedIncidentsPluginDefinition = __webpack_require__(/*! ./corePlugins/SelfContainedIncidents/main.js */ \"./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/main.js\");\nvar SelfContainedIncidentsPlugin = loadPlugin(SelfContainedIncidentsPluginDefinition);\nvar ExtendableClip = __webpack_require__(/*! ./corePlugins/SelfContainedIncidents/ExtendableClip */ \"./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/ExtendableClip.js\");\n\nvar TimeCapsule = __webpack_require__(/*! ./_coreUtils/TimeCapsule */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/TimeCapsule.js\");\n\nmodule.exports = {\n    Channel: Channel,\n    Group: Group,\n    Clip: SelfContainedIncidentsPlugin.Clip,\n    ClipFromDefinition: ClipFromDefinition,\n    Incident: Incident,\n    ProgrammaticIncident: ProgrammaticIncidentPlugin.ProgrammaticIncident,\n    DummyIncident: ProgrammaticIncidentPlugin.DummyIncident,\n    TimedIncident: TimedIncident,\n\n    _channels: {\n        'motor-cortex-js': Channel,\n        '@kissmybutton/programmatic-incidents': ProgrammaticIncidentPluginDefinition.channel,\n        '@kissmybutton/self-contained-incidents': SelfContainedIncidentsPluginDefinition.channel\n    },\n\n    // channels\n    AttributeChannel: AttributeChannel,\n\n    TimeCapsule: TimeCapsule,\n\n    conf: conf,\n    Timer: Timer,\n\n    ExtendableClip: ExtendableClip,\n\n    Helper: Helper,\n\n    loadPlugin: loadPlugin,\n\n    _GAIN_CHANGE: pipeMessages._GAIN_CHANGE\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L21haW4uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L21haW4uanM/MzAyZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIENoYW5uZWwgPSByZXF1aXJlKCcuL19DaGFubmVscy9DaGFubmVsJyk7XG52YXIgR3JvdXAgPSByZXF1aXJlKCcuL19CYXNlQ2xhc3Nlcy9Hcm91cCcpO1xudmFyIEluY2lkZW50ID0gcmVxdWlyZSgnLi9fQmFzZUNsYXNzZXMvSW5jaWRlbnQnKTtcbnZhciBUaW1lZEluY2lkZW50ID0gcmVxdWlyZSgnLi9fQmFzZUNsYXNzZXMvVGltZWRJbmNpZGVudCcpO1xudmFyIEhlbHBlciA9IHJlcXVpcmUoJy4vX2NvcmVVdGlscy9IZWxwZXInKTt2YXIgaGVscGVyID0gbmV3IEhlbHBlcigpO1xudmFyIEF0dHJpYnV0ZUNoYW5uZWwgPSByZXF1aXJlKCcuL19DaGFubmVscy9fQXR0cmlidXRlL0F0dHJpYnV0ZUNoYW5uZWwnKTtcbnZhciBDbGlwRnJvbURlZmluaXRpb24gPSByZXF1aXJlKCcuL2NvcmVQbHVnaW5zL1NlbGZDb250YWluZWRJbmNpZGVudHMvQ2xpcEZyb21EZWZpbml0aW9uJyk7XG52YXIgU2VsZkNvbnRhaW5lZENoYW5uZWwgPSByZXF1aXJlKCcuL2NvcmVQbHVnaW5zL1NlbGZDb250YWluZWRJbmNpZGVudHMvU0NJQ2hhbm5lbCcpO1xudmFyIHBpcGVNZXNzYWdlcyA9IHJlcXVpcmUoJy4vY29uZmlndXJhdGlvbi9waXBlc0NvbmYnKTtcblxudmFyIGNvbmYgPSByZXF1aXJlKCcuL2NvbmZpZ3VyYXRpb24vZ2VuZXJhbENvbmYnKTtcbnZhciBUaW1lciA9IHJlcXVpcmUoJy4vdXRpbHMvVGltZXInKTtcblxudmFyIGNoZWNrUGx1Z2luID0gZnVuY3Rpb24gY2hlY2tQbHVnaW4obWFpbikge1xuICAgIGlmIChtYWluLmhhc093blByb3BlcnR5KCdkZWZhdWx0JykpIHtcbiAgICAgICAgbWFpbiA9IG1haW4uZGVmYXVsdDtcbiAgICB9XG5cbiAgICB2YXIgcGx1Z2luX25hbWUgPSBtYWluLm5wbV9uYW1lO1xuICAgIHZhciBjaGVjayA9IHRydWU7XG5cbiAgICBpZiAoIW1haW4uaGFzT3duUHJvcGVydHkoJ2luY2lkZW50cycpKSB7XG4gICAgICAgIGhlbHBlci5lcnJvcignRXJyb3Igb24gcGx1Z2luICcgKyBwbHVnaW5fbmFtZSArICcuIEEgcGx1Z2luIG11c3QgZXhwb3NlIGF0IGxlYXN0IG9uZSBJbmNpZGVudC5cXG4gICAgICAgIEV4cG9zZWQgcGx1Z2luIEluY2lkZW50cyBzaG91bGQgYmUgZGVmaW5lZCBvbiB0aGUgXCJpbmNpZGVudHNcIiBrZXkgb2YgdGhlIG1haW4uanMgZmlsZS4nKTtcbiAgICAgICAgY2hlY2sgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIWhlbHBlci5pc0FycmF5KG1haW4uaW5jaWRlbnRzKSkge1xuICAgICAgICBoZWxwZXIuZXJyb3IoJ0Vycm9yIG9uIHBsdWdpbiAnICsgcGx1Z2luX25hbWUgKyAnLiB0aGVQbHVnaW4gZXhwb3NlZCBJbmNpZGVudHMgYXJlIGRlZmluZWQgb24gdGhlIFwiaW5jaWRlbnRzXCIga2V5IG9mIHRoZSBtYWluLmpzIGZpbGUgaW4gYXJyYXkgZm9ybWF0LlxcbiAgICAgICAgUGxlYXNlIHJlZmVyIHRvIHRoZSBkb2N1bWVudGF0aW9uJyk7XG4gICAgICAgIGNoZWNrID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYWluLmluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGV4cG9zZWRJbmNpZGVudERlZmluaXRpb24gPSBtYWluLmluY2lkZW50c1tpXTtcbiAgICAgICAgICAgIGlmIChfdHlwZW9mKGV4cG9zZWRJbmNpZGVudERlZmluaXRpb24uZXhwb3J0YWJsZSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwb3NlZEluY2lkZW50RGVmaW5pdGlvbi5leHBvcnRhYmxlLmhhc093blByb3BlcnR5KCdkZWZhdWx0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwb3NlZEluY2lkZW50RGVmaW5pdGlvbi5leHBvcnRhYmxlID0gZXhwb3NlZEluY2lkZW50RGVmaW5pdGlvbi5leHBvcnRhYmxlLmRlZmF1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoZXhwb3NlZEluY2lkZW50RGVmaW5pdGlvbi5leHBvcnRhYmxlLnByb3RvdHlwZSBpbnN0YW5jZW9mIEluY2lkZW50KSkge1xuICAgICAgICAgICAgICAgIGhlbHBlci5lcnJvcignRXJyb3Igb24gcGx1Z2luICcgKyBwbHVnaW5fbmFtZSArICcuIEV4cG9ydGFibGUgSW5jaWRlbnRzIGJ5IGFueSBwbHVnaW4gbXVzdCBleHRlbmQgb25lIG9mIHRoZSBiYXNlIGNsYXNzZXMgcHJvdmlkZWQgYnkgTW90b3JDb3J0ZXguXFxuICAgICAgICAgICAgICAgICcgKyBleHBvc2VkSW5jaWRlbnREZWZpbml0aW9uLmV4cG9ydGFibGUuY29uc3RydWN0b3IubmFtZSArICcgZG9lc25cXCd0LlxcbiAgICAgICAgICAgICAgICBQbGVhc2UgcmVmZXIgdG8gZG9jdW1lbnRhdGlvbicpO1xuICAgICAgICAgICAgICAgIGNoZWNrID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZXhwb3NlZEluY2lkZW50RGVmaW5pdGlvbi5oYXNPd25Qcm9wZXJ0eSgnbmFtZScpKSB7XG4gICAgICAgICAgICAgICAgaGVscGVyLmVycm9yKCdFcnJvciBvbiBwbHVnaW4gJyArIHBsdWdpbl9uYW1lICsgJy4gRXhwb3J0YWJsZSBJbmNpZGVudHMgYnkgYW55IHBsdWdpbiBtdXN0IGhhdmUgdGhlIFwibmFtZVwiIGtleSB3aGljaCBkZWZpbmVzIHRoZSBuYW1lIG9mIHRoZSBleHBvcnRlZCBJbmNpZGVudC5cXG4gICAgICAgICAgICAgICAgUGxlYXNlIHJlZmVyIHRvIGRvY3VtZW50YXRpb24nKTtcbiAgICAgICAgICAgICAgICBjaGVjayA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWV4cG9zZWRJbmNpZGVudERlZmluaXRpb24uaGFzT3duUHJvcGVydHkoJ3Byb3BUeXBlcycpKSB7XG4gICAgICAgICAgICAgICAgaGVscGVyLmxvZygnV2FybmluZyBvbiBwbHVnaW4gJyArIHBsdWdpbl9uYW1lICsgJy5cXG4gICAgICAgICAgICAgICAgSXRcXCdzIGFsd2F5cyBnb29kIGZvciBwbHVnaW5zIHRvIGRlZmluZSB0aGUgc3VwcG9ydGVkIHByb3BUeXBlcyBvZiB0aGVpciBleHBvc2VkIEluY2lkZW50c1xcJyBzdXBwb3J0ZWQgcHJvcGVydGllcy5cXG4gICAgICAgICAgICAgICAgJyArIGV4cG9zZWRJbmNpZGVudERlZmluaXRpb24uZXhwb3J0YWJsZS5jb25zdHJ1Y3Rvci5uYW1lICsgJyBkb2VzblxcJ3QuXFxuICAgICAgICAgICAgICAgIFBsZWFzZSByZWZlciB0byBkb2N1bWVudGF0aW9uJywgJ3dhcm5pbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghbWFpbi5oYXNPd25Qcm9wZXJ0eSgnY2hhbm5lbCcpKSB7XG4gICAgICAgIGhlbHBlci5lcnJvcignRXJyb3Igb24gcGx1Z2luICcgKyBwbHVnaW5fbmFtZSArICcuIEEgcGx1Z2luIG11c3QgYWx3YXlzIGRlZmluZSBpdHMgQ2hhbm5lbCBvbiB0aGUgXCJjaGFubmVsXCIga2V5IG9mIHRoZSBtYWluLmpzIGZpbGUuXFxuICAgICAgICBJdFxcJ3MgbWlzc2luZy4gUGxlYXNlIHJlZmVyIHRvIGRvY3VtZW50YXRpb24nKTtcbiAgICAgICAgY2hlY2sgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoX3R5cGVvZihtYWluLmNoYW5uZWwpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBpZiAobWFpbi5jaGFubmVsLmhhc093blByb3BlcnR5KCdkZWZhdWx0JykpIHtcbiAgICAgICAgICAgICAgICBtYWluLmNoYW5uZWwgPSBtYWluLmNoYW5uZWwuZGVmYXVsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjaGVjaztcbn07XG5cbi8vIHBsdWdpbl9uYW1lIGlzIHRoZSB1bmlxdWUgbmFtZSBvZiB0aGUgcGx1Z2luXG5mdW5jdGlvbiBsb2FkUGx1Z2luKHBsdWdpbikge1xuICAgIGlmIChwbHVnaW4uaGFzT3duUHJvcGVydHkoJ2RlZmF1bHQnKSkge1xuICAgICAgICBwbHVnaW4gPSBwbHVnaW4uZGVmYXVsdDtcbiAgICB9XG5cbiAgICBpZiAoIXBsdWdpbi5oYXNPd25Qcm9wZXJ0eSgnbnBtX25hbWUnKSkge1xuICAgICAgICBwbHVnaW4ubnBtX25hbWUgPSAncGx1Z2luXycgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB9XG5cbiAgICBpZiAoIXBsdWdpbi5oYXNPd25Qcm9wZXJ0eSgnY2hhbm5lbCcpKSB7XG4gICAgICAgIHBsdWdpbi5jaGFubmVsID0gQ2hhbm5lbDtcbiAgICB9XG4gICAgaWYgKCFjaGVja1BsdWdpbihwbHVnaW4pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGVQbHVnaW4gaXMgdGhlIHBsdWdpbiBvYmplY3Qgd2hpY2ggd2lsbCBob2xkIG9uIGl0cyBrZXlzXG4gICAgICAgIC8vIHRoZSBuYW1lcyBvZiB0aGUgZXhwb3NlZCBJbmNpZGVudHMgb2YgaXRzLiBUaGUga2V5cyBvZiB0aGlzIG9iamVjdFxuICAgICAgICAvLyBhcmUgZ29pbmcgdG8gYmUgaWRlbnRpY2FsIHdpdGggdGhlIG5hbWVzIG9mIHRoZSBjbGFzc2VzIGV4cG9zZWRcbiAgICAgICAgdmFyIHRoZVBsdWdpbiA9IHt9O1xuXG4gICAgICAgIGlmIChwbHVnaW4uaGFzT3duUHJvcGVydHkoJ2NsaXAnKSkge1xuICAgICAgICAgICAgaWYgKF90eXBlb2YocGx1Z2luLmNsaXApID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5jbGlwLmhhc093blByb3BlcnR5KCdkZWZhdWx0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luLmNsaXAgPSBwbHVnaW4uY2xpcC5kZWZhdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGVQbHVnaW4sICdDbGlwJywge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgV3JhcHBlckNsYXNzID0gZnVuY3Rpb24gV3JhcHBlckNsYXNzKGF0dHJzLCBwcm9wcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdyYXBwZXJDbGFzcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW50aWF0ZWRJbmNpZGVudCA9IG5ldyBwbHVnaW4uY2xpcChhdHRycywgcHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFudGlhdGVkSW5jaWRlbnQucGx1Z2luX2NoYW5uZWxfY2xhc3MgPSBTZWxmQ29udGFpbmVkQ2hhbm5lbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc3RhbnRpYXRlZEluY2lkZW50Lm1jX3BsdWdpbl9ucG1fbmFtZSA9ICdAa2lzc215YnV0dG9uL3NlbGYtY29udGFpbmVkLWluY2lkZW50cyc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW50aWF0ZWRJbmNpZGVudDtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gV3JhcHBlckNsYXNzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gdGhlUGx1Z2luLkNsaXAgPSBwbHVnaW4uY2xpcDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZvciBlYWNoIG9mIHRoZSBleHBvc2VkIEluY2lkZW50c1xuXG4gICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGkpIHtcbiAgICAgICAgICAgIHZhciBpbmNpZGVudENsYXNzID0gcGx1Z2luLmluY2lkZW50c1tpXS5leHBvcnRhYmxlO1xuXG4gICAgICAgICAgICAvLyBUT0RPIGhhbmxkZSB0aGUgZGlmZmVyZW50IGNzcyBzdHlsZSBpc29sYXRpb24gdmVyc2lvbnMgdGhyb3VnaCB0aGUgY3NzSXNvbGF0aW9uIHBhcmFtZXRlciBvZiB0aGUgY29udGFpbmVyUGFyYW1zIG9mIHRoZSBpbmNpZGVudFxuXG4gICAgICAgICAgICAvLyBkeW5hbWljYWxseSBhc3NpZ24gZ2V0dGVycyBvbiB0aGUgSW5jaWRlbnQncyBuYW1lIGtleSBvZiB0aGUgdGhlUGx1Z2luIG9iamVjdFxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoZVBsdWdpbiwgcGx1Z2luLmluY2lkZW50c1tpXS5uYW1lLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBnZXR0ZXIgd2lsbCBjb25zdHJ1Y3QgYSB3cmFwcGVyIGNsYXNzIHdoaWNoIG9uIHRoZSBjb25zdHJ1Y3RvciB3aWxsIGluc3RhbnRpYXRlIGFuIG9iamVjdCBvZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhwb3NlZCBjbGFzcywgc2V0IHRvIGl0IHRoZSBwbHVnaW4gbmFtZSBhbmQgY2hhbm5lbCBjbGFzcyBwYXJhbWV0ZXJzIGFuZCByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgZnJvbSB0aGUgY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgICAgdmFyIFdyYXBwZXJDbGFzcyA9IGZ1bmN0aW9uIFdyYXBwZXJDbGFzcyhhdHRycywgcHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXcmFwcGVyQ2xhc3MpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdGFudGlhdGVkSW5jaWRlbnQgPSBuZXcgaW5jaWRlbnRDbGFzcyhhdHRycywgcHJvcHMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW50aWF0ZWRJbmNpZGVudC5tY19wbHVnaW5fbnBtX25hbWUgPSBwbHVnaW4ubnBtX25hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGx1Z2luLmluY2lkZW50c1tpXS5ieXBhc3NDaGFubmVsICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGV4cG9ydGFibGUgaW5jaWRlbnQgaGFzIHRoZSBmbGFnIGJ5cGFzc0NoYW5uZWwgdGhlIGluY2lkZW50IHdpbGwgYmUgdHJlYXRlZCBhcyBtb3RvcmNvcnRleCBpbmNpZGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbnRpYXRlZEluY2lkZW50LnBsdWdpbl9jaGFubmVsX2NsYXNzID0gcGx1Z2luLmNoYW5uZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbnRpYXRlZEluY2lkZW50LmJ5cGFzc0NoYW5uZWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGx1Z2luLmNoYW5uZWwudHlwZSA9PT0gXCJhdHRyaWJ1dGVzXCIgJiYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnc2VsZWN0b3InKSB8fCBwcm9wcy5zZWxlY3RvciA9PT0gbnVsbCB8fCBwcm9wcy5zZWxlY3RvciA9PT0gdW5kZWZpbmVkKSAmJiBwbHVnaW4uaW5jaWRlbnRzW2ldLmJ5cGFzc0NoYW5uZWwgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWxwZXIuZXJyb3IoJ1lvdSB0cmllZCB0byBpbnN0YW50aWF0ZSBhbiBJbmNpZGVudCBvZiBwbHVnaW4gJyArIHBsdWdpbi5ucG1fbmFtZSArICcgd2l0aG91dCBwYXNzaW5nIHByb3BzLnNlbGVjdG9yLiBUaGlzIHBsdWdpbiB1c2VzIHRoZSBBdHRyaWJ1dGVDaGFubmVsIGFuZCB0aHVzIGFsbCBvZiBpdHMgaW5jaWRlbnRzIG11c3QgXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmUgaW5pdGlhbGlzZWQgd2l0aCBhIHZhbGlkIHByb3BzLnNlbGVjdG9yLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBhIGdvb2QgaWRlYSB0byBib3RoIHZhbGlkYXRlIHRoZSBwcm9wcyBoZXJlIGJlZm9yZSByZXR1cm5pbmcgdGhlIG5ldyBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsc28gaXMgYSBnb29kIGlkZWEgdG8gY3JlYXRlIGEgUHJveHkgZm9yIHRoZSBpbnN0YW50aWF0ZWQgSW5jaWRlbnQgdG8gcHJldmVudCBzZXR0aW5nOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWQsIHBsdWdpbl9jaGFubmVsX2NsYXNzLCBtY19wbHVnaW5fbnBtX25hbWVcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbnRpYXRlZEluY2lkZW50O1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIDtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gV3JhcHBlckNsYXNzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2luLmluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgX2xvb3AoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoZVBsdWdpbjtcbiAgICB9XG59XG5cbnZhciBQcm9ncmFtbWF0aWNJbmNpZGVudFBsdWdpbkRlZmluaXRpb24gPSByZXF1aXJlKCcuL2NvcmVQbHVnaW5zL1Byb2dyYW1tYXRpY0luY2lkZW50cy9tYWluLmpzJyk7XG52YXIgUHJvZ3JhbW1hdGljSW5jaWRlbnRQbHVnaW4gPSBsb2FkUGx1Z2luKFByb2dyYW1tYXRpY0luY2lkZW50UGx1Z2luRGVmaW5pdGlvbik7XG5cbnZhciBTZWxmQ29udGFpbmVkSW5jaWRlbnRzUGx1Z2luRGVmaW5pdGlvbiA9IHJlcXVpcmUoJy4vY29yZVBsdWdpbnMvU2VsZkNvbnRhaW5lZEluY2lkZW50cy9tYWluLmpzJyk7XG52YXIgU2VsZkNvbnRhaW5lZEluY2lkZW50c1BsdWdpbiA9IGxvYWRQbHVnaW4oU2VsZkNvbnRhaW5lZEluY2lkZW50c1BsdWdpbkRlZmluaXRpb24pO1xudmFyIEV4dGVuZGFibGVDbGlwID0gcmVxdWlyZSgnLi9jb3JlUGx1Z2lucy9TZWxmQ29udGFpbmVkSW5jaWRlbnRzL0V4dGVuZGFibGVDbGlwJyk7XG5cbnZhciBUaW1lQ2Fwc3VsZSA9IHJlcXVpcmUoJy4vX2NvcmVVdGlscy9UaW1lQ2Fwc3VsZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBDaGFubmVsOiBDaGFubmVsLFxuICAgIEdyb3VwOiBHcm91cCxcbiAgICBDbGlwOiBTZWxmQ29udGFpbmVkSW5jaWRlbnRzUGx1Z2luLkNsaXAsXG4gICAgQ2xpcEZyb21EZWZpbml0aW9uOiBDbGlwRnJvbURlZmluaXRpb24sXG4gICAgSW5jaWRlbnQ6IEluY2lkZW50LFxuICAgIFByb2dyYW1tYXRpY0luY2lkZW50OiBQcm9ncmFtbWF0aWNJbmNpZGVudFBsdWdpbi5Qcm9ncmFtbWF0aWNJbmNpZGVudCxcbiAgICBEdW1teUluY2lkZW50OiBQcm9ncmFtbWF0aWNJbmNpZGVudFBsdWdpbi5EdW1teUluY2lkZW50LFxuICAgIFRpbWVkSW5jaWRlbnQ6IFRpbWVkSW5jaWRlbnQsXG5cbiAgICBfY2hhbm5lbHM6IHtcbiAgICAgICAgJ21vdG9yLWNvcnRleC1qcyc6IENoYW5uZWwsXG4gICAgICAgICdAa2lzc215YnV0dG9uL3Byb2dyYW1tYXRpYy1pbmNpZGVudHMnOiBQcm9ncmFtbWF0aWNJbmNpZGVudFBsdWdpbkRlZmluaXRpb24uY2hhbm5lbCxcbiAgICAgICAgJ0BraXNzbXlidXR0b24vc2VsZi1jb250YWluZWQtaW5jaWRlbnRzJzogU2VsZkNvbnRhaW5lZEluY2lkZW50c1BsdWdpbkRlZmluaXRpb24uY2hhbm5lbFxuICAgIH0sXG5cbiAgICAvLyBjaGFubmVsc1xuICAgIEF0dHJpYnV0ZUNoYW5uZWw6IEF0dHJpYnV0ZUNoYW5uZWwsXG5cbiAgICBUaW1lQ2Fwc3VsZTogVGltZUNhcHN1bGUsXG5cbiAgICBjb25mOiBjb25mLFxuICAgIFRpbWVyOiBUaW1lcixcblxuICAgIEV4dGVuZGFibGVDbGlwOiBFeHRlbmRhYmxlQ2xpcCxcblxuICAgIEhlbHBlcjogSGVscGVyLFxuXG4gICAgbG9hZFBsdWdpbjogbG9hZFBsdWdpbixcblxuICAgIF9HQUlOX0NIQU5HRTogcGlwZU1lc3NhZ2VzLl9HQUlOX0NIQU5HRVxufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/main.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/utils/Timer.js":
/*!********************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/utils/Timer.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Helper = __webpack_require__(/*! ../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar conf = __webpack_require__(/*! ../configuration/generalConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\nvar Draggabilly = __webpack_require__(/*! draggabilly */ \"./node_modules/draggabilly/draggabilly.js\");\nvar TimeCapsule = __webpack_require__(/*! ../_coreUtils/TimeCapsule */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/TimeCapsule.js\");\nvar timeCapsule = new TimeCapsule();\nvar journey = null;\n\n/**\n * @classdesc\n * Timer's purpose is to provide an interface through which any TimedIncident (such as a Scene or a Clip)\n * can both privide info regarding their timing state but also provide an interface for interacting /\n * altering the timing of it\n */\n\nvar Timer = function () {\n    function Timer(props) {\n        _classCallCheck(this, Timer);\n\n        this.id = props.id || helper.getAnId();\n        this.cursor = document.getElementById('time-cursor');\n        this.leftSlot = document.getElementsByClassName('left-slot')[0];\n        this.rightSlot = document.getElementsByClassName('right-slot')[0];\n        this.playButton = document.getElementById('play-pause');\n        this.Incident = props.Incident;\n        this.subscribeToTimer();\n        this.subscribeToEvents();\n        this.afterRender();\n        this.previousTimestamp = 0;\n        this.previousIncidentState = 'idle';\n        this.width = props.width;\n        this.cursorWidth = props.cursorWidth || 10;\n    }\n\n    _createClass(Timer, [{\n        key: 'millisecondChange',\n        value: function millisecondChange(millisecond, state) {\n            // helper.log(millisecond);\n            this.cursor.style.left = 'calc(' + millisecond * 100 / this.Incident.duration + '% - ' + this.cursorWidth + 'px)';\n            this.leftSlot.innerHTML = millisecond;\n            this.rightSlot.innerHTML = this.Incident.duration - millisecond;\n        }\n    }, {\n        key: 'eventBroadcast',\n        value: function eventBroadcast(eventName, meta) {\n            if (eventName === 'state-change') {\n                if (meta.newState === 'waiting') {\n                    this.playButton.innerHTML = 'Resume';\n                } else if (meta.newState === 'playing') {\n                    this.playButton.innerHTML = 'Pause';\n                } else if (meta.newState === 'completed') {\n                    this.leftSlot.innerHTML = this.Incident.duration;\n                    this.rightSlot.innerHTML = 0;\n                    this.playButton.innerHTML = \"completed\";\n                    helper.log(this.Incident);\n                } else if (meta.newState === 'transitional') {\n                    this.playButton.innerHTML = \"transitioning\";\n                } else if (meta.newState === 'idle') {\n                    this.playButton.innerHTML = \"Play\";\n                }\n            } else if (eventName === 'attribute-rejection') {\n                helper.log('Attributes', meta.attributes, 'have been rejected from animation with id ' + meta.animationID);\n            } else if (eventName === 'animation-rejection') {\n                helper.log('Animation ' + meta.animationID + ' has been rejected as all attributes of it overlap on specific elements because of existing animations');\n            } else if (eventName === 'duration-change') {\n                this.millisecondChange(this.Incident.runTimeInfo.currentMillisecond, this.Incident.state);\n            }\n        }\n    }, {\n        key: 'subscribeToEvents',\n        value: function subscribeToEvents() {\n            // helper.error('Timer is subscirbing to the clips events');\n            this.Incident.subscribeToEvents(this.id, this.eventBroadcast.bind(this));\n        }\n    }, {\n        key: 'subscribeToTimer',\n        value: function subscribeToTimer() {\n            // helper.log('Timer is subscirbing to the clips timer', 'notice');\n            this.Incident.subscribe(this.id, this.millisecondChange.bind(this));\n        }\n    }, {\n        key: 'handleDragStart',\n        value: function handleDragStart(event, pointer) {\n            // helper.log('drag is starting', 'warning')\n            journey = timeCapsule.startJourney(this.Incident);\n        }\n    }, {\n        key: 'handleDrag',\n        value: function handleDrag(event, pointer, position) {\n            var millisecond = Math.round(this.Incident.duration * position.x / this.width);\n            if (millisecond < 0) {\n                millisecond = 0;\n            }\n            this.leftSlot.innerHTML = millisecond;\n            this.rightSlot.innerHTML = this.Incident.duration - millisecond;\n\n            journey.station(millisecond);\n        }\n    }, {\n        key: 'handleDragEnd',\n        value: function handleDragEnd(event, pointer) {\n            //  Velocity.defaults.speed=1;\n            // this.previousTimestamp is the target millisecond of the drag\n\n            journey.destination();\n\n            helper.log(this.Incident.exportState());\n        }\n    }, {\n        key: 'afterRender',\n        value: function afterRender() {\n            var that = this;\n\n            this.playButton.onclick = function (e) {\n                if (that.Incident.state === 'playing') {\n                    that.Incident.wait();\n                } else if (that.Incident.state === 'waiting') {\n                    that.Incident.resume();\n                } else if (that.Incident.state === 'idle') {\n                    that.Incident.play();\n                }\n            };\n\n            var elem = document.querySelector('#time-cursor');\n            var draggie = new Draggabilly(elem, {\n                axis: 'x',\n                containment: '.bar'\n            });\n\n            draggie.on('dragStart', this.handleDragStart.bind(this));\n            draggie.on('dragMove', function (event, pointer) {\n                that.handleDrag(event, pointer, draggie.position);\n            });\n            draggie.on('dragEnd', this.handleDragEnd.bind(this));\n        }\n    }, {\n        key: 'render',\n        value: function render(container) {}\n    }]);\n\n    return Timer;\n}();\n\nmodule.exports = Timer;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L3V0aWxzL1RpbWVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC91dGlscy9UaW1lci5qcz85NmYwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEhlbHBlciA9IHJlcXVpcmUoJy4uL19jb3JlVXRpbHMvSGVscGVyJyk7XG52YXIgaGVscGVyID0gbmV3IEhlbHBlcigpO1xudmFyIGNvbmYgPSByZXF1aXJlKCcuLi9jb25maWd1cmF0aW9uL2dlbmVyYWxDb25mJyk7XG52YXIgRHJhZ2dhYmlsbHkgPSByZXF1aXJlKCdkcmFnZ2FiaWxseScpO1xudmFyIFRpbWVDYXBzdWxlID0gcmVxdWlyZSgnLi4vX2NvcmVVdGlscy9UaW1lQ2Fwc3VsZScpO1xudmFyIHRpbWVDYXBzdWxlID0gbmV3IFRpbWVDYXBzdWxlKCk7XG52YXIgam91cm5leSA9IG51bGw7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogVGltZXIncyBwdXJwb3NlIGlzIHRvIHByb3ZpZGUgYW4gaW50ZXJmYWNlIHRocm91Z2ggd2hpY2ggYW55IFRpbWVkSW5jaWRlbnQgKHN1Y2ggYXMgYSBTY2VuZSBvciBhIENsaXApXG4gKiBjYW4gYm90aCBwcml2aWRlIGluZm8gcmVnYXJkaW5nIHRoZWlyIHRpbWluZyBzdGF0ZSBidXQgYWxzbyBwcm92aWRlIGFuIGludGVyZmFjZSBmb3IgaW50ZXJhY3RpbmcgL1xuICogYWx0ZXJpbmcgdGhlIHRpbWluZyBvZiBpdFxuICovXG5cbnZhciBUaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUaW1lcihwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGltZXIpO1xuXG4gICAgICAgIHRoaXMuaWQgPSBwcm9wcy5pZCB8fCBoZWxwZXIuZ2V0QW5JZCgpO1xuICAgICAgICB0aGlzLmN1cnNvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0aW1lLWN1cnNvcicpO1xuICAgICAgICB0aGlzLmxlZnRTbG90ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbGVmdC1zbG90JylbMF07XG4gICAgICAgIHRoaXMucmlnaHRTbG90ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgncmlnaHQtc2xvdCcpWzBdO1xuICAgICAgICB0aGlzLnBsYXlCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGxheS1wYXVzZScpO1xuICAgICAgICB0aGlzLkluY2lkZW50ID0gcHJvcHMuSW5jaWRlbnQ7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9UaW1lcigpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZVRvRXZlbnRzKCk7XG4gICAgICAgIHRoaXMuYWZ0ZXJSZW5kZXIoKTtcbiAgICAgICAgdGhpcy5wcmV2aW91c1RpbWVzdGFtcCA9IDA7XG4gICAgICAgIHRoaXMucHJldmlvdXNJbmNpZGVudFN0YXRlID0gJ2lkbGUnO1xuICAgICAgICB0aGlzLndpZHRoID0gcHJvcHMud2lkdGg7XG4gICAgICAgIHRoaXMuY3Vyc29yV2lkdGggPSBwcm9wcy5jdXJzb3JXaWR0aCB8fCAxMDtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoVGltZXIsIFt7XG4gICAgICAgIGtleTogJ21pbGxpc2Vjb25kQ2hhbmdlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1pbGxpc2Vjb25kQ2hhbmdlKG1pbGxpc2Vjb25kLCBzdGF0ZSkge1xuICAgICAgICAgICAgLy8gaGVscGVyLmxvZyhtaWxsaXNlY29uZCk7XG4gICAgICAgICAgICB0aGlzLmN1cnNvci5zdHlsZS5sZWZ0ID0gJ2NhbGMoJyArIG1pbGxpc2Vjb25kICogMTAwIC8gdGhpcy5JbmNpZGVudC5kdXJhdGlvbiArICclIC0gJyArIHRoaXMuY3Vyc29yV2lkdGggKyAncHgpJztcbiAgICAgICAgICAgIHRoaXMubGVmdFNsb3QuaW5uZXJIVE1MID0gbWlsbGlzZWNvbmQ7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0U2xvdC5pbm5lckhUTUwgPSB0aGlzLkluY2lkZW50LmR1cmF0aW9uIC0gbWlsbGlzZWNvbmQ7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2V2ZW50QnJvYWRjYXN0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGV2ZW50QnJvYWRjYXN0KGV2ZW50TmFtZSwgbWV0YSkge1xuICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gJ3N0YXRlLWNoYW5nZScpIHtcbiAgICAgICAgICAgICAgICBpZiAobWV0YS5uZXdTdGF0ZSA9PT0gJ3dhaXRpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGxheUJ1dHRvbi5pbm5lckhUTUwgPSAnUmVzdW1lJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1ldGEubmV3U3RhdGUgPT09ICdwbGF5aW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsYXlCdXR0b24uaW5uZXJIVE1MID0gJ1BhdXNlJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1ldGEubmV3U3RhdGUgPT09ICdjb21wbGV0ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGVmdFNsb3QuaW5uZXJIVE1MID0gdGhpcy5JbmNpZGVudC5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yaWdodFNsb3QuaW5uZXJIVE1MID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbGF5QnV0dG9uLmlubmVySFRNTCA9IFwiY29tcGxldGVkXCI7XG4gICAgICAgICAgICAgICAgICAgIGhlbHBlci5sb2codGhpcy5JbmNpZGVudCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtZXRhLm5ld1N0YXRlID09PSAndHJhbnNpdGlvbmFsJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsYXlCdXR0b24uaW5uZXJIVE1MID0gXCJ0cmFuc2l0aW9uaW5nXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtZXRhLm5ld1N0YXRlID09PSAnaWRsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbGF5QnV0dG9uLmlubmVySFRNTCA9IFwiUGxheVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnROYW1lID09PSAnYXR0cmlidXRlLXJlamVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBoZWxwZXIubG9nKCdBdHRyaWJ1dGVzJywgbWV0YS5hdHRyaWJ1dGVzLCAnaGF2ZSBiZWVuIHJlamVjdGVkIGZyb20gYW5pbWF0aW9uIHdpdGggaWQgJyArIG1ldGEuYW5pbWF0aW9uSUQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudE5hbWUgPT09ICdhbmltYXRpb24tcmVqZWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGhlbHBlci5sb2coJ0FuaW1hdGlvbiAnICsgbWV0YS5hbmltYXRpb25JRCArICcgaGFzIGJlZW4gcmVqZWN0ZWQgYXMgYWxsIGF0dHJpYnV0ZXMgb2YgaXQgb3ZlcmxhcCBvbiBzcGVjaWZpYyBlbGVtZW50cyBiZWNhdXNlIG9mIGV4aXN0aW5nIGFuaW1hdGlvbnMnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnROYW1lID09PSAnZHVyYXRpb24tY2hhbmdlJykge1xuICAgICAgICAgICAgICAgIHRoaXMubWlsbGlzZWNvbmRDaGFuZ2UodGhpcy5JbmNpZGVudC5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQsIHRoaXMuSW5jaWRlbnQuc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzdWJzY3JpYmVUb0V2ZW50cycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdWJzY3JpYmVUb0V2ZW50cygpIHtcbiAgICAgICAgICAgIC8vIGhlbHBlci5lcnJvcignVGltZXIgaXMgc3Vic2NpcmJpbmcgdG8gdGhlIGNsaXBzIGV2ZW50cycpO1xuICAgICAgICAgICAgdGhpcy5JbmNpZGVudC5zdWJzY3JpYmVUb0V2ZW50cyh0aGlzLmlkLCB0aGlzLmV2ZW50QnJvYWRjYXN0LmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzdWJzY3JpYmVUb1RpbWVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN1YnNjcmliZVRvVGltZXIoKSB7XG4gICAgICAgICAgICAvLyBoZWxwZXIubG9nKCdUaW1lciBpcyBzdWJzY2lyYmluZyB0byB0aGUgY2xpcHMgdGltZXInLCAnbm90aWNlJyk7XG4gICAgICAgICAgICB0aGlzLkluY2lkZW50LnN1YnNjcmliZSh0aGlzLmlkLCB0aGlzLm1pbGxpc2Vjb25kQ2hhbmdlLmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdoYW5kbGVEcmFnU3RhcnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlRHJhZ1N0YXJ0KGV2ZW50LCBwb2ludGVyKSB7XG4gICAgICAgICAgICAvLyBoZWxwZXIubG9nKCdkcmFnIGlzIHN0YXJ0aW5nJywgJ3dhcm5pbmcnKVxuICAgICAgICAgICAgam91cm5leSA9IHRpbWVDYXBzdWxlLnN0YXJ0Sm91cm5leSh0aGlzLkluY2lkZW50KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaGFuZGxlRHJhZycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVEcmFnKGV2ZW50LCBwb2ludGVyLCBwb3NpdGlvbikge1xuICAgICAgICAgICAgdmFyIG1pbGxpc2Vjb25kID0gTWF0aC5yb3VuZCh0aGlzLkluY2lkZW50LmR1cmF0aW9uICogcG9zaXRpb24ueCAvIHRoaXMud2lkdGgpO1xuICAgICAgICAgICAgaWYgKG1pbGxpc2Vjb25kIDwgMCkge1xuICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGVmdFNsb3QuaW5uZXJIVE1MID0gbWlsbGlzZWNvbmQ7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0U2xvdC5pbm5lckhUTUwgPSB0aGlzLkluY2lkZW50LmR1cmF0aW9uIC0gbWlsbGlzZWNvbmQ7XG5cbiAgICAgICAgICAgIGpvdXJuZXkuc3RhdGlvbihtaWxsaXNlY29uZCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2hhbmRsZURyYWdFbmQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlRHJhZ0VuZChldmVudCwgcG9pbnRlcikge1xuICAgICAgICAgICAgLy8gIFZlbG9jaXR5LmRlZmF1bHRzLnNwZWVkPTE7XG4gICAgICAgICAgICAvLyB0aGlzLnByZXZpb3VzVGltZXN0YW1wIGlzIHRoZSB0YXJnZXQgbWlsbGlzZWNvbmQgb2YgdGhlIGRyYWdcblxuICAgICAgICAgICAgam91cm5leS5kZXN0aW5hdGlvbigpO1xuXG4gICAgICAgICAgICBoZWxwZXIubG9nKHRoaXMuSW5jaWRlbnQuZXhwb3J0U3RhdGUoKSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2FmdGVyUmVuZGVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFmdGVyUmVuZGVyKCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICB0aGlzLnBsYXlCdXR0b24ub25jbGljayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoYXQuSW5jaWRlbnQuc3RhdGUgPT09ICdwbGF5aW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LkluY2lkZW50LndhaXQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoYXQuSW5jaWRlbnQuc3RhdGUgPT09ICd3YWl0aW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LkluY2lkZW50LnJlc3VtZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhhdC5JbmNpZGVudC5zdGF0ZSA9PT0gJ2lkbGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuSW5jaWRlbnQucGxheSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBlbGVtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3RpbWUtY3Vyc29yJyk7XG4gICAgICAgICAgICB2YXIgZHJhZ2dpZSA9IG5ldyBEcmFnZ2FiaWxseShlbGVtLCB7XG4gICAgICAgICAgICAgICAgYXhpczogJ3gnLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5tZW50OiAnLmJhcidcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkcmFnZ2llLm9uKCdkcmFnU3RhcnQnLCB0aGlzLmhhbmRsZURyYWdTdGFydC5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIGRyYWdnaWUub24oJ2RyYWdNb3ZlJywgZnVuY3Rpb24gKGV2ZW50LCBwb2ludGVyKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5oYW5kbGVEcmFnKGV2ZW50LCBwb2ludGVyLCBkcmFnZ2llLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZHJhZ2dpZS5vbignZHJhZ0VuZCcsIHRoaXMuaGFuZGxlRHJhZ0VuZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVuZGVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcihjb250YWluZXIpIHt9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFRpbWVyO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbWVyOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/utils/Timer.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.clonedeep/index.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.clonedeep/index.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, module) {/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize include=\"filter,sortBy,findIndex,find,forEach,cloneDeep\" exports=\"npm\"`\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_FLAT_FLAG = 2,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports =  true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsMap = nodeUtil && nodeUtil.isMap,\n    nodeIsSet = nodeUtil && nodeUtil.isSet,\n    nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,\n    getPrototype = overArg(Object.getPrototypeOf, Object),\n    objectCreate = Object.create,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(proto) {\n    if (!isObject(proto)) {\n      return {};\n    }\n    if (objectCreate) {\n      return objectCreate(proto);\n    }\n    object.prototype = proto;\n    var result = new object;\n    object.prototype = undefined;\n    return result;\n  };\n}());\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\n/**\n * The base implementation of `_.assignIn` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssignIn(object, source) {\n  return object && copyObject(source, keysIn(source), object);\n}\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Deep clone\n *  2 - Flatten inherited properties\n *  4 - Clone symbols\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  var result,\n      isDeep = bitmask & CLONE_DEEP_FLAG,\n      isFlat = bitmask & CLONE_FLAT_FLAG,\n      isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      result = (isFlat || isFunc) ? {} : initCloneObject(value);\n      if (!isDeep) {\n        return isFlat\n          ? copySymbolsIn(value, baseAssignIn(result, value))\n          : copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (isSet(value)) {\n    value.forEach(function(subValue) {\n      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n    });\n\n    return result;\n  }\n\n  if (isMap(value)) {\n    value.forEach(function(subValue, key) {\n      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n    });\n\n    return result;\n  }\n\n  var keysFunc = isFull\n    ? (isFlat ? getAllKeysIn : getAllKeys)\n    : (isFlat ? keysIn : keys);\n\n  var props = isArr ? undefined : keysFunc(value);\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n  });\n  return result;\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isMap` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n */\nfunction baseIsMap(value) {\n  return isObjectLike(value) && getTag(value) == mapTag;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isSet` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n */\nfunction baseIsSet(value) {\n  return isObjectLike(value) && getTag(value) == setTag;\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var length = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n  buffer.copy(result);\n  return result;\n}\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      baseAssignValue(object, key, newValue);\n    } else {\n      assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}\n\n/**\n * Copies own symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\n/**\n * Copies own and inherited symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbolsIn(source, object) {\n  return copyObject(source, getSymbolsIn(source), object);\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Creates an array of own and inherited enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeysIn(object) {\n  return baseGetAllKeys(object, keysIn, getSymbolsIn);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\n/**\n * Creates an array of the own and inherited enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n  var result = [];\n  while (object) {\n    arrayPush(result, getSymbols(object));\n    object = getPrototype(object);\n  }\n  return result;\n};\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = new array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return new Ctor;\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return new Ctor;\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * This method is like `_.clone` except that it recursively clones `value`.\n *\n * @static\n * @memberOf _\n * @since 1.0.0\n * @category Lang\n * @param {*} value The value to recursively clone.\n * @returns {*} Returns the deep cloned value.\n * @see _.clone\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var deep = _.cloneDeep(objects);\n * console.log(deep[0] === objects[0]);\n * // => false\n */\nfunction cloneDeep(value) {\n  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Map` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n * @example\n *\n * _.isMap(new Map);\n * // => true\n *\n * _.isMap(new WeakMap);\n * // => false\n */\nvar isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\n/**\n * Checks if `value` is classified as a `Set` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n * @example\n *\n * _.isSet(new Set);\n * // => true\n *\n * _.isSet(new WeakSet);\n * // => false\n */\nvar isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = cloneDeep;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9sb2Rhc2gtY3VzdG9tLWJ1aWxkL21vZHVsYXJpemUvbG9kYXNoLmNsb25lZGVlcC9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2xvZGFzaC1jdXN0b20tYnVpbGQvbW9kdWxhcml6ZS9sb2Rhc2guY2xvbmVkZWVwL2luZGV4LmpzPzAzYzciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBMb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGluY2x1ZGU9XCJmaWx0ZXIsc29ydEJ5LGZpbmRJbmRleCxmaW5kLGZvckVhY2gsY2xvbmVEZWVwXCIgZXhwb3J0cz1cIm5wbVwiYFxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcy5mb3VuZGF0aW9uLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfREVFUF9GTEFHID0gMSxcbiAgICBDTE9ORV9GTEFUX0ZMQUcgPSAyLFxuICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVGbGFncyA9IC9cXHcqJC87XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgc3VwcG9ydGVkIGJ5IGBfLmNsb25lYC4gKi9cbnZhciBjbG9uZWFibGVUYWdzID0ge307XG5jbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxuY2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGFWaWV3VGFnXSA9XG5jbG9uZWFibGVUYWdzW2Jvb2xUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRlVGFnXSA9XG5jbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID0gY2xvbmVhYmxlVGFnc1tmbG9hdDY0VGFnXSA9XG5jbG9uZWFibGVUYWdzW2ludDhUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQxNlRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW21hcFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tudW1iZXJUYWddID0gY2xvbmVhYmxlVGFnc1tvYmplY3RUYWddID1cbmNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc2V0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3N0cmluZ1RhZ10gPSBjbG9uZWFibGVUYWdzW3N5bWJvbFRhZ10gPVxuY2xvbmVhYmxlVGFnc1t1aW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPVxuY2xvbmVhYmxlVGFnc1t1aW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbmNsb25lYWJsZVRhZ3NbZXJyb3JUYWddID0gY2xvbmVhYmxlVGFnc1tmdW5jVGFnXSA9XG5jbG9uZWFibGVUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc01hcCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzTWFwLFxuICAgIG5vZGVJc1NldCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzU2V0LFxuICAgIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgU3ltYm9sID0gcm9vdC5TeW1ib2wsXG4gICAgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheSxcbiAgICBhbGxvY1Vuc2FmZSA9IEJ1ZmZlciA/IEJ1ZmZlci5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZCxcbiAgICBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KSxcbiAgICBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlLFxuICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2UsXG4gICAgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG4gICAgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKSxcbiAgICBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpLFxuICAgIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKSxcbiAgICBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpLFxuICAgIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKSxcbiAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbnZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICB9XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn0oKSk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25JbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbkluKG9iamVjdCwgc291cmNlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCBhbmQgYF8uY2xvbmVEZWVwYCB3aGljaCB0cmFja3NcbiAqIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gRGVlcCBjbG9uZVxuICogIDIgLSBGbGF0dGVuIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG4gKiAgNCAtIENsb25lIHN5bWJvbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIG9iamVjdHMgYW5kIHRoZWlyIGNsb25lIGNvdW50ZXJwYXJ0cy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrKSB7XG4gIHZhciByZXN1bHQsXG4gICAgICBpc0RlZXAgPSBiaXRtYXNrICYgQ0xPTkVfREVFUF9GTEFHLFxuICAgICAgaXNGbGF0ID0gYml0bWFzayAmIENMT05FX0ZMQVRfRkxBRyxcbiAgICAgIGlzRnVsbCA9IGJpdG1hc2sgJiBDTE9ORV9TWU1CT0xTX0ZMQUc7XG5cbiAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcih2YWx1ZSk7XG4gIH1cbiAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgaWYgKGlzQXJyKSB7XG4gICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgIGlmICghaXNEZWVwKSB7XG4gICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcblxuICAgIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSwgaXNEZWVwKTtcbiAgICB9XG4gICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgcmVzdWx0ID0gKGlzRmxhdCB8fCBpc0Z1bmMpID8ge30gOiBpbml0Q2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGlzRmxhdFxuICAgICAgICAgID8gY29weVN5bWJvbHNJbih2YWx1ZSwgYmFzZUFzc2lnbkluKHJlc3VsdCwgdmFsdWUpKVxuICAgICAgICAgIDogY29weVN5bWJvbHModmFsdWUsIGJhc2VBc3NpZ24ocmVzdWx0LCB2YWx1ZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWNsb25lYWJsZVRhZ3NbdGFnXSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGlzRGVlcCk7XG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KHZhbHVlKTtcbiAgaWYgKHN0YWNrZWQpIHtcbiAgICByZXR1cm4gc3RhY2tlZDtcbiAgfVxuICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdCk7XG5cbiAgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUpIHtcbiAgICAgIHJlc3VsdC5hZGQoYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdWJWYWx1ZSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKGlzTWFwKHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0LnNldChrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIga2V5c0Z1bmMgPSBpc0Z1bGxcbiAgICA/IChpc0ZsYXQgPyBnZXRBbGxLZXlzSW4gOiBnZXRBbGxLZXlzKVxuICAgIDogKGlzRmxhdCA/IGtleXNJbiA6IGtleXMpO1xuXG4gIHZhciBwcm9wcyA9IGlzQXJyID8gdW5kZWZpbmVkIDoga2V5c0Z1bmModmFsdWUpO1xuICBhcnJheUVhY2gocHJvcHMgfHwgdmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIGtleSA9IHN1YlZhbHVlO1xuICAgICAgc3ViVmFsdWUgPSB2YWx1ZVtrZXldO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hcGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWFwKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gbWFwVGFnO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1NldGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzU2V0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gc2V0VGFnO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuICBpZiAoaXNEZWVwKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICB9XG4gIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGRhdGFWaWV3YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFWaWV3IFRoZSBkYXRhIHZpZXcgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGRhdGEgdmlldy5cbiAqL1xuZnVuY3Rpb24gY2xvbmVEYXRhVmlldyhkYXRhVmlldywgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKGRhdGFWaWV3LmJ1ZmZlcikgOiBkYXRhVmlldy5idWZmZXI7XG4gIHJldHVybiBuZXcgZGF0YVZpZXcuY29uc3RydWN0b3IoYnVmZmVyLCBkYXRhVmlldy5ieXRlT2Zmc2V0LCBkYXRhVmlldy5ieXRlTGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHJlZ2V4cGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWdleHAgVGhlIHJlZ2V4cCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCByZWdleHAuXG4gKi9cbmZ1bmN0aW9uIGNsb25lUmVnRXhwKHJlZ2V4cCkge1xuICB2YXIgcmVzdWx0ID0gbmV3IHJlZ2V4cC5jb25zdHJ1Y3RvcihyZWdleHAuc291cmNlLCByZUZsYWdzLmV4ZWMocmVnZXhwKSk7XG4gIHJlc3VsdC5sYXN0SW5kZXggPSByZWdleHAubGFzdEluZGV4O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgYHN5bWJvbGAgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc3ltYm9sIFRoZSBzeW1ib2wgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHN5bWJvbCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNsb25lU3ltYm9sKHN5bWJvbCkge1xuICByZXR1cm4gc3ltYm9sVmFsdWVPZiA/IE9iamVjdChzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG4vKipcbiAqIENvcGllcyBvd24gc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHMoc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbi8qKlxuICogQ29waWVzIG93biBhbmQgaW5oZXJpdGVkIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzSW4oc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzSW4oc291cmNlKSwgb2JqZWN0KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNJbiwgZ2V0U3ltYm9sc0luKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9sc0luID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB3aGlsZSAob2JqZWN0KSB7XG4gICAgYXJyYXlQdXNoKHJlc3VsdCwgZ2V0U3ltYm9scyhvYmplY3QpKTtcbiAgICBvYmplY3QgPSBnZXRQcm90b3R5cGUob2JqZWN0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gYXJyYXkgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAvLyBBZGQgcHJvcGVydGllcyBhc3NpZ25lZCBieSBgUmVnRXhwI2V4ZWNgLlxuICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgIHJlc3VsdC5pbnB1dCA9IGFycmF5LmlucHV0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgOiB7fTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUgYmFzZWQgb24gaXRzIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTWFwYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBgU2V0YCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGlzRGVlcCkge1xuICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgcmV0dXJuIGNsb25lQXJyYXlCdWZmZXIob2JqZWN0KTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3IoK29iamVjdCk7XG5cbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgcmV0dXJuIGNsb25lRGF0YVZpZXcob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBmbG9hdDMyVGFnOiBjYXNlIGZsb2F0NjRUYWc6XG4gICAgY2FzZSBpbnQ4VGFnOiBjYXNlIGludDE2VGFnOiBjYXNlIGludDMyVGFnOlxuICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVUeXBlZEFycmF5KG9iamVjdCwgaXNEZWVwKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgcmV0dXJuIGNsb25lUmVnRXhwKG9iamVjdCk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcjtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgcmV0dXJuIGNsb25lU3ltYm9sKG9iamVjdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBjbG9uZXMgYHZhbHVlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDEuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmVjdXJzaXZlbHkgY2xvbmUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gKiBAc2VlIF8uY2xvbmVcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gKlxuICogdmFyIGRlZXAgPSBfLmNsb25lRGVlcChvYmplY3RzKTtcbiAqIGNvbnNvbGUubG9nKGRlZXBbMF0gPT09IG9iamVjdHNbMF0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gY2xvbmVEZWVwKHZhbHVlKSB7XG4gIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRyk7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTWFwYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc01hcChuZXcgTWFwKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTWFwKG5ldyBXZWFrTWFwKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc01hcCA9IG5vZGVJc01hcCA/IGJhc2VVbmFyeShub2RlSXNNYXApIDogYmFzZUlzTWFwO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU2V0YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1NldChuZXcgU2V0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU2V0KG5ldyBXZWFrU2V0KTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1NldCA9IG5vZGVJc1NldCA/IGJhc2VVbmFyeShub2RlSXNTZXQpIDogYmFzZUlzU2V0O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lRGVlcDtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.clonedeep/index.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.filter/index.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.filter/index.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, module) {/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize include=\"filter,sortBy,findIndex,find,forEach,cloneDeep\" exports=\"npm\"`\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports =  true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\n/**\n * The base implementation of `_.filter` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction baseFilter(collection, predicate) {\n  var result = [];\n  baseEach(collection, function(value, index, collection) {\n    if (predicate(value, index, collection)) {\n      result.push(value);\n    }\n  });\n  return result;\n}\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\n/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      result = false;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\n/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Iterates over elements of `collection`, returning an array of all elements\n * `predicate` returns truthy for. The predicate is invoked with three\n * arguments: (value, index|key, collection).\n *\n * **Note:** Unlike `_.remove`, this method returns a new array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n * @see _.reject\n * @example\n *\n * var users = [\n *   { 'user': 'barney', 'age': 36, 'active': true },\n *   { 'user': 'fred',   'age': 40, 'active': false }\n * ];\n *\n * _.filter(users, function(o) { return !o.active; });\n * // => objects for ['fred']\n *\n * // The `_.matches` iteratee shorthand.\n * _.filter(users, { 'age': 36, 'active': true });\n * // => objects for ['barney']\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.filter(users, ['active', false]);\n * // => objects for ['fred']\n *\n * // The `_.property` iteratee shorthand.\n * _.filter(users, 'active');\n * // => objects for ['barney']\n */\nfunction filter(collection, predicate) {\n  var func = isArray(collection) ? arrayFilter : baseFilter;\n  return func(collection, baseIteratee(predicate, 3));\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = filter;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9sb2Rhc2gtY3VzdG9tLWJ1aWxkL21vZHVsYXJpemUvbG9kYXNoLmZpbHRlci9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2xvZGFzaC1jdXN0b20tYnVpbGQvbW9kdWxhcml6ZS9sb2Rhc2guZmlsdGVyL2luZGV4LmpzP2MyNTQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBMb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGluY2x1ZGU9XCJmaWx0ZXIsc29ydEJ5LGZpbmRJbmRleCxmaW5kLGZvckVhY2gsY2xvbmVEZWVwXCIgZXhwb3J0cz1cIm5wbVwiYFxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcy5mb3VuZGF0aW9uLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDAsXG4gICAgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC8sXG4gICAgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXG4gICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIFN5bWJvbCA9IHJvb3QuU3ltYm9sLFxuICAgIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXksXG4gICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcbiAgICBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZSxcbiAgICBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLFxuICAgIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3JyksXG4gICAgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKSxcbiAgICBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyksXG4gICAgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKSxcbiAgICBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyksXG4gICAgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG5TZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcblNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqL1xudmFyIGJhc2VFYWNoID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93bik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmlsdGVyYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbnZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAwLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgfVxuICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuXG4gIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvYmpJc0FyciA9IHRydWU7XG4gICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICB9XG4gIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRykpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gIWxlbmd0aDtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpXG4gICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlcyhzb3VyY2UpIHtcbiAgdmFyIG1hdGNoRGF0YSA9IGdldE1hdGNoRGF0YShzb3VyY2UpO1xuICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShtYXRjaERhdGFbMF1bMF0sIG1hdGNoRGF0YVswXVsxXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSh0b0tleShwYXRoKSwgc3JjVmFsdWUpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgb2JqVmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcbiAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG1hdGNoIGRhdGEgb2YgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXMob2JqZWN0KSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBmYWxzZTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gKiBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUoa2V5LCBzcmNWYWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiZcbiAgICAgIChzcmNWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gT2JqZWN0KG9iamVjdCkpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9KTtcblxuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG4gIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcbiAgICByZXN1bHQucHVzaChxdW90ZSA/IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyBhbiBhcnJheSBvZiBhbGwgZWxlbWVudHNcbiAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICpcbiAqICoqTm90ZToqKiBVbmxpa2UgYF8ucmVtb3ZlYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKiBAc2VlIF8ucmVqZWN0XG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICogXTtcbiAqXG4gKiBfLmZpbHRlcih1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmlsdGVyKHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maWx0ZXIodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbHRlcih1c2VycywgJ2FjdGl2ZScpO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICovXG5mdW5jdGlvbiBmaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RmlsdGVyIDogYmFzZUZpbHRlcjtcbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG5tZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjcuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gKlxuICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gKiAvLyA9PiAnZGVmYXVsdCdcbiAqL1xuZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFtcbiAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICogXTtcbiAqXG4gKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqXG4gKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICogLy8gPT4gWzEsIDJdXG4gKi9cbmZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaWx0ZXI7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.filter/index.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.find/index.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.find/index.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, module) {/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize include=\"filter,sortBy,findIndex,find,forEach,cloneDeep\" exports=\"npm\"`\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_SAFE_INTEGER = 9007199254740991,\n    MAX_INTEGER = 1.7976931348623157e+308,\n    NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports =  true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object),\n    nativeMax = Math.max;\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\n/**\n * Creates a `_.find` or `_.findLast` function.\n *\n * @private\n * @param {Function} findIndexFunc The function to find the collection index.\n * @returns {Function} Returns the new find function.\n */\nfunction createFind(findIndexFunc) {\n  return function(collection, predicate, fromIndex) {\n    var iterable = Object(collection);\n    if (!isArrayLike(collection)) {\n      var iteratee = baseIteratee(predicate, 3);\n      collection = keys(collection);\n      predicate = function(key) { return iteratee(iterable[key], key, iterable); };\n    }\n    var index = findIndexFunc(collection, predicate, fromIndex);\n    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n  };\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      result = false;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\n/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * This method is like `_.find` except that it returns the index of the first\n * element `predicate` returns truthy for instead of the element itself.\n *\n * @static\n * @memberOf _\n * @since 1.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the found element, else `-1`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': false },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': true }\n * ];\n *\n * _.findIndex(users, function(o) { return o.user == 'barney'; });\n * // => 0\n *\n * // The `_.matches` iteratee shorthand.\n * _.findIndex(users, { 'user': 'fred', 'active': false });\n * // => 1\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.findIndex(users, ['active', false]);\n * // => 0\n *\n * // The `_.property` iteratee shorthand.\n * _.findIndex(users, 'active');\n * // => 2\n */\nfunction findIndex(array, predicate, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger(fromIndex);\n  if (index < 0) {\n    index = nativeMax(length + index, 0);\n  }\n  return baseFindIndex(array, baseIteratee(predicate, 3), index);\n}\n\n/**\n * Iterates over elements of `collection`, returning the first element\n * `predicate` returns truthy for. The predicate is invoked with three\n * arguments: (value, index|key, collection).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {*} Returns the matched element, else `undefined`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'age': 36, 'active': true },\n *   { 'user': 'fred',    'age': 40, 'active': false },\n *   { 'user': 'pebbles', 'age': 1,  'active': true }\n * ];\n *\n * _.find(users, function(o) { return o.age < 40; });\n * // => object for 'barney'\n *\n * // The `_.matches` iteratee shorthand.\n * _.find(users, { 'age': 1, 'active': true });\n * // => object for 'pebbles'\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.find(users, ['active', false]);\n * // => object for 'fred'\n *\n * // The `_.property` iteratee shorthand.\n * _.find(users, 'active');\n * // => object for 'barney'\n */\nvar find = createFind(findIndex);\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = find;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9sb2Rhc2gtY3VzdG9tLWJ1aWxkL21vZHVsYXJpemUvbG9kYXNoLmZpbmQvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9sb2Rhc2gtY3VzdG9tLWJ1aWxkL21vZHVsYXJpemUvbG9kYXNoLmZpbmQvaW5kZXguanM/MjFiYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIExvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgaW5jbHVkZT1cImZpbHRlcixzb3J0QnksZmluZEluZGV4LGZpbmQsZm9yRWFjaCxjbG9uZURlZXBcIiBleHBvcnRzPVwibnBtXCJgXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pzLmZvdW5kYXRpb24vPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xudmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMCxcbiAgICBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MSxcbiAgICBNQVhfSU5URUdFUiA9IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4LFxuICAgIE5BTiA9IDAgLyAwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvLFxuICAgIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuXG4gIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBTeW1ib2wgPSByb290LlN5bWJvbCxcbiAgICBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5LFxuICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2UsXG4gICAgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxcbiAgICBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KSxcbiAgICBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpLFxuICAgIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyksXG4gICAgUHJvbWlzZSA9IGdldE5hdGl2ZShyb290LCAnUHJvbWlzZScpLFxuICAgIFNldCA9IGdldE5hdGl2ZShyb290LCAnU2V0JyksXG4gICAgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpLFxuICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzID09IG51bGwgPyAwIDogdmFsdWVzLmxlbmd0aDtcblxuICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHRoaXMuYWRkKHZhbHVlc1tpbmRleF0pO1xuICB9XG59XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgYWRkXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBhbGlhcyBwdXNoXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAwLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgfVxuICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuXG4gIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvYmpJc0FyciA9IHRydWU7XG4gICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICB9XG4gIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRykpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gIWxlbmd0aDtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpXG4gICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlcyhzb3VyY2UpIHtcbiAgdmFyIG1hdGNoRGF0YSA9IGdldE1hdGNoRGF0YShzb3VyY2UpO1xuICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShtYXRjaERhdGFbMF1bMF0sIG1hdGNoRGF0YVswXVsxXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSh0b0tleShwYXRoKSwgc3JjVmFsdWUpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgb2JqVmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcbiAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBfLmZpbmRgIG9yIGBfLmZpbmRMYXN0YCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZmluZEluZGV4RnVuYyBUaGUgZnVuY3Rpb24gdG8gZmluZCB0aGUgY29sbGVjdGlvbiBpbmRleC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZpbmQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZpbmQoZmluZEluZGV4RnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG4gICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgdmFyIGl0ZXJhdGVlID0gYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSwgMyk7XG4gICAgICBjb2xsZWN0aW9uID0ga2V5cyhjb2xsZWN0aW9uKTtcbiAgICAgIHByZWRpY2F0ZSA9IGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSk7IH07XG4gICAgfVxuICAgIHZhciBpbmRleCA9IGZpbmRJbmRleEZ1bmMoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBmcm9tSW5kZXgpO1xuICAgIHJldHVybiBpbmRleCA+IC0xID8gaXRlcmFibGVbaXRlcmF0ZWUgPyBjb2xsZWN0aW9uW2luZGV4XSA6IGluZGV4XSA6IHVuZGVmaW5lZDtcbiAgfTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUc7XG4gICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksXG4gICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICBvdGhQcm9wcyA9IGdldEFsbEtleXMob3RoZXIpLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxuICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBnZXRNYXRjaERhdGEob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHZhciBrZXkgPSByZXN1bHRbbGVuZ3RoXSxcbiAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICB9KTtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgZXhpc3RzIG9uIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHByb3BlcnRpZXMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgaGFzRnVuYykge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pO1xuICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICB9XG4gIGlmIChyZXN1bHQgfHwgKytpbmRleCAhPSBsZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IG9iamVjdC5sZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpICYmXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcbiAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAqICBlcXVhbGl0eSBjb21wYXJpc29ucywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gIH07XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xuICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICB2YXIgcmVzdWx0ID0gbWVtb2l6ZShmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xuICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfSk7XG5cbiAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDYgLyogLiAqLykge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0XG4gKiBlbGVtZW50IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDEuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAqIF07XG4gKlxuICogXy5maW5kSW5kZXgodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlciA9PSAnYmFybmV5JzsgfSk7XG4gKiAvLyA9PiAwXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2ZyZWQnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gKiAvLyA9PiAxXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAqIC8vID0+IDBcbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiAyXG4gKi9cbmZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICBpZiAoIWxlbmd0aCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICB2YXIgaW5kZXggPSBmcm9tSW5kZXggPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIGluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKTtcbiAgfVxuICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGluZGV4KTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIHRoZSBmaXJzdCBlbGVtZW50XG4gKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAqIF07XG4gKlxuICogXy5maW5kKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAqIC8vID0+IG9iamVjdCBmb3IgJ2Jhcm5leSdcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kKHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAqIC8vID0+IG9iamVjdCBmb3IgJ3BlYmJsZXMnXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gKiAvLyA9PiBvYmplY3QgZm9yICdmcmVkJ1xuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kKHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiBvYmplY3QgZm9yICdiYXJuZXknXG4gKi9cbnZhciBmaW5kID0gY3JlYXRlRmluZChmaW5kSW5kZXgpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG5tZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIGZpbml0ZSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEyLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0Zpbml0ZSgzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvRmluaXRlKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwO1xuICB9XG4gIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICBpZiAodmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSAtSU5GSU5JVFkpIHtcbiAgICB2YXIgc2lnbiA9ICh2YWx1ZSA8IDAgPyAtMSA6IDEpO1xuICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvaW50ZWdlcikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0ludGVnZXIoMy4yKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDBcbiAqXG4gKiBfLnRvSW50ZWdlcihJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9JbnRlZ2VyKCczLjInKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0b0Zpbml0ZSh2YWx1ZSksXG4gICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xuXG4gIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IChyZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQpIDogMDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvTnVtYmVyKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiBJbmZpbml0eVxuICpcbiAqIF8udG9OdW1iZXIoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBOQU47XG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgfVxuICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICogLy8gPT4gJ2RlZmF1bHQnXG4gKi9cbmZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbXG4gKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAqIF07XG4gKlxuICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICogLy8gPT4gWzIsIDFdXG4gKlxuICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAqIC8vID0+IFsxLCAyXVxuICovXG5mdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZDtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.find/index.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.findindex/index.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.findindex/index.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, module) {/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize include=\"filter,sortBy,findIndex,find,forEach,cloneDeep\" exports=\"npm\"`\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_SAFE_INTEGER = 9007199254740991,\n    MAX_INTEGER = 1.7976931348623157e+308,\n    NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports =  true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object),\n    nativeMax = Math.max;\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      result = false;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\n/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * This method is like `_.find` except that it returns the index of the first\n * element `predicate` returns truthy for instead of the element itself.\n *\n * @static\n * @memberOf _\n * @since 1.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the found element, else `-1`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': false },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': true }\n * ];\n *\n * _.findIndex(users, function(o) { return o.user == 'barney'; });\n * // => 0\n *\n * // The `_.matches` iteratee shorthand.\n * _.findIndex(users, { 'user': 'fred', 'active': false });\n * // => 1\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.findIndex(users, ['active', false]);\n * // => 0\n *\n * // The `_.property` iteratee shorthand.\n * _.findIndex(users, 'active');\n * // => 2\n */\nfunction findIndex(array, predicate, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger(fromIndex);\n  if (index < 0) {\n    index = nativeMax(length + index, 0);\n  }\n  return baseFindIndex(array, baseIteratee(predicate, 3), index);\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = findIndex;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9sb2Rhc2gtY3VzdG9tLWJ1aWxkL21vZHVsYXJpemUvbG9kYXNoLmZpbmRpbmRleC9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2xvZGFzaC1jdXN0b20tYnVpbGQvbW9kdWxhcml6ZS9sb2Rhc2guZmluZGluZGV4L2luZGV4LmpzP2I3OGUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBMb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGluY2x1ZGU9XCJmaWx0ZXIsc29ydEJ5LGZpbmRJbmRleCxmaW5kLGZvckVhY2gsY2xvbmVEZWVwXCIgZXhwb3J0cz1cIm5wbVwiYFxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcy5mb3VuZGF0aW9uLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDAsXG4gICAgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTEsXG4gICAgTUFYX0lOVEVHRVIgPSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOCxcbiAgICBOQU4gPSAwIC8gMDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLyxcbiAgICByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXRcbiAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMSA6IC0xKTtcblxuICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbi8qKlxuICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqL1xuZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgU3ltYm9sID0gcm9vdC5TeW1ib2wsXG4gICAgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheSxcbiAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICAgIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlLFxuICAgIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG4gICAgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCksXG4gICAgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKSxcbiAgICBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpLFxuICAgIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKSxcbiAgICBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpLFxuICAgIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKSxcbiAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCksXG4gICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG5cbiAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgIG9iaklzT2JqID0gZmFsc2U7XG4gIH1cbiAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgfVxuICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoRGF0YSBUaGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3MgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCxcbiAgICAgIGxlbmd0aCA9IGluZGV4LFxuICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuICFsZW5ndGg7XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIGlmICgobm9DdXN0b21pemVyICYmIGRhdGFbMl0pXG4gICAgICAgICAgPyBkYXRhWzFdICE9PSBvYmplY3RbZGF0YVswXV1cbiAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuICAgICAgICBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2s7XG4gICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gaWRlbnRpdHk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgPyBiYXNlTWF0Y2hlc1Byb3BlcnR5KHZhbHVlWzBdLCB2YWx1ZVsxXSlcbiAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICB9XG4gIHJldHVybiBwcm9wZXJ0eSh2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgcmV0dXJuIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9ialZhbHVlID09PSBzcmNWYWx1ZSlcbiAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyk7XG4gIH07XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG1hdGNoIGRhdGEgb2YgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXMob2JqZWN0KSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBmYWxzZTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gKiBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUoa2V5LCBzcmNWYWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiZcbiAgICAgIChzcmNWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gT2JqZWN0KG9iamVjdCkpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9KTtcblxuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG4gIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcbiAgICByZXN1bHQucHVzaChxdW90ZSA/IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3RcbiAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMS4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICogXTtcbiAqXG4gKiBfLmZpbmRJbmRleCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyID09ICdiYXJuZXknOyB9KTtcbiAqIC8vID0+IDBcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnZnJlZCcsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAqIC8vID0+IDFcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRJbmRleCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gMFxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsICdhY3RpdmUnKTtcbiAqIC8vID0+IDJcbiAqL1xuZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHZhciBpbmRleCA9IGZyb21JbmRleCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuICB9XG4gIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgaW5kZXgpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG5tZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIGZpbml0ZSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEyLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0Zpbml0ZSgzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvRmluaXRlKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwO1xuICB9XG4gIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICBpZiAodmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSAtSU5GSU5JVFkpIHtcbiAgICB2YXIgc2lnbiA9ICh2YWx1ZSA8IDAgPyAtMSA6IDEpO1xuICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvaW50ZWdlcikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0ludGVnZXIoMy4yKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDBcbiAqXG4gKiBfLnRvSW50ZWdlcihJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9JbnRlZ2VyKCczLjInKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0b0Zpbml0ZSh2YWx1ZSksXG4gICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xuXG4gIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IChyZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQpIDogMDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvTnVtYmVyKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiBJbmZpbml0eVxuICpcbiAqIF8udG9OdW1iZXIoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBOQU47XG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgfVxuICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICogLy8gPT4gJ2RlZmF1bHQnXG4gKi9cbmZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbXG4gKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAqIF07XG4gKlxuICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICogLy8gPT4gWzIsIDFdXG4gKlxuICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAqIC8vID0+IFsxLCAyXVxuICovXG5mdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZEluZGV4O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.findindex/index.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.sortby/index.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.sortby/index.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, module) {/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize include=\"filter,sortBy,findIndex,find,forEach,cloneDeep\" exports=\"npm\"`\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** Used to detect hot functions by number of calls within a span of milliseconds. */\nvar HOT_COUNT = 800,\n    HOT_SPAN = 16;\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports =  true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * The base implementation of `_.sortBy` which uses `comparer` to define the\n * sort order of `array` and replaces criteria objects with their corresponding\n * values.\n *\n * @private\n * @param {Array} array The array to sort.\n * @param {Function} comparer The function to define sort order.\n * @returns {Array} Returns `array`.\n */\nfunction baseSortBy(array, comparer) {\n  var length = array.length;\n\n  array.sort(comparer);\n  while (length--) {\n    array[length] = array[length].value;\n  }\n  return array;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object),\n    nativeMax = Math.max,\n    nativeNow = Date.now;\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\n/**\n * The base implementation of `_.flatten` with support for restricting flattening.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {number} depth The maximum recursion depth.\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  var index = -1,\n      length = array.length;\n\n  predicate || (predicate = isFlattenable);\n  result || (result = []);\n\n  while (++index < length) {\n    var value = array[index];\n    if (depth > 0 && predicate(value)) {\n      if (depth > 1) {\n        // Recursively flatten arrays (susceptible to call stack limits).\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        arrayPush(result, value);\n      }\n    } else if (!isStrict) {\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.map` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction baseMap(collection, iteratee) {\n  var index = -1,\n      result = isArrayLike(collection) ? Array(collection.length) : [];\n\n  baseEach(collection, function(value, key, collection) {\n    result[++index] = iteratee(value, key, collection);\n  });\n  return result;\n}\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\n\n/**\n * The base implementation of `_.orderBy` without param guards.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n * @param {string[]} orders The sort orders of `iteratees`.\n * @returns {Array} Returns the new sorted array.\n */\nfunction baseOrderBy(collection, iteratees, orders) {\n  var index = -1;\n  iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));\n\n  var result = baseMap(collection, function(value, key, collection) {\n    var criteria = arrayMap(iteratees, function(iteratee) {\n      return iteratee(value);\n    });\n    return { 'criteria': criteria, 'index': ++index, 'value': value };\n  });\n\n  return baseSortBy(result, function(object, other) {\n    return compareMultiple(object, other, orders);\n  });\n}\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  return setToString(overRest(func, start, identity), func + '');\n}\n\n/**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar baseSetToString = !defineProperty ? identity : function(func, string) {\n  return defineProperty(func, 'toString', {\n    'configurable': true,\n    'enumerable': false,\n    'value': constant(string),\n    'writable': true\n  });\n};\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\n/**\n * Compares values to sort them in ascending order.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {number} Returns the sort order indicator for `value`.\n */\nfunction compareAscending(value, other) {\n  if (value !== other) {\n    var valIsDefined = value !== undefined,\n        valIsNull = value === null,\n        valIsReflexive = value === value,\n        valIsSymbol = isSymbol(value);\n\n    var othIsDefined = other !== undefined,\n        othIsNull = other === null,\n        othIsReflexive = other === other,\n        othIsSymbol = isSymbol(other);\n\n    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n        (valIsNull && othIsDefined && othIsReflexive) ||\n        (!valIsDefined && othIsReflexive) ||\n        !valIsReflexive) {\n      return 1;\n    }\n    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n        (othIsNull && valIsDefined && valIsReflexive) ||\n        (!othIsDefined && valIsReflexive) ||\n        !othIsReflexive) {\n      return -1;\n    }\n  }\n  return 0;\n}\n\n/**\n * Used by `_.orderBy` to compare multiple properties of a value to another\n * and stable sort them.\n *\n * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n * of corresponding values.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {boolean[]|string[]} orders The order to sort by for each property.\n * @returns {number} Returns the sort order indicator for `object`.\n */\nfunction compareMultiple(object, other, orders) {\n  var index = -1,\n      objCriteria = object.criteria,\n      othCriteria = other.criteria,\n      length = objCriteria.length,\n      ordersLength = orders.length;\n\n  while (++index < length) {\n    var result = compareAscending(objCriteria[index], othCriteria[index]);\n    if (result) {\n      if (index >= ordersLength) {\n        return result;\n      }\n      var order = orders[index];\n      return result * (order == 'desc' ? -1 : 1);\n    }\n  }\n  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n  // that causes it, under certain circumstances, to provide the same value for\n  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n  // for more details.\n  //\n  // This also ensures a stable sort in V8 and other engines.\n  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n  return object.index - other.index;\n}\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\n/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      result = false;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\n/**\n * Checks if `value` is a flattenable `arguments` object or array.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n */\nfunction isFlattenable(value) {\n  return isArray(value) || isArguments(value) ||\n    !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\n/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */\nfunction overRest(func, start, transform) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\n/**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar setToString = shortOut(baseSetToString);\n\n/**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */\nfunction shortOut(func) {\n  var count = 0,\n      lastCalled = 0;\n\n  return function() {\n    var stamp = nativeNow(),\n        remaining = HOT_SPAN - (stamp - lastCalled);\n\n    lastCalled = stamp;\n    if (remaining > 0) {\n      if (++count >= HOT_COUNT) {\n        return arguments[0];\n      }\n    } else {\n      count = 0;\n    }\n    return func.apply(undefined, arguments);\n  };\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Creates an array of elements, sorted in ascending order by the results of\n * running each element in a collection thru each iteratee. This method\n * performs a stable sort, that is, it preserves the original sort order of\n * equal elements. The iteratees are invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {...(Function|Function[])} [iteratees=[_.identity]]\n *  The iteratees to sort by.\n * @returns {Array} Returns the new sorted array.\n * @example\n *\n * var users = [\n *   { 'user': 'fred',   'age': 48 },\n *   { 'user': 'barney', 'age': 36 },\n *   { 'user': 'fred',   'age': 40 },\n *   { 'user': 'barney', 'age': 34 }\n * ];\n *\n * _.sortBy(users, [function(o) { return o.user; }]);\n * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n *\n * _.sortBy(users, ['user', 'age']);\n * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]\n */\nvar sortBy = baseRest(function(collection, iteratees) {\n  if (collection == null) {\n    return [];\n  }\n  var length = iteratees.length;\n  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n    iteratees = [];\n  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n    iteratees = [iteratees[0]];\n  }\n  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n});\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = sortBy;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9sb2Rhc2gtY3VzdG9tLWJ1aWxkL21vZHVsYXJpemUvbG9kYXNoLnNvcnRieS9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2xvZGFzaC1jdXN0b20tYnVpbGQvbW9kdWxhcml6ZS9sb2Rhc2guc29ydGJ5L2luZGV4LmpzP2FjM2YiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBMb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGluY2x1ZGU9XCJmaWx0ZXIsc29ydEJ5LGZpbmRJbmRleCxmaW5kLGZvckVhY2gsY2xvbmVEZWVwXCIgZXhwb3J0cz1cIm5wbVwiYFxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcy5mb3VuZGF0aW9uLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3QgZnVuY3Rpb25zIGJ5IG51bWJlciBvZiBjYWxscyB3aXRoaW4gYSBzcGFuIG9mIG1pbGxpc2Vjb25kcy4gKi9cbnZhciBIT1RfQ09VTlQgPSA4MDAsXG4gICAgSE9UX1NQQU4gPSAxNjtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMCxcbiAgICBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLyxcbiAgICByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICovXG5mdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRCeWAgd2hpY2ggdXNlcyBgY29tcGFyZXJgIHRvIGRlZmluZSB0aGVcbiAqIHNvcnQgb3JkZXIgb2YgYGFycmF5YCBhbmQgcmVwbGFjZXMgY3JpdGVyaWEgb2JqZWN0cyB3aXRoIHRoZWlyIGNvcnJlc3BvbmRpbmdcbiAqIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNvcnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJlciBUaGUgZnVuY3Rpb24gdG8gZGVmaW5lIHNvcnQgb3JkZXIuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYmFzZVNvcnRCeShhcnJheSwgY29tcGFyZXIpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBhcnJheS5zb3J0KGNvbXBhcmVyKTtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgYXJyYXlbbGVuZ3RoXSA9IGFycmF5W2xlbmd0aF0udmFsdWU7XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBTeW1ib2wgPSByb290LlN5bWJvbCxcbiAgICBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5LFxuICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2UsXG4gICAgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCA/IFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUgOiB1bmRlZmluZWQsXG4gICAgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG4gICAgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCksXG4gICAgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgbmF0aXZlTm93ID0gRGF0ZS5ub3c7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKSxcbiAgICBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpLFxuICAgIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKSxcbiAgICBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpLFxuICAgIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKSxcbiAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICovXG52YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG52YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCksXG4gICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG5cbiAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgIG9iaklzT2JqID0gZmFsc2U7XG4gIH1cbiAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgfVxuICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoRGF0YSBUaGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3MgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCxcbiAgICAgIGxlbmd0aCA9IGluZGV4LFxuICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuICFsZW5ndGg7XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIGlmICgobm9DdXN0b21pemVyICYmIGRhdGFbMl0pXG4gICAgICAgICAgPyBkYXRhWzFdICE9PSBvYmplY3RbZGF0YVswXV1cbiAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuICAgICAgICBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2s7XG4gICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gaWRlbnRpdHk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgPyBiYXNlTWF0Y2hlc1Byb3BlcnR5KHZhbHVlWzBdLCB2YWx1ZVsxXSlcbiAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICB9XG4gIHJldHVybiBwcm9wZXJ0eSh2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXBgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gQXJyYXkoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG5cbiAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IGl0ZXJhdGVlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgcmV0dXJuIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9ialZhbHVlID09PSBzcmNWYWx1ZSlcbiAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyk7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ub3JkZXJCeWAgd2l0aG91dCBwYXJhbSBndWFyZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb25bXXxPYmplY3RbXXxzdHJpbmdbXX0gaXRlcmF0ZWVzIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAqIEBwYXJhbSB7c3RyaW5nW119IG9yZGVycyBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKSB7XG4gIHZhciBpbmRleCA9IC0xO1xuICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMubGVuZ3RoID8gaXRlcmF0ZWVzIDogW2lkZW50aXR5XSwgYmFzZVVuYXJ5KGJhc2VJdGVyYXRlZSkpO1xuXG4gIHZhciByZXN1bHQgPSBiYXNlTWFwKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICB2YXIgY3JpdGVyaWEgPSBhcnJheU1hcChpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gaXRlcmF0ZWUodmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiB7ICdjcml0ZXJpYSc6IGNyaXRlcmlhLCAnaW5kZXgnOiArK2luZGV4LCAndmFsdWUnOiB2YWx1ZSB9O1xuICB9KTtcblxuICByZXR1cm4gYmFzZVNvcnRCeShyZXN1bHQsIGZ1bmN0aW9uKG9iamVjdCwgb3RoZXIpIHtcbiAgICByZXR1cm4gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycyk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAocGF0aCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIENvbXBhcmVzIHZhbHVlcyB0byBzb3J0IHRoZW0gaW4gYXNjZW5kaW5nIG9yZGVyLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgdmFsdWVgLlxuICovXG5mdW5jdGlvbiBjb21wYXJlQXNjZW5kaW5nKHZhbHVlLCBvdGhlcikge1xuICBpZiAodmFsdWUgIT09IG90aGVyKSB7XG4gICAgdmFyIHZhbElzRGVmaW5lZCA9IHZhbHVlICE9PSB1bmRlZmluZWQsXG4gICAgICAgIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuICAgICAgICB2YWxJc1JlZmxleGl2ZSA9IHZhbHVlID09PSB2YWx1ZSxcbiAgICAgICAgdmFsSXNTeW1ib2wgPSBpc1N5bWJvbCh2YWx1ZSk7XG5cbiAgICB2YXIgb3RoSXNEZWZpbmVkID0gb3RoZXIgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgb3RoSXNOdWxsID0gb3RoZXIgPT09IG51bGwsXG4gICAgICAgIG90aElzUmVmbGV4aXZlID0gb3RoZXIgPT09IG90aGVyLFxuICAgICAgICBvdGhJc1N5bWJvbCA9IGlzU3ltYm9sKG90aGVyKTtcblxuICAgIGlmICgoIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wgJiYgIXZhbElzU3ltYm9sICYmIHZhbHVlID4gb3RoZXIpIHx8XG4gICAgICAgICh2YWxJc1N5bWJvbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUgJiYgIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wpIHx8XG4gICAgICAgICh2YWxJc051bGwgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAoIXZhbElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgIXZhbElzUmVmbGV4aXZlKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKCghdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCAmJiAhb3RoSXNTeW1ib2wgJiYgdmFsdWUgPCBvdGhlcikgfHxcbiAgICAgICAgKG90aElzU3ltYm9sICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSAmJiAhdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCkgfHxcbiAgICAgICAgKG90aElzTnVsbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICghb3RoSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAhb3RoSXNSZWZsZXhpdmUpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8qKlxuICogVXNlZCBieSBgXy5vcmRlckJ5YCB0byBjb21wYXJlIG11bHRpcGxlIHByb3BlcnRpZXMgb2YgYSB2YWx1ZSB0byBhbm90aGVyXG4gKiBhbmQgc3RhYmxlIHNvcnQgdGhlbS5cbiAqXG4gKiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlcyBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLFxuICogc3BlY2lmeSBhbiBvcmRlciBvZiBcImRlc2NcIiBmb3IgZGVzY2VuZGluZyBvciBcImFzY1wiIGZvciBhc2NlbmRpbmcgc29ydCBvcmRlclxuICogb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbltdfHN0cmluZ1tdfSBvcmRlcnMgVGhlIG9yZGVyIHRvIHNvcnQgYnkgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBvYmpDcml0ZXJpYSA9IG9iamVjdC5jcml0ZXJpYSxcbiAgICAgIG90aENyaXRlcmlhID0gb3RoZXIuY3JpdGVyaWEsXG4gICAgICBsZW5ndGggPSBvYmpDcml0ZXJpYS5sZW5ndGgsXG4gICAgICBvcmRlcnNMZW5ndGggPSBvcmRlcnMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHJlc3VsdCA9IGNvbXBhcmVBc2NlbmRpbmcob2JqQ3JpdGVyaWFbaW5kZXhdLCBvdGhDcml0ZXJpYVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIGlmIChpbmRleCA+PSBvcmRlcnNMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBvcmRlciA9IG9yZGVyc1tpbmRleF07XG4gICAgICByZXR1cm4gcmVzdWx0ICogKG9yZGVyID09ICdkZXNjJyA/IC0xIDogMSk7XG4gICAgfVxuICB9XG4gIC8vIEZpeGVzIGFuIGBBcnJheSNzb3J0YCBidWcgaW4gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBhcHBsaWNhdGlvbnNcbiAgLy8gdGhhdCBjYXVzZXMgaXQsIHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlcywgdG8gcHJvdmlkZSB0aGUgc2FtZSB2YWx1ZSBmb3JcbiAgLy8gYG9iamVjdGAgYW5kIGBvdGhlcmAuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvcHVsbC8xMjQ3XG4gIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gIC8vXG4gIC8vIFRoaXMgYWxzbyBlbnN1cmVzIGEgc3RhYmxlIHNvcnQgaW4gVjggYW5kIG90aGVyIGVuZ2luZXMuXG4gIC8vIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD05MCBmb3IgbW9yZSBkZXRhaWxzLlxuICByZXR1cm4gb2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXg7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG1hdGNoIGRhdGEgb2YgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXMob2JqZWN0KSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBmYWxzZTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmxhdHRlbmFibGUgYGFyZ3VtZW50c2Agb2JqZWN0IG9yIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzRmxhdHRlbmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICEhKHNwcmVhZGFibGVTeW1ib2wgJiYgdmFsdWUgJiYgdmFsdWVbc3ByZWFkYWJsZVN5bWJvbF0pO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICkge1xuICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYG1hdGNoZXNQcm9wZXJ0eWAgZm9yIHNvdXJjZSB2YWx1ZXMgc3VpdGFibGVcbiAqIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZSAmJlxuICAgICAgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBPYmplY3Qob2JqZWN0KSkpO1xuICB9O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH0pO1xuXG4gIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBpbmRleCA9IC0xO1xuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbi8qKlxuICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBzZXRUb1N0cmluZyA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQnbGwgc2hvcnQgb3V0IGFuZCBpbnZva2UgYGlkZW50aXR5YCBpbnN0ZWFkXG4gKiBvZiBgZnVuY2Agd2hlbiBpdCdzIGNhbGxlZCBgSE9UX0NPVU5UYCBvciBtb3JlIHRpbWVzIGluIGBIT1RfU1BBTmBcbiAqIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzaG9ydGFibGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHNob3J0T3V0KGZ1bmMpIHtcbiAgdmFyIGNvdW50ID0gMCxcbiAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhbXAgPSBuYXRpdmVOb3coKSxcbiAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDYgLyogLiAqLykge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMsIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgdGhlIHJlc3VsdHMgb2ZcbiAqIHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiB0aHJ1IGVhY2ggaXRlcmF0ZWUuIFRoaXMgbWV0aG9kXG4gKiBwZXJmb3JtcyBhIHN0YWJsZSBzb3J0LCB0aGF0IGlzLCBpdCBwcmVzZXJ2ZXMgdGhlIG9yaWdpbmFsIHNvcnQgb3JkZXIgb2ZcbiAqIGVxdWFsIGVsZW1lbnRzLiBUaGUgaXRlcmF0ZWVzIGFyZSBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gKiAgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQ4IH0sXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH0sXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM0IH1cbiAqIF07XG4gKlxuICogXy5zb3J0QnkodXNlcnMsIFtmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXI7IH1dKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM2XSwgWydiYXJuZXknLCAzNF0sIFsnZnJlZCcsIDQ4XSwgWydmcmVkJywgNDBdXVxuICpcbiAqIF8uc29ydEJ5KHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzRdLCBbJ2Jhcm5leScsIDM2XSwgWydmcmVkJywgNDBdLCBbJ2ZyZWQnLCA0OF1dXG4gKi9cbnZhciBzb3J0QnkgPSBiYXNlUmVzdChmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZXMpIHtcbiAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gaXRlcmF0ZWVzLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCA+IDEgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0pKSB7XG4gICAgaXRlcmF0ZWVzID0gW107XG4gIH0gZWxzZSBpZiAobGVuZ3RoID4gMiAmJiBpc0l0ZXJhdGVlQ2FsbChpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSwgaXRlcmF0ZWVzWzJdKSkge1xuICAgIGl0ZXJhdGVlcyA9IFtpdGVyYXRlZXNbMF1dO1xuICB9XG4gIHJldHVybiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBiYXNlRmxhdHRlbihpdGVyYXRlZXMsIDEpLCBbXSk7XG59KTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG4vKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICogLy8gPT4gJ2RlZmF1bHQnXG4gKi9cbmZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW1xuICogICB7ICdhJzogeyAnYic6IDIgfSB9LFxuICogICB7ICdhJzogeyAnYic6IDEgfSB9XG4gKiBdO1xuICpcbiAqIF8ubWFwKG9iamVjdHMsIF8ucHJvcGVydHkoJ2EuYicpKTtcbiAqIC8vID0+IFsyLCAxXVxuICpcbiAqIF8ubWFwKF8uc29ydEJ5KG9iamVjdHMsIF8ucHJvcGVydHkoWydhJywgJ2InXSkpLCAnYS5iJyk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqL1xuZnVuY3Rpb24gcHJvcGVydHkocGF0aCkge1xuICByZXR1cm4gaXNLZXkocGF0aCkgPyBiYXNlUHJvcGVydHkodG9LZXkocGF0aCkpIDogYmFzZVByb3BlcnR5RGVlcChwYXRoKTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNvcnRCeTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.sortby/index.js\n");

/***/ }),

/***/ "./node_modules/draggabilly/draggabilly.js":
/*!*************************************************!*\
  !*** ./node_modules/draggabilly/draggabilly.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Draggabilly v2.2.0\n * Make that shiz draggable\n * https://draggabilly.desandro.com\n * MIT license\n */\n\n/*jshint browser: true, strict: true, undef: true, unused: true */\n\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */ /*globals define, module, require */\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n        __webpack_require__(/*! get-size/get-size */ \"./node_modules/get-size/get-size.js\"),\n        __webpack_require__(/*! unidragger/unidragger */ \"./node_modules/unidragger/unidragger.js\")\n      ], __WEBPACK_AMD_DEFINE_RESULT__ = (function( getSize, Unidragger ) {\n        return factory( window, getSize, Unidragger );\n      }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n}( window, function factory( window, getSize, Unidragger ) {\n\n'use strict';\n\n// -------------------------- helpers & variables -------------------------- //\n\n// extend objects\nfunction extend( a, b ) {\n  for ( var prop in b ) {\n    a[ prop ] = b[ prop ];\n  }\n  return a;\n}\n\nfunction noop() {}\n\nvar jQuery = window.jQuery;\n\n// --------------------------  -------------------------- //\n\nfunction Draggabilly( element, options ) {\n  // querySelector if string\n  this.element = typeof element == 'string' ?\n    document.querySelector( element ) : element;\n\n  if ( jQuery ) {\n    this.$element = jQuery( this.element );\n  }\n\n  // options\n  this.options = extend( {}, this.constructor.defaults );\n  this.option( options );\n\n  this._create();\n}\n\n// inherit Unidragger methods\nvar proto = Draggabilly.prototype = Object.create( Unidragger.prototype );\n\nDraggabilly.defaults = {\n};\n\n/**\n * set options\n * @param {Object} opts\n */\nproto.option = function( opts ) {\n  extend( this.options, opts );\n};\n\n// css position values that don't need to be set\nvar positionValues = {\n  relative: true,\n  absolute: true,\n  fixed: true\n};\n\nproto._create = function() {\n  // properties\n  this.position = {};\n  this._getPosition();\n\n  this.startPoint = { x: 0, y: 0 };\n  this.dragPoint = { x: 0, y: 0 };\n\n  this.startPosition = extend( {}, this.position );\n\n  // set relative positioning\n  var style = getComputedStyle( this.element );\n  if ( !positionValues[ style.position ] ) {\n    this.element.style.position = 'relative';\n  }\n\n  // events, bridge jQuery events from vanilla\n  this.on( 'pointerDown', this.onPointerDown );\n  this.on( 'pointerMove', this.onPointerMove );\n  this.on( 'pointerUp', this.onPointerUp );\n\n  this.enable();\n  this.setHandles();\n};\n\n/**\n * set this.handles and bind start events to 'em\n */\nproto.setHandles = function() {\n  this.handles = this.options.handle ?\n    this.element.querySelectorAll( this.options.handle ) : [ this.element ];\n\n  this.bindHandles();\n};\n\n/**\n * emits events via EvEmitter and jQuery events\n * @param {String} type - name of event\n * @param {Event} event - original event\n * @param {Array} args - extra arguments\n */\nproto.dispatchEvent = function( type, event, args ) {\n  var emitArgs = [ event ].concat( args );\n  this.emitEvent( type, emitArgs );\n  this.dispatchJQueryEvent( type, event, args );\n};\n\nproto.dispatchJQueryEvent = function( type, event, args ) {\n  var jQuery = window.jQuery;\n  // trigger jQuery event\n  if ( !jQuery || !this.$element ) {\n    return;\n  }\n  // create jQuery event\n  var $event = jQuery.Event( event );\n  $event.type = type;\n  this.$element.trigger( $event, args );\n};\n\n// -------------------------- position -------------------------- //\n\n// get x/y position from style\nproto._getPosition = function() {\n  var style = getComputedStyle( this.element );\n  var x = this._getPositionCoord( style.left, 'width' );\n  var y = this._getPositionCoord( style.top, 'height' );\n  // clean up 'auto' or other non-integer values\n  this.position.x = isNaN( x ) ? 0 : x;\n  this.position.y = isNaN( y ) ? 0 : y;\n\n  this._addTransformPosition( style );\n};\n\nproto._getPositionCoord = function( styleSide, measure ) {\n  if ( styleSide.indexOf('%') != -1 ) {\n    // convert percent into pixel for Safari, #75\n    var parentSize = getSize( this.element.parentNode );\n    // prevent not-in-DOM element throwing bug, #131\n    return !parentSize ? 0 :\n      ( parseFloat( styleSide ) / 100 ) * parentSize[ measure ];\n  }\n  return parseInt( styleSide, 10 );\n};\n\n// add transform: translate( x, y ) to position\nproto._addTransformPosition = function( style ) {\n  var transform = style.transform;\n  // bail out if value is 'none'\n  if ( transform.indexOf('matrix') !== 0 ) {\n    return;\n  }\n  // split matrix(1, 0, 0, 1, x, y)\n  var matrixValues = transform.split(',');\n  // translate X value is in 12th or 4th position\n  var xIndex = transform.indexOf('matrix3d') === 0 ? 12 : 4;\n  var translateX = parseInt( matrixValues[ xIndex ], 10 );\n  // translate Y value is in 13th or 5th position\n  var translateY = parseInt( matrixValues[ xIndex + 1 ], 10 );\n  this.position.x += translateX;\n  this.position.y += translateY;\n};\n\n// -------------------------- events -------------------------- //\n\nproto.onPointerDown = function( event, pointer ) {\n  this.element.classList.add('is-pointer-down');\n  this.dispatchJQueryEvent( 'pointerDown', event, [ pointer ] );\n};\n\n/**\n * drag start\n * @param {Event} event\n * @param {Event or Touch} pointer\n */\nproto.dragStart = function( event, pointer ) {\n  if ( !this.isEnabled ) {\n    return;\n  }\n  this._getPosition();\n  this.measureContainment();\n  // position _when_ drag began\n  this.startPosition.x = this.position.x;\n  this.startPosition.y = this.position.y;\n  // reset left/top style\n  this.setLeftTop();\n\n  this.dragPoint.x = 0;\n  this.dragPoint.y = 0;\n\n  this.element.classList.add('is-dragging');\n  this.dispatchEvent( 'dragStart', event, [ pointer ] );\n  // start animation\n  this.animate();\n};\n\nproto.measureContainment = function() {\n  var container = this.getContainer();\n  if ( !container ) {\n    return;\n  }\n\n  var elemSize = getSize( this.element );\n  var containerSize = getSize( container );\n  var elemRect = this.element.getBoundingClientRect();\n  var containerRect = container.getBoundingClientRect();\n\n  var borderSizeX = containerSize.borderLeftWidth + containerSize.borderRightWidth;\n  var borderSizeY = containerSize.borderTopWidth + containerSize.borderBottomWidth;\n\n  var position = this.relativeStartPosition = {\n    x: elemRect.left - ( containerRect.left + containerSize.borderLeftWidth ),\n    y: elemRect.top - ( containerRect.top + containerSize.borderTopWidth )\n  };\n\n  this.containSize = {\n    width: ( containerSize.width - borderSizeX ) - position.x - elemSize.width,\n    height: ( containerSize.height - borderSizeY ) - position.y - elemSize.height\n  };\n};\n\nproto.getContainer = function() {\n  var containment = this.options.containment;\n  if ( !containment ) {\n    return;\n  }\n  var isElement = containment instanceof HTMLElement;\n  // use as element\n  if ( isElement ) {\n    return containment;\n  }\n  // querySelector if string\n  if ( typeof containment == 'string' ) {\n    return document.querySelector( containment );\n  }\n  // fallback to parent element\n  return this.element.parentNode;\n};\n\n// ----- move event ----- //\n\nproto.onPointerMove = function( event, pointer, moveVector ) {\n  this.dispatchJQueryEvent( 'pointerMove', event, [ pointer, moveVector ] );\n};\n\n/**\n * drag move\n * @param {Event} event\n * @param {Event or Touch} pointer\n */\nproto.dragMove = function( event, pointer, moveVector ) {\n  if ( !this.isEnabled ) {\n    return;\n  }\n  var dragX = moveVector.x;\n  var dragY = moveVector.y;\n\n  var grid = this.options.grid;\n  var gridX = grid && grid[0];\n  var gridY = grid && grid[1];\n\n  dragX = applyGrid( dragX, gridX );\n  dragY = applyGrid( dragY, gridY );\n\n  dragX = this.containDrag( 'x', dragX, gridX );\n  dragY = this.containDrag( 'y', dragY, gridY );\n\n  // constrain to axis\n  dragX = this.options.axis == 'y' ? 0 : dragX;\n  dragY = this.options.axis == 'x' ? 0 : dragY;\n\n  this.position.x = this.startPosition.x + dragX;\n  this.position.y = this.startPosition.y + dragY;\n  // set dragPoint properties\n  this.dragPoint.x = dragX;\n  this.dragPoint.y = dragY;\n\n  this.dispatchEvent( 'dragMove', event, [ pointer, moveVector ] );\n};\n\nfunction applyGrid( value, grid, method ) {\n  method = method || 'round';\n  return grid ? Math[ method ]( value / grid ) * grid : value;\n}\n\nproto.containDrag = function( axis, drag, grid ) {\n  if ( !this.options.containment ) {\n    return drag;\n  }\n  var measure = axis == 'x' ? 'width' : 'height';\n\n  var rel = this.relativeStartPosition[ axis ];\n  var min = applyGrid( -rel, grid, 'ceil' );\n  var max = this.containSize[ measure ];\n  max = applyGrid( max, grid, 'floor' );\n  return  Math.max( min, Math.min( max, drag ) );\n};\n\n// ----- end event ----- //\n\n/**\n * pointer up\n * @param {Event} event\n * @param {Event or Touch} pointer\n */\nproto.onPointerUp = function( event, pointer ) {\n  this.element.classList.remove('is-pointer-down');\n  this.dispatchJQueryEvent( 'pointerUp', event, [ pointer ] );\n};\n\n/**\n * drag end\n * @param {Event} event\n * @param {Event or Touch} pointer\n */\nproto.dragEnd = function( event, pointer ) {\n  if ( !this.isEnabled ) {\n    return;\n  }\n  // use top left position when complete\n  this.element.style.transform = '';\n  this.setLeftTop();\n  this.element.classList.remove('is-dragging');\n  this.dispatchEvent( 'dragEnd', event, [ pointer ] );\n};\n\n// -------------------------- animation -------------------------- //\n\nproto.animate = function() {\n  // only render and animate if dragging\n  if ( !this.isDragging ) {\n    return;\n  }\n\n  this.positionDrag();\n\n  var _this = this;\n  requestAnimationFrame( function animateFrame() {\n    _this.animate();\n  });\n\n};\n\n// left/top positioning\nproto.setLeftTop = function() {\n  this.element.style.left = this.position.x + 'px';\n  this.element.style.top  = this.position.y + 'px';\n};\n\nproto.positionDrag = function() {\n  this.element.style.transform = 'translate3d( ' + this.dragPoint.x +\n    'px, ' + this.dragPoint.y + 'px, 0)';\n};\n\n// ----- staticClick ----- //\n\nproto.staticClick = function( event, pointer ) {\n  this.dispatchEvent( 'staticClick', event, [ pointer ] );\n};\n\n// ----- methods ----- //\n\n/**\n * @param {Number} x\n * @param {Number} y\n */\nproto.setPosition = function( x, y ) {\n  this.position.x = x;\n  this.position.y = y;\n  this.setLeftTop();\n};\n\nproto.enable = function() {\n  this.isEnabled = true;\n};\n\nproto.disable = function() {\n  this.isEnabled = false;\n  if ( this.isDragging ) {\n    this.dragEnd();\n  }\n};\n\nproto.destroy = function() {\n  this.disable();\n  // reset styles\n  this.element.style.transform = '';\n  this.element.style.left = '';\n  this.element.style.top = '';\n  this.element.style.position = '';\n  // unbind handles\n  this.unbindHandles();\n  // remove jQuery data\n  if ( this.$element ) {\n    this.$element.removeData('draggabilly');\n  }\n};\n\n// ----- jQuery bridget ----- //\n\n// required for jQuery bridget\nproto._init = noop;\n\nif ( jQuery && jQuery.bridget ) {\n  jQuery.bridget( 'draggabilly', Draggabilly );\n}\n\n// -----  ----- //\n\nreturn Draggabilly;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZHJhZ2dhYmlsbHkvZHJhZ2dhYmlsbHkuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJhZ2dhYmlsbHkvZHJhZ2dhYmlsbHkuanM/Y2U4OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIERyYWdnYWJpbGx5IHYyLjIuMFxuICogTWFrZSB0aGF0IHNoaXogZHJhZ2dhYmxlXG4gKiBodHRwczovL2RyYWdnYWJpbGx5LmRlc2FuZHJvLmNvbVxuICogTUlUIGxpY2Vuc2VcbiAqL1xuXG4vKmpzaGludCBicm93c2VyOiB0cnVlLCBzdHJpY3Q6IHRydWUsIHVuZGVmOiB0cnVlLCB1bnVzZWQ6IHRydWUgKi9cblxuKCBmdW5jdGlvbiggd2luZG93LCBmYWN0b3J5ICkge1xuICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgLyoganNoaW50IHN0cmljdDogZmFsc2UgKi8gLypnbG9iYWxzIGRlZmluZSwgbW9kdWxlLCByZXF1aXJlICovXG4gIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG4gICAgLy8gQU1EXG4gICAgZGVmaW5lKCBbXG4gICAgICAgICdnZXQtc2l6ZS9nZXQtc2l6ZScsXG4gICAgICAgICd1bmlkcmFnZ2VyL3VuaWRyYWdnZXInXG4gICAgICBdLFxuICAgICAgZnVuY3Rpb24oIGdldFNpemUsIFVuaWRyYWdnZXIgKSB7XG4gICAgICAgIHJldHVybiBmYWN0b3J5KCB3aW5kb3csIGdldFNpemUsIFVuaWRyYWdnZXIgKTtcbiAgICAgIH0pO1xuICB9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzICkge1xuICAgIC8vIENvbW1vbkpTXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KFxuICAgICAgd2luZG93LFxuICAgICAgcmVxdWlyZSgnZ2V0LXNpemUnKSxcbiAgICAgIHJlcXVpcmUoJ3VuaWRyYWdnZXInKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgLy8gYnJvd3NlciBnbG9iYWxcbiAgICB3aW5kb3cuRHJhZ2dhYmlsbHkgPSBmYWN0b3J5KFxuICAgICAgd2luZG93LFxuICAgICAgd2luZG93LmdldFNpemUsXG4gICAgICB3aW5kb3cuVW5pZHJhZ2dlclxuICAgICk7XG4gIH1cblxufSggd2luZG93LCBmdW5jdGlvbiBmYWN0b3J5KCB3aW5kb3csIGdldFNpemUsIFVuaWRyYWdnZXIgKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gaGVscGVycyAmIHZhcmlhYmxlcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4vLyBleHRlbmQgb2JqZWN0c1xuZnVuY3Rpb24gZXh0ZW5kKCBhLCBiICkge1xuICBmb3IgKCB2YXIgcHJvcCBpbiBiICkge1xuICAgIGFbIHByb3AgXSA9IGJbIHByb3AgXTtcbiAgfVxuICByZXR1cm4gYTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBqUXVlcnkgPSB3aW5kb3cualF1ZXJ5O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuZnVuY3Rpb24gRHJhZ2dhYmlsbHkoIGVsZW1lbnQsIG9wdGlvbnMgKSB7XG4gIC8vIHF1ZXJ5U2VsZWN0b3IgaWYgc3RyaW5nXG4gIHRoaXMuZWxlbWVudCA9IHR5cGVvZiBlbGVtZW50ID09ICdzdHJpbmcnID9cbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCBlbGVtZW50ICkgOiBlbGVtZW50O1xuXG4gIGlmICggalF1ZXJ5ICkge1xuICAgIHRoaXMuJGVsZW1lbnQgPSBqUXVlcnkoIHRoaXMuZWxlbWVudCApO1xuICB9XG5cbiAgLy8gb3B0aW9uc1xuICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoIHt9LCB0aGlzLmNvbnN0cnVjdG9yLmRlZmF1bHRzICk7XG4gIHRoaXMub3B0aW9uKCBvcHRpb25zICk7XG5cbiAgdGhpcy5fY3JlYXRlKCk7XG59XG5cbi8vIGluaGVyaXQgVW5pZHJhZ2dlciBtZXRob2RzXG52YXIgcHJvdG8gPSBEcmFnZ2FiaWxseS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBVbmlkcmFnZ2VyLnByb3RvdHlwZSApO1xuXG5EcmFnZ2FiaWxseS5kZWZhdWx0cyA9IHtcbn07XG5cbi8qKlxuICogc2V0IG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cbnByb3RvLm9wdGlvbiA9IGZ1bmN0aW9uKCBvcHRzICkge1xuICBleHRlbmQoIHRoaXMub3B0aW9ucywgb3B0cyApO1xufTtcblxuLy8gY3NzIHBvc2l0aW9uIHZhbHVlcyB0aGF0IGRvbid0IG5lZWQgdG8gYmUgc2V0XG52YXIgcG9zaXRpb25WYWx1ZXMgPSB7XG4gIHJlbGF0aXZlOiB0cnVlLFxuICBhYnNvbHV0ZTogdHJ1ZSxcbiAgZml4ZWQ6IHRydWVcbn07XG5cbnByb3RvLl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gcHJvcGVydGllc1xuICB0aGlzLnBvc2l0aW9uID0ge307XG4gIHRoaXMuX2dldFBvc2l0aW9uKCk7XG5cbiAgdGhpcy5zdGFydFBvaW50ID0geyB4OiAwLCB5OiAwIH07XG4gIHRoaXMuZHJhZ1BvaW50ID0geyB4OiAwLCB5OiAwIH07XG5cbiAgdGhpcy5zdGFydFBvc2l0aW9uID0gZXh0ZW5kKCB7fSwgdGhpcy5wb3NpdGlvbiApO1xuXG4gIC8vIHNldCByZWxhdGl2ZSBwb3NpdGlvbmluZ1xuICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKCB0aGlzLmVsZW1lbnQgKTtcbiAgaWYgKCAhcG9zaXRpb25WYWx1ZXNbIHN0eWxlLnBvc2l0aW9uIF0gKSB7XG4gICAgdGhpcy5lbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgfVxuXG4gIC8vIGV2ZW50cywgYnJpZGdlIGpRdWVyeSBldmVudHMgZnJvbSB2YW5pbGxhXG4gIHRoaXMub24oICdwb2ludGVyRG93bicsIHRoaXMub25Qb2ludGVyRG93biApO1xuICB0aGlzLm9uKCAncG9pbnRlck1vdmUnLCB0aGlzLm9uUG9pbnRlck1vdmUgKTtcbiAgdGhpcy5vbiggJ3BvaW50ZXJVcCcsIHRoaXMub25Qb2ludGVyVXAgKTtcblxuICB0aGlzLmVuYWJsZSgpO1xuICB0aGlzLnNldEhhbmRsZXMoKTtcbn07XG5cbi8qKlxuICogc2V0IHRoaXMuaGFuZGxlcyBhbmQgYmluZCBzdGFydCBldmVudHMgdG8gJ2VtXG4gKi9cbnByb3RvLnNldEhhbmRsZXMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5oYW5kbGVzID0gdGhpcy5vcHRpb25zLmhhbmRsZSA/XG4gICAgdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoIHRoaXMub3B0aW9ucy5oYW5kbGUgKSA6IFsgdGhpcy5lbGVtZW50IF07XG5cbiAgdGhpcy5iaW5kSGFuZGxlcygpO1xufTtcblxuLyoqXG4gKiBlbWl0cyBldmVudHMgdmlhIEV2RW1pdHRlciBhbmQgalF1ZXJ5IGV2ZW50c1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBuYW1lIG9mIGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIG9yaWdpbmFsIGV2ZW50XG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIC0gZXh0cmEgYXJndW1lbnRzXG4gKi9cbnByb3RvLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiggdHlwZSwgZXZlbnQsIGFyZ3MgKSB7XG4gIHZhciBlbWl0QXJncyA9IFsgZXZlbnQgXS5jb25jYXQoIGFyZ3MgKTtcbiAgdGhpcy5lbWl0RXZlbnQoIHR5cGUsIGVtaXRBcmdzICk7XG4gIHRoaXMuZGlzcGF0Y2hKUXVlcnlFdmVudCggdHlwZSwgZXZlbnQsIGFyZ3MgKTtcbn07XG5cbnByb3RvLmRpc3BhdGNoSlF1ZXJ5RXZlbnQgPSBmdW5jdGlvbiggdHlwZSwgZXZlbnQsIGFyZ3MgKSB7XG4gIHZhciBqUXVlcnkgPSB3aW5kb3cualF1ZXJ5O1xuICAvLyB0cmlnZ2VyIGpRdWVyeSBldmVudFxuICBpZiAoICFqUXVlcnkgfHwgIXRoaXMuJGVsZW1lbnQgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGNyZWF0ZSBqUXVlcnkgZXZlbnRcbiAgdmFyICRldmVudCA9IGpRdWVyeS5FdmVudCggZXZlbnQgKTtcbiAgJGV2ZW50LnR5cGUgPSB0eXBlO1xuICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoICRldmVudCwgYXJncyApO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gcG9zaXRpb24gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuLy8gZ2V0IHgveSBwb3NpdGlvbiBmcm9tIHN0eWxlXG5wcm90by5fZ2V0UG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSggdGhpcy5lbGVtZW50ICk7XG4gIHZhciB4ID0gdGhpcy5fZ2V0UG9zaXRpb25Db29yZCggc3R5bGUubGVmdCwgJ3dpZHRoJyApO1xuICB2YXIgeSA9IHRoaXMuX2dldFBvc2l0aW9uQ29vcmQoIHN0eWxlLnRvcCwgJ2hlaWdodCcgKTtcbiAgLy8gY2xlYW4gdXAgJ2F1dG8nIG9yIG90aGVyIG5vbi1pbnRlZ2VyIHZhbHVlc1xuICB0aGlzLnBvc2l0aW9uLnggPSBpc05hTiggeCApID8gMCA6IHg7XG4gIHRoaXMucG9zaXRpb24ueSA9IGlzTmFOKCB5ICkgPyAwIDogeTtcblxuICB0aGlzLl9hZGRUcmFuc2Zvcm1Qb3NpdGlvbiggc3R5bGUgKTtcbn07XG5cbnByb3RvLl9nZXRQb3NpdGlvbkNvb3JkID0gZnVuY3Rpb24oIHN0eWxlU2lkZSwgbWVhc3VyZSApIHtcbiAgaWYgKCBzdHlsZVNpZGUuaW5kZXhPZignJScpICE9IC0xICkge1xuICAgIC8vIGNvbnZlcnQgcGVyY2VudCBpbnRvIHBpeGVsIGZvciBTYWZhcmksICM3NVxuICAgIHZhciBwYXJlbnRTaXplID0gZ2V0U2l6ZSggdGhpcy5lbGVtZW50LnBhcmVudE5vZGUgKTtcbiAgICAvLyBwcmV2ZW50IG5vdC1pbi1ET00gZWxlbWVudCB0aHJvd2luZyBidWcsICMxMzFcbiAgICByZXR1cm4gIXBhcmVudFNpemUgPyAwIDpcbiAgICAgICggcGFyc2VGbG9hdCggc3R5bGVTaWRlICkgLyAxMDAgKSAqIHBhcmVudFNpemVbIG1lYXN1cmUgXTtcbiAgfVxuICByZXR1cm4gcGFyc2VJbnQoIHN0eWxlU2lkZSwgMTAgKTtcbn07XG5cbi8vIGFkZCB0cmFuc2Zvcm06IHRyYW5zbGF0ZSggeCwgeSApIHRvIHBvc2l0aW9uXG5wcm90by5fYWRkVHJhbnNmb3JtUG9zaXRpb24gPSBmdW5jdGlvbiggc3R5bGUgKSB7XG4gIHZhciB0cmFuc2Zvcm0gPSBzdHlsZS50cmFuc2Zvcm07XG4gIC8vIGJhaWwgb3V0IGlmIHZhbHVlIGlzICdub25lJ1xuICBpZiAoIHRyYW5zZm9ybS5pbmRleE9mKCdtYXRyaXgnKSAhPT0gMCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gc3BsaXQgbWF0cml4KDEsIDAsIDAsIDEsIHgsIHkpXG4gIHZhciBtYXRyaXhWYWx1ZXMgPSB0cmFuc2Zvcm0uc3BsaXQoJywnKTtcbiAgLy8gdHJhbnNsYXRlIFggdmFsdWUgaXMgaW4gMTJ0aCBvciA0dGggcG9zaXRpb25cbiAgdmFyIHhJbmRleCA9IHRyYW5zZm9ybS5pbmRleE9mKCdtYXRyaXgzZCcpID09PSAwID8gMTIgOiA0O1xuICB2YXIgdHJhbnNsYXRlWCA9IHBhcnNlSW50KCBtYXRyaXhWYWx1ZXNbIHhJbmRleCBdLCAxMCApO1xuICAvLyB0cmFuc2xhdGUgWSB2YWx1ZSBpcyBpbiAxM3RoIG9yIDV0aCBwb3NpdGlvblxuICB2YXIgdHJhbnNsYXRlWSA9IHBhcnNlSW50KCBtYXRyaXhWYWx1ZXNbIHhJbmRleCArIDEgXSwgMTAgKTtcbiAgdGhpcy5wb3NpdGlvbi54ICs9IHRyYW5zbGF0ZVg7XG4gIHRoaXMucG9zaXRpb24ueSArPSB0cmFuc2xhdGVZO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gZXZlbnRzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbnByb3RvLm9uUG9pbnRlckRvd24gPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XG4gIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdpcy1wb2ludGVyLWRvd24nKTtcbiAgdGhpcy5kaXNwYXRjaEpRdWVyeUV2ZW50KCAncG9pbnRlckRvd24nLCBldmVudCwgWyBwb2ludGVyIF0gKTtcbn07XG5cbi8qKlxuICogZHJhZyBzdGFydFxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwYXJhbSB7RXZlbnQgb3IgVG91Y2h9IHBvaW50ZXJcbiAqL1xucHJvdG8uZHJhZ1N0YXJ0ID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICBpZiAoICF0aGlzLmlzRW5hYmxlZCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5fZ2V0UG9zaXRpb24oKTtcbiAgdGhpcy5tZWFzdXJlQ29udGFpbm1lbnQoKTtcbiAgLy8gcG9zaXRpb24gX3doZW5fIGRyYWcgYmVnYW5cbiAgdGhpcy5zdGFydFBvc2l0aW9uLnggPSB0aGlzLnBvc2l0aW9uLng7XG4gIHRoaXMuc3RhcnRQb3NpdGlvbi55ID0gdGhpcy5wb3NpdGlvbi55O1xuICAvLyByZXNldCBsZWZ0L3RvcCBzdHlsZVxuICB0aGlzLnNldExlZnRUb3AoKTtcblxuICB0aGlzLmRyYWdQb2ludC54ID0gMDtcbiAgdGhpcy5kcmFnUG9pbnQueSA9IDA7XG5cbiAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2lzLWRyYWdnaW5nJyk7XG4gIHRoaXMuZGlzcGF0Y2hFdmVudCggJ2RyYWdTdGFydCcsIGV2ZW50LCBbIHBvaW50ZXIgXSApO1xuICAvLyBzdGFydCBhbmltYXRpb25cbiAgdGhpcy5hbmltYXRlKCk7XG59O1xuXG5wcm90by5tZWFzdXJlQ29udGFpbm1lbnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNvbnRhaW5lciA9IHRoaXMuZ2V0Q29udGFpbmVyKCk7XG4gIGlmICggIWNvbnRhaW5lciApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZWxlbVNpemUgPSBnZXRTaXplKCB0aGlzLmVsZW1lbnQgKTtcbiAgdmFyIGNvbnRhaW5lclNpemUgPSBnZXRTaXplKCBjb250YWluZXIgKTtcbiAgdmFyIGVsZW1SZWN0ID0gdGhpcy5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgY29udGFpbmVyUmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICB2YXIgYm9yZGVyU2l6ZVggPSBjb250YWluZXJTaXplLmJvcmRlckxlZnRXaWR0aCArIGNvbnRhaW5lclNpemUuYm9yZGVyUmlnaHRXaWR0aDtcbiAgdmFyIGJvcmRlclNpemVZID0gY29udGFpbmVyU2l6ZS5ib3JkZXJUb3BXaWR0aCArIGNvbnRhaW5lclNpemUuYm9yZGVyQm90dG9tV2lkdGg7XG5cbiAgdmFyIHBvc2l0aW9uID0gdGhpcy5yZWxhdGl2ZVN0YXJ0UG9zaXRpb24gPSB7XG4gICAgeDogZWxlbVJlY3QubGVmdCAtICggY29udGFpbmVyUmVjdC5sZWZ0ICsgY29udGFpbmVyU2l6ZS5ib3JkZXJMZWZ0V2lkdGggKSxcbiAgICB5OiBlbGVtUmVjdC50b3AgLSAoIGNvbnRhaW5lclJlY3QudG9wICsgY29udGFpbmVyU2l6ZS5ib3JkZXJUb3BXaWR0aCApXG4gIH07XG5cbiAgdGhpcy5jb250YWluU2l6ZSA9IHtcbiAgICB3aWR0aDogKCBjb250YWluZXJTaXplLndpZHRoIC0gYm9yZGVyU2l6ZVggKSAtIHBvc2l0aW9uLnggLSBlbGVtU2l6ZS53aWR0aCxcbiAgICBoZWlnaHQ6ICggY29udGFpbmVyU2l6ZS5oZWlnaHQgLSBib3JkZXJTaXplWSApIC0gcG9zaXRpb24ueSAtIGVsZW1TaXplLmhlaWdodFxuICB9O1xufTtcblxucHJvdG8uZ2V0Q29udGFpbmVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb250YWlubWVudCA9IHRoaXMub3B0aW9ucy5jb250YWlubWVudDtcbiAgaWYgKCAhY29udGFpbm1lbnQgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBpc0VsZW1lbnQgPSBjb250YWlubWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICAvLyB1c2UgYXMgZWxlbWVudFxuICBpZiAoIGlzRWxlbWVudCApIHtcbiAgICByZXR1cm4gY29udGFpbm1lbnQ7XG4gIH1cbiAgLy8gcXVlcnlTZWxlY3RvciBpZiBzdHJpbmdcbiAgaWYgKCB0eXBlb2YgY29udGFpbm1lbnQgPT0gJ3N0cmluZycgKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoIGNvbnRhaW5tZW50ICk7XG4gIH1cbiAgLy8gZmFsbGJhY2sgdG8gcGFyZW50IGVsZW1lbnRcbiAgcmV0dXJuIHRoaXMuZWxlbWVudC5wYXJlbnROb2RlO1xufTtcblxuLy8gLS0tLS0gbW92ZSBldmVudCAtLS0tLSAvL1xuXG5wcm90by5vblBvaW50ZXJNb3ZlID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyLCBtb3ZlVmVjdG9yICkge1xuICB0aGlzLmRpc3BhdGNoSlF1ZXJ5RXZlbnQoICdwb2ludGVyTW92ZScsIGV2ZW50LCBbIHBvaW50ZXIsIG1vdmVWZWN0b3IgXSApO1xufTtcblxuLyoqXG4gKiBkcmFnIG1vdmVcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50IG9yIFRvdWNofSBwb2ludGVyXG4gKi9cbnByb3RvLmRyYWdNb3ZlID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyLCBtb3ZlVmVjdG9yICkge1xuICBpZiAoICF0aGlzLmlzRW5hYmxlZCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGRyYWdYID0gbW92ZVZlY3Rvci54O1xuICB2YXIgZHJhZ1kgPSBtb3ZlVmVjdG9yLnk7XG5cbiAgdmFyIGdyaWQgPSB0aGlzLm9wdGlvbnMuZ3JpZDtcbiAgdmFyIGdyaWRYID0gZ3JpZCAmJiBncmlkWzBdO1xuICB2YXIgZ3JpZFkgPSBncmlkICYmIGdyaWRbMV07XG5cbiAgZHJhZ1ggPSBhcHBseUdyaWQoIGRyYWdYLCBncmlkWCApO1xuICBkcmFnWSA9IGFwcGx5R3JpZCggZHJhZ1ksIGdyaWRZICk7XG5cbiAgZHJhZ1ggPSB0aGlzLmNvbnRhaW5EcmFnKCAneCcsIGRyYWdYLCBncmlkWCApO1xuICBkcmFnWSA9IHRoaXMuY29udGFpbkRyYWcoICd5JywgZHJhZ1ksIGdyaWRZICk7XG5cbiAgLy8gY29uc3RyYWluIHRvIGF4aXNcbiAgZHJhZ1ggPSB0aGlzLm9wdGlvbnMuYXhpcyA9PSAneScgPyAwIDogZHJhZ1g7XG4gIGRyYWdZID0gdGhpcy5vcHRpb25zLmF4aXMgPT0gJ3gnID8gMCA6IGRyYWdZO1xuXG4gIHRoaXMucG9zaXRpb24ueCA9IHRoaXMuc3RhcnRQb3NpdGlvbi54ICsgZHJhZ1g7XG4gIHRoaXMucG9zaXRpb24ueSA9IHRoaXMuc3RhcnRQb3NpdGlvbi55ICsgZHJhZ1k7XG4gIC8vIHNldCBkcmFnUG9pbnQgcHJvcGVydGllc1xuICB0aGlzLmRyYWdQb2ludC54ID0gZHJhZ1g7XG4gIHRoaXMuZHJhZ1BvaW50LnkgPSBkcmFnWTtcblxuICB0aGlzLmRpc3BhdGNoRXZlbnQoICdkcmFnTW92ZScsIGV2ZW50LCBbIHBvaW50ZXIsIG1vdmVWZWN0b3IgXSApO1xufTtcblxuZnVuY3Rpb24gYXBwbHlHcmlkKCB2YWx1ZSwgZ3JpZCwgbWV0aG9kICkge1xuICBtZXRob2QgPSBtZXRob2QgfHwgJ3JvdW5kJztcbiAgcmV0dXJuIGdyaWQgPyBNYXRoWyBtZXRob2QgXSggdmFsdWUgLyBncmlkICkgKiBncmlkIDogdmFsdWU7XG59XG5cbnByb3RvLmNvbnRhaW5EcmFnID0gZnVuY3Rpb24oIGF4aXMsIGRyYWcsIGdyaWQgKSB7XG4gIGlmICggIXRoaXMub3B0aW9ucy5jb250YWlubWVudCApIHtcbiAgICByZXR1cm4gZHJhZztcbiAgfVxuICB2YXIgbWVhc3VyZSA9IGF4aXMgPT0gJ3gnID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuXG4gIHZhciByZWwgPSB0aGlzLnJlbGF0aXZlU3RhcnRQb3NpdGlvblsgYXhpcyBdO1xuICB2YXIgbWluID0gYXBwbHlHcmlkKCAtcmVsLCBncmlkLCAnY2VpbCcgKTtcbiAgdmFyIG1heCA9IHRoaXMuY29udGFpblNpemVbIG1lYXN1cmUgXTtcbiAgbWF4ID0gYXBwbHlHcmlkKCBtYXgsIGdyaWQsICdmbG9vcicgKTtcbiAgcmV0dXJuICBNYXRoLm1heCggbWluLCBNYXRoLm1pbiggbWF4LCBkcmFnICkgKTtcbn07XG5cbi8vIC0tLS0tIGVuZCBldmVudCAtLS0tLSAvL1xuXG4vKipcbiAqIHBvaW50ZXIgdXBcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50IG9yIFRvdWNofSBwb2ludGVyXG4gKi9cbnByb3RvLm9uUG9pbnRlclVwID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnaXMtcG9pbnRlci1kb3duJyk7XG4gIHRoaXMuZGlzcGF0Y2hKUXVlcnlFdmVudCggJ3BvaW50ZXJVcCcsIGV2ZW50LCBbIHBvaW50ZXIgXSApO1xufTtcblxuLyoqXG4gKiBkcmFnIGVuZFxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwYXJhbSB7RXZlbnQgb3IgVG91Y2h9IHBvaW50ZXJcbiAqL1xucHJvdG8uZHJhZ0VuZCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgaWYgKCAhdGhpcy5pc0VuYWJsZWQgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIHVzZSB0b3AgbGVmdCBwb3NpdGlvbiB3aGVuIGNvbXBsZXRlXG4gIHRoaXMuZWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSAnJztcbiAgdGhpcy5zZXRMZWZ0VG9wKCk7XG4gIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdpcy1kcmFnZ2luZycpO1xuICB0aGlzLmRpc3BhdGNoRXZlbnQoICdkcmFnRW5kJywgZXZlbnQsIFsgcG9pbnRlciBdICk7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBhbmltYXRpb24gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxucHJvdG8uYW5pbWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBvbmx5IHJlbmRlciBhbmQgYW5pbWF0ZSBpZiBkcmFnZ2luZ1xuICBpZiAoICF0aGlzLmlzRHJhZ2dpbmcgKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5wb3NpdGlvbkRyYWcoKTtcblxuICB2YXIgX3RoaXMgPSB0aGlzO1xuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIGZ1bmN0aW9uIGFuaW1hdGVGcmFtZSgpIHtcbiAgICBfdGhpcy5hbmltYXRlKCk7XG4gIH0pO1xuXG59O1xuXG4vLyBsZWZ0L3RvcCBwb3NpdGlvbmluZ1xucHJvdG8uc2V0TGVmdFRvcCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVsZW1lbnQuc3R5bGUubGVmdCA9IHRoaXMucG9zaXRpb24ueCArICdweCc7XG4gIHRoaXMuZWxlbWVudC5zdHlsZS50b3AgID0gdGhpcy5wb3NpdGlvbi55ICsgJ3B4Jztcbn07XG5cbnByb3RvLnBvc2l0aW9uRHJhZyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZTNkKCAnICsgdGhpcy5kcmFnUG9pbnQueCArXG4gICAgJ3B4LCAnICsgdGhpcy5kcmFnUG9pbnQueSArICdweCwgMCknO1xufTtcblxuLy8gLS0tLS0gc3RhdGljQ2xpY2sgLS0tLS0gLy9cblxucHJvdG8uc3RhdGljQ2xpY2sgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XG4gIHRoaXMuZGlzcGF0Y2hFdmVudCggJ3N0YXRpY0NsaWNrJywgZXZlbnQsIFsgcG9pbnRlciBdICk7XG59O1xuXG4vLyAtLS0tLSBtZXRob2RzIC0tLS0tIC8vXG5cbi8qKlxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKi9cbnByb3RvLnNldFBvc2l0aW9uID0gZnVuY3Rpb24oIHgsIHkgKSB7XG4gIHRoaXMucG9zaXRpb24ueCA9IHg7XG4gIHRoaXMucG9zaXRpb24ueSA9IHk7XG4gIHRoaXMuc2V0TGVmdFRvcCgpO1xufTtcblxucHJvdG8uZW5hYmxlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuaXNFbmFibGVkID0gdHJ1ZTtcbn07XG5cbnByb3RvLmRpc2FibGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5pc0VuYWJsZWQgPSBmYWxzZTtcbiAgaWYgKCB0aGlzLmlzRHJhZ2dpbmcgKSB7XG4gICAgdGhpcy5kcmFnRW5kKCk7XG4gIH1cbn07XG5cbnByb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5kaXNhYmxlKCk7XG4gIC8vIHJlc2V0IHN0eWxlc1xuICB0aGlzLmVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gJyc7XG4gIHRoaXMuZWxlbWVudC5zdHlsZS5sZWZ0ID0gJyc7XG4gIHRoaXMuZWxlbWVudC5zdHlsZS50b3AgPSAnJztcbiAgdGhpcy5lbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJyc7XG4gIC8vIHVuYmluZCBoYW5kbGVzXG4gIHRoaXMudW5iaW5kSGFuZGxlcygpO1xuICAvLyByZW1vdmUgalF1ZXJ5IGRhdGFcbiAgaWYgKCB0aGlzLiRlbGVtZW50ICkge1xuICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlRGF0YSgnZHJhZ2dhYmlsbHknKTtcbiAgfVxufTtcblxuLy8gLS0tLS0galF1ZXJ5IGJyaWRnZXQgLS0tLS0gLy9cblxuLy8gcmVxdWlyZWQgZm9yIGpRdWVyeSBicmlkZ2V0XG5wcm90by5faW5pdCA9IG5vb3A7XG5cbmlmICggalF1ZXJ5ICYmIGpRdWVyeS5icmlkZ2V0ICkge1xuICBqUXVlcnkuYnJpZGdldCggJ2RyYWdnYWJpbGx5JywgRHJhZ2dhYmlsbHkgKTtcbn1cblxuLy8gLS0tLS0gIC0tLS0tIC8vXG5cbnJldHVybiBEcmFnZ2FiaWxseTtcblxufSkpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQSxXQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/draggabilly/draggabilly.js\n");

/***/ }),

/***/ "./node_modules/ev-emitter/ev-emitter.js":
/*!***********************************************!*\
  !*** ./node_modules/ev-emitter/ev-emitter.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * EvEmitter v1.1.0\n * Lil' event emitter\n * MIT License\n */\n\n/* jshint unused: true, undef: true, strict: true */\n\n( function( global, factory ) {\n  // universal module definition\n  /* jshint strict: false */ /* globals define, module, window */\n  if ( true ) {\n    // AMD - RequireJS\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n}( typeof window != 'undefined' ? window : this, function() {\n\n\"use strict\";\n\nfunction EvEmitter() {}\n\nvar proto = EvEmitter.prototype;\n\nproto.on = function( eventName, listener ) {\n  if ( !eventName || !listener ) {\n    return;\n  }\n  // set events hash\n  var events = this._events = this._events || {};\n  // set listeners array\n  var listeners = events[ eventName ] = events[ eventName ] || [];\n  // only add once\n  if ( listeners.indexOf( listener ) == -1 ) {\n    listeners.push( listener );\n  }\n\n  return this;\n};\n\nproto.once = function( eventName, listener ) {\n  if ( !eventName || !listener ) {\n    return;\n  }\n  // add event\n  this.on( eventName, listener );\n  // set once flag\n  // set onceEvents hash\n  var onceEvents = this._onceEvents = this._onceEvents || {};\n  // set onceListeners object\n  var onceListeners = onceEvents[ eventName ] = onceEvents[ eventName ] || {};\n  // set flag\n  onceListeners[ listener ] = true;\n\n  return this;\n};\n\nproto.off = function( eventName, listener ) {\n  var listeners = this._events && this._events[ eventName ];\n  if ( !listeners || !listeners.length ) {\n    return;\n  }\n  var index = listeners.indexOf( listener );\n  if ( index != -1 ) {\n    listeners.splice( index, 1 );\n  }\n\n  return this;\n};\n\nproto.emitEvent = function( eventName, args ) {\n  var listeners = this._events && this._events[ eventName ];\n  if ( !listeners || !listeners.length ) {\n    return;\n  }\n  // copy over to avoid interference if .off() in listener\n  listeners = listeners.slice(0);\n  args = args || [];\n  // once stuff\n  var onceListeners = this._onceEvents && this._onceEvents[ eventName ];\n\n  for ( var i=0; i < listeners.length; i++ ) {\n    var listener = listeners[i]\n    var isOnce = onceListeners && onceListeners[ listener ];\n    if ( isOnce ) {\n      // remove listener\n      // remove before trigger to prevent recursion\n      this.off( eventName, listener );\n      // unset once flag\n      delete onceListeners[ listener ];\n    }\n    // trigger listener\n    listener.apply( this, args );\n  }\n\n  return this;\n};\n\nproto.allOff = function() {\n  delete this._events;\n  delete this._onceEvents;\n};\n\nreturn EvEmitter;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXYtZW1pdHRlci9ldi1lbWl0dGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V2LWVtaXR0ZXIvZXYtZW1pdHRlci5qcz8wOTQ5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXZFbWl0dGVyIHYxLjEuMFxuICogTGlsJyBldmVudCBlbWl0dGVyXG4gKiBNSVQgTGljZW5zZVxuICovXG5cbi8qIGpzaGludCB1bnVzZWQ6IHRydWUsIHVuZGVmOiB0cnVlLCBzdHJpY3Q6IHRydWUgKi9cblxuKCBmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgLyoganNoaW50IHN0cmljdDogZmFsc2UgKi8gLyogZ2xvYmFscyBkZWZpbmUsIG1vZHVsZSwgd2luZG93ICovXG4gIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG4gICAgLy8gQU1EIC0gUmVxdWlyZUpTXG4gICAgZGVmaW5lKCBmYWN0b3J5ICk7XG4gIH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgLy8gQ29tbW9uSlMgLSBCcm93c2VyaWZ5LCBXZWJwYWNrXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQnJvd3NlciBnbG9iYWxzXG4gICAgZ2xvYmFsLkV2RW1pdHRlciA9IGZhY3RvcnkoKTtcbiAgfVxuXG59KCB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBFdkVtaXR0ZXIoKSB7fVxuXG52YXIgcHJvdG8gPSBFdkVtaXR0ZXIucHJvdG90eXBlO1xuXG5wcm90by5vbiA9IGZ1bmN0aW9uKCBldmVudE5hbWUsIGxpc3RlbmVyICkge1xuICBpZiAoICFldmVudE5hbWUgfHwgIWxpc3RlbmVyICkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBzZXQgZXZlbnRzIGhhc2hcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgLy8gc2V0IGxpc3RlbmVycyBhcnJheVxuICB2YXIgbGlzdGVuZXJzID0gZXZlbnRzWyBldmVudE5hbWUgXSA9IGV2ZW50c1sgZXZlbnROYW1lIF0gfHwgW107XG4gIC8vIG9ubHkgYWRkIG9uY2VcbiAgaWYgKCBsaXN0ZW5lcnMuaW5kZXhPZiggbGlzdGVuZXIgKSA9PSAtMSApIHtcbiAgICBsaXN0ZW5lcnMucHVzaCggbGlzdGVuZXIgKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ub25jZSA9IGZ1bmN0aW9uKCBldmVudE5hbWUsIGxpc3RlbmVyICkge1xuICBpZiAoICFldmVudE5hbWUgfHwgIWxpc3RlbmVyICkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBhZGQgZXZlbnRcbiAgdGhpcy5vbiggZXZlbnROYW1lLCBsaXN0ZW5lciApO1xuICAvLyBzZXQgb25jZSBmbGFnXG4gIC8vIHNldCBvbmNlRXZlbnRzIGhhc2hcbiAgdmFyIG9uY2VFdmVudHMgPSB0aGlzLl9vbmNlRXZlbnRzID0gdGhpcy5fb25jZUV2ZW50cyB8fCB7fTtcbiAgLy8gc2V0IG9uY2VMaXN0ZW5lcnMgb2JqZWN0XG4gIHZhciBvbmNlTGlzdGVuZXJzID0gb25jZUV2ZW50c1sgZXZlbnROYW1lIF0gPSBvbmNlRXZlbnRzWyBldmVudE5hbWUgXSB8fCB7fTtcbiAgLy8gc2V0IGZsYWdcbiAgb25jZUxpc3RlbmVyc1sgbGlzdGVuZXIgXSA9IHRydWU7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5vZmYgPSBmdW5jdGlvbiggZXZlbnROYW1lLCBsaXN0ZW5lciApIHtcbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHNbIGV2ZW50TmFtZSBdO1xuICBpZiAoICFsaXN0ZW5lcnMgfHwgIWxpc3RlbmVycy5sZW5ndGggKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKCBsaXN0ZW5lciApO1xuICBpZiAoIGluZGV4ICE9IC0xICkge1xuICAgIGxpc3RlbmVycy5zcGxpY2UoIGluZGV4LCAxICk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLmVtaXRFdmVudCA9IGZ1bmN0aW9uKCBldmVudE5hbWUsIGFyZ3MgKSB7XG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHMgJiYgdGhpcy5fZXZlbnRzWyBldmVudE5hbWUgXTtcbiAgaWYgKCAhbGlzdGVuZXJzIHx8ICFsaXN0ZW5lcnMubGVuZ3RoICkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBjb3B5IG92ZXIgdG8gYXZvaWQgaW50ZXJmZXJlbmNlIGlmIC5vZmYoKSBpbiBsaXN0ZW5lclxuICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuc2xpY2UoMCk7XG4gIGFyZ3MgPSBhcmdzIHx8IFtdO1xuICAvLyBvbmNlIHN0dWZmXG4gIHZhciBvbmNlTGlzdGVuZXJzID0gdGhpcy5fb25jZUV2ZW50cyAmJiB0aGlzLl9vbmNlRXZlbnRzWyBldmVudE5hbWUgXTtcblxuICBmb3IgKCB2YXIgaT0wOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrICkge1xuICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXVxuICAgIHZhciBpc09uY2UgPSBvbmNlTGlzdGVuZXJzICYmIG9uY2VMaXN0ZW5lcnNbIGxpc3RlbmVyIF07XG4gICAgaWYgKCBpc09uY2UgKSB7XG4gICAgICAvLyByZW1vdmUgbGlzdGVuZXJcbiAgICAgIC8vIHJlbW92ZSBiZWZvcmUgdHJpZ2dlciB0byBwcmV2ZW50IHJlY3Vyc2lvblxuICAgICAgdGhpcy5vZmYoIGV2ZW50TmFtZSwgbGlzdGVuZXIgKTtcbiAgICAgIC8vIHVuc2V0IG9uY2UgZmxhZ1xuICAgICAgZGVsZXRlIG9uY2VMaXN0ZW5lcnNbIGxpc3RlbmVyIF07XG4gICAgfVxuICAgIC8vIHRyaWdnZXIgbGlzdGVuZXJcbiAgICBsaXN0ZW5lci5hcHBseSggdGhpcywgYXJncyApO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5hbGxPZmYgPSBmdW5jdGlvbigpIHtcbiAgZGVsZXRlIHRoaXMuX2V2ZW50cztcbiAgZGVsZXRlIHRoaXMuX29uY2VFdmVudHM7XG59O1xuXG5yZXR1cm4gRXZFbWl0dGVyO1xuXG59KSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBLFdBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ev-emitter/ev-emitter.js\n");

/***/ }),

/***/ "./node_modules/get-size/get-size.js":
/*!*******************************************!*\
  !*** ./node_modules/get-size/get-size.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * getSize v2.0.3\n * measure size of elements\n * MIT license\n */\n\n/* jshint browser: true, strict: true, undef: true, unused: true */\n/* globals console: false */\n\n( function( window, factory ) {\n  /* jshint strict: false */ /* globals define, module */\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n})( window, function factory() {\n'use strict';\n\n// -------------------------- helpers -------------------------- //\n\n// get a number from a string, not a percentage\nfunction getStyleSize( value ) {\n  var num = parseFloat( value );\n  // not a percent like '100%', and a number\n  var isValid = value.indexOf('%') == -1 && !isNaN( num );\n  return isValid && num;\n}\n\nfunction noop() {}\n\nvar logError = typeof console == 'undefined' ? noop :\n  function( message ) {\n    console.error( message );\n  };\n\n// -------------------------- measurements -------------------------- //\n\nvar measurements = [\n  'paddingLeft',\n  'paddingRight',\n  'paddingTop',\n  'paddingBottom',\n  'marginLeft',\n  'marginRight',\n  'marginTop',\n  'marginBottom',\n  'borderLeftWidth',\n  'borderRightWidth',\n  'borderTopWidth',\n  'borderBottomWidth'\n];\n\nvar measurementsLength = measurements.length;\n\nfunction getZeroSize() {\n  var size = {\n    width: 0,\n    height: 0,\n    innerWidth: 0,\n    innerHeight: 0,\n    outerWidth: 0,\n    outerHeight: 0\n  };\n  for ( var i=0; i < measurementsLength; i++ ) {\n    var measurement = measurements[i];\n    size[ measurement ] = 0;\n  }\n  return size;\n}\n\n// -------------------------- getStyle -------------------------- //\n\n/**\n * getStyle, get style of element, check for Firefox bug\n * https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n */\nfunction getStyle( elem ) {\n  var style = getComputedStyle( elem );\n  if ( !style ) {\n    logError( 'Style returned ' + style +\n      '. Are you running this code in a hidden iframe on Firefox? ' +\n      'See https://bit.ly/getsizebug1' );\n  }\n  return style;\n}\n\n// -------------------------- setup -------------------------- //\n\nvar isSetup = false;\n\nvar isBoxSizeOuter;\n\n/**\n * setup\n * check isBoxSizerOuter\n * do on first getSize() rather than on page load for Firefox bug\n */\nfunction setup() {\n  // setup once\n  if ( isSetup ) {\n    return;\n  }\n  isSetup = true;\n\n  // -------------------------- box sizing -------------------------- //\n\n  /**\n   * Chrome & Safari measure the outer-width on style.width on border-box elems\n   * IE11 & Firefox<29 measures the inner-width\n   */\n  var div = document.createElement('div');\n  div.style.width = '200px';\n  div.style.padding = '1px 2px 3px 4px';\n  div.style.borderStyle = 'solid';\n  div.style.borderWidth = '1px 2px 3px 4px';\n  div.style.boxSizing = 'border-box';\n\n  var body = document.body || document.documentElement;\n  body.appendChild( div );\n  var style = getStyle( div );\n  // round value for browser zoom. desandro/masonry#928\n  isBoxSizeOuter = Math.round( getStyleSize( style.width ) ) == 200;\n  getSize.isBoxSizeOuter = isBoxSizeOuter;\n\n  body.removeChild( div );\n}\n\n// -------------------------- getSize -------------------------- //\n\nfunction getSize( elem ) {\n  setup();\n\n  // use querySeletor if elem is string\n  if ( typeof elem == 'string' ) {\n    elem = document.querySelector( elem );\n  }\n\n  // do not proceed on non-objects\n  if ( !elem || typeof elem != 'object' || !elem.nodeType ) {\n    return;\n  }\n\n  var style = getStyle( elem );\n\n  // if hidden, everything is 0\n  if ( style.display == 'none' ) {\n    return getZeroSize();\n  }\n\n  var size = {};\n  size.width = elem.offsetWidth;\n  size.height = elem.offsetHeight;\n\n  var isBorderBox = size.isBorderBox = style.boxSizing == 'border-box';\n\n  // get all measurements\n  for ( var i=0; i < measurementsLength; i++ ) {\n    var measurement = measurements[i];\n    var value = style[ measurement ];\n    var num = parseFloat( value );\n    // any 'auto', 'medium' value will be 0\n    size[ measurement ] = !isNaN( num ) ? num : 0;\n  }\n\n  var paddingWidth = size.paddingLeft + size.paddingRight;\n  var paddingHeight = size.paddingTop + size.paddingBottom;\n  var marginWidth = size.marginLeft + size.marginRight;\n  var marginHeight = size.marginTop + size.marginBottom;\n  var borderWidth = size.borderLeftWidth + size.borderRightWidth;\n  var borderHeight = size.borderTopWidth + size.borderBottomWidth;\n\n  var isBorderBoxSizeOuter = isBorderBox && isBoxSizeOuter;\n\n  // overwrite width and height if we can get it from style\n  var styleWidth = getStyleSize( style.width );\n  if ( styleWidth !== false ) {\n    size.width = styleWidth +\n      // add padding and border unless it's already including it\n      ( isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth );\n  }\n\n  var styleHeight = getStyleSize( style.height );\n  if ( styleHeight !== false ) {\n    size.height = styleHeight +\n      // add padding and border unless it's already including it\n      ( isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight );\n  }\n\n  size.innerWidth = size.width - ( paddingWidth + borderWidth );\n  size.innerHeight = size.height - ( paddingHeight + borderHeight );\n\n  size.outerWidth = size.width + marginWidth;\n  size.outerHeight = size.height + marginHeight;\n\n  return size;\n}\n\nreturn getSize;\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2V0LXNpemUvZ2V0LXNpemUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2V0LXNpemUvZ2V0LXNpemUuanM/NDBhZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGdldFNpemUgdjIuMC4zXG4gKiBtZWFzdXJlIHNpemUgb2YgZWxlbWVudHNcbiAqIE1JVCBsaWNlbnNlXG4gKi9cblxuLyoganNoaW50IGJyb3dzZXI6IHRydWUsIHN0cmljdDogdHJ1ZSwgdW5kZWY6IHRydWUsIHVudXNlZDogdHJ1ZSAqL1xuLyogZ2xvYmFscyBjb25zb2xlOiBmYWxzZSAqL1xuXG4oIGZ1bmN0aW9uKCB3aW5kb3csIGZhY3RvcnkgKSB7XG4gIC8qIGpzaGludCBzdHJpY3Q6IGZhbHNlICovIC8qIGdsb2JhbHMgZGVmaW5lLCBtb2R1bGUgKi9cbiAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAvLyBBTURcbiAgICBkZWZpbmUoIGZhY3RvcnkgKTtcbiAgfSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcbiAgICAvLyBDb21tb25KU1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIGJyb3dzZXIgZ2xvYmFsXG4gICAgd2luZG93LmdldFNpemUgPSBmYWN0b3J5KCk7XG4gIH1cblxufSkoIHdpbmRvdywgZnVuY3Rpb24gZmFjdG9yeSgpIHtcbid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gaGVscGVycyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4vLyBnZXQgYSBudW1iZXIgZnJvbSBhIHN0cmluZywgbm90IGEgcGVyY2VudGFnZVxuZnVuY3Rpb24gZ2V0U3R5bGVTaXplKCB2YWx1ZSApIHtcbiAgdmFyIG51bSA9IHBhcnNlRmxvYXQoIHZhbHVlICk7XG4gIC8vIG5vdCBhIHBlcmNlbnQgbGlrZSAnMTAwJScsIGFuZCBhIG51bWJlclxuICB2YXIgaXNWYWxpZCA9IHZhbHVlLmluZGV4T2YoJyUnKSA9PSAtMSAmJiAhaXNOYU4oIG51bSApO1xuICByZXR1cm4gaXNWYWxpZCAmJiBudW07XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG52YXIgbG9nRXJyb3IgPSB0eXBlb2YgY29uc29sZSA9PSAndW5kZWZpbmVkJyA/IG5vb3AgOlxuICBmdW5jdGlvbiggbWVzc2FnZSApIHtcbiAgICBjb25zb2xlLmVycm9yKCBtZXNzYWdlICk7XG4gIH07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIG1lYXN1cmVtZW50cyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG52YXIgbWVhc3VyZW1lbnRzID0gW1xuICAncGFkZGluZ0xlZnQnLFxuICAncGFkZGluZ1JpZ2h0JyxcbiAgJ3BhZGRpbmdUb3AnLFxuICAncGFkZGluZ0JvdHRvbScsXG4gICdtYXJnaW5MZWZ0JyxcbiAgJ21hcmdpblJpZ2h0JyxcbiAgJ21hcmdpblRvcCcsXG4gICdtYXJnaW5Cb3R0b20nLFxuICAnYm9yZGVyTGVmdFdpZHRoJyxcbiAgJ2JvcmRlclJpZ2h0V2lkdGgnLFxuICAnYm9yZGVyVG9wV2lkdGgnLFxuICAnYm9yZGVyQm90dG9tV2lkdGgnXG5dO1xuXG52YXIgbWVhc3VyZW1lbnRzTGVuZ3RoID0gbWVhc3VyZW1lbnRzLmxlbmd0aDtcblxuZnVuY3Rpb24gZ2V0WmVyb1NpemUoKSB7XG4gIHZhciBzaXplID0ge1xuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMCxcbiAgICBpbm5lcldpZHRoOiAwLFxuICAgIGlubmVySGVpZ2h0OiAwLFxuICAgIG91dGVyV2lkdGg6IDAsXG4gICAgb3V0ZXJIZWlnaHQ6IDBcbiAgfTtcbiAgZm9yICggdmFyIGk9MDsgaSA8IG1lYXN1cmVtZW50c0xlbmd0aDsgaSsrICkge1xuICAgIHZhciBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1tpXTtcbiAgICBzaXplWyBtZWFzdXJlbWVudCBdID0gMDtcbiAgfVxuICByZXR1cm4gc2l6ZTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gZ2V0U3R5bGUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuLyoqXG4gKiBnZXRTdHlsZSwgZ2V0IHN0eWxlIG9mIGVsZW1lbnQsIGNoZWNrIGZvciBGaXJlZm94IGJ1Z1xuICogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTQ4Mzk3XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlKCBlbGVtICkge1xuICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG4gIGlmICggIXN0eWxlICkge1xuICAgIGxvZ0Vycm9yKCAnU3R5bGUgcmV0dXJuZWQgJyArIHN0eWxlICtcbiAgICAgICcuIEFyZSB5b3UgcnVubmluZyB0aGlzIGNvZGUgaW4gYSBoaWRkZW4gaWZyYW1lIG9uIEZpcmVmb3g/ICcgK1xuICAgICAgJ1NlZSBodHRwczovL2JpdC5seS9nZXRzaXplYnVnMScgKTtcbiAgfVxuICByZXR1cm4gc3R5bGU7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHNldHVwIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbnZhciBpc1NldHVwID0gZmFsc2U7XG5cbnZhciBpc0JveFNpemVPdXRlcjtcblxuLyoqXG4gKiBzZXR1cFxuICogY2hlY2sgaXNCb3hTaXplck91dGVyXG4gKiBkbyBvbiBmaXJzdCBnZXRTaXplKCkgcmF0aGVyIHRoYW4gb24gcGFnZSBsb2FkIGZvciBGaXJlZm94IGJ1Z1xuICovXG5mdW5jdGlvbiBzZXR1cCgpIHtcbiAgLy8gc2V0dXAgb25jZVxuICBpZiAoIGlzU2V0dXAgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlzU2V0dXAgPSB0cnVlO1xuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGJveCBzaXppbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuICAvKipcbiAgICogQ2hyb21lICYgU2FmYXJpIG1lYXN1cmUgdGhlIG91dGVyLXdpZHRoIG9uIHN0eWxlLndpZHRoIG9uIGJvcmRlci1ib3ggZWxlbXNcbiAgICogSUUxMSAmIEZpcmVmb3g8MjkgbWVhc3VyZXMgdGhlIGlubmVyLXdpZHRoXG4gICAqL1xuICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi5zdHlsZS53aWR0aCA9ICcyMDBweCc7XG4gIGRpdi5zdHlsZS5wYWRkaW5nID0gJzFweCAycHggM3B4IDRweCc7XG4gIGRpdi5zdHlsZS5ib3JkZXJTdHlsZSA9ICdzb2xpZCc7XG4gIGRpdi5zdHlsZS5ib3JkZXJXaWR0aCA9ICcxcHggMnB4IDNweCA0cHgnO1xuICBkaXYuc3R5bGUuYm94U2l6aW5nID0gJ2JvcmRlci1ib3gnO1xuXG4gIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIGJvZHkuYXBwZW5kQ2hpbGQoIGRpdiApO1xuICB2YXIgc3R5bGUgPSBnZXRTdHlsZSggZGl2ICk7XG4gIC8vIHJvdW5kIHZhbHVlIGZvciBicm93c2VyIHpvb20uIGRlc2FuZHJvL21hc29ucnkjOTI4XG4gIGlzQm94U2l6ZU91dGVyID0gTWF0aC5yb3VuZCggZ2V0U3R5bGVTaXplKCBzdHlsZS53aWR0aCApICkgPT0gMjAwO1xuICBnZXRTaXplLmlzQm94U2l6ZU91dGVyID0gaXNCb3hTaXplT3V0ZXI7XG5cbiAgYm9keS5yZW1vdmVDaGlsZCggZGl2ICk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGdldFNpemUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuZnVuY3Rpb24gZ2V0U2l6ZSggZWxlbSApIHtcbiAgc2V0dXAoKTtcblxuICAvLyB1c2UgcXVlcnlTZWxldG9yIGlmIGVsZW0gaXMgc3RyaW5nXG4gIGlmICggdHlwZW9mIGVsZW0gPT0gJ3N0cmluZycgKSB7XG4gICAgZWxlbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoIGVsZW0gKTtcbiAgfVxuXG4gIC8vIGRvIG5vdCBwcm9jZWVkIG9uIG5vbi1vYmplY3RzXG4gIGlmICggIWVsZW0gfHwgdHlwZW9mIGVsZW0gIT0gJ29iamVjdCcgfHwgIWVsZW0ubm9kZVR5cGUgKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHN0eWxlID0gZ2V0U3R5bGUoIGVsZW0gKTtcblxuICAvLyBpZiBoaWRkZW4sIGV2ZXJ5dGhpbmcgaXMgMFxuICBpZiAoIHN0eWxlLmRpc3BsYXkgPT0gJ25vbmUnICkge1xuICAgIHJldHVybiBnZXRaZXJvU2l6ZSgpO1xuICB9XG5cbiAgdmFyIHNpemUgPSB7fTtcbiAgc2l6ZS53aWR0aCA9IGVsZW0ub2Zmc2V0V2lkdGg7XG4gIHNpemUuaGVpZ2h0ID0gZWxlbS5vZmZzZXRIZWlnaHQ7XG5cbiAgdmFyIGlzQm9yZGVyQm94ID0gc2l6ZS5pc0JvcmRlckJveCA9IHN0eWxlLmJveFNpemluZyA9PSAnYm9yZGVyLWJveCc7XG5cbiAgLy8gZ2V0IGFsbCBtZWFzdXJlbWVudHNcbiAgZm9yICggdmFyIGk9MDsgaSA8IG1lYXN1cmVtZW50c0xlbmd0aDsgaSsrICkge1xuICAgIHZhciBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1tpXTtcbiAgICB2YXIgdmFsdWUgPSBzdHlsZVsgbWVhc3VyZW1lbnQgXTtcbiAgICB2YXIgbnVtID0gcGFyc2VGbG9hdCggdmFsdWUgKTtcbiAgICAvLyBhbnkgJ2F1dG8nLCAnbWVkaXVtJyB2YWx1ZSB3aWxsIGJlIDBcbiAgICBzaXplWyBtZWFzdXJlbWVudCBdID0gIWlzTmFOKCBudW0gKSA/IG51bSA6IDA7XG4gIH1cblxuICB2YXIgcGFkZGluZ1dpZHRoID0gc2l6ZS5wYWRkaW5nTGVmdCArIHNpemUucGFkZGluZ1JpZ2h0O1xuICB2YXIgcGFkZGluZ0hlaWdodCA9IHNpemUucGFkZGluZ1RvcCArIHNpemUucGFkZGluZ0JvdHRvbTtcbiAgdmFyIG1hcmdpbldpZHRoID0gc2l6ZS5tYXJnaW5MZWZ0ICsgc2l6ZS5tYXJnaW5SaWdodDtcbiAgdmFyIG1hcmdpbkhlaWdodCA9IHNpemUubWFyZ2luVG9wICsgc2l6ZS5tYXJnaW5Cb3R0b207XG4gIHZhciBib3JkZXJXaWR0aCA9IHNpemUuYm9yZGVyTGVmdFdpZHRoICsgc2l6ZS5ib3JkZXJSaWdodFdpZHRoO1xuICB2YXIgYm9yZGVySGVpZ2h0ID0gc2l6ZS5ib3JkZXJUb3BXaWR0aCArIHNpemUuYm9yZGVyQm90dG9tV2lkdGg7XG5cbiAgdmFyIGlzQm9yZGVyQm94U2l6ZU91dGVyID0gaXNCb3JkZXJCb3ggJiYgaXNCb3hTaXplT3V0ZXI7XG5cbiAgLy8gb3ZlcndyaXRlIHdpZHRoIGFuZCBoZWlnaHQgaWYgd2UgY2FuIGdldCBpdCBmcm9tIHN0eWxlXG4gIHZhciBzdHlsZVdpZHRoID0gZ2V0U3R5bGVTaXplKCBzdHlsZS53aWR0aCApO1xuICBpZiAoIHN0eWxlV2lkdGggIT09IGZhbHNlICkge1xuICAgIHNpemUud2lkdGggPSBzdHlsZVdpZHRoICtcbiAgICAgIC8vIGFkZCBwYWRkaW5nIGFuZCBib3JkZXIgdW5sZXNzIGl0J3MgYWxyZWFkeSBpbmNsdWRpbmcgaXRcbiAgICAgICggaXNCb3JkZXJCb3hTaXplT3V0ZXIgPyAwIDogcGFkZGluZ1dpZHRoICsgYm9yZGVyV2lkdGggKTtcbiAgfVxuXG4gIHZhciBzdHlsZUhlaWdodCA9IGdldFN0eWxlU2l6ZSggc3R5bGUuaGVpZ2h0ICk7XG4gIGlmICggc3R5bGVIZWlnaHQgIT09IGZhbHNlICkge1xuICAgIHNpemUuaGVpZ2h0ID0gc3R5bGVIZWlnaHQgK1xuICAgICAgLy8gYWRkIHBhZGRpbmcgYW5kIGJvcmRlciB1bmxlc3MgaXQncyBhbHJlYWR5IGluY2x1ZGluZyBpdFxuICAgICAgKCBpc0JvcmRlckJveFNpemVPdXRlciA/IDAgOiBwYWRkaW5nSGVpZ2h0ICsgYm9yZGVySGVpZ2h0ICk7XG4gIH1cblxuICBzaXplLmlubmVyV2lkdGggPSBzaXplLndpZHRoIC0gKCBwYWRkaW5nV2lkdGggKyBib3JkZXJXaWR0aCApO1xuICBzaXplLmlubmVySGVpZ2h0ID0gc2l6ZS5oZWlnaHQgLSAoIHBhZGRpbmdIZWlnaHQgKyBib3JkZXJIZWlnaHQgKTtcblxuICBzaXplLm91dGVyV2lkdGggPSBzaXplLndpZHRoICsgbWFyZ2luV2lkdGg7XG4gIHNpemUub3V0ZXJIZWlnaHQgPSBzaXplLmhlaWdodCArIG1hcmdpbkhlaWdodDtcblxuICByZXR1cm4gc2l6ZTtcbn1cblxucmV0dXJuIGdldFNpemU7XG5cbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQSxXQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/get-size/get-size.js\n");

/***/ }),

/***/ "./node_modules/sigma/build/sigma.require.js":
/*!***************************************************!*\
  !*** ./node_modules/sigma/build/sigma.require.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";(function(undefined) {\n  'use strict';\n\n  var __instances = {};\n\n  /**\n   * This is the sigma instances constructor. One instance of sigma represent\n   * one graph. It is possible to represent this grap with several renderers\n   * at the same time. By default, the default renderer (WebGL + Canvas\n   * polyfill) will be used as the only renderer, with the container specified\n   * in the configuration.\n   *\n   * @param  {?*}    conf The configuration of the instance. There are a lot of\n   *                      different recognized forms to instantiate sigma, check\n   *                      example files, documentation in this file and unit\n   *                      tests to know more.\n   * @return {sigma}      The fresh new sigma instance.\n   *\n   * Instanciating sigma:\n   * ********************\n   * If no parameter is given to the constructor, the instance will be created\n   * without any renderer or camera. It will just instantiate the graph, and\n   * other modules will have to be instantiated through the public methods,\n   * like \"addRenderer\" etc:\n   *\n   *  > s0 = new sigma();\n   *  > s0.addRenderer({\n   *  >   type: 'canvas',\n   *  >   container: 'my-container-id'\n   *  > });\n   *\n   * In most of the cases, sigma will simply be used with the default renderer.\n   * Then, since the only required parameter is the DOM container, there are\n   * some simpler way to call the constructor. The four following calls do the\n   * exact same things:\n   *\n   *  > s1 = new sigma('my-container-id');\n   *  > s2 = new sigma(document.getElementById('my-container-id'));\n   *  > s3 = new sigma({\n   *  >   container: document.getElementById('my-container-id')\n   *  > });\n   *  > s4 = new sigma({\n   *  >   renderers: [{\n   *  >     container: document.getElementById('my-container-id')\n   *  >   }]\n   *  > });\n   *\n   * Recognized parameters:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters, when calling the\n   * constructor with to top level configuration object (fourth case in the\n   * previous examples):\n   *\n   *   {?string} id        The id of the instance. It will be generated\n   *                       automatically if not specified.\n   *   {?array}  renderers An array containing objects describing renderers.\n   *   {?object} graph     An object containing an array of nodes and an array\n   *                       of edges, to avoid having to add them by hand later.\n   *   {?object} settings  An object containing instance specific settings that\n   *                       will override the default ones defined in the object\n   *                       sigma.settings.\n   */\n  var sigma = function(conf) {\n    // Local variables:\n    // ****************\n    var i,\n        l,\n        a,\n        c,\n        o,\n        id;\n\n    sigma.classes.dispatcher.extend(this);\n\n    // Private attributes:\n    // *******************\n    var _self = this,\n        _conf = conf || {};\n\n    // Little shortcut:\n    // ****************\n    // The configuration is supposed to have a list of the configuration\n    // objects for each renderer.\n    //  - If there are no configuration at all, then nothing is done.\n    //  - If there are no renderer list, the given configuration object will be\n    //    considered as describing the first and only renderer.\n    //  - If there are no renderer list nor \"container\" object, it will be\n    //    considered as the container itself (a DOM element).\n    //  - If the argument passed to sigma() is a string, it will be considered\n    //    as the ID of the DOM container.\n    if (\n      typeof _conf === 'string' ||\n      _conf instanceof HTMLElement\n    )\n      _conf = {\n        renderers: [_conf]\n      };\n    else if (Object.prototype.toString.call(_conf) === '[object Array]')\n      _conf = {\n        renderers: _conf\n      };\n\n    // Also check \"renderer\" and \"container\" keys:\n    o = _conf.renderers || _conf.renderer || _conf.container;\n    if (!_conf.renderers || _conf.renderers.length === 0)\n      if (\n        typeof o === 'string' ||\n        o instanceof HTMLElement ||\n        (typeof o === 'object' && 'container' in o)\n      )\n        _conf.renderers = [o];\n\n    // Recense the instance:\n    if (_conf.id) {\n      if (__instances[_conf.id])\n        throw 'sigma: Instance \"' + _conf.id + '\" already exists.';\n      Object.defineProperty(this, 'id', {\n        value: _conf.id\n      });\n    } else {\n      id = 0;\n      while (__instances[id])\n        id++;\n      Object.defineProperty(this, 'id', {\n        value: '' + id\n      });\n    }\n    __instances[this.id] = this;\n\n    // Initialize settings function:\n    this.settings = new sigma.classes.configurable(\n      sigma.settings,\n      _conf.settings || {}\n    );\n\n    // Initialize locked attributes:\n    Object.defineProperty(this, 'graph', {\n      value: new sigma.classes.graph(this.settings),\n      configurable: true\n    });\n    Object.defineProperty(this, 'middlewares', {\n      value: [],\n      configurable: true\n    });\n    Object.defineProperty(this, 'cameras', {\n      value: {},\n      configurable: true\n    });\n    Object.defineProperty(this, 'renderers', {\n      value: {},\n      configurable: true\n    });\n    Object.defineProperty(this, 'renderersPerCamera', {\n      value: {},\n      configurable: true\n    });\n    Object.defineProperty(this, 'cameraFrames', {\n      value: {},\n      configurable: true\n    });\n    Object.defineProperty(this, 'camera', {\n      get: function() {\n        return this.cameras[0];\n      }\n    });\n    Object.defineProperty(this, 'events', {\n      value: [\n        'click',\n        'rightClick',\n        'clickStage',\n        'doubleClickStage',\n        'rightClickStage',\n        'clickNode',\n        'clickNodes',\n        'doubleClickNode',\n        'doubleClickNodes',\n        'rightClickNode',\n        'rightClickNodes',\n        'overNode',\n        'overNodes',\n        'outNode',\n        'outNodes',\n        'downNode',\n        'downNodes',\n        'upNode',\n        'upNodes'\n      ],\n      configurable: true\n    });\n\n    // Add a custom handler, to redispatch events from renderers:\n    this._handler = (function(e) {\n      var k,\n          data = {};\n\n      for (k in e.data)\n        data[k] = e.data[k];\n\n      data.renderer = e.target;\n      this.dispatchEvent(e.type, data);\n    }).bind(this);\n\n    // Initialize renderers:\n    a = _conf.renderers || [];\n    for (i = 0, l = a.length; i < l; i++)\n      this.addRenderer(a[i]);\n\n    // Initialize middlewares:\n    a = _conf.middlewares || [];\n    for (i = 0, l = a.length; i < l; i++)\n      this.middlewares.push(\n        typeof a[i] === 'string' ?\n          sigma.middlewares[a[i]] :\n          a[i]\n      );\n\n    // Check if there is already a graph to fill in:\n    if (typeof _conf.graph === 'object' && _conf.graph) {\n      this.graph.read(_conf.graph);\n\n      // If a graph is given to the to the instance, the \"refresh\" method is\n      // directly called:\n      this.refresh();\n    }\n\n    // Deal with resize:\n    window.addEventListener('resize', function() {\n      if (_self.settings)\n        _self.refresh();\n    });\n  };\n\n\n\n\n  /**\n   * This methods will instantiate and reference a new camera. If no id is\n   * specified, then an automatic id will be generated.\n   *\n   * @param  {?string}              id Eventually the camera id.\n   * @return {sigma.classes.camera}    The fresh new camera instance.\n   */\n  sigma.prototype.addCamera = function(id) {\n    var self = this,\n        camera;\n\n    if (!arguments.length) {\n      id = 0;\n      while (this.cameras['' + id])\n        id++;\n      id = '' + id;\n    }\n\n    if (this.cameras[id])\n      throw 'sigma.addCamera: The camera \"' + id + '\" already exists.';\n\n    camera = new sigma.classes.camera(id, this.graph, this.settings);\n    this.cameras[id] = camera;\n\n    // Add a quadtree to the camera:\n    camera.quadtree = new sigma.classes.quad();\n\n    // Add an edgequadtree to the camera:\n    if (sigma.classes.edgequad !== undefined) {\n      camera.edgequadtree = new sigma.classes.edgequad();\n    }\n\n    camera.bind('coordinatesUpdated', function(e) {\n      self.renderCamera(camera, camera.isAnimated);\n    });\n\n    this.renderersPerCamera[id] = [];\n\n    return camera;\n  };\n\n  /**\n   * This method kills a camera, and every renderer attached to it.\n   *\n   * @param  {string|camera} v The camera to kill or its ID.\n   * @return {sigma}           Returns the instance.\n   */\n  sigma.prototype.killCamera = function(v) {\n    v = typeof v === 'string' ? this.cameras[v] : v;\n\n    if (!v)\n      throw 'sigma.killCamera: The camera is undefined.';\n\n    var i,\n        l,\n        a = this.renderersPerCamera[v.id];\n\n    for (l = a.length, i = l - 1; i >= 0; i--)\n      this.killRenderer(a[i]);\n\n    delete this.renderersPerCamera[v.id];\n    delete this.cameraFrames[v.id];\n    delete this.cameras[v.id];\n\n    if (v.kill)\n      v.kill();\n\n    return this;\n  };\n\n  /**\n   * This methods will instantiate and reference a new renderer. The \"type\"\n   * argument can be the constructor or its name in the \"sigma.renderers\"\n   * package. If no type is specified, then \"sigma.renderers.def\" will be used.\n   * If no id is specified, then an automatic id will be generated.\n   *\n   * @param  {?object}  options Eventually some options to give to the renderer\n   *                            constructor.\n   * @return {renderer}         The fresh new renderer instance.\n   *\n   * Recognized parameters:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters in the \"options\"\n   * object:\n   *\n   *   {?string}            id     Eventually the renderer id.\n   *   {?(function|string)} type   Eventually the renderer constructor or its\n   *                               name in the \"sigma.renderers\" package.\n   *   {?(camera|string)}   camera Eventually the renderer camera or its\n   *                               id.\n   */\n  sigma.prototype.addRenderer = function(options) {\n    var id,\n        fn,\n        camera,\n        renderer,\n        o = options || {};\n\n    // Polymorphism:\n    if (typeof o === 'string')\n      o = {\n        container: document.getElementById(o)\n      };\n    else if (o instanceof HTMLElement)\n      o = {\n        container: o\n      };\n\n    // If the container still is a string, we get it by id\n    if (typeof o.container === 'string')\n      o.container = document.getElementById(o.container);\n\n    // Reference the new renderer:\n    if (!('id' in o)) {\n      id = 0;\n      while (this.renderers['' + id])\n        id++;\n      id = '' + id;\n    } else\n      id = o.id;\n\n    if (this.renderers[id])\n      throw 'sigma.addRenderer: The renderer \"' + id + '\" already exists.';\n\n    // Find the good constructor:\n    fn = typeof o.type === 'function' ? o.type : sigma.renderers[o.type];\n    fn = fn || sigma.renderers.def;\n\n    // Find the good camera:\n    camera = 'camera' in o ?\n      (\n        o.camera instanceof sigma.classes.camera ?\n          o.camera :\n          this.cameras[o.camera] || this.addCamera(o.camera)\n      ) :\n      this.addCamera();\n\n    if (this.cameras[camera.id] !== camera)\n      throw 'sigma.addRenderer: The camera is not properly referenced.';\n\n    // Instantiate:\n    renderer = new fn(this.graph, camera, this.settings, o);\n    this.renderers[id] = renderer;\n    Object.defineProperty(renderer, 'id', {\n      value: id\n    });\n\n    // Bind events:\n    if (renderer.bind)\n      renderer.bind(\n        [\n          'click',\n          'rightClick',\n          'clickStage',\n          'doubleClickStage',\n          'rightClickStage',\n          'clickNode',\n          'clickNodes',\n          'clickEdge',\n          'clickEdges',\n          'doubleClickNode',\n          'doubleClickNodes',\n          'doubleClickEdge',\n          'doubleClickEdges',\n          'rightClickNode',\n          'rightClickNodes',\n          'rightClickEdge',\n          'rightClickEdges',\n          'overNode',\n          'overNodes',\n          'overEdge',\n          'overEdges',\n          'outNode',\n          'outNodes',\n          'outEdge',\n          'outEdges',\n          'downNode',\n          'downNodes',\n          'downEdge',\n          'downEdges',\n          'upNode',\n          'upNodes',\n          'upEdge',\n          'upEdges'\n        ],\n        this._handler\n      );\n\n    // Reference the renderer by its camera:\n    this.renderersPerCamera[camera.id].push(renderer);\n\n    return renderer;\n  };\n\n  /**\n   * This method kills a renderer.\n   *\n   * @param  {string|renderer} v The renderer to kill or its ID.\n   * @return {sigma}             Returns the instance.\n   */\n  sigma.prototype.killRenderer = function(v) {\n    v = typeof v === 'string' ? this.renderers[v] : v;\n\n    if (!v)\n      throw 'sigma.killRenderer: The renderer is undefined.';\n\n    var a = this.renderersPerCamera[v.camera.id],\n        i = a.indexOf(v);\n\n    if (i >= 0)\n      a.splice(i, 1);\n\n    if (v.kill)\n      v.kill();\n\n    delete this.renderers[v.id];\n\n    return this;\n  };\n\n\n\n\n  /**\n   * This method calls the \"render\" method of each renderer, with the same\n   * arguments than the \"render\" method, but will also check if the renderer\n   * has a \"process\" method, and call it if it exists.\n   *\n   * It is useful for quadtrees or WebGL processing, for instance.\n   *\n   * @param  {?object}  options Eventually some options to give to the refresh\n   *                            method.\n   * @return {sigma}            Returns the instance itself.\n   *\n   * Recognized parameters:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters in the \"options\"\n   * object:\n   *\n   *   {?boolean} skipIndexation A flag specifying wether or not the refresh\n   *                             function should reindex the graph in the\n   *                             quadtrees or not (default: false).\n   */\n  sigma.prototype.refresh = function(options) {\n    var i,\n        l,\n        k,\n        a,\n        c,\n        bounds,\n        prefix = 0;\n\n    options = options || {};\n\n    // Call each middleware:\n    a = this.middlewares || [];\n    for (i = 0, l = a.length; i < l; i++)\n      a[i].call(\n        this,\n        (i === 0) ? '' : 'tmp' + prefix + ':',\n        (i === l - 1) ? 'ready:' : ('tmp' + (++prefix) + ':')\n      );\n\n    // Then, for each camera, call the \"rescale\" middleware, unless the\n    // settings specify not to:\n    for (k in this.cameras) {\n      c = this.cameras[k];\n      if (\n        c.settings('autoRescale') &&\n        this.renderersPerCamera[c.id] &&\n        this.renderersPerCamera[c.id].length\n      )\n        sigma.middlewares.rescale.call(\n          this,\n          a.length ? 'ready:' : '',\n          c.readPrefix,\n          {\n            width: this.renderersPerCamera[c.id][0].width,\n            height: this.renderersPerCamera[c.id][0].height\n          }\n        );\n      else\n        sigma.middlewares.copy.call(\n          this,\n          a.length ? 'ready:' : '',\n          c.readPrefix\n        );\n\n      if (!options.skipIndexation) {\n        // Find graph boundaries:\n        bounds = sigma.utils.getBoundaries(\n          this.graph,\n          c.readPrefix\n        );\n\n        // Refresh quadtree:\n        c.quadtree.index(this.graph.nodes(), {\n          prefix: c.readPrefix,\n          bounds: {\n            x: bounds.minX,\n            y: bounds.minY,\n            width: bounds.maxX - bounds.minX,\n            height: bounds.maxY - bounds.minY\n          }\n        });\n\n        // Refresh edgequadtree:\n        if (\n          c.edgequadtree !== undefined &&\n          c.settings('drawEdges') &&\n          c.settings('enableEdgeHovering')\n        ) {\n          c.edgequadtree.index(this.graph, {\n            prefix: c.readPrefix,\n            bounds: {\n              x: bounds.minX,\n              y: bounds.minY,\n              width: bounds.maxX - bounds.minX,\n              height: bounds.maxY - bounds.minY\n            }\n          });\n        }\n      }\n    }\n\n    // Call each renderer:\n    a = Object.keys(this.renderers);\n    for (i = 0, l = a.length; i < l; i++)\n      if (this.renderers[a[i]].process) {\n        if (this.settings('skipErrors'))\n          try {\n            this.renderers[a[i]].process();\n          } catch (e) {\n            console.log(\n              'Warning: The renderer \"' + a[i] + '\" crashed on \".process()\"'\n            );\n          }\n        else\n          this.renderers[a[i]].process();\n      }\n\n    this.render();\n\n    return this;\n  };\n\n  /**\n   * This method calls the \"render\" method of each renderer.\n   *\n   * @return {sigma} Returns the instance itself.\n   */\n  sigma.prototype.render = function() {\n    var i,\n        l,\n        a,\n        prefix = 0;\n\n    // Call each renderer:\n    a = Object.keys(this.renderers);\n    for (i = 0, l = a.length; i < l; i++)\n      if (this.settings('skipErrors'))\n        try {\n          this.renderers[a[i]].render();\n        } catch (e) {\n          if (this.settings('verbose'))\n            console.log(\n              'Warning: The renderer \"' + a[i] + '\" crashed on \".render()\"'\n            );\n        }\n      else\n        this.renderers[a[i]].render();\n\n    return this;\n  };\n\n  /**\n   * This method calls the \"render\" method of each renderer that is bound to\n   * the specified camera. To improve the performances, if this method is\n   * called too often, the number of effective renderings is limitated to one\n   * per frame, unless you are using the \"force\" flag.\n   *\n   * @param  {sigma.classes.camera} camera The camera to render.\n   * @param  {?boolean}             force  If true, will render the camera\n   *                                       directly.\n   * @return {sigma}                       Returns the instance itself.\n   */\n  sigma.prototype.renderCamera = function(camera, force) {\n    var i,\n        l,\n        a,\n        self = this;\n\n    if (force) {\n      a = this.renderersPerCamera[camera.id];\n      for (i = 0, l = a.length; i < l; i++)\n        if (this.settings('skipErrors'))\n          try {\n            a[i].render();\n          } catch (e) {\n            if (this.settings('verbose'))\n              console.log(\n                'Warning: The renderer \"' + a[i].id + '\" crashed on \".render()\"'\n              );\n          }\n        else\n          a[i].render();\n    } else {\n      if (!this.cameraFrames[camera.id]) {\n        a = this.renderersPerCamera[camera.id];\n        for (i = 0, l = a.length; i < l; i++)\n          if (this.settings('skipErrors'))\n            try {\n              a[i].render();\n            } catch (e) {\n              if (this.settings('verbose'))\n                console.log(\n                  'Warning: The renderer \"' +\n                    a[i].id +\n                    '\" crashed on \".render()\"'\n                );\n            }\n          else\n            a[i].render();\n\n        this.cameraFrames[camera.id] = requestAnimationFrame(function() {\n          delete self.cameraFrames[camera.id];\n        });\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * This method calls the \"kill\" method of each module and destroys any\n   * reference from the instance.\n   */\n  sigma.prototype.kill = function() {\n    var k;\n\n    // Dispatching event\n    this.dispatchEvent('kill');\n\n    // Kill graph:\n    this.graph.kill();\n\n    // Kill middlewares:\n    delete this.middlewares;\n\n    // Kill each renderer:\n    for (k in this.renderers)\n      this.killRenderer(this.renderers[k]);\n\n    // Kill each camera:\n    for (k in this.cameras)\n      this.killCamera(this.cameras[k]);\n\n    delete this.renderers;\n    delete this.cameras;\n\n    // Kill everything else:\n    for (k in this)\n      if (this.hasOwnProperty(k))\n        delete this[k];\n\n    delete __instances[this.id];\n  };\n\n\n\n\n  /**\n   * Returns a clone of the instances object or a specific running instance.\n   *\n   * @param  {?string} id Eventually an instance ID.\n   * @return {object}     The related instance or a clone of the instances\n   *                      object.\n   */\n  sigma.instances = function(id) {\n    return arguments.length ?\n      __instances[id] :\n      sigma.utils.extend({}, __instances);\n  };\n\n\n\n  /**\n   * The current version of sigma:\n   */\n  sigma.version = '1.2.1';\n\n\n\n\n  /**\n   * EXPORT:\n   * *******\n   */\n  if (typeof this.sigma !== 'undefined')\n    throw 'An object called sigma is already in the global scope.';\n\n  this.sigma = sigma;\n\n}).call(this);\n\n/**\n * conrad.js is a tiny JavaScript jobs scheduler,\n *\n * Version: 0.1.0\n * Sources: http://github.com/jacomyal/conrad.js\n * Doc:     http://github.com/jacomyal/conrad.js#readme\n *\n * License:\n * --------\n * Copyright  2013 Alexis Jacomy, Sciences-Po mdialab\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * The Software is provided \"as is\", without warranty of any kind, express or\n * implied, including but not limited to the warranties of merchantability,\n * fitness for a particular purpose and noninfringement. In no event shall the\n * authors or copyright holders be liable for any claim, damages or other\n * liability, whether in an action of contract, tort or otherwise, arising\n * from, out of or in connection with the software or the use or other dealings\n * in the Software.\n */\n(function(global) {\n  'use strict';\n\n  // Check that conrad.js has not been loaded yet:\n  if (global.conrad)\n    throw new Error('conrad already exists');\n\n\n  /**\n   * PRIVATE VARIABLES:\n   * ******************\n   */\n\n  /**\n   * A flag indicating whether conrad is running or not.\n   *\n   * @type {Number}\n   */\n  var _lastFrameTime;\n\n  /**\n   * A flag indicating whether conrad is running or not.\n   *\n   * @type {Boolean}\n   */\n  var _isRunning = false;\n\n  /**\n   * The hash of registered jobs. Each job must at least have a unique ID\n   * under the key \"id\" and a function under the key \"job\". This hash\n   * contains each running job and each waiting job.\n   *\n   * @type {Object}\n   */\n  var _jobs = {};\n\n  /**\n   * The hash of currently running jobs.\n   *\n   * @type {Object}\n   */\n  var _runningJobs = {};\n\n  /**\n   * The array of currently running jobs, sorted by priority.\n   *\n   * @type {Array}\n   */\n  var _sortedByPriorityJobs = [];\n\n  /**\n   * The array of currently waiting jobs.\n   *\n   * @type {Object}\n   */\n  var _waitingJobs = {};\n\n  /**\n   * The array of finished jobs. They are stored in an array, since two jobs\n   * with the same \"id\" can happen at two different times.\n   *\n   * @type {Array}\n   */\n  var _doneJobs = [];\n\n  /**\n   * A dirty flag to keep conrad from starting: Indeed, when addJob() is called\n   * with several jobs, conrad must be started only at the end. This flag keeps\n   * me from duplicating the code that effectively adds a job.\n   *\n   * @type {Boolean}\n   */\n  var _noStart = false;\n\n  /**\n   * An hash containing some global settings about how conrad.js should\n   * behave.\n   *\n   * @type {Object}\n   */\n  var _parameters = {\n    frameDuration: 20,\n    history: true\n  };\n\n  /**\n   * This object contains every handlers bound to conrad events. It does not\n   * requirea any DOM implementation, since the events are all JavaScript.\n   *\n   * @type {Object}\n   */\n  var _handlers = Object.create(null);\n\n\n  /**\n   * PRIVATE FUNCTIONS:\n   * ******************\n   */\n\n  /**\n   * Will execute the handler everytime that the indicated event (or the\n   * indicated events) will be triggered.\n   *\n   * @param  {string|array|object} events  The name of the event (or the events\n   *                                       separated by spaces).\n   * @param  {function(Object)}    handler The handler to bind.\n   * @return {Object}                      Returns conrad.\n   */\n  function _bind(events, handler) {\n    var i,\n        i_end,\n        event,\n        eArray;\n\n    if (!arguments.length)\n      return;\n    else if (\n      arguments.length === 1 &&\n      Object(arguments[0]) === arguments[0]\n    )\n      for (events in arguments[0])\n        _bind(events, arguments[0][events]);\n    else if (arguments.length > 1) {\n      eArray =\n        Array.isArray(events) ?\n          events :\n          events.split(/ /);\n\n      for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {\n        event = eArray[i];\n\n        if (!_handlers[event])\n          _handlers[event] = [];\n\n        // Using an object instead of directly the handler will make possible\n        // later to add flags\n        _handlers[event].push({\n          handler: handler\n        });\n      }\n    }\n  }\n\n  /**\n   * Removes the handler from a specified event (or specified events).\n   *\n   * @param  {?string}           events  The name of the event (or the events\n   *                                     separated by spaces). If undefined,\n   *                                     then all handlers are removed.\n   * @param  {?function(Object)} handler The handler to unbind. If undefined,\n   *                                     each handler bound to the event or the\n   *                                     events will be removed.\n   * @return {Object}            Returns conrad.\n   */\n  function _unbind(events, handler) {\n    var i,\n        i_end,\n        j,\n        j_end,\n        a,\n        event,\n        eArray = Array.isArray(events) ?\n                   events :\n                   events.split(/ /);\n\n    if (!arguments.length)\n      _handlers = Object.create(null);\n    else if (handler) {\n      for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {\n        event = eArray[i];\n        if (_handlers[event]) {\n          a = [];\n          for (j = 0, j_end = _handlers[event].length; j !== j_end; j += 1)\n            if (_handlers[event][j].handler !== handler)\n              a.push(_handlers[event][j]);\n\n          _handlers[event] = a;\n        }\n\n        if (_handlers[event] && _handlers[event].length === 0)\n          delete _handlers[event];\n      }\n    } else\n      for (i = 0, i_end = eArray.length; i !== i_end; i += 1)\n        delete _handlers[eArray[i]];\n  }\n\n  /**\n   * Executes each handler bound to the event.\n   *\n   * @param  {string}  events The name of the event (or the events separated\n   *                          by spaces).\n   * @param  {?Object} data   The content of the event (optional).\n   * @return {Object}         Returns conrad.\n   */\n  function _dispatch(events, data) {\n    var i,\n        j,\n        i_end,\n        j_end,\n        event,\n        eventName,\n        eArray = Array.isArray(events) ?\n                   events :\n                   events.split(/ /);\n\n    data = data === undefined ? {} : data;\n\n    for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {\n      eventName = eArray[i];\n\n      if (_handlers[eventName]) {\n        event = {\n          type: eventName,\n          data: data || {}\n        };\n\n        for (j = 0, j_end = _handlers[eventName].length; j !== j_end; j += 1)\n          try {\n            _handlers[eventName][j].handler(event);\n          } catch (e) {}\n      }\n    }\n  }\n\n  /**\n   * Executes the most prioritary job once, and deals with filling the stats\n   * (done, time, averageTime, currentTime, etc...).\n   *\n   * @return {?Object} Returns the job object if it has to be killed, null else.\n   */\n  function _executeFirstJob() {\n    var i,\n        l,\n        test,\n        kill,\n        pushed = false,\n        time = __dateNow(),\n        job = _sortedByPriorityJobs.shift();\n\n    // Execute the job and look at the result:\n    test = job.job();\n\n    // Deal with stats:\n    time = __dateNow() - time;\n    job.done++;\n    job.time += time;\n    job.currentTime += time;\n    job.weightTime = job.currentTime / (job.weight || 1);\n    job.averageTime = job.time / job.done;\n\n    // Check if the job has to be killed:\n    kill = job.count ? (job.count <= job.done) : !test;\n\n    // Reset priorities:\n    if (!kill) {\n      for (i = 0, l = _sortedByPriorityJobs.length; i < l; i++)\n        if (_sortedByPriorityJobs[i].weightTime > job.weightTime) {\n          _sortedByPriorityJobs.splice(i, 0, job);\n          pushed = true;\n          break;\n        }\n\n      if (!pushed)\n        _sortedByPriorityJobs.push(job);\n    }\n\n    return kill ? job : null;\n  }\n\n  /**\n   * Activates a job, by adding it to the _runningJobs object and the\n   * _sortedByPriorityJobs array. It also initializes its currentTime value.\n   *\n   * @param  {Object} job The job to activate.\n   */\n  function _activateJob(job) {\n    var l = _sortedByPriorityJobs.length;\n\n    // Add the job to the running jobs:\n    _runningJobs[job.id] = job;\n    job.status = 'running';\n\n    // Add the job to the priorities:\n    if (l) {\n      job.weightTime = _sortedByPriorityJobs[l - 1].weightTime;\n      job.currentTime = job.weightTime * (job.weight || 1);\n    }\n\n    // Initialize the job and dispatch:\n    job.startTime = __dateNow();\n    _dispatch('jobStarted', __clone(job));\n\n    _sortedByPriorityJobs.push(job);\n  }\n\n  /**\n   * The main loop of conrad.js:\n   *  . It executes job such that they all occupate the same processing time.\n   *  . It stops jobs that do not need to be executed anymore.\n   *  . It triggers callbacks when it is relevant.\n   *  . It starts waiting jobs when they need to be started.\n   *  . It injects frames to keep a constant frapes per second ratio.\n   *  . It stops itself when there are no more jobs to execute.\n   */\n  function _loop() {\n    var k,\n        o,\n        l,\n        job,\n        time,\n        deadJob;\n\n    // Deal with the newly added jobs (the _jobs object):\n    for (k in _jobs) {\n      job = _jobs[k];\n\n      if (job.after)\n        _waitingJobs[k] = job;\n      else\n        _activateJob(job);\n\n      delete _jobs[k];\n    }\n\n    // Set the _isRunning flag to false if there are no running job:\n    _isRunning = !!_sortedByPriorityJobs.length;\n\n    // Deal with the running jobs (the _runningJobs object):\n    while (\n      _sortedByPriorityJobs.length &&\n      __dateNow() - _lastFrameTime < _parameters.frameDuration\n    ) {\n      deadJob = _executeFirstJob();\n\n      // Deal with the case where the job has ended:\n      if (deadJob) {\n        _killJob(deadJob.id);\n\n        // Check for waiting jobs:\n        for (k in _waitingJobs)\n          if (_waitingJobs[k].after === deadJob.id) {\n            _activateJob(_waitingJobs[k]);\n            delete _waitingJobs[k];\n          }\n      }\n    }\n\n    // Check if conrad still has jobs to deal with, and kill it if not:\n    if (_isRunning) {\n      // Update the _lastFrameTime:\n      _lastFrameTime = __dateNow();\n\n      _dispatch('enterFrame');\n      setTimeout(_loop, 0);\n    } else\n      _dispatch('stop');\n  }\n\n  /**\n   * Adds one or more jobs, and starts the loop if no job was running before. A\n   * job is at least a unique string \"id\" and a function, and there are some\n   * parameters that you can specify for each job to modify the way conrad will\n   * execute it. If a job is added with the \"id\" of another job that is waiting\n   * or still running, an error will be thrown.\n   *\n   * When a job is added, it is referenced in the _jobs object, by its id.\n   * Then, if it has to be executed right now, it will be also referenced in\n   * the _runningJobs object. If it has to wait, then it will be added into the\n   * _waitingJobs object, until it can start.\n   *\n   * Keep reading this documentation to see how to call this method.\n   *\n   * @return {Object} Returns conrad.\n   *\n   * Adding one job:\n   * ***************\n   * Basically, a job is defined by its string id and a function (the job). It\n   * is also possible to add some parameters:\n   *\n   *  > conrad.addJob('myJobId', myJobFunction);\n   *  > conrad.addJob('myJobId', {\n   *  >   job: myJobFunction,\n   *  >   someParameter: someValue\n   *  > });\n   *  > conrad.addJob({\n   *  >   id: 'myJobId',\n   *  >   job: myJobFunction,\n   *  >   someParameter: someValue\n   *  > });\n   *\n   * Adding several jobs:\n   * ********************\n   * When adding several jobs at the same time, it is possible to specify\n   * parameters for each one individually or for all:\n   *\n   *  > conrad.addJob([\n   *  >   {\n   *  >     id: 'myJobId1',\n   *  >     job: myJobFunction1,\n   *  >     someParameter1: someValue1\n   *  >   },\n   *  >   {\n   *  >     id: 'myJobId2',\n   *  >     job: myJobFunction2,\n   *  >     someParameter2: someValue2\n   *  >   }\n   *  > ], {\n   *  >   someCommonParameter: someCommonValue\n   *  > });\n   *  > conrad.addJob({\n   *  >   myJobId1: {,\n   *  >     job: myJobFunction1,\n   *  >     someParameter1: someValue1\n   *  >   },\n   *  >   myJobId2: {,\n   *  >     job: myJobFunction2,\n   *  >     someParameter2: someValue2\n   *  >   }\n   *  > }, {\n   *  >   someCommonParameter: someCommonValue\n   *  > });\n   *  > conrad.addJob({\n   *  >   myJobId1: myJobFunction1,\n   *  >   myJobId2: myJobFunction2\n   *  > }, {\n   *  >   someCommonParameter: someCommonValue\n   *  > });\n   *\n   *  Recognized parameters:\n   *  **********************\n   *  Here is the exhaustive list of every accepted parameters:\n   *\n   *    {?Function} end      A callback to execute when the job is ended. It is\n   *                         not executed if the job is killed instead of ended\n   *                         \"naturally\".\n   *    {?Integer}  count    The number of time the job has to be executed.\n   *    {?Number}   weight   If specified, the job will be executed as it was\n   *                         added \"weight\" times.\n   *    {?String}   after    The id of another job (eventually not added yet).\n   *                         If specified, this job will start only when the\n   *                         specified \"after\" job is ended.\n   */\n  function _addJob(v1, v2) {\n    var i,\n        l,\n        o;\n\n    // Array of jobs:\n    if (Array.isArray(v1)) {\n      // Keep conrad to start until the last job is added:\n      _noStart = true;\n\n      for (i = 0, l = v1.length; i < l; i++)\n        _addJob(v1[i].id, __extend(v1[i], v2));\n\n      _noStart = false;\n      if (!_isRunning) {\n        // Update the _lastFrameTime:\n        _lastFrameTime = __dateNow();\n\n        _dispatch('start');\n        _loop();\n      }\n    } else if (typeof v1 === 'object') {\n      // One job (object):\n      if (typeof v1.id === 'string')\n        _addJob(v1.id, v1);\n\n      // Hash of jobs:\n      else {\n        // Keep conrad to start until the last job is added:\n        _noStart = true;\n\n        for (i in v1)\n          if (typeof v1[i] === 'function')\n            _addJob(i, __extend({\n              job: v1[i]\n            }, v2));\n          else\n            _addJob(i, __extend(v1[i], v2));\n\n        _noStart = false;\n        if (!_isRunning) {\n          // Update the _lastFrameTime:\n          _lastFrameTime = __dateNow();\n\n          _dispatch('start');\n          _loop();\n        }\n      }\n\n    // One job (string, *):\n    } else if (typeof v1 === 'string') {\n      if (_hasJob(v1))\n        throw new Error(\n          '[conrad.addJob] Job with id \"' + v1 + '\" already exists.'\n        );\n\n      // One job (string, function):\n      if (typeof v2 === 'function') {\n        o = {\n          id: v1,\n          done: 0,\n          time: 0,\n          status: 'waiting',\n          currentTime: 0,\n          averageTime: 0,\n          weightTime: 0,\n          job: v2\n        };\n\n      // One job (string, object):\n      } else if (typeof v2 === 'object') {\n        o = __extend(\n          {\n            id: v1,\n            done: 0,\n            time: 0,\n            status: 'waiting',\n            currentTime: 0,\n            averageTime: 0,\n            weightTime: 0\n          },\n          v2\n        );\n\n      // If none of those cases, throw an error:\n      } else\n        throw new Error('[conrad.addJob] Wrong arguments.');\n\n      // Effectively add the job:\n      _jobs[v1] = o;\n      _dispatch('jobAdded', __clone(o));\n\n      // Check if the loop has to be started:\n      if (!_isRunning && !_noStart) {\n        // Update the _lastFrameTime:\n        _lastFrameTime = __dateNow();\n\n        _dispatch('start');\n        _loop();\n      }\n\n    // If none of those cases, throw an error:\n    } else\n      throw new Error('[conrad.addJob] Wrong arguments.');\n\n    return this;\n  }\n\n  /**\n   * Kills one or more jobs, indicated by their ids. It is only possible to\n   * kill running jobs or waiting jobs. If you try to kill a job that does not\n   * exist or that is already killed, a warning will be thrown.\n   *\n   * @param  {Array|String} v1 A string job id or an array of job ids.\n   * @return {Object}       Returns conrad.\n   */\n  function _killJob(v1) {\n    var i,\n        l,\n        k,\n        a,\n        job,\n        found = false;\n\n    // Array of job ids:\n    if (Array.isArray(v1))\n      for (i = 0, l = v1.length; i < l; i++)\n        _killJob(v1[i]);\n\n    // One job's id:\n    else if (typeof v1 === 'string') {\n      a = [_runningJobs, _waitingJobs, _jobs];\n\n      // Remove the job from the hashes:\n      for (i = 0, l = a.length; i < l; i++)\n        if (v1 in a[i]) {\n          job = a[i][v1];\n\n          if (_parameters.history) {\n            job.status = 'done';\n            _doneJobs.push(job);\n          }\n\n          _dispatch('jobEnded', __clone(job));\n          delete a[i][v1];\n\n          if (typeof job.end === 'function')\n            job.end();\n\n          found = true;\n        }\n\n      // Remove the priorities array:\n      a = _sortedByPriorityJobs;\n      for (i = 0, l = a.length; i < l; i++)\n        if (a[i].id === v1) {\n          a.splice(i, 1);\n          break;\n        }\n\n      if (!found)\n        throw new Error('[conrad.killJob] Job \"' + v1 + '\" not found.');\n\n    // If none of those cases, throw an error:\n    } else\n      throw new Error('[conrad.killJob] Wrong arguments.');\n\n    return this;\n  }\n\n  /**\n   * Kills every running, waiting, and just added jobs.\n   *\n   * @return {Object} Returns conrad.\n   */\n  function _killAll() {\n    var k,\n        jobs = __extend(_jobs, _runningJobs, _waitingJobs);\n\n    // Take every jobs and push them into the _doneJobs object:\n    if (_parameters.history)\n      for (k in jobs) {\n        jobs[k].status = 'done';\n        _doneJobs.push(jobs[k]);\n\n        if (typeof jobs[k].end === 'function')\n          jobs[k].end();\n      }\n\n    // Reinitialize the different jobs lists:\n    _jobs = {};\n    _waitingJobs = {};\n    _runningJobs = {};\n    _sortedByPriorityJobs = [];\n\n    // In case some jobs are added right after the kill:\n    _isRunning = false;\n\n    return this;\n  }\n\n  /**\n   * Returns true if a job with the specified id is currently running or\n   * waiting, and false else.\n   *\n   * @param  {String}  id The id of the job.\n   * @return {?Object} Returns the job object if it exists.\n   */\n  function _hasJob(id) {\n    var job = _jobs[id] || _runningJobs[id] || _waitingJobs[id];\n    return job ? __extend(job) : null;\n  }\n\n  /**\n   * This method will set the setting specified by \"v1\" to the value specified\n   * by \"v2\" if both are given, and else return the current value of the\n   * settings \"v1\".\n   *\n   * @param  {String}   v1 The name of the property.\n   * @param  {?*}       v2 Eventually, a value to set to the specified\n   *                       property.\n   * @return {Object|*} Returns the specified settings value if \"v2\" is not\n   *                    given, and conrad else.\n   */\n  function _settings(v1, v2) {\n    var o;\n\n    if (typeof a1 === 'string' && arguments.length === 1)\n      return _parameters[a1];\n    else {\n      o = (typeof a1 === 'object' && arguments.length === 1) ?\n        a1 || {} :\n        {};\n      if (typeof a1 === 'string')\n        o[a1] = a2;\n\n      for (var k in o)\n        if (o[k] !== undefined)\n          _parameters[k] = o[k];\n        else\n          delete _parameters[k];\n\n      return this;\n    }\n  }\n\n  /**\n   * Returns true if conrad is currently running, and false else.\n   *\n   * @return {Boolean} Returns _isRunning.\n   */\n  function _getIsRunning() {\n    return _isRunning;\n  }\n\n  /**\n   * Unreference every job that is stored in the _doneJobs object. It will\n   * not be possible anymore to get stats about these jobs, but it will release\n   * the memory.\n   *\n   * @return {Object} Returns conrad.\n   */\n  function _clearHistory() {\n    _doneJobs = [];\n    return this;\n  }\n\n  /**\n   * Returns a snapshot of every data about jobs that wait to be started, are\n   * currently running or are done.\n   *\n   * It is possible to get only running, waiting or done jobs by giving\n   * \"running\", \"waiting\" or \"done\" as fist argument.\n   *\n   * It is also possible to get every job with a specified id by giving it as\n   * first argument. Also, using a RegExp instead of an id will return every\n   * jobs whose ids match the RegExp. And these two last use cases work as well\n   * by giving before \"running\", \"waiting\" or \"done\".\n   *\n   * @return {Array} The array of the matching jobs.\n   *\n   * Some call examples:\n   * *******************\n   *  > conrad.getStats('running')\n   *  > conrad.getStats('waiting')\n   *  > conrad.getStats('done')\n   *  > conrad.getStats('myJob')\n   *  > conrad.getStats(/test/)\n   *  > conrad.getStats('running', 'myRunningJob')\n   *  > conrad.getStats('running', /test/)\n   */\n  function _getStats(v1, v2) {\n    var a,\n        k,\n        i,\n        l,\n        stats,\n        pattern,\n        isPatternString;\n\n    if (!arguments.length) {\n      stats = [];\n\n      for (k in _jobs)\n        stats.push(_jobs[k]);\n\n      for (k in _waitingJobs)\n        stats.push(_waitingJobs[k]);\n\n      for (k in _runningJobs)\n        stats.push(_runningJobs[k]);\n\n      stats = stats.concat(_doneJobs);\n    }\n\n    if (typeof v1 === 'string')\n      switch (v1) {\n        case 'waiting':\n          stats = __objectValues(_waitingJobs);\n          break;\n        case 'running':\n          stats = __objectValues(_runningJobs);\n          break;\n        case 'done':\n          stats = _doneJobs;\n          break;\n        default:\n          pattern = v1;\n      }\n\n    if (v1 instanceof RegExp)\n      pattern = v1;\n\n    if (!pattern && (typeof v2 === 'string' || v2 instanceof RegExp))\n      pattern = v2;\n\n    // Filter jobs if a pattern is given:\n    if (pattern) {\n      isPatternString = typeof pattern === 'string';\n\n      if (stats instanceof Array) {\n        a = stats;\n      } else if (typeof stats === 'object') {\n        a = [];\n\n        for (k in stats)\n          a = a.concat(stats[k]);\n      } else {\n        a = [];\n\n        for (k in _jobs)\n          a.push(_jobs[k]);\n\n        for (k in _waitingJobs)\n          a.push(_waitingJobs[k]);\n\n        for (k in _runningJobs)\n          a.push(_runningJobs[k]);\n\n        a = a.concat(_doneJobs);\n      }\n\n      stats = [];\n      for (i = 0, l = a.length; i < l; i++)\n        if (isPatternString ? a[i].id === pattern : a[i].id.match(pattern))\n          stats.push(a[i]);\n    }\n\n    return __clone(stats);\n  }\n\n\n  /**\n   * TOOLS FUNCTIONS:\n   * ****************\n   */\n\n  /**\n   * This function takes any number of objects as arguments, copies from each\n   * of these objects each pair key/value into a new object, and finally\n   * returns this object.\n   *\n   * The arguments are parsed from the last one to the first one, such that\n   * when two objects have keys in common, the \"earliest\" object wins.\n   *\n   * Example:\n   * ********\n   *  > var o1 = {\n   *  >       a: 1,\n   *  >       b: 2,\n   *  >       c: '3'\n   *  >     },\n   *  >     o2 = {\n   *  >       c: '4',\n   *  >       d: [ 5 ]\n   *  >     };\n   *  > __extend(o1, o2);\n   *  > // Returns: {\n   *  > //   a: 1,\n   *  > //   b: 2,\n   *  > //   c: '3',\n   *  > //   d: [ 5 ]\n   *  > // };\n   *\n   * @param  {Object+} Any number of objects.\n   * @return {Object}  The merged object.\n   */\n  function __extend() {\n    var i,\n        k,\n        res = {},\n        l = arguments.length;\n\n    for (i = l - 1; i >= 0; i--)\n      for (k in arguments[i])\n        res[k] = arguments[i][k];\n\n    return res;\n  }\n\n  /**\n   * This function simply clones an object. This object must contain only\n   * objects, arrays and immutable values. Since it is not public, it does not\n   * deal with cyclic references, DOM elements and instantiated objects - so\n   * use it carefully.\n   *\n   * @param  {Object} The object to clone.\n   * @return {Object} The clone.\n   */\n  function __clone(item) {\n    var result, i, k, l;\n\n    if (!item)\n      return item;\n\n    if (Array.isArray(item)) {\n      result = [];\n      for (i = 0, l = item.length; i < l; i++)\n        result.push(__clone(item[i]));\n    } else if (typeof item === 'object') {\n      result = {};\n      for (i in item)\n        result[i] = __clone(item[i]);\n    } else\n      result = item;\n\n    return result;\n  }\n\n  /**\n   * Returns an array containing the values of an object.\n   *\n   * @param  {Object} The object.\n   * @return {Array}  The array of values.\n   */\n  function __objectValues(o) {\n    var k,\n        a = [];\n\n    for (k in o)\n      a.push(o[k]);\n\n    return a;\n  }\n\n  /**\n   * A short \"Date.now()\" polyfill.\n   *\n   * @return {Number} The current time (in ms).\n   */\n  function __dateNow() {\n    return Date.now ? Date.now() : new Date().getTime();\n  }\n\n  /**\n   * Polyfill for the Array.isArray function:\n   */\n  if (!Array.isArray)\n    Array.isArray = function(v) {\n      return Object.prototype.toString.call(v) === '[object Array]';\n    };\n\n\n  /**\n   * EXPORT PUBLIC API:\n   * ******************\n   */\n  var conrad = {\n    hasJob: _hasJob,\n    addJob: _addJob,\n    killJob: _killJob,\n    killAll: _killAll,\n    settings: _settings,\n    getStats: _getStats,\n    isRunning: _getIsRunning,\n    clearHistory: _clearHistory,\n\n    // Events management:\n    bind: _bind,\n    unbind: _unbind,\n\n    // Version:\n    version: '0.1.0'\n  };\n\n  if (true) {\n    if ( true && module.exports)\n      exports = module.exports = conrad;\n    exports.conrad = conrad;\n  }\n  global.conrad = conrad;\n})(this);\n\n// Hardcoded export for the node.js version:\nvar sigma = this.sigma,\n    conrad = this.conrad;\n\nsigma.conrad = conrad;\n\n// Dirty polyfills to permit sigma usage in node\nif (typeof HTMLElement === 'undefined')\n  HTMLElement = function() {};\n\nif (typeof window === 'undefined')\n  window = {\n    addEventListener: function() {}\n  };\n\nif (true) {\n  if ( true && module.exports)\n    exports = module.exports = sigma;\n  exports.sigma = sigma;\n}\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  var _root = this;\n\n  // Initialize packages:\n  sigma.utils = sigma.utils || {};\n\n  /**\n   * MISC UTILS:\n   */\n  /**\n   * This function takes any number of objects as arguments, copies from each\n   * of these objects each pair key/value into a new object, and finally\n   * returns this object.\n   *\n   * The arguments are parsed from the last one to the first one, such that\n   * when several objects have keys in common, the \"earliest\" object wins.\n   *\n   * Example:\n   * ********\n   *  > var o1 = {\n   *  >       a: 1,\n   *  >       b: 2,\n   *  >       c: '3'\n   *  >     },\n   *  >     o2 = {\n   *  >       c: '4',\n   *  >       d: [ 5 ]\n   *  >     };\n   *  > sigma.utils.extend(o1, o2);\n   *  > // Returns: {\n   *  > //   a: 1,\n   *  > //   b: 2,\n   *  > //   c: '3',\n   *  > //   d: [ 5 ]\n   *  > // };\n   *\n   * @param  {object+} Any number of objects.\n   * @return {object}  The merged object.\n   */\n  sigma.utils.extend = function() {\n    var i,\n        k,\n        res = {},\n        l = arguments.length;\n\n    for (i = l - 1; i >= 0; i--)\n      for (k in arguments[i])\n        res[k] = arguments[i][k];\n\n    return res;\n  };\n\n  /**\n   * A short \"Date.now()\" polyfill.\n   *\n   * @return {Number} The current time (in ms).\n   */\n  sigma.utils.dateNow = function() {\n    return Date.now ? Date.now() : new Date().getTime();\n  };\n\n  /**\n   * Takes a package name as parameter and checks at each lebel if it exists,\n   * and if it does not, creates it.\n   *\n   * Example:\n   * ********\n   *  > sigma.utils.pkg('a.b.c');\n   *  > a.b.c;\n   *  > // Object {};\n   *  >\n   *  > sigma.utils.pkg('a.b.d');\n   *  > a.b;\n   *  > // Object { c: {}, d: {} };\n   *\n   * @param  {string} pkgName The name of the package to create/find.\n   * @return {object}         The related package.\n   */\n  sigma.utils.pkg = function(pkgName) {\n    return (pkgName || '').split('.').reduce(function(context, objName) {\n      return (objName in context) ?\n        context[objName] :\n        (context[objName] = {});\n    }, _root);\n  };\n\n  /**\n   * Returns a unique incremental number ID.\n   *\n   * Example:\n   * ********\n   *  > sigma.utils.id();\n   *  > // 1;\n   *  >\n   *  > sigma.utils.id();\n   *  > // 2;\n   *  >\n   *  > sigma.utils.id();\n   *  > // 3;\n   *\n   * @param  {string} pkgName The name of the package to create/find.\n   * @return {object}         The related package.\n   */\n  sigma.utils.id = (function() {\n    var i = 0;\n    return function() {\n      return ++i;\n    };\n  })();\n\n  /**\n   * This function takes an hexa color (for instance \"#ffcc00\" or \"#fc0\") or a\n   * rgb / rgba color (like \"rgb(255,255,12)\" or \"rgba(255,255,12,1)\") and\n   * returns an integer equal to \"r * 255 * 255 + g * 255 + b\", to gain some\n   * memory in the data given to WebGL shaders.\n   *\n   * Note that the function actually caches its results for better performance.\n   *\n   * @param  {string} val The hexa or rgba color.\n   * @return {number}     The number value.\n   */\n  var floatColorCache = {};\n\n  sigma.utils.floatColor = function(val) {\n\n    // Is the color already computed?\n    if (floatColorCache[val])\n      return floatColorCache[val];\n\n    var original = val,\n        r = 0,\n        g = 0,\n        b = 0;\n\n    if (val[0] === '#') {\n      val = val.slice(1);\n\n      if (val.length === 3) {\n        r = parseInt(val.charAt(0) + val.charAt(0), 16);\n        g = parseInt(val.charAt(1) + val.charAt(1), 16);\n        b = parseInt(val.charAt(2) + val.charAt(2), 16);\n      }\n      else {\n        r = parseInt(val.charAt(0) + val.charAt(1), 16);\n        g = parseInt(val.charAt(2) + val.charAt(3), 16);\n        b = parseInt(val.charAt(4) + val.charAt(5), 16);\n      }\n    } else if (val.match(/^ *rgba? *\\(/)) {\n      val = val.match(\n        /^ *rgba? *\\( *([0-9]*) *, *([0-9]*) *, *([0-9]*) *(,.*)?\\) *$/\n      );\n      r = +val[1];\n      g = +val[2];\n      b = +val[3];\n    }\n\n    var color = (\n      r * 256 * 256 +\n      g * 256 +\n      b\n    );\n\n    // Caching the color\n    floatColorCache[original] = color;\n\n    return color;\n  };\n\n    /**\n   * Perform a zoom into a camera, with or without animation, to the\n   * coordinates indicated using a specified ratio.\n   *\n   * Recognized parameters:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters in the animation\n   * object:\n   *\n   *   {?number} duration     An amount of time that means the duration of the\n   *                          animation. If this parameter doesn't exist the\n   *                          zoom will be performed without animation.\n   *   {?function} onComplete A function to perform it after the animation. It\n   *                          will be performed even if there is no duration.\n   *\n   * @param {camera}     The camera where perform the zoom.\n   * @param {x}          The X coordiantion where the zoom goes.\n   * @param {y}          The Y coordiantion where the zoom goes.\n   * @param {ratio}      The ratio to apply it to the current camera ratio.\n   * @param {?animation} A dictionary with options for a possible animation.\n   */\n  sigma.utils.zoomTo = function(camera, x, y, ratio, animation) {\n    var settings = camera.settings,\n        count,\n        newRatio,\n        animationSettings,\n        coordinates;\n\n    // Create the newRatio dealing with min / max:\n    newRatio = Math.max(\n      settings('zoomMin'),\n      Math.min(\n        settings('zoomMax'),\n        camera.ratio * ratio\n      )\n    );\n\n    // Check that the new ratio is different from the initial one:\n    if (newRatio !== camera.ratio) {\n      // Create the coordinates variable:\n      ratio = newRatio / camera.ratio;\n      coordinates = {\n        x: x * (1 - ratio) + camera.x,\n        y: y * (1 - ratio) + camera.y,\n        ratio: newRatio\n      };\n\n      if (animation && animation.duration) {\n        // Complete the animation setings:\n        count = sigma.misc.animation.killAll(camera);\n        animation = sigma.utils.extend(\n          animation,\n          {\n            easing: count ? 'quadraticOut' : 'quadraticInOut'\n          }\n        );\n\n        sigma.misc.animation.camera(camera, coordinates, animation);\n      } else {\n        camera.goTo(coordinates);\n        if (animation && animation.onComplete)\n          animation.onComplete();\n      }\n    }\n  };\n\n  /**\n   * Return the control point coordinates for a quadratic bezier curve.\n   *\n   * @param  {number} x1  The X coordinate of the start point.\n   * @param  {number} y1  The Y coordinate of the start point.\n   * @param  {number} x2  The X coordinate of the end point.\n   * @param  {number} y2  The Y coordinate of the end point.\n   * @return {x,y}        The control point coordinates.\n   */\n  sigma.utils.getQuadraticControlPoint = function(x1, y1, x2, y2) {\n    return {\n      x: (x1 + x2) / 2 + (y2 - y1) / 4,\n      y: (y1 + y2) / 2 + (x1 - x2) / 4\n    };\n  };\n\n  /**\n    * Compute the coordinates of the point positioned\n    * at length t in the quadratic bezier curve.\n    *\n    * @param  {number} t  In [0,1] the step percentage to reach\n    *                     the point in the curve from the context point.\n    * @param  {number} x1 The X coordinate of the context point.\n    * @param  {number} y1 The Y coordinate of the context point.\n    * @param  {number} x2 The X coordinate of the ending point.\n    * @param  {number} y2 The Y coordinate of the ending point.\n    * @param  {number} xi The X coordinate of the control point.\n    * @param  {number} yi The Y coordinate of the control point.\n    * @return {object}    {x,y}.\n  */\n  sigma.utils.getPointOnQuadraticCurve = function(t, x1, y1, x2, y2, xi, yi) {\n    // http://stackoverflow.com/a/5634528\n    return {\n      x: Math.pow(1 - t, 2) * x1 + 2 * (1 - t) * t * xi + Math.pow(t, 2) * x2,\n      y: Math.pow(1 - t, 2) * y1 + 2 * (1 - t) * t * yi + Math.pow(t, 2) * y2\n    };\n  };\n\n  /**\n    * Compute the coordinates of the point positioned\n    * at length t in the cubic bezier curve.\n    *\n    * @param  {number} t  In [0,1] the step percentage to reach\n    *                     the point in the curve from the context point.\n    * @param  {number} x1 The X coordinate of the context point.\n    * @param  {number} y1 The Y coordinate of the context point.\n    * @param  {number} x2 The X coordinate of the end point.\n    * @param  {number} y2 The Y coordinate of the end point.\n    * @param  {number} cx The X coordinate of the first control point.\n    * @param  {number} cy The Y coordinate of the first control point.\n    * @param  {number} dx The X coordinate of the second control point.\n    * @param  {number} dy The Y coordinate of the second control point.\n    * @return {object}    {x,y} The point at t.\n  */\n  sigma.utils.getPointOnBezierCurve =\n    function(t, x1, y1, x2, y2, cx, cy, dx, dy) {\n    // http://stackoverflow.com/a/15397596\n    // Blending functions:\n    var B0_t = Math.pow(1 - t, 3),\n        B1_t = 3 * t * Math.pow(1 - t, 2),\n        B2_t = 3 * Math.pow(t, 2) * (1 - t),\n        B3_t = Math.pow(t, 3);\n\n    return {\n      x: (B0_t * x1) + (B1_t * cx) + (B2_t * dx) + (B3_t * x2),\n      y: (B0_t * y1) + (B1_t * cy) + (B2_t * dy) + (B3_t * y2)\n    };\n  };\n\n  /**\n   * Return the coordinates of the two control points for a self loop (i.e.\n   * where the start point is also the end point) computed as a cubic bezier\n   * curve.\n   *\n   * @param  {number} x    The X coordinate of the node.\n   * @param  {number} y    The Y coordinate of the node.\n   * @param  {number} size The node size.\n   * @return {x1,y1,x2,y2} The coordinates of the two control points.\n   */\n  sigma.utils.getSelfLoopControlPoints = function(x , y, size) {\n    return {\n      x1: x - size * 7,\n      y1: y,\n      x2: x,\n      y2: y + size * 7\n    };\n  };\n\n  /**\n   * Return the euclidian distance between two points of a plane\n   * with an orthonormal basis.\n   *\n   * @param  {number} x1  The X coordinate of the first point.\n   * @param  {number} y1  The Y coordinate of the first point.\n   * @param  {number} x2  The X coordinate of the second point.\n   * @param  {number} y2  The Y coordinate of the second point.\n   * @return {number}     The euclidian distance.\n   */\n  sigma.utils.getDistance = function(x0, y0, x1, y1) {\n    return Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));\n  };\n\n  /**\n   * Return the coordinates of the intersection points of two circles.\n   *\n   * @param  {number} x0  The X coordinate of center location of the first\n   *                      circle.\n   * @param  {number} y0  The Y coordinate of center location of the first\n   *                      circle.\n   * @param  {number} r0  The radius of the first circle.\n   * @param  {number} x1  The X coordinate of center location of the second\n   *                      circle.\n   * @param  {number} y1  The Y coordinate of center location of the second\n   *                      circle.\n   * @param  {number} r1  The radius of the second circle.\n   * @return {xi,yi}      The coordinates of the intersection points.\n   */\n  sigma.utils.getCircleIntersection = function(x0, y0, r0, x1, y1, r1) {\n    // http://stackoverflow.com/a/12219802\n    var a, dx, dy, d, h, rx, ry, x2, y2;\n\n    // dx and dy are the vertical and horizontal distances between the circle\n    // centers:\n    dx = x1 - x0;\n    dy = y1 - y0;\n\n    // Determine the straight-line distance between the centers:\n    d = Math.sqrt((dy * dy) + (dx * dx));\n\n    // Check for solvability:\n    if (d > (r0 + r1)) {\n        // No solution. circles do not intersect.\n        return false;\n    }\n    if (d < Math.abs(r0 - r1)) {\n        // No solution. one circle is contained in the other.\n        return false;\n    }\n\n    //'point 2' is the point where the line through the circle intersection\n    // points crosses the line between the circle centers.\n\n    // Determine the distance from point 0 to point 2:\n    a = ((r0 * r0) - (r1 * r1) + (d * d)) / (2.0 * d);\n\n    // Determine the coordinates of point 2:\n    x2 = x0 + (dx * a / d);\n    y2 = y0 + (dy * a / d);\n\n    // Determine the distance from point 2 to either of the intersection\n    // points:\n    h = Math.sqrt((r0 * r0) - (a * a));\n\n    // Determine the offsets of the intersection points from point 2:\n    rx = -dy * (h / d);\n    ry = dx * (h / d);\n\n    // Determine the absolute intersection points:\n    var xi = x2 + rx;\n    var xi_prime = x2 - rx;\n    var yi = y2 + ry;\n    var yi_prime = y2 - ry;\n\n    return {xi: xi, xi_prime: xi_prime, yi: yi, yi_prime: yi_prime};\n  };\n\n  /**\n    * Check if a point is on a line segment.\n    *\n    * @param  {number} x       The X coordinate of the point to check.\n    * @param  {number} y       The Y coordinate of the point to check.\n    * @param  {number} x1      The X coordinate of the line start point.\n    * @param  {number} y1      The Y coordinate of the line start point.\n    * @param  {number} x2      The X coordinate of the line end point.\n    * @param  {number} y2      The Y coordinate of the line end point.\n    * @param  {number} epsilon The precision (consider the line thickness).\n    * @return {boolean}        True if point is \"close to\" the line\n    *                          segment, false otherwise.\n  */\n  sigma.utils.isPointOnSegment = function(x, y, x1, y1, x2, y2, epsilon) {\n    // http://stackoverflow.com/a/328122\n    var crossProduct = Math.abs((y - y1) * (x2 - x1) - (x - x1) * (y2 - y1)),\n        d = sigma.utils.getDistance(x1, y1, x2, y2),\n        nCrossProduct = crossProduct / d; // normalized cross product\n\n    return (nCrossProduct < epsilon &&\n     Math.min(x1, x2) <= x && x <= Math.max(x1, x2) &&\n     Math.min(y1, y2) <= y && y <= Math.max(y1, y2));\n  };\n\n  /**\n    * Check if a point is on a quadratic bezier curve segment with a thickness.\n    *\n    * @param  {number} x       The X coordinate of the point to check.\n    * @param  {number} y       The Y coordinate of the point to check.\n    * @param  {number} x1      The X coordinate of the curve start point.\n    * @param  {number} y1      The Y coordinate of the curve start point.\n    * @param  {number} x2      The X coordinate of the curve end point.\n    * @param  {number} y2      The Y coordinate of the curve end point.\n    * @param  {number} cpx     The X coordinate of the curve control point.\n    * @param  {number} cpy     The Y coordinate of the curve control point.\n    * @param  {number} epsilon The precision (consider the line thickness).\n    * @return {boolean}        True if (x,y) is on the curve segment,\n    *                          false otherwise.\n  */\n  sigma.utils.isPointOnQuadraticCurve =\n    function(x, y, x1, y1, x2, y2, cpx, cpy, epsilon) {\n    // Fails if the point is too far from the extremities of the segment,\n    // preventing for more costly computation:\n    var dP1P2 = sigma.utils.getDistance(x1, y1, x2, y2);\n    if (Math.abs(x - x1) > dP1P2 || Math.abs(y - y1) > dP1P2) {\n      return false;\n    }\n\n    var dP1 = sigma.utils.getDistance(x, y, x1, y1),\n        dP2 = sigma.utils.getDistance(x, y, x2, y2),\n        t = 0.5,\n        r = (dP1 < dP2) ? -0.01 : 0.01,\n        rThreshold = 0.001,\n        i = 100,\n        pt = sigma.utils.getPointOnQuadraticCurve(t, x1, y1, x2, y2, cpx, cpy),\n        dt = sigma.utils.getDistance(x, y, pt.x, pt.y),\n        old_dt;\n\n    // This algorithm minimizes the distance from the point to the curve. It\n    // find the optimal t value where t=0 is the start point and t=1 is the end\n    // point of the curve, starting from t=0.5.\n    // It terminates because it runs a maximum of i interations.\n    while (i-- > 0 &&\n      t >= 0 && t <= 1 &&\n      (dt > epsilon) &&\n      (r > rThreshold || r < -rThreshold)) {\n      old_dt = dt;\n      pt = sigma.utils.getPointOnQuadraticCurve(t, x1, y1, x2, y2, cpx, cpy);\n      dt = sigma.utils.getDistance(x, y, pt.x, pt.y);\n\n      if (dt > old_dt) {\n        // not the right direction:\n        // halfstep in the opposite direction\n        r = -r / 2;\n        t += r;\n      }\n      else if (t + r < 0 || t + r > 1) {\n        // oops, we've gone too far:\n        // revert with a halfstep\n        r = r / 2;\n        dt = old_dt;\n      }\n      else {\n        // progress:\n        t += r;\n      }\n    }\n\n    return dt < epsilon;\n  };\n\n\n  /**\n    * Check if a point is on a cubic bezier curve segment with a thickness.\n    *\n    * @param  {number} x       The X coordinate of the point to check.\n    * @param  {number} y       The Y coordinate of the point to check.\n    * @param  {number} x1      The X coordinate of the curve start point.\n    * @param  {number} y1      The Y coordinate of the curve start point.\n    * @param  {number} x2      The X coordinate of the curve end point.\n    * @param  {number} y2      The Y coordinate of the curve end point.\n    * @param  {number} cpx1    The X coordinate of the 1st curve control point.\n    * @param  {number} cpy1    The Y coordinate of the 1st curve control point.\n    * @param  {number} cpx2    The X coordinate of the 2nd curve control point.\n    * @param  {number} cpy2    The Y coordinate of the 2nd curve control point.\n    * @param  {number} epsilon The precision (consider the line thickness).\n    * @return {boolean}        True if (x,y) is on the curve segment,\n    *                          false otherwise.\n  */\n  sigma.utils.isPointOnBezierCurve =\n    function(x, y, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2, epsilon) {\n    // Fails if the point is too far from the extremities of the segment,\n    // preventing for more costly computation:\n    var dP1CP1 = sigma.utils.getDistance(x1, y1, cpx1, cpy1);\n    if (Math.abs(x - x1) > dP1CP1 || Math.abs(y - y1) > dP1CP1) {\n      return false;\n    }\n\n    var dP1 = sigma.utils.getDistance(x, y, x1, y1),\n        dP2 = sigma.utils.getDistance(x, y, x2, y2),\n        t = 0.5,\n        r = (dP1 < dP2) ? -0.01 : 0.01,\n        rThreshold = 0.001,\n        i = 100,\n        pt = sigma.utils.getPointOnBezierCurve(\n          t, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2),\n        dt = sigma.utils.getDistance(x, y, pt.x, pt.y),\n        old_dt;\n\n    // This algorithm minimizes the distance from the point to the curve. It\n    // find the optimal t value where t=0 is the start point and t=1 is the end\n    // point of the curve, starting from t=0.5.\n    // It terminates because it runs a maximum of i interations.\n    while (i-- > 0 &&\n      t >= 0 && t <= 1 &&\n      (dt > epsilon) &&\n      (r > rThreshold || r < -rThreshold)) {\n      old_dt = dt;\n      pt = sigma.utils.getPointOnBezierCurve(\n        t, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2);\n      dt = sigma.utils.getDistance(x, y, pt.x, pt.y);\n\n      if (dt > old_dt) {\n        // not the right direction:\n        // halfstep in the opposite direction\n        r = -r / 2;\n        t += r;\n      }\n      else if (t + r < 0 || t + r > 1) {\n        // oops, we've gone too far:\n        // revert with a halfstep\n        r = r / 2;\n        dt = old_dt;\n      }\n      else {\n        // progress:\n        t += r;\n      }\n    }\n\n    return dt < epsilon;\n  };\n\n\n  /**\n   * ************\n   * EVENTS UTILS:\n   * ************\n   */\n  /**\n   * Here are some useful functions to unify extraction of the information we\n   * need with mouse events and touch events, from different browsers:\n   */\n\n  /**\n   * Extract the local X position from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {number}   The local X value of the mouse.\n   */\n  sigma.utils.getX = function(e) {\n    return (\n      (e.offsetX !== undefined && e.offsetX) ||\n      (e.layerX !== undefined && e.layerX) ||\n      (e.clientX !== undefined && e.clientX)\n    );\n  };\n\n  /**\n   * Extract the local Y position from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {number}   The local Y value of the mouse.\n   */\n  sigma.utils.getY = function(e) {\n    return (\n      (e.offsetY !== undefined && e.offsetY) ||\n      (e.layerY !== undefined && e.layerY) ||\n      (e.clientY !== undefined && e.clientY)\n    );\n  };\n\n  /**\n   * The pixel ratio of the screen. Taking zoom into account\n   *\n   * @return {number}        Pixel ratio of the screen\n   */\n  sigma.utils.getPixelRatio = function() {\n    var ratio = 1;\n    if (window.screen.deviceXDPI !== undefined &&\n         window.screen.logicalXDPI !== undefined &&\n         window.screen.deviceXDPI > window.screen.logicalXDPI) {\n        ratio = window.screen.systemXDPI / window.screen.logicalXDPI;\n    }\n    else if (window.devicePixelRatio !== undefined) {\n        ratio = window.devicePixelRatio;\n    }\n    return ratio;\n  };\n\n  /**\n   * Extract the width from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {number}   The width of the event's target.\n   */\n  sigma.utils.getWidth = function(e) {\n    var w = (!e.target.ownerSVGElement) ?\n              e.target.width :\n              e.target.ownerSVGElement.width;\n\n    return (\n      (typeof w === 'number' && w) ||\n      (w !== undefined && w.baseVal !== undefined && w.baseVal.value)\n    );\n  };\n\n  /**\n   * Extract the center from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {object}   The center of the event's target.\n   */\n  sigma.utils.getCenter = function(e) {\n    var ratio = e.target.namespaceURI.indexOf('svg') !== -1 ? 1 :\n        sigma.utils.getPixelRatio();\n    return {\n      x: sigma.utils.getWidth(e) / (2 * ratio),\n      y: sigma.utils.getHeight(e) / (2 * ratio)\n    };\n  };\n\n  /**\n   * Convert mouse coords to sigma coords\n   *\n   * @param  {event}   e A mouse or touch event.\n   * @param  {number?} x The x coord to convert\n   * @param  {number?} x The y coord to convert\n   *\n   * @return {object}    The standardized event\n   */\n  sigma.utils.mouseCoords = function(e, x, y) {\n    x = x || sigma.utils.getX(e);\n    y = y || sigma.utils.getY(e);\n    return {\n        x: x - sigma.utils.getCenter(e).x,\n        y: y - sigma.utils.getCenter(e).y,\n        clientX: e.clientX,\n        clientY: e.clientY,\n        ctrlKey: e.ctrlKey,\n        metaKey: e.metaKey,\n        altKey: e.altKey,\n        shiftKey: e.shiftKey\n    };\n  };\n\n  /**\n   * Extract the height from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {number}   The height of the event's target.\n   */\n  sigma.utils.getHeight = function(e) {\n    var h = (!e.target.ownerSVGElement) ?\n              e.target.height :\n              e.target.ownerSVGElement.height;\n\n    return (\n      (typeof h === 'number' && h) ||\n      (h !== undefined && h.baseVal !== undefined && h.baseVal.value)\n    );\n  };\n\n  /**\n   * Extract the wheel delta from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {number}   The wheel delta of the mouse.\n   */\n  sigma.utils.getDelta = function(e) {\n    return (\n      (e.wheelDelta !== undefined && e.wheelDelta) ||\n      (e.detail !== undefined && -e.detail)\n    );\n  };\n\n  /**\n   * Returns the offset of a DOM element.\n   *\n   * @param  {DOMElement} dom The element to retrieve the position.\n   * @return {object}         The offset of the DOM element (top, left).\n   */\n  sigma.utils.getOffset = function(dom) {\n    var left = 0,\n        top = 0;\n\n    while (dom) {\n      top = top + parseInt(dom.offsetTop);\n      left = left + parseInt(dom.offsetLeft);\n      dom = dom.offsetParent;\n    }\n\n    return {\n      top: top,\n      left: left\n    };\n  };\n\n  /**\n   * Simulates a \"double click\" event.\n   *\n   * @param  {HTMLElement} target   The event target.\n   * @param  {string}      type     The event type.\n   * @param  {function}    callback The callback to execute.\n   */\n  sigma.utils.doubleClick = function(target, type, callback) {\n    var clicks = 0,\n        self = this,\n        handlers;\n\n    target._doubleClickHandler = target._doubleClickHandler || {};\n    target._doubleClickHandler[type] = target._doubleClickHandler[type] || [];\n    handlers = target._doubleClickHandler[type];\n\n    handlers.push(function(e) {\n      clicks++;\n\n      if (clicks === 2) {\n        clicks = 0;\n        return callback(e);\n      } else if (clicks === 1) {\n        setTimeout(function() {\n          clicks = 0;\n        }, sigma.settings.doubleClickTimeout);\n      }\n    });\n\n    target.addEventListener(type, handlers[handlers.length - 1], false);\n  };\n\n  /**\n   * Unbind simulated \"double click\" events.\n   *\n   * @param  {HTMLElement} target   The event target.\n   * @param  {string}      type     The event type.\n   */\n  sigma.utils.unbindDoubleClick = function(target, type) {\n    var handler,\n        handlers = (target._doubleClickHandler || {})[type] || [];\n\n    while ((handler = handlers.pop())) {\n      target.removeEventListener(type, handler);\n    }\n\n    delete (target._doubleClickHandler || {})[type];\n  };\n\n\n\n\n  /**\n   * Here are just some of the most basic easing functions, used for the\n   * animated camera \"goTo\" calls.\n   *\n   * If you need some more easings functions, don't hesitate to add them to\n   * sigma.utils.easings. But I will not add some more here or merge PRs\n   * containing, because I do not want sigma sources full of overkill and never\n   * used stuff...\n   */\n  sigma.utils.easings = sigma.utils.easings || {};\n  sigma.utils.easings.linearNone = function(k) {\n    return k;\n  };\n  sigma.utils.easings.quadraticIn = function(k) {\n    return k * k;\n  };\n  sigma.utils.easings.quadraticOut = function(k) {\n    return k * (2 - k);\n  };\n  sigma.utils.easings.quadraticInOut = function(k) {\n    if ((k *= 2) < 1)\n      return 0.5 * k * k;\n    return - 0.5 * (--k * (k - 2) - 1);\n  };\n  sigma.utils.easings.cubicIn = function(k) {\n    return k * k * k;\n  };\n  sigma.utils.easings.cubicOut = function(k) {\n    return --k * k * k + 1;\n  };\n  sigma.utils.easings.cubicInOut = function(k) {\n    if ((k *= 2) < 1)\n      return 0.5 * k * k * k;\n    return 0.5 * ((k -= 2) * k * k + 2);\n  };\n\n\n\n\n  /**\n   * ************\n   * WEBGL UTILS:\n   * ************\n   */\n  /**\n   * Loads a WebGL shader and returns it.\n   *\n   * @param  {WebGLContext}           gl           The WebGLContext to use.\n   * @param  {string}                 shaderSource The shader source.\n   * @param  {number}                 shaderType   The type of shader.\n   * @param  {function(string): void} error        Callback for errors.\n   * @return {WebGLShader}                         The created shader.\n   */\n  sigma.utils.loadShader = function(gl, shaderSource, shaderType, error) {\n    var compiled,\n        shader = gl.createShader(shaderType);\n\n    // Load the shader source\n    gl.shaderSource(shader, shaderSource);\n\n    // Compile the shader\n    gl.compileShader(shader);\n\n    // Check the compile status\n    compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\n    // If something went wrong:\n    if (!compiled) {\n      if (error) {\n        error(\n          'Error compiling shader \"' + shader + '\":' +\n          gl.getShaderInfoLog(shader)\n        );\n      }\n\n      gl.deleteShader(shader);\n      return null;\n    }\n\n    return shader;\n  };\n\n  /**\n   * Creates a program, attaches shaders, binds attrib locations, links the\n   * program and calls useProgram.\n   *\n   * @param  {Array.<WebGLShader>}    shaders   The shaders to attach.\n   * @param  {Array.<string>}         attribs   The attribs names.\n   * @param  {Array.<number>}         locations The locations for the attribs.\n   * @param  {function(string): void} error     Callback for errors.\n   * @return {WebGLProgram}                     The created program.\n   */\n  sigma.utils.loadProgram = function(gl, shaders, attribs, loc, error) {\n    var i,\n        linked,\n        program = gl.createProgram();\n\n    for (i = 0; i < shaders.length; ++i)\n      gl.attachShader(program, shaders[i]);\n\n    if (attribs)\n      for (i = 0; i < attribs.length; ++i)\n        gl.bindAttribLocation(\n          program,\n          locations ? locations[i] : i,\n          opt_attribs[i]\n        );\n\n    gl.linkProgram(program);\n\n    // Check the link status\n    linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n    if (!linked) {\n      if (error)\n        error('Error in program linking: ' + gl.getProgramInfoLog(program));\n\n      gl.deleteProgram(program);\n      return null;\n    }\n\n    return program;\n  };\n\n\n\n\n  /**\n   * *********\n   * MATRICES:\n   * *********\n   * The following utils are just here to help generating the transformation\n   * matrices for the WebGL renderers.\n   */\n  sigma.utils.pkg('sigma.utils.matrices');\n\n  /**\n   * The returns a 3x3 translation matrix.\n   *\n   * @param  {number} dx The X translation.\n   * @param  {number} dy The Y translation.\n   * @return {array}     Returns the matrix.\n   */\n  sigma.utils.matrices.translation = function(dx, dy) {\n    return [\n      1, 0, 0,\n      0, 1, 0,\n      dx, dy, 1\n    ];\n  };\n\n  /**\n   * The returns a 3x3 or 2x2 rotation matrix.\n   *\n   * @param  {number}  angle The rotation angle.\n   * @param  {boolean} m2    If true, the function will return a 2x2 matrix.\n   * @return {array}         Returns the matrix.\n   */\n  sigma.utils.matrices.rotation = function(angle, m2) {\n    var cos = Math.cos(angle),\n        sin = Math.sin(angle);\n\n    return m2 ? [\n      cos, -sin,\n      sin, cos\n    ] : [\n      cos, -sin, 0,\n      sin, cos, 0,\n      0, 0, 1\n    ];\n  };\n\n  /**\n   * The returns a 3x3 or 2x2 homothetic transformation matrix.\n   *\n   * @param  {number}  ratio The scaling ratio.\n   * @param  {boolean} m2    If true, the function will return a 2x2 matrix.\n   * @return {array}         Returns the matrix.\n   */\n  sigma.utils.matrices.scale = function(ratio, m2) {\n    return m2 ? [\n      ratio, 0,\n      0, ratio\n    ] : [\n      ratio, 0, 0,\n      0, ratio, 0,\n      0, 0, 1\n    ];\n  };\n\n  /**\n   * The returns a 3x3 or 2x2 homothetic transformation matrix.\n   *\n   * @param  {array}   a  The first matrix.\n   * @param  {array}   b  The second matrix.\n   * @param  {boolean} m2 If true, the function will assume both matrices are\n   *                      2x2.\n   * @return {array}      Returns the matrix.\n   */\n  sigma.utils.matrices.multiply = function(a, b, m2) {\n    var l = m2 ? 2 : 3,\n        a00 = a[0 * l + 0],\n        a01 = a[0 * l + 1],\n        a02 = a[0 * l + 2],\n        a10 = a[1 * l + 0],\n        a11 = a[1 * l + 1],\n        a12 = a[1 * l + 2],\n        a20 = a[2 * l + 0],\n        a21 = a[2 * l + 1],\n        a22 = a[2 * l + 2],\n        b00 = b[0 * l + 0],\n        b01 = b[0 * l + 1],\n        b02 = b[0 * l + 2],\n        b10 = b[1 * l + 0],\n        b11 = b[1 * l + 1],\n        b12 = b[1 * l + 2],\n        b20 = b[2 * l + 0],\n        b21 = b[2 * l + 1],\n        b22 = b[2 * l + 2];\n\n    return m2 ? [\n      a00 * b00 + a01 * b10,\n      a00 * b01 + a01 * b11,\n      a10 * b00 + a11 * b10,\n      a10 * b01 + a11 * b11\n    ] : [\n      a00 * b00 + a01 * b10 + a02 * b20,\n      a00 * b01 + a01 * b11 + a02 * b21,\n      a00 * b02 + a01 * b12 + a02 * b22,\n      a10 * b00 + a11 * b10 + a12 * b20,\n      a10 * b01 + a11 * b11 + a12 * b21,\n      a10 * b02 + a11 * b12 + a12 * b22,\n      a20 * b00 + a21 * b10 + a22 * b20,\n      a20 * b01 + a21 * b11 + a22 * b21,\n      a20 * b02 + a21 * b12 + a22 * b22\n    ];\n  };\n}).call(this);\n\n;(function(global) {\n  'use strict';\n\n  /**\n   * http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n   * http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n   * requestAnimationFrame polyfill by Erik Mller.\n   * fixes from Paul Irish and Tino Zijdel\n   * MIT license\n   */\n  var x,\n      lastTime = 0,\n      vendors = ['ms', 'moz', 'webkit', 'o'];\n\n  for (x = 0; x < vendors.length && !global.requestAnimationFrame; x++) {\n    global.requestAnimationFrame =\n      global[vendors[x] + 'RequestAnimationFrame'];\n    global.cancelAnimationFrame =\n      global[vendors[x] + 'CancelAnimationFrame'] ||\n      global[vendors[x] + 'CancelRequestAnimationFrame'];\n  }\n\n  if (!global.requestAnimationFrame)\n    global.requestAnimationFrame = function(callback, element) {\n      var currTime = new Date().getTime(),\n          timeToCall = Math.max(0, 16 - (currTime - lastTime)),\n          id = global.setTimeout(\n            function() {\n              callback(currTime + timeToCall);\n            },\n            timeToCall\n          );\n\n      lastTime = currTime + timeToCall;\n      return id;\n    };\n\n  if (!global.cancelAnimationFrame)\n    global.cancelAnimationFrame = function(id) {\n      clearTimeout(id);\n    };\n\n  /**\n   * Function.prototype.bind polyfill found on MDN.\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Compatibility\n   * Public domain\n   */\n  if (!Function.prototype.bind)\n    Function.prototype.bind = function(oThis) {\n      if (typeof this !== 'function')\n        // Closest thing possible to the ECMAScript 5 internal IsCallable\n        // function:\n        throw new TypeError(\n          'Function.prototype.bind - what is trying to be bound is not callable'\n        );\n\n      var aArgs = Array.prototype.slice.call(arguments, 1),\n          fToBind = this,\n          fNOP,\n          fBound;\n\n      fNOP = function() {};\n      fBound = function() {\n        return fToBind.apply(\n          this instanceof fNOP && oThis ?\n            this :\n            oThis,\n          aArgs.concat(Array.prototype.slice.call(arguments))\n        );\n      };\n\n      fNOP.prototype = this.prototype;\n      fBound.prototype = new fNOP();\n\n      return fBound;\n    };\n})(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Packages initialization:\n  sigma.utils.pkg('sigma.settings');\n\n  var settings = {\n    /**\n     * GRAPH SETTINGS:\n     * ***************\n     */\n    // {boolean} Indicates if the data have to be cloned in methods to add\n    //           nodes or edges.\n    clone: true,\n    // {boolean} Indicates if nodes \"id\" values and edges \"id\", \"source\" and\n    //           \"target\" values must be set as immutable.\n    immutable: true,\n    // {boolean} Indicates if sigma can log its errors and warnings.\n    verbose: false,\n\n\n    /**\n     * RENDERERS SETTINGS:\n     * *******************\n     */\n    // {string}\n    classPrefix: 'sigma',\n    // {string}\n    defaultNodeType: 'def',\n    // {string}\n    defaultEdgeType: 'def',\n    // {string}\n    defaultLabelColor: '#000',\n    // {string}\n    defaultEdgeColor: '#000',\n    // {string}\n    defaultNodeColor: '#000',\n    // {string}\n    defaultLabelSize: 14,\n    // {string} Indicates how to choose the edges color. Available values:\n    //          \"source\", \"target\", \"default\"\n    edgeColor: 'source',\n    // {number} Defines the minimal edge's arrow display size.\n    minArrowSize: 0,\n    // {string}\n    font: 'arial',\n    // {string} Example: 'bold'\n    fontStyle: '',\n    // {string} Indicates how to choose the labels color. Available values:\n    //          \"node\", \"default\"\n    labelColor: 'default',\n    // {string} Indicates how to choose the labels size. Available values:\n    //          \"fixed\", \"proportional\"\n    labelSize: 'fixed',\n    // {string} The ratio between the font size of the label and the node size.\n    labelSizeRatio: 1,\n    // {number} The minimum size a node must have to see its label displayed.\n    labelThreshold: 8,\n    // {number} The oversampling factor used in WebGL renderer.\n    webglOversamplingRatio: 2,\n    // {number} The size of the border of hovered nodes.\n    borderSize: 0,\n    // {number} The default hovered node border's color.\n    defaultNodeBorderColor: '#000',\n    // {number} The hovered node's label font. If not specified, will heritate\n    //          the \"font\" value.\n    hoverFont: '',\n    // {boolean} If true, then only one node can be hovered at a time.\n    singleHover: true,\n    // {string} Example: 'bold'\n    hoverFontStyle: '',\n    // {string} Indicates how to choose the hovered nodes shadow color.\n    //          Available values: \"node\", \"default\"\n    labelHoverShadow: 'default',\n    // {string}\n    labelHoverShadowColor: '#000',\n    // {string} Indicates how to choose the hovered nodes color.\n    //          Available values: \"node\", \"default\"\n    nodeHoverColor: 'node',\n    // {string}\n    defaultNodeHoverColor: '#000',\n    // {string} Indicates how to choose the hovered nodes background color.\n    //          Available values: \"node\", \"default\"\n    labelHoverBGColor: 'default',\n    // {string}\n    defaultHoverLabelBGColor: '#fff',\n    // {string} Indicates how to choose the hovered labels color.\n    //          Available values: \"node\", \"default\"\n    labelHoverColor: 'default',\n    // {string}\n    defaultLabelHoverColor: '#000',\n    // {string} Indicates how to choose the edges hover color. Available values:\n    //          \"edge\", \"default\"\n    edgeHoverColor: 'edge',\n    // {number} The size multiplicator of hovered edges.\n    edgeHoverSizeRatio: 1,\n    // {string}\n    defaultEdgeHoverColor: '#000',\n    // {boolean} Indicates if the edge extremities must be hovered when the\n    //           edge is hovered.\n    edgeHoverExtremities: false,\n    // {booleans} The different drawing modes:\n    //           false: Layered not displayed.\n    //           true: Layered displayed.\n    drawEdges: true,\n    drawNodes: true,\n    drawLabels: true,\n    drawEdgeLabels: false,\n    // {boolean} Indicates if the edges must be drawn in several frames or in\n    //           one frame, as the nodes and labels are drawn.\n    batchEdgesDrawing: false,\n    // {boolean} Indicates if the edges must be hidden during dragging and\n    //           animations.\n    hideEdgesOnMove: false,\n    // {numbers} The different batch sizes, when elements are displayed in\n    //           several frames.\n    canvasEdgesBatchSize: 500,\n    webglEdgesBatchSize: 1000,\n\n\n\n\n    /**\n     * RESCALE SETTINGS:\n     * *****************\n     */\n    // {string} Indicates of to scale the graph relatively to its container.\n    //          Available values: \"inside\", \"outside\"\n    scalingMode: 'inside',\n    // {number} The margin to keep around the graph.\n    sideMargin: 0,\n    // {number} Determine the size of the smallest and the biggest node / edges\n    //          on the screen. This mapping makes easier to display the graph,\n    //          avoiding too big nodes that take half of the screen, or too\n    //          small ones that are not readable. If the two parameters are\n    //          equals, then the minimal display size will be 0. And if they\n    //          are both equal to 0, then there is no mapping, and the radius\n    //          of the nodes will be their size.\n    minEdgeSize: 0.5,\n    maxEdgeSize: 1,\n    minNodeSize: 1,\n    maxNodeSize: 8,\n\n\n\n\n    /**\n     * CAPTORS SETTINGS:\n     * *****************\n     */\n    // {boolean}\n    touchEnabled: true,\n    // {boolean}\n    mouseEnabled: true,\n    // {boolean}\n    mouseWheelEnabled: true,\n    // {boolean}\n    doubleClickEnabled: true,\n    // {boolean} Defines whether the custom events such as \"clickNode\" can be\n    //           used.\n    eventsEnabled: true,\n    // {number} Defines by how much multiplicating the zooming level when the\n    //          user zooms with the mouse-wheel.\n    zoomingRatio: 1.7,\n    // {number} Defines by how much multiplicating the zooming level when the\n    //          user zooms by double clicking.\n    doubleClickZoomingRatio: 2.2,\n    // {number} The minimum zooming level.\n    zoomMin: 0.0625,\n    // {number} The maximum zooming level.\n    zoomMax: 2,\n    // {number} The duration of animations following a mouse scrolling.\n    mouseZoomDuration: 200,\n    // {number} The duration of animations following a mouse double click.\n    doubleClickZoomDuration: 200,\n    // {number} The duration of animations following a mouse dropping.\n    mouseInertiaDuration: 200,\n    // {number} The inertia power (mouse captor).\n    mouseInertiaRatio: 3,\n    // {number} The duration of animations following a touch dropping.\n    touchInertiaDuration: 200,\n    // {number} The inertia power (touch captor).\n    touchInertiaRatio: 3,\n    // {number} The maximum time between two clicks to make it a double click.\n    doubleClickTimeout: 300,\n    // {number} The maximum time between two taps to make it a double tap.\n    doubleTapTimeout: 300,\n    // {number} The maximum time of dragging to trigger intertia.\n    dragTimeout: 200,\n\n\n\n\n    /**\n     * GLOBAL SETTINGS:\n     * ****************\n     */\n    // {boolean} Determines whether the instance has to refresh itself\n    //           automatically when a \"resize\" event is dispatched from the\n    //           window object.\n    autoResize: true,\n    // {boolean} Determines whether the \"rescale\" middleware has to be called\n    //           automatically for each camera on refresh.\n    autoRescale: true,\n    // {boolean} If set to false, the camera method \"goTo\" will basically do\n    //           nothing.\n    enableCamera: true,\n    // {boolean} If set to false, the nodes cannot be hovered.\n    enableHovering: true,\n    // {boolean} If set to true, the edges can be hovered.\n    enableEdgeHovering: false,\n    // {number} The size of the area around the edges to activate hovering.\n    edgeHoverPrecision: 5,\n    // {boolean} If set to true, the rescale middleware will ignore node sizes\n    //           to determine the graphs boundings.\n    rescaleIgnoreSize: false,\n    // {boolean} Determines if the core has to try to catch errors on\n    //           rendering.\n    skipErrors: false,\n\n\n\n\n    /**\n     * CAMERA SETTINGS:\n     * ****************\n     */\n    // {number} The power degrees applied to the nodes/edges size relatively to\n    //          the zooming level. Basically:\n    //           > onScreenR = Math.pow(zoom, nodesPowRatio) * R\n    //           > onScreenT = Math.pow(zoom, edgesPowRatio) * T\n    nodesPowRatio: 0.5,\n    edgesPowRatio: 0.5,\n\n\n\n\n    /**\n     * ANIMATIONS SETTINGS:\n     * ********************\n     */\n    // {number} The default animation time.\n    animationsTime: 200\n  };\n\n  // Export the previously designed settings:\n  sigma.settings = sigma.utils.extend(sigma.settings || {}, settings);\n}).call(this);\n\n;(function() {\n  'use strict';\n\n  /**\n   * Dispatcher constructor.\n   *\n   * @return {dispatcher} The new dispatcher instance.\n   */\n  var dispatcher = function() {\n    Object.defineProperty(this, '_handlers', {\n      value: {}\n    });\n  };\n\n\n\n\n  /**\n   * Will execute the handler everytime that the indicated event (or the\n   * indicated events) will be triggered.\n   *\n   * @param  {string}           events  The name of the event (or the events\n   *                                    separated by spaces).\n   * @param  {function(Object)} handler The handler to bind.\n   * @return {dispatcher}               Returns the instance itself.\n   */\n  dispatcher.prototype.bind = function(events, handler) {\n    var i,\n        l,\n        event,\n        eArray;\n\n    if (\n      arguments.length === 1 &&\n      typeof arguments[0] === 'object'\n    )\n      for (events in arguments[0])\n        this.bind(events, arguments[0][events]);\n    else if (\n      arguments.length === 2 &&\n      typeof arguments[1] === 'function'\n    ) {\n      eArray = typeof events === 'string' ? events.split(' ') : events;\n\n      for (i = 0, l = eArray.length; i !== l; i += 1) {\n        event = eArray[i];\n\n        // Check that event is not '':\n        if (!event)\n          continue;\n\n        if (!this._handlers[event])\n          this._handlers[event] = [];\n\n        // Using an object instead of directly the handler will make possible\n        // later to add flags\n        this._handlers[event].push({\n          handler: handler\n        });\n      }\n    } else\n      throw 'bind: Wrong arguments.';\n\n    return this;\n  };\n\n  /**\n   * Removes the handler from a specified event (or specified events).\n   *\n   * @param  {?string}           events  The name of the event (or the events\n   *                                     separated by spaces). If undefined,\n   *                                     then all handlers are removed.\n   * @param  {?function(object)} handler The handler to unbind. If undefined,\n   *                                     each handler bound to the event or the\n   *                                     events will be removed.\n   * @return {dispatcher}                Returns the instance itself.\n   */\n  dispatcher.prototype.unbind = function(events, handler) {\n    var i,\n        n,\n        j,\n        m,\n        k,\n        a,\n        event,\n        eArray = typeof events === 'string' ? events.split(' ') : events;\n\n    if (!arguments.length) {\n      for (k in this._handlers)\n        delete this._handlers[k];\n      return this;\n    }\n\n    if (handler) {\n      for (i = 0, n = eArray.length; i !== n; i += 1) {\n        event = eArray[i];\n        if (this._handlers[event]) {\n          a = [];\n          for (j = 0, m = this._handlers[event].length; j !== m; j += 1)\n            if (this._handlers[event][j].handler !== handler)\n              a.push(this._handlers[event][j]);\n\n          this._handlers[event] = a;\n        }\n\n        if (this._handlers[event] && this._handlers[event].length === 0)\n          delete this._handlers[event];\n      }\n    } else\n      for (i = 0, n = eArray.length; i !== n; i += 1)\n        delete this._handlers[eArray[i]];\n\n    return this;\n  };\n\n  /**\n   * Executes each handler bound to the event\n   *\n   * @param  {string}     events The name of the event (or the events separated\n   *                             by spaces).\n   * @param  {?object}    data   The content of the event (optional).\n   * @return {dispatcher}        Returns the instance itself.\n   */\n  dispatcher.prototype.dispatchEvent = function(events, data) {\n    var i,\n        n,\n        j,\n        m,\n        a,\n        event,\n        eventName,\n        self = this,\n        eArray = typeof events === 'string' ? events.split(' ') : events;\n\n    data = data === undefined ? {} : data;\n\n    for (i = 0, n = eArray.length; i !== n; i += 1) {\n      eventName = eArray[i];\n\n      if (this._handlers[eventName]) {\n        event = self.getEvent(eventName, data);\n        a = [];\n\n        for (j = 0, m = this._handlers[eventName].length; j !== m; j += 1) {\n          this._handlers[eventName][j].handler(event);\n          if (!this._handlers[eventName][j].one)\n            a.push(this._handlers[eventName][j]);\n        }\n\n        this._handlers[eventName] = a;\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * Return an event object.\n   *\n   * @param  {string}  events The name of the event.\n   * @param  {?object} data   The content of the event (optional).\n   * @return {object}         Returns the instance itself.\n   */\n  dispatcher.prototype.getEvent = function(event, data) {\n    return {\n      type: event,\n      data: data || {},\n      target: this\n    };\n  };\n\n  /**\n   * A useful function to deal with inheritance. It will make the target\n   * inherit the prototype of the class dispatcher as well as its constructor.\n   *\n   * @param {object} target The target.\n   */\n  dispatcher.extend = function(target, args) {\n    var k;\n\n    for (k in dispatcher.prototype)\n      if (dispatcher.prototype.hasOwnProperty(k))\n        target[k] = dispatcher.prototype[k];\n\n    dispatcher.apply(target, args);\n  };\n\n\n\n\n  /**\n   * EXPORT:\n   * *******\n   */\n  if (typeof this.sigma !== 'undefined') {\n    this.sigma.classes = this.sigma.classes || {};\n    this.sigma.classes.dispatcher = dispatcher;\n  } else if (true) {\n    if ( true && module.exports)\n      exports = module.exports = dispatcher;\n    exports.dispatcher = dispatcher;\n  } else\n    {}\n}).call(this);\n\n;(function() {\n  'use strict';\n\n  /**\n   * This utils aims to facilitate the manipulation of each instance setting.\n   * Using a function instead of an object brings two main advantages: First,\n   * it will be easier in the future to catch settings updates through a\n   * function than an object. Second, giving it a full object will \"merge\" it\n   * to the settings object properly, keeping us to have to always add a loop.\n   *\n   * @return {configurable} The \"settings\" function.\n   */\n  var configurable = function() {\n    var i,\n        l,\n        data = {},\n        datas = Array.prototype.slice.call(arguments, 0);\n\n    /**\n     * The method to use to set or get any property of this instance.\n     *\n     * @param  {string|object}    a1 If it is a string and if a2 is undefined,\n     *                               then it will return the corresponding\n     *                               property. If it is a string and if a2 is\n     *                               set, then it will set a2 as the property\n     *                               corresponding to a1, and return this. If\n     *                               it is an object, then each pair string +\n     *                               object(or any other type) will be set as a\n     *                               property.\n     * @param  {*?}               a2 The new property corresponding to a1 if a1\n     *                               is a string.\n     * @return {*|configurable}      Returns itself or the corresponding\n     *                               property.\n     *\n     * Polymorphism:\n     * *************\n     * Here are some basic use examples:\n     *\n     *  > settings = new configurable();\n     *  > settings('mySetting', 42);\n     *  > settings('mySetting'); // Logs: 42\n     *  > settings('mySetting', 123);\n     *  > settings('mySetting'); // Logs: 123\n     *  > settings({mySetting: 456});\n     *  > settings('mySetting'); // Logs: 456\n     *\n     * Also, it is possible to use the function as a fallback:\n     *  > settings({mySetting: 'abc'}, 'mySetting');  // Logs: 'abc'\n     *  > settings({hisSetting: 'abc'}, 'mySetting'); // Logs: 456\n     */\n    var settings = function(a1, a2) {\n      var o,\n          i,\n          l,\n          k;\n\n      if (arguments.length === 1 && typeof a1 === 'string') {\n        if (data[a1] !== undefined)\n          return data[a1];\n        for (i = 0, l = datas.length; i < l; i++)\n          if (datas[i][a1] !== undefined)\n            return datas[i][a1];\n        return undefined;\n      } else if (typeof a1 === 'object' && typeof a2 === 'string') {\n        return (a1 || {})[a2] !== undefined ? a1[a2] : settings(a2);\n      } else {\n        o = (typeof a1 === 'object' && a2 === undefined) ? a1 : {};\n\n        if (typeof a1 === 'string')\n          o[a1] = a2;\n\n        for (i = 0, k = Object.keys(o), l = k.length; i < l; i++)\n          data[k[i]] = o[k[i]];\n\n        return this;\n      }\n    };\n\n    /**\n     * This method returns a new configurable function, with new objects\n     *\n     * @param  {object*}  Any number of objects to search in.\n     * @return {function} Returns the function. Check its documentation to know\n     *                    more about how it works.\n     */\n    settings.embedObjects = function() {\n      var args = datas.concat(\n        data\n      ).concat(\n        Array.prototype.splice.call(arguments, 0)\n      );\n\n      return configurable.apply({}, args);\n    };\n\n    // Initialize\n    for (i = 0, l = arguments.length; i < l; i++)\n      settings(arguments[i]);\n\n    return settings;\n  };\n\n  /**\n   * EXPORT:\n   * *******\n   */\n  if (typeof this.sigma !== 'undefined') {\n    this.sigma.classes = this.sigma.classes || {};\n    this.sigma.classes.configurable = configurable;\n  } else if (true) {\n    if ( true && module.exports)\n      exports = module.exports = configurable;\n    exports.configurable = configurable;\n  } else\n    {}\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  var _methods = Object.create(null),\n      _indexes = Object.create(null),\n      _initBindings = Object.create(null),\n      _methodBindings = Object.create(null),\n      _methodBeforeBindings = Object.create(null),\n      _defaultSettings = {\n        immutable: true,\n        clone: true\n      },\n      _defaultSettingsFunction = function(key) {\n        return _defaultSettings[key];\n      };\n\n  /**\n   * The graph constructor. It initializes the data and the indexes, and binds\n   * the custom indexes and methods to its own scope.\n   *\n   * Recognized parameters:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters in the settings\n   * object:\n   *\n   *   {boolean} clone     Indicates if the data have to be cloned in methods\n   *                       to add nodes or edges.\n   *   {boolean} immutable Indicates if nodes \"id\" values and edges \"id\",\n   *                       \"source\" and \"target\" values must be set as\n   *                       immutable.\n   *\n   * @param  {?configurable} settings Eventually a settings function.\n   * @return {graph}                  The new graph instance.\n   */\n  var graph = function(settings) {\n    var k,\n        fn,\n        data;\n\n    /**\n     * DATA:\n     * *****\n     * Every data that is callable from graph methods are stored in this \"data\"\n     * object. This object will be served as context for all these methods,\n     * and it is possible to add other type of data in it.\n     */\n    data = {\n      /**\n       * SETTINGS FUNCTION:\n       * ******************\n       */\n      settings: settings || _defaultSettingsFunction,\n\n      /**\n       * MAIN DATA:\n       * **********\n       */\n      nodesArray: [],\n      edgesArray: [],\n\n      /**\n       * GLOBAL INDEXES:\n       * ***************\n       * These indexes just index data by ids.\n       */\n      nodesIndex: Object.create(null),\n      edgesIndex: Object.create(null),\n\n      /**\n       * LOCAL INDEXES:\n       * **************\n       * These indexes refer from node to nodes. Each key is an id, and each\n       * value is the array of the ids of related nodes.\n       */\n      inNeighborsIndex: Object.create(null),\n      outNeighborsIndex: Object.create(null),\n      allNeighborsIndex: Object.create(null),\n\n      inNeighborsCount: Object.create(null),\n      outNeighborsCount: Object.create(null),\n      allNeighborsCount: Object.create(null)\n    };\n\n    // Execute bindings:\n    for (k in _initBindings)\n      _initBindings[k].call(data);\n\n    // Add methods to both the scope and the data objects:\n    for (k in _methods) {\n      fn = __bindGraphMethod(k, data, _methods[k]);\n      this[k] = fn;\n      data[k] = fn;\n    }\n  };\n\n\n\n\n  /**\n   * A custom tool to bind methods such that function that are bound to it will\n   * be executed anytime the method is called.\n   *\n   * @param  {string}   methodName The name of the method to bind.\n   * @param  {object}   scope      The scope where the method must be executed.\n   * @param  {function} fn         The method itself.\n   * @return {function}            The new method.\n   */\n  function __bindGraphMethod(methodName, scope, fn) {\n    var result = function() {\n      var k,\n          res;\n\n      // Execute \"before\" bound functions:\n      for (k in _methodBeforeBindings[methodName])\n        _methodBeforeBindings[methodName][k].apply(scope, arguments);\n\n      // Apply the method:\n      res = fn.apply(scope, arguments);\n\n      // Execute bound functions:\n      for (k in _methodBindings[methodName])\n        _methodBindings[methodName][k].apply(scope, arguments);\n\n      // Return res:\n      return res;\n    };\n\n    return result;\n  }\n\n  /**\n   * This custom tool function removes every pair key/value from an hash. The\n   * goal is to avoid creating a new object while some other references are\n   * still hanging in some scopes...\n   *\n   * @param  {object} obj The object to empty.\n   * @return {object}     The empty object.\n   */\n  function __emptyObject(obj) {\n    var k;\n\n    for (k in obj)\n      if (!('hasOwnProperty' in obj) || obj.hasOwnProperty(k))\n        delete obj[k];\n\n    return obj;\n  }\n\n\n\n\n  /**\n   * This global method adds a method that will be bound to the futurly created\n   * graph instances.\n   *\n   * Since these methods will be bound to their scope when the instances are\n   * created, it does not use the prototype. Because of that, methods have to\n   * be added before instances are created to make them available.\n   *\n   * Here is an example:\n   *\n   *  > graph.addMethod('getNodesCount', function() {\n   *  >   return this.nodesArray.length;\n   *  > });\n   *  >\n   *  > var myGraph = new graph();\n   *  > console.log(myGraph.getNodesCount()); // outputs 0\n   *\n   * @param  {string}   methodName The name of the method.\n   * @param  {function} fn         The method itself.\n   * @return {object}              The global graph constructor.\n   */\n  graph.addMethod = function(methodName, fn) {\n    if (\n      typeof methodName !== 'string' ||\n      typeof fn !== 'function' ||\n      arguments.length !== 2\n    )\n      throw 'addMethod: Wrong arguments.';\n\n    if (_methods[methodName] || graph[methodName])\n      throw 'The method \"' + methodName + '\" already exists.';\n\n    _methods[methodName] = fn;\n    _methodBindings[methodName] = Object.create(null);\n    _methodBeforeBindings[methodName] = Object.create(null);\n\n    return this;\n  };\n\n  /**\n   * This global method returns true if the method has already been added, and\n   * false else.\n   *\n   * Here are some examples:\n   *\n   *  > graph.hasMethod('addNode'); // returns true\n   *  > graph.hasMethod('hasMethod'); // returns true\n   *  > graph.hasMethod('unexistingMethod'); // returns false\n   *\n   * @param  {string}  methodName The name of the method.\n   * @return {boolean}            The result.\n   */\n  graph.hasMethod = function(methodName) {\n    return !!(_methods[methodName] || graph[methodName]);\n  };\n\n  /**\n   * This global methods attaches a function to a method. Anytime the specified\n   * method is called, the attached function is called right after, with the\n   * same arguments and in the same scope. The attached function is called\n   * right before if the last argument is true, unless the method is the graph\n   * constructor.\n   *\n   * To attach a function to the graph constructor, use 'constructor' as the\n   * method name (first argument).\n   *\n   * The main idea is to have a clean way to keep custom indexes up to date,\n   * for instance:\n   *\n   *  > var timesAddNodeCalled = 0;\n   *  > graph.attach('addNode', 'timesAddNodeCalledInc', function() {\n   *  >   timesAddNodeCalled++;\n   *  > });\n   *  >\n   *  > var myGraph = new graph();\n   *  > console.log(timesAddNodeCalled); // outputs 0\n   *  >\n   *  > myGraph.addNode({ id: '1' }).addNode({ id: '2' });\n   *  > console.log(timesAddNodeCalled); // outputs 2\n   *\n   * The idea for calling a function before is to provide pre-processors, for\n   * instance:\n   *\n   *  > var colorPalette = { Person: '#C3CBE1', Place: '#9BDEBD' };\n   *  > graph.attach('addNode', 'applyNodeColorPalette', function(n) {\n   *  >   n.color = colorPalette[n.category];\n   *  > }, true);\n   *  >\n   *  > var myGraph = new graph();\n   *  > myGraph.addNode({ id: 'n0', category: 'Person' });\n   *  > console.log(myGraph.nodes('n0').color); // outputs '#C3CBE1'\n   *\n   * @param  {string}   methodName The name of the related method or\n   *                               \"constructor\".\n   * @param  {string}   key        The key to identify the function to attach.\n   * @param  {function} fn         The function to bind.\n   * @param  {boolean}  before     If true the function is called right before.\n   * @return {object}              The global graph constructor.\n   */\n  graph.attach = function(methodName, key, fn, before) {\n    if (\n      typeof methodName !== 'string' ||\n      typeof key !== 'string' ||\n      typeof fn !== 'function' ||\n      arguments.length < 3 ||\n      arguments.length > 4\n    )\n      throw 'attach: Wrong arguments.';\n\n    var bindings;\n\n    if (methodName === 'constructor')\n      bindings = _initBindings;\n    else {\n      if (before) {\n        if (!_methodBeforeBindings[methodName])\n        throw 'The method \"' + methodName + '\" does not exist.';\n\n        bindings = _methodBeforeBindings[methodName];\n      }\n      else {\n        if (!_methodBindings[methodName])\n          throw 'The method \"' + methodName + '\" does not exist.';\n\n        bindings = _methodBindings[methodName];\n      }\n    }\n\n    if (bindings[key])\n      throw 'A function \"' + key + '\" is already attached ' +\n            'to the method \"' + methodName + '\".';\n\n    bindings[key] = fn;\n\n    return this;\n  };\n\n  /**\n   * Alias of attach(methodName, key, fn, true).\n   */\n  graph.attachBefore = function(methodName, key, fn) {\n    return this.attach(methodName, key, fn, true);\n  };\n\n  /**\n   * This methods is just an helper to deal with custom indexes. It takes as\n   * arguments the name of the index and an object containing all the different\n   * functions to bind to the methods.\n   *\n   * Here is a basic example, that creates an index to keep the number of nodes\n   * in the current graph. It also adds a method to provide a getter on that\n   * new index:\n   *\n   *  > sigma.classes.graph.addIndex('nodesCount', {\n   *  >   constructor: function() {\n   *  >     this.nodesCount = 0;\n   *  >   },\n   *  >   addNode: function() {\n   *  >     this.nodesCount++;\n   *  >   },\n   *  >   dropNode: function() {\n   *  >     this.nodesCount--;\n   *  >   }\n   *  > });\n   *  >\n   *  > sigma.classes.graph.addMethod('getNodesCount', function() {\n   *  >   return this.nodesCount;\n   *  > });\n   *  >\n   *  > var myGraph = new sigma.classes.graph();\n   *  > console.log(myGraph.getNodesCount()); // outputs 0\n   *  >\n   *  > myGraph.addNode({ id: '1' }).addNode({ id: '2' });\n   *  > console.log(myGraph.getNodesCount()); // outputs 2\n   *\n   * @param  {string} name     The name of the index.\n   * @param  {object} bindings The object containing the functions to bind.\n   * @return {object}          The global graph constructor.\n   */\n  graph.addIndex = function(name, bindings) {\n    if (\n      typeof name !== 'string' ||\n      Object(bindings) !== bindings ||\n      arguments.length !== 2\n    )\n      throw 'addIndex: Wrong arguments.';\n\n    if (_indexes[name])\n      throw 'The index \"' + name + '\" already exists.';\n\n    var k;\n\n    // Store the bindings:\n    _indexes[name] = bindings;\n\n    // Attach the bindings:\n    for (k in bindings)\n      if (typeof bindings[k] !== 'function')\n        throw 'The bindings must be functions.';\n      else\n        graph.attach(k, name, bindings[k]);\n\n    return this;\n  };\n\n\n\n\n  /**\n   * This method adds a node to the graph. The node must be an object, with a\n   * string under the key \"id\". Except for this, it is possible to add any\n   * other attribute, that will be preserved all along the manipulations.\n   *\n   * If the graph option \"clone\" has a truthy value, the node will be cloned\n   * when added to the graph. Also, if the graph option \"immutable\" has a\n   * truthy value, its id will be defined as immutable.\n   *\n   * @param  {object} node The node to add.\n   * @return {object}      The graph instance.\n   */\n  graph.addMethod('addNode', function(node) {\n    // Check that the node is an object and has an id:\n    if (Object(node) !== node || arguments.length !== 1)\n      throw 'addNode: Wrong arguments.';\n\n    if (typeof node.id !== 'string' && typeof node.id !== 'number')\n      throw 'The node must have a string or number id.';\n\n    if (this.nodesIndex[node.id])\n      throw 'The node \"' + node.id + '\" already exists.';\n\n    var k,\n        id = node.id,\n        validNode = Object.create(null);\n\n    // Check the \"clone\" option:\n    if (this.settings('clone')) {\n      for (k in node)\n        if (k !== 'id')\n          validNode[k] = node[k];\n    } else\n      validNode = node;\n\n    // Check the \"immutable\" option:\n    if (this.settings('immutable'))\n      Object.defineProperty(validNode, 'id', {\n        value: id,\n        enumerable: true\n      });\n    else\n      validNode.id = id;\n\n    // Add empty containers for edges indexes:\n    this.inNeighborsIndex[id] = Object.create(null);\n    this.outNeighborsIndex[id] = Object.create(null);\n    this.allNeighborsIndex[id] = Object.create(null);\n\n    this.inNeighborsCount[id] = 0;\n    this.outNeighborsCount[id] = 0;\n    this.allNeighborsCount[id] = 0;\n\n    // Add the node to indexes:\n    this.nodesArray.push(validNode);\n    this.nodesIndex[validNode.id] = validNode;\n\n    // Return the current instance:\n    return this;\n  });\n\n  /**\n   * This method adds an edge to the graph. The edge must be an object, with a\n   * string under the key \"id\", and strings under the keys \"source\" and\n   * \"target\" that design existing nodes. Except for this, it is possible to\n   * add any other attribute, that will be preserved all along the\n   * manipulations.\n   *\n   * If the graph option \"clone\" has a truthy value, the edge will be cloned\n   * when added to the graph. Also, if the graph option \"immutable\" has a\n   * truthy value, its id, source and target will be defined as immutable.\n   *\n   * @param  {object} edge The edge to add.\n   * @return {object}      The graph instance.\n   */\n  graph.addMethod('addEdge', function(edge) {\n    // Check that the edge is an object and has an id:\n    if (Object(edge) !== edge || arguments.length !== 1)\n      throw 'addEdge: Wrong arguments.';\n\n    if (typeof edge.id !== 'string' && typeof edge.id !== 'number')\n      throw 'The edge must have a string or number id.';\n\n    if ((typeof edge.source !== 'string' && typeof edge.source !== 'number') ||\n        !this.nodesIndex[edge.source])\n      throw 'The edge source must have an existing node id.';\n\n    if ((typeof edge.target !== 'string' && typeof edge.target !== 'number') ||\n        !this.nodesIndex[edge.target])\n      throw 'The edge target must have an existing node id.';\n\n    if (this.edgesIndex[edge.id])\n      throw 'The edge \"' + edge.id + '\" already exists.';\n\n    var k,\n        validEdge = Object.create(null);\n\n    // Check the \"clone\" option:\n    if (this.settings('clone')) {\n      for (k in edge)\n        if (k !== 'id' && k !== 'source' && k !== 'target')\n          validEdge[k] = edge[k];\n    } else\n      validEdge = edge;\n\n    // Check the \"immutable\" option:\n    if (this.settings('immutable')) {\n      Object.defineProperty(validEdge, 'id', {\n        value: edge.id,\n        enumerable: true\n      });\n\n      Object.defineProperty(validEdge, 'source', {\n        value: edge.source,\n        enumerable: true\n      });\n\n      Object.defineProperty(validEdge, 'target', {\n        value: edge.target,\n        enumerable: true\n      });\n    } else {\n      validEdge.id = edge.id;\n      validEdge.source = edge.source;\n      validEdge.target = edge.target;\n    }\n\n    // Add the edge to indexes:\n    this.edgesArray.push(validEdge);\n    this.edgesIndex[validEdge.id] = validEdge;\n\n    if (!this.inNeighborsIndex[validEdge.target][validEdge.source])\n      this.inNeighborsIndex[validEdge.target][validEdge.source] =\n        Object.create(null);\n    this.inNeighborsIndex[validEdge.target][validEdge.source][validEdge.id] =\n      validEdge;\n\n    if (!this.outNeighborsIndex[validEdge.source][validEdge.target])\n      this.outNeighborsIndex[validEdge.source][validEdge.target] =\n        Object.create(null);\n    this.outNeighborsIndex[validEdge.source][validEdge.target][validEdge.id] =\n      validEdge;\n\n    if (!this.allNeighborsIndex[validEdge.source][validEdge.target])\n      this.allNeighborsIndex[validEdge.source][validEdge.target] =\n        Object.create(null);\n    this.allNeighborsIndex[validEdge.source][validEdge.target][validEdge.id] =\n      validEdge;\n\n    if (validEdge.target !== validEdge.source) {\n      if (!this.allNeighborsIndex[validEdge.target][validEdge.source])\n        this.allNeighborsIndex[validEdge.target][validEdge.source] =\n          Object.create(null);\n      this.allNeighborsIndex[validEdge.target][validEdge.source][validEdge.id] =\n        validEdge;\n    }\n\n    // Keep counts up to date:\n    this.inNeighborsCount[validEdge.target]++;\n    this.outNeighborsCount[validEdge.source]++;\n    this.allNeighborsCount[validEdge.target]++;\n    this.allNeighborsCount[validEdge.source]++;\n\n    return this;\n  });\n\n  /**\n   * This method drops a node from the graph. It also removes each edge that is\n   * bound to it, through the dropEdge method. An error is thrown if the node\n   * does not exist.\n   *\n   * @param  {string} id The node id.\n   * @return {object}    The graph instance.\n   */\n  graph.addMethod('dropNode', function(id) {\n    // Check that the arguments are valid:\n    if ((typeof id !== 'string' && typeof id !== 'number') ||\n        arguments.length !== 1)\n      throw 'dropNode: Wrong arguments.';\n\n    if (!this.nodesIndex[id])\n      throw 'The node \"' + id + '\" does not exist.';\n\n    var i, k, l;\n\n    // Remove the node from indexes:\n    delete this.nodesIndex[id];\n    for (i = 0, l = this.nodesArray.length; i < l; i++)\n      if (this.nodesArray[i].id === id) {\n        this.nodesArray.splice(i, 1);\n        break;\n      }\n\n    // Remove related edges:\n    for (i = this.edgesArray.length - 1; i >= 0; i--)\n      if (this.edgesArray[i].source === id || this.edgesArray[i].target === id)\n        this.dropEdge(this.edgesArray[i].id);\n\n    // Remove related edge indexes:\n    delete this.inNeighborsIndex[id];\n    delete this.outNeighborsIndex[id];\n    delete this.allNeighborsIndex[id];\n\n    delete this.inNeighborsCount[id];\n    delete this.outNeighborsCount[id];\n    delete this.allNeighborsCount[id];\n\n    for (k in this.nodesIndex) {\n      delete this.inNeighborsIndex[k][id];\n      delete this.outNeighborsIndex[k][id];\n      delete this.allNeighborsIndex[k][id];\n    }\n\n    return this;\n  });\n\n  /**\n   * This method drops an edge from the graph. An error is thrown if the edge\n   * does not exist.\n   *\n   * @param  {string} id The edge id.\n   * @return {object}    The graph instance.\n   */\n  graph.addMethod('dropEdge', function(id) {\n    // Check that the arguments are valid:\n    if ((typeof id !== 'string' && typeof id !== 'number') ||\n        arguments.length !== 1)\n      throw 'dropEdge: Wrong arguments.';\n\n    if (!this.edgesIndex[id])\n      throw 'The edge \"' + id + '\" does not exist.';\n\n    var i, l, edge;\n\n    // Remove the edge from indexes:\n    edge = this.edgesIndex[id];\n    delete this.edgesIndex[id];\n    for (i = 0, l = this.edgesArray.length; i < l; i++)\n      if (this.edgesArray[i].id === id) {\n        this.edgesArray.splice(i, 1);\n        break;\n      }\n\n    delete this.inNeighborsIndex[edge.target][edge.source][edge.id];\n    if (!Object.keys(this.inNeighborsIndex[edge.target][edge.source]).length)\n      delete this.inNeighborsIndex[edge.target][edge.source];\n\n    delete this.outNeighborsIndex[edge.source][edge.target][edge.id];\n    if (!Object.keys(this.outNeighborsIndex[edge.source][edge.target]).length)\n      delete this.outNeighborsIndex[edge.source][edge.target];\n\n    delete this.allNeighborsIndex[edge.source][edge.target][edge.id];\n    if (!Object.keys(this.allNeighborsIndex[edge.source][edge.target]).length)\n      delete this.allNeighborsIndex[edge.source][edge.target];\n\n    if (edge.target !== edge.source) {\n      delete this.allNeighborsIndex[edge.target][edge.source][edge.id];\n      if (!Object.keys(this.allNeighborsIndex[edge.target][edge.source]).length)\n        delete this.allNeighborsIndex[edge.target][edge.source];\n    }\n\n    this.inNeighborsCount[edge.target]--;\n    this.outNeighborsCount[edge.source]--;\n    this.allNeighborsCount[edge.source]--;\n    this.allNeighborsCount[edge.target]--;\n\n    return this;\n  });\n\n  /**\n   * This method destroys the current instance. It basically empties each index\n   * and methods attached to the graph.\n   */\n  graph.addMethod('kill', function() {\n    // Delete arrays:\n    this.nodesArray.length = 0;\n    this.edgesArray.length = 0;\n    delete this.nodesArray;\n    delete this.edgesArray;\n\n    // Delete indexes:\n    delete this.nodesIndex;\n    delete this.edgesIndex;\n    delete this.inNeighborsIndex;\n    delete this.outNeighborsIndex;\n    delete this.allNeighborsIndex;\n    delete this.inNeighborsCount;\n    delete this.outNeighborsCount;\n    delete this.allNeighborsCount;\n  });\n\n  /**\n   * This method empties the nodes and edges arrays, as well as the different\n   * indexes.\n   *\n   * @return {object} The graph instance.\n   */\n  graph.addMethod('clear', function() {\n    this.nodesArray.length = 0;\n    this.edgesArray.length = 0;\n\n    // Due to GC issues, I prefer not to create new object. These objects are\n    // only available from the methods and attached functions, but still, it is\n    // better to prevent ghost references to unrelevant data...\n    __emptyObject(this.nodesIndex);\n    __emptyObject(this.edgesIndex);\n    __emptyObject(this.nodesIndex);\n    __emptyObject(this.inNeighborsIndex);\n    __emptyObject(this.outNeighborsIndex);\n    __emptyObject(this.allNeighborsIndex);\n    __emptyObject(this.inNeighborsCount);\n    __emptyObject(this.outNeighborsCount);\n    __emptyObject(this.allNeighborsCount);\n\n    return this;\n  });\n\n  /**\n   * This method reads an object and adds the nodes and edges, through the\n   * proper methods \"addNode\" and \"addEdge\".\n   *\n   * Here is an example:\n   *\n   *  > var myGraph = new graph();\n   *  > myGraph.read({\n   *  >   nodes: [\n   *  >     { id: 'n0' },\n   *  >     { id: 'n1' }\n   *  >   ],\n   *  >   edges: [\n   *  >     {\n   *  >       id: 'e0',\n   *  >       source: 'n0',\n   *  >       target: 'n1'\n   *  >     }\n   *  >   ]\n   *  > });\n   *  >\n   *  > console.log(\n   *  >   myGraph.nodes().length,\n   *  >   myGraph.edges().length\n   *  > ); // outputs 2 1\n   *\n   * @param  {object} g The graph object.\n   * @return {object}   The graph instance.\n   */\n  graph.addMethod('read', function(g) {\n    var i,\n        a,\n        l;\n\n    a = g.nodes || [];\n    for (i = 0, l = a.length; i < l; i++)\n      this.addNode(a[i]);\n\n    a = g.edges || [];\n    for (i = 0, l = a.length; i < l; i++)\n      this.addEdge(a[i]);\n\n    return this;\n  });\n\n  /**\n   * This methods returns one or several nodes, depending on how it is called.\n   *\n   * To get the array of nodes, call \"nodes\" without argument. To get a\n   * specific node, call it with the id of the node. The get multiple node,\n   * call it with an array of ids, and it will return the array of nodes, in\n   * the same order.\n   *\n   * @param  {?(string|array)} v Eventually one id, an array of ids.\n   * @return {object|array}      The related node or array of nodes.\n   */\n  graph.addMethod('nodes', function(v) {\n    // Clone the array of nodes and return it:\n    if (!arguments.length)\n      return this.nodesArray.slice(0);\n\n    // Return the related node:\n    if (arguments.length === 1 &&\n        (typeof v === 'string' || typeof v === 'number'))\n      return this.nodesIndex[v];\n\n    // Return an array of the related node:\n    if (\n      arguments.length === 1 &&\n      Object.prototype.toString.call(v) === '[object Array]'\n    ) {\n      var i,\n          l,\n          a = [];\n\n      for (i = 0, l = v.length; i < l; i++)\n        if (typeof v[i] === 'string' || typeof v[i] === 'number')\n          a.push(this.nodesIndex[v[i]]);\n        else\n          throw 'nodes: Wrong arguments.';\n\n      return a;\n    }\n\n    throw 'nodes: Wrong arguments.';\n  });\n\n  /**\n   * This methods returns the degree of one or several nodes, depending on how\n   * it is called. It is also possible to get incoming or outcoming degrees\n   * instead by specifying 'in' or 'out' as a second argument.\n   *\n   * @param  {string|array} v     One id, an array of ids.\n   * @param  {?string}      which Which degree is required. Values are 'in',\n   *                              'out', and by default the normal degree.\n   * @return {number|array}       The related degree or array of degrees.\n   */\n  graph.addMethod('degree', function(v, which) {\n    // Check which degree is required:\n    which = {\n      'in': this.inNeighborsCount,\n      'out': this.outNeighborsCount\n    }[which || ''] || this.allNeighborsCount;\n\n    // Return the related node:\n    if (typeof v === 'string' || typeof v === 'number')\n      return which[v];\n\n    // Return an array of the related node:\n    if (Object.prototype.toString.call(v) === '[object Array]') {\n      var i,\n          l,\n          a = [];\n\n      for (i = 0, l = v.length; i < l; i++)\n        if (typeof v[i] === 'string' || typeof v[i] === 'number')\n          a.push(which[v[i]]);\n        else\n          throw 'degree: Wrong arguments.';\n\n      return a;\n    }\n\n    throw 'degree: Wrong arguments.';\n  });\n\n  /**\n   * This methods returns one or several edges, depending on how it is called.\n   *\n   * To get the array of edges, call \"edges\" without argument. To get a\n   * specific edge, call it with the id of the edge. The get multiple edge,\n   * call it with an array of ids, and it will return the array of edges, in\n   * the same order.\n   *\n   * @param  {?(string|array)} v Eventually one id, an array of ids.\n   * @return {object|array}      The related edge or array of edges.\n   */\n  graph.addMethod('edges', function(v) {\n    // Clone the array of edges and return it:\n    if (!arguments.length)\n      return this.edgesArray.slice(0);\n\n    // Return the related edge:\n    if (arguments.length === 1 &&\n        (typeof v === 'string' || typeof v === 'number'))\n      return this.edgesIndex[v];\n\n    // Return an array of the related edge:\n    if (\n      arguments.length === 1 &&\n      Object.prototype.toString.call(v) === '[object Array]'\n    ) {\n      var i,\n          l,\n          a = [];\n\n      for (i = 0, l = v.length; i < l; i++)\n        if (typeof v[i] === 'string' || typeof v[i] === 'number')\n          a.push(this.edgesIndex[v[i]]);\n        else\n          throw 'edges: Wrong arguments.';\n\n      return a;\n    }\n\n    throw 'edges: Wrong arguments.';\n  });\n\n\n  /**\n   * EXPORT:\n   * *******\n   */\n  if (typeof sigma !== 'undefined') {\n    sigma.classes = sigma.classes || Object.create(null);\n    sigma.classes.graph = graph;\n  } else if (true) {\n    if ( true && module.exports)\n      exports = module.exports = graph;\n    exports.graph = graph;\n  } else\n    {}\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  sigma.utils.pkg('sigma.classes');\n\n  /**\n   * The camera constructor. It just initializes its attributes and methods.\n   *\n   * @param  {string}       id       The id.\n   * @param  {sigma.classes.graph}  graph    The graph.\n   * @param  {configurable} settings The settings function.\n   * @param  {?object}      options  Eventually some overriding options.\n   * @return {camera}                Returns the fresh new camera instance.\n   */\n  sigma.classes.camera = function(id, graph, settings, options) {\n    sigma.classes.dispatcher.extend(this);\n\n    Object.defineProperty(this, 'graph', {\n      value: graph\n    });\n    Object.defineProperty(this, 'id', {\n      value: id\n    });\n    Object.defineProperty(this, 'readPrefix', {\n      value: 'read_cam' + id + ':'\n    });\n    Object.defineProperty(this, 'prefix', {\n      value: 'cam' + id + ':'\n    });\n\n    this.x = 0;\n    this.y = 0;\n    this.ratio = 1;\n    this.angle = 0;\n    this.isAnimated = false;\n    this.settings = (typeof options === 'object' && options) ?\n      settings.embedObject(options) :\n      settings;\n  };\n\n  /**\n   * Updates the camera position.\n   *\n   * @param  {object} coordinates The new coordinates object.\n   * @return {camera}             Returns the camera.\n   */\n  sigma.classes.camera.prototype.goTo = function(coordinates) {\n    if (!this.settings('enableCamera'))\n      return this;\n\n    var i,\n        l,\n        c = coordinates || {},\n        keys = ['x', 'y', 'ratio', 'angle'];\n\n    for (i = 0, l = keys.length; i < l; i++)\n      if (c[keys[i]] !== undefined) {\n        if (typeof c[keys[i]] === 'number' && !isNaN(c[keys[i]]))\n          this[keys[i]] = c[keys[i]];\n        else\n          throw 'Value for \"' + keys[i] + '\" is not a number.';\n      }\n\n    this.dispatchEvent('coordinatesUpdated');\n    return this;\n  };\n\n  /**\n   * This method takes a graph and computes for each node and edges its\n   * coordinates relatively to the center of the camera. Basically, it will\n   * compute the coordinates that will be used by the graphic renderers.\n   *\n   * Since it should be possible to use different cameras and different\n   * renderers, it is possible to specify a prefix to put before the new\n   * coordinates (to get something like \"node.camera1_x\")\n   *\n   * @param  {?string} read    The prefix of the coordinates to read.\n   * @param  {?string} write   The prefix of the coordinates to write.\n   * @param  {?object} options Eventually an object of options. Those can be:\n   *                           - A restricted nodes array.\n   *                           - A restricted edges array.\n   *                           - A width.\n   *                           - A height.\n   * @return {camera}        Returns the camera.\n   */\n  sigma.classes.camera.prototype.applyView = function(read, write, options) {\n    options = options || {};\n    write = write !== undefined ? write : this.prefix;\n    read = read !== undefined ? read : this.readPrefix;\n\n    var nodes = options.nodes || this.graph.nodes(),\n        edges = options.edges || this.graph.edges();\n\n    var i,\n        l,\n        node,\n        relCos = Math.cos(this.angle) / this.ratio,\n        relSin = Math.sin(this.angle) / this.ratio,\n        nodeRatio = Math.pow(this.ratio, this.settings('nodesPowRatio')),\n        edgeRatio = Math.pow(this.ratio, this.settings('edgesPowRatio')),\n        xOffset = (options.width || 0) / 2 - this.x * relCos - this.y * relSin,\n        yOffset = (options.height || 0) / 2 - this.y * relCos + this.x * relSin;\n\n    for (i = 0, l = nodes.length; i < l; i++) {\n      node = nodes[i];\n      node[write + 'x'] =\n        (node[read + 'x'] || 0) * relCos +\n        (node[read + 'y'] || 0) * relSin +\n        xOffset;\n      node[write + 'y'] =\n        (node[read + 'y'] || 0) * relCos -\n        (node[read + 'x'] || 0) * relSin +\n        yOffset;\n      node[write + 'size'] =\n        (node[read + 'size'] || 0) /\n        nodeRatio;\n    }\n\n    for (i = 0, l = edges.length; i < l; i++) {\n      edges[i][write + 'size'] =\n        (edges[i][read + 'size'] || 0) /\n        edgeRatio;\n    }\n\n    return this;\n  };\n\n  /**\n   * This function converts the coordinates of a point from the frame of the\n   * camera to the frame of the graph.\n   *\n   * @param  {number} x The X coordinate of the point in the frame of the\n   *                    camera.\n   * @param  {number} y The Y coordinate of the point in the frame of the\n   *                    camera.\n   * @return {object}   The point coordinates in the frame of the graph.\n   */\n  sigma.classes.camera.prototype.graphPosition = function(x, y, vector) {\n    var X = 0,\n        Y = 0,\n        cos = Math.cos(this.angle),\n        sin = Math.sin(this.angle);\n\n    // Revert the origin differential vector:\n    if (!vector) {\n      X = - (this.x * cos + this.y * sin) / this.ratio;\n      Y = - (this.y * cos - this.x * sin) / this.ratio;\n    }\n\n    return {\n      x: (x * cos + y * sin) / this.ratio + X,\n      y: (y * cos - x * sin) / this.ratio + Y\n    };\n  };\n\n  /**\n   * This function converts the coordinates of a point from the frame of the\n   * graph to the frame of the camera.\n   *\n   * @param  {number} x The X coordinate of the point in the frame of the\n   *                    graph.\n   * @param  {number} y The Y coordinate of the point in the frame of the\n   *                    graph.\n   * @return {object}   The point coordinates in the frame of the camera.\n   */\n  sigma.classes.camera.prototype.cameraPosition = function(x, y, vector) {\n    var X = 0,\n        Y = 0,\n        cos = Math.cos(this.angle),\n        sin = Math.sin(this.angle);\n\n    // Revert the origin differential vector:\n    if (!vector) {\n      X = - (this.x * cos + this.y * sin) / this.ratio;\n      Y = - (this.y * cos - this.x * sin) / this.ratio;\n    }\n\n    return {\n      x: ((x - X) * cos - (y - Y) * sin) * this.ratio,\n      y: ((y - Y) * cos + (x - X) * sin) * this.ratio\n    };\n  };\n\n  /**\n   * This method returns the transformation matrix of the camera. This is\n   * especially useful to apply the camera view directly in shaders, in case of\n   * WebGL rendering.\n   *\n   * @return {array} The transformation matrix.\n   */\n  sigma.classes.camera.prototype.getMatrix = function() {\n    var scale = sigma.utils.matrices.scale(1 / this.ratio),\n        rotation = sigma.utils.matrices.rotation(this.angle),\n        translation = sigma.utils.matrices.translation(-this.x, -this.y),\n        matrix = sigma.utils.matrices.multiply(\n          translation,\n          sigma.utils.matrices.multiply(\n            rotation,\n            scale\n          )\n        );\n\n    return matrix;\n  };\n\n  /**\n   * Taking a width and a height as parameters, this method returns the\n   * coordinates of the rectangle representing the camera on screen, in the\n   * graph's referentiel.\n   *\n   * To keep displaying labels of nodes going out of the screen, the method\n   * keeps a margin around the screen in the returned rectangle.\n   *\n   * @param  {number} width  The width of the screen.\n   * @param  {number} height The height of the screen.\n   * @return {object}        The rectangle as x1, y1, x2 and y2, representing\n   *                         two opposite points.\n   */\n  sigma.classes.camera.prototype.getRectangle = function(width, height) {\n    var widthVect = this.cameraPosition(width, 0, true),\n        heightVect = this.cameraPosition(0, height, true),\n        centerVect = this.cameraPosition(width / 2, height / 2, true),\n        marginX = this.cameraPosition(width / 4, 0, true).x,\n        marginY = this.cameraPosition(0, height / 4, true).y;\n\n    return {\n      x1: this.x - centerVect.x - marginX,\n      y1: this.y - centerVect.y - marginY,\n      x2: this.x - centerVect.x + marginX + widthVect.x,\n      y2: this.y - centerVect.y - marginY + widthVect.y,\n      height: Math.sqrt(\n        Math.pow(heightVect.x, 2) +\n        Math.pow(heightVect.y + 2 * marginY, 2)\n      )\n    };\n  };\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  /**\n   * Sigma Quadtree Module\n   * =====================\n   *\n   * Author: Guillaume Plique (Yomguithereal)\n   * Version: 0.2\n   */\n\n\n\n  /**\n   * Quad Geometric Operations\n   * -------------------------\n   *\n   * A useful batch of geometric operations used by the quadtree.\n   */\n\n  var _geom = {\n\n    /**\n     * Transforms a graph node with x, y and size into an\n     * axis-aligned square.\n     *\n     * @param  {object} A graph node with at least a point (x, y) and a size.\n     * @return {object} A square: two points (x1, y1), (x2, y2) and height.\n     */\n    pointToSquare: function(n) {\n      return {\n        x1: n.x - n.size,\n        y1: n.y - n.size,\n        x2: n.x + n.size,\n        y2: n.y - n.size,\n        height: n.size * 2\n      };\n    },\n\n    /**\n     * Checks whether a rectangle is axis-aligned.\n     *\n     * @param  {object}  A rectangle defined by two points\n     *                   (x1, y1) and (x2, y2).\n     * @return {boolean} True if the rectangle is axis-aligned.\n     */\n    isAxisAligned: function(r) {\n      return r.x1 === r.x2 || r.y1 === r.y2;\n    },\n\n    /**\n     * Compute top points of an axis-aligned rectangle. This is useful in\n     * cases when the rectangle has been rotated (left, right or bottom up) and\n     * later operations need to know the top points.\n     *\n     * @param  {object} An axis-aligned rectangle defined by two points\n     *                  (x1, y1), (x2, y2) and height.\n     * @return {object} A rectangle: two points (x1, y1), (x2, y2) and height.\n     */\n    axisAlignedTopPoints: function(r) {\n\n      // Basic\n      if (r.y1 === r.y2 && r.x1 < r.x2)\n        return r;\n\n      // Rotated to right\n      if (r.x1 === r.x2 && r.y2 > r.y1)\n        return {\n          x1: r.x1 - r.height, y1: r.y1,\n          x2: r.x1, y2: r.y1,\n          height: r.height\n        };\n\n      // Rotated to left\n      if (r.x1 === r.x2 && r.y2 < r.y1)\n        return {\n          x1: r.x1, y1: r.y2,\n          x2: r.x2 + r.height, y2: r.y2,\n          height: r.height\n        };\n\n      // Bottom's up\n      return {\n        x1: r.x2, y1: r.y1 - r.height,\n        x2: r.x1, y2: r.y1 - r.height,\n        height: r.height\n      };\n    },\n\n    /**\n     * Get coordinates of a rectangle's lower left corner from its top points.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @return {object} Coordinates of the corner (x, y).\n     */\n    lowerLeftCoor: function(r) {\n      var width = (\n        Math.sqrt(\n          Math.pow(r.x2 - r.x1, 2) +\n          Math.pow(r.y2 - r.y1, 2)\n        )\n      );\n\n      return {\n        x: r.x1 - (r.y2 - r.y1) * r.height / width,\n        y: r.y1 + (r.x2 - r.x1) * r.height / width\n      };\n    },\n\n    /**\n     * Get coordinates of a rectangle's lower right corner from its top points\n     * and its lower left corner.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @param  {object} A corner's coordinates (x, y).\n     * @return {object} Coordinates of the corner (x, y).\n     */\n    lowerRightCoor: function(r, llc) {\n      return {\n        x: llc.x - r.x1 + r.x2,\n        y: llc.y - r.y1 + r.y2\n      };\n    },\n\n    /**\n     * Get the coordinates of all the corners of a rectangle from its top point.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @return {array}  An array of the four corners' coordinates (x, y).\n     */\n    rectangleCorners: function(r) {\n      var llc = this.lowerLeftCoor(r),\n          lrc = this.lowerRightCoor(r, llc);\n\n      return [\n        {x: r.x1, y: r.y1},\n        {x: r.x2, y: r.y2},\n        {x: llc.x, y: llc.y},\n        {x: lrc.x, y: lrc.y}\n      ];\n    },\n\n    /**\n     * Split a square defined by its boundaries into four.\n     *\n     * @param  {object} Boundaries of the square (x, y, width, height).\n     * @return {array}  An array containing the four new squares, themselves\n     *                  defined by an array of their four corners (x, y).\n     */\n    splitSquare: function(b) {\n      return [\n        [\n          {x: b.x, y: b.y},\n          {x: b.x + b.width / 2, y: b.y},\n          {x: b.x, y: b.y + b.height / 2},\n          {x: b.x + b.width / 2, y: b.y + b.height / 2}\n        ],\n        [\n          {x: b.x + b.width / 2, y: b.y},\n          {x: b.x + b.width, y: b.y},\n          {x: b.x + b.width / 2, y: b.y + b.height / 2},\n          {x: b.x + b.width, y: b.y + b.height / 2}\n        ],\n        [\n          {x: b.x, y: b.y + b.height / 2},\n          {x: b.x + b.width / 2, y: b.y + b.height / 2},\n          {x: b.x, y: b.y + b.height},\n          {x: b.x + b.width / 2, y: b.y + b.height}\n        ],\n        [\n          {x: b.x + b.width / 2, y: b.y + b.height / 2},\n          {x: b.x + b.width, y: b.y + b.height / 2},\n          {x: b.x + b.width / 2, y: b.y + b.height},\n          {x: b.x + b.width, y: b.y + b.height}\n        ]\n      ];\n    },\n\n    /**\n     * Compute the four axis between corners of rectangle A and corners of\n     * rectangle B. This is needed later to check an eventual collision.\n     *\n     * @param  {array} An array of rectangle A's four corners (x, y).\n     * @param  {array} An array of rectangle B's four corners (x, y).\n     * @return {array} An array of four axis defined by their coordinates (x,y).\n     */\n    axis: function(c1, c2) {\n      return [\n        {x: c1[1].x - c1[0].x, y: c1[1].y - c1[0].y},\n        {x: c1[1].x - c1[3].x, y: c1[1].y - c1[3].y},\n        {x: c2[0].x - c2[2].x, y: c2[0].y - c2[2].y},\n        {x: c2[0].x - c2[1].x, y: c2[0].y - c2[1].y}\n      ];\n    },\n\n    /**\n     * Project a rectangle's corner on an axis.\n     *\n     * @param  {object} Coordinates of a corner (x, y).\n     * @param  {object} Coordinates of an axis (x, y).\n     * @return {object} The projection defined by coordinates (x, y).\n     */\n    projection: function(c, a) {\n      var l = (\n        (c.x * a.x + c.y * a.y) /\n        (Math.pow(a.x, 2) + Math.pow(a.y, 2))\n      );\n\n      return {\n        x: l * a.x,\n        y: l * a.y\n      };\n    },\n\n    /**\n     * Check whether two rectangles collide on one particular axis.\n     *\n     * @param  {object}   An axis' coordinates (x, y).\n     * @param  {array}    Rectangle A's corners.\n     * @param  {array}    Rectangle B's corners.\n     * @return {boolean}  True if the rectangles collide on the axis.\n     */\n    axisCollision: function(a, c1, c2) {\n      var sc1 = [],\n          sc2 = [];\n\n      for (var ci = 0; ci < 4; ci++) {\n        var p1 = this.projection(c1[ci], a),\n            p2 = this.projection(c2[ci], a);\n\n        sc1.push(p1.x * a.x + p1.y * a.y);\n        sc2.push(p2.x * a.x + p2.y * a.y);\n      }\n\n      var maxc1 = Math.max.apply(Math, sc1),\n          maxc2 = Math.max.apply(Math, sc2),\n          minc1 = Math.min.apply(Math, sc1),\n          minc2 = Math.min.apply(Math, sc2);\n\n      return (minc2 <= maxc1 && maxc2 >= minc1);\n    },\n\n    /**\n     * Check whether two rectangles collide on each one of their four axis. If\n     * all axis collide, then the two rectangles do collide on the plane.\n     *\n     * @param  {array}    Rectangle A's corners.\n     * @param  {array}    Rectangle B's corners.\n     * @return {boolean}  True if the rectangles collide.\n     */\n    collision: function(c1, c2) {\n      var axis = this.axis(c1, c2),\n          col = true;\n\n      for (var i = 0; i < 4; i++)\n        col = col && this.axisCollision(axis[i], c1, c2);\n\n      return col;\n    }\n  };\n\n\n  /**\n   * Quad Functions\n   * ------------\n   *\n   * The Quadtree functions themselves.\n   * For each of those functions, we consider that in a splitted quad, the\n   * index of each node is the following:\n   * 0: top left\n   * 1: top right\n   * 2: bottom left\n   * 3: bottom right\n   *\n   * Moreover, the hereafter quad's philosophy is to consider that if an element\n   * collides with more than one nodes, this element belongs to each of the\n   * nodes it collides with where other would let it lie on a higher node.\n   */\n\n  /**\n   * Get the index of the node containing the point in the quad\n   *\n   * @param  {object}  point      A point defined by coordinates (x, y).\n   * @param  {object}  quadBounds Boundaries of the quad (x, y, width, heigth).\n   * @return {integer}            The index of the node containing the point.\n   */\n  function _quadIndex(point, quadBounds) {\n    var xmp = quadBounds.x + quadBounds.width / 2,\n        ymp = quadBounds.y + quadBounds.height / 2,\n        top = (point.y < ymp),\n        left = (point.x < xmp);\n\n    if (top) {\n      if (left)\n        return 0;\n      else\n        return 1;\n    }\n    else {\n      if (left)\n        return 2;\n      else\n        return 3;\n    }\n  }\n\n  /**\n   * Get a list of indexes of nodes containing an axis-aligned rectangle\n   *\n   * @param  {object}  rectangle   A rectangle defined by two points (x1, y1),\n   *                               (x2, y2) and height.\n   * @param  {array}   quadCorners An array of the quad nodes' corners.\n   * @return {array}               An array of indexes containing one to\n   *                               four integers.\n   */\n  function _quadIndexes(rectangle, quadCorners) {\n    var indexes = [];\n\n    // Iterating through quads\n    for (var i = 0; i < 4; i++)\n      if ((rectangle.x2 >= quadCorners[i][0].x) &&\n          (rectangle.x1 <= quadCorners[i][1].x) &&\n          (rectangle.y1 + rectangle.height >= quadCorners[i][0].y) &&\n          (rectangle.y1 <= quadCorners[i][2].y))\n        indexes.push(i);\n\n    return indexes;\n  }\n\n  /**\n   * Get a list of indexes of nodes containing a non-axis-aligned rectangle\n   *\n   * @param  {array}  corners      An array containing each corner of the\n   *                               rectangle defined by its coordinates (x, y).\n   * @param  {array}  quadCorners  An array of the quad nodes' corners.\n   * @return {array}               An array of indexes containing one to\n   *                               four integers.\n   */\n  function _quadCollision(corners, quadCorners) {\n    var indexes = [];\n\n    // Iterating through quads\n    for (var i = 0; i < 4; i++)\n      if (_geom.collision(corners, quadCorners[i]))\n        indexes.push(i);\n\n    return indexes;\n  }\n\n  /**\n   * Subdivide a quad by creating a node at a precise index. The function does\n   * not generate all four nodes not to potentially create unused nodes.\n   *\n   * @param  {integer}  index The index of the node to create.\n   * @param  {object}   quad  The quad object to subdivide.\n   * @return {object}         A new quad representing the node created.\n   */\n  function _quadSubdivide(index, quad) {\n    var next = quad.level + 1,\n        subw = Math.round(quad.bounds.width / 2),\n        subh = Math.round(quad.bounds.height / 2),\n        qx = Math.round(quad.bounds.x),\n        qy = Math.round(quad.bounds.y),\n        x,\n        y;\n\n    switch (index) {\n      case 0:\n        x = qx;\n        y = qy;\n        break;\n      case 1:\n        x = qx + subw;\n        y = qy;\n        break;\n      case 2:\n        x = qx;\n        y = qy + subh;\n        break;\n      case 3:\n        x = qx + subw;\n        y = qy + subh;\n        break;\n    }\n\n    return _quadTree(\n      {x: x, y: y, width: subw, height: subh},\n      next,\n      quad.maxElements,\n      quad.maxLevel\n    );\n  }\n\n  /**\n   * Recursively insert an element into the quadtree. Only points\n   * with size, i.e. axis-aligned squares, may be inserted with this\n   * method.\n   *\n   * @param  {object}  el         The element to insert in the quadtree.\n   * @param  {object}  sizedPoint A sized point defined by two top points\n   *                              (x1, y1), (x2, y2) and height.\n   * @param  {object}  quad       The quad in which to insert the element.\n   * @return {undefined}          The function does not return anything.\n   */\n  function _quadInsert(el, sizedPoint, quad) {\n    if (quad.level < quad.maxLevel) {\n\n      // Searching appropriate quads\n      var indexes = _quadIndexes(sizedPoint, quad.corners);\n\n      // Iterating\n      for (var i = 0, l = indexes.length; i < l; i++) {\n\n        // Subdividing if necessary\n        if (quad.nodes[indexes[i]] === undefined)\n          quad.nodes[indexes[i]] = _quadSubdivide(indexes[i], quad);\n\n        // Recursion\n        _quadInsert(el, sizedPoint, quad.nodes[indexes[i]]);\n      }\n    }\n    else {\n\n      // Pushing the element in a leaf node\n      quad.elements.push(el);\n    }\n  }\n\n  /**\n   * Recursively retrieve every elements held by the node containing the\n   * searched point.\n   *\n   * @param  {object}  point The searched point (x, y).\n   * @param  {object}  quad  The searched quad.\n   * @return {array}         An array of elements contained in the relevant\n   *                         node.\n   */\n  function _quadRetrievePoint(point, quad) {\n    if (quad.level < quad.maxLevel) {\n      var index = _quadIndex(point, quad.bounds);\n\n      // If node does not exist we return an empty list\n      if (quad.nodes[index] !== undefined) {\n        return _quadRetrievePoint(point, quad.nodes[index]);\n      }\n      else {\n        return [];\n      }\n    }\n    else {\n      return quad.elements;\n    }\n  }\n\n  /**\n   * Recursively retrieve every elements contained within an rectangular area\n   * that may or may not be axis-aligned.\n   *\n   * @param  {object|array} rectData       The searched area defined either by\n   *                                       an array of four corners (x, y) in\n   *                                       the case of a non-axis-aligned\n   *                                       rectangle or an object with two top\n   *                                       points (x1, y1), (x2, y2) and height.\n   * @param  {object}       quad           The searched quad.\n   * @param  {function}     collisionFunc  The collision function used to search\n   *                                       for node indexes.\n   * @param  {array?}       els            The retrieved elements.\n   * @return {array}                       An array of elements contained in the\n   *                                       area.\n   */\n  function _quadRetrieveArea(rectData, quad, collisionFunc, els) {\n    els = els || {};\n\n    if (quad.level < quad.maxLevel) {\n      var indexes = collisionFunc(rectData, quad.corners);\n\n      for (var i = 0, l = indexes.length; i < l; i++)\n        if (quad.nodes[indexes[i]] !== undefined)\n          _quadRetrieveArea(\n            rectData,\n            quad.nodes[indexes[i]],\n            collisionFunc,\n            els\n          );\n    } else\n      for (var j = 0, m = quad.elements.length; j < m; j++)\n        if (els[quad.elements[j].id] === undefined)\n          els[quad.elements[j].id] = quad.elements[j];\n\n    return els;\n  }\n\n  /**\n   * Creates the quadtree object itself.\n   *\n   * @param  {object}   bounds       The boundaries of the quad defined by an\n   *                                 origin (x, y), width and heigth.\n   * @param  {integer}  level        The level of the quad in the tree.\n   * @param  {integer}  maxElements  The max number of element in a leaf node.\n   * @param  {integer}  maxLevel     The max recursion level of the tree.\n   * @return {object}                The quadtree object.\n   */\n  function _quadTree(bounds, level, maxElements, maxLevel) {\n    return {\n      level: level || 0,\n      bounds: bounds,\n      corners: _geom.splitSquare(bounds),\n      maxElements: maxElements || 20,\n      maxLevel: maxLevel || 4,\n      elements: [],\n      nodes: []\n    };\n  }\n\n\n  /**\n   * Sigma Quad Constructor\n   * ----------------------\n   *\n   * The quad API as exposed to sigma.\n   */\n\n  /**\n   * The quad core that will become the sigma interface with the quadtree.\n   *\n   * property {object} _tree  Property holding the quadtree object.\n   * property {object} _geom  Exposition of the _geom namespace for testing.\n   * property {object} _cache Cache for the area method.\n   */\n  var quad = function() {\n    this._geom = _geom;\n    this._tree = null;\n    this._cache = {\n      query: false,\n      result: false\n    };\n  };\n\n  /**\n   * Index a graph by inserting its nodes into the quadtree.\n   *\n   * @param  {array}  nodes   An array of nodes to index.\n   * @param  {object} params  An object of parameters with at least the quad\n   *                          bounds.\n   * @return {object}         The quadtree object.\n   *\n   * Parameters:\n   * ----------\n   * bounds:      {object}   boundaries of the quad defined by its origin (x, y)\n   *                         width and heigth.\n   * prefix:      {string?}  a prefix for node geometric attributes.\n   * maxElements: {integer?} the max number of elements in a leaf node.\n   * maxLevel:    {integer?} the max recursion level of the tree.\n   */\n  quad.prototype.index = function(nodes, params) {\n\n    // Enforcing presence of boundaries\n    if (!params.bounds)\n      throw 'sigma.classes.quad.index: bounds information not given.';\n\n    // Prefix\n    var prefix = params.prefix || '';\n\n    // Building the tree\n    this._tree = _quadTree(\n      params.bounds,\n      0,\n      params.maxElements,\n      params.maxLevel\n    );\n\n    // Inserting graph nodes into the tree\n    for (var i = 0, l = nodes.length; i < l; i++) {\n\n      // Inserting node\n      _quadInsert(\n        nodes[i],\n        _geom.pointToSquare({\n          x: nodes[i][prefix + 'x'],\n          y: nodes[i][prefix + 'y'],\n          size: nodes[i][prefix + 'size']\n        }),\n        this._tree\n      );\n    }\n\n    // Reset cache:\n    this._cache = {\n      query: false,\n      result: false\n    };\n\n    // remove?\n    return this._tree;\n  };\n\n  /**\n   * Retrieve every graph nodes held by the quadtree node containing the\n   * searched point.\n   *\n   * @param  {number} x of the point.\n   * @param  {number} y of the point.\n   * @return {array}  An array of nodes retrieved.\n   */\n  quad.prototype.point = function(x, y) {\n    return this._tree ?\n      _quadRetrievePoint({x: x, y: y}, this._tree) || [] :\n      [];\n  };\n\n  /**\n   * Retrieve every graph nodes within a rectangular area. The methods keep the\n   * last area queried in cache for optimization reason and will act differently\n   * for the same reason if the area is axis-aligned or not.\n   *\n   * @param  {object} A rectangle defined by two top points (x1, y1), (x2, y2)\n   *                  and height.\n   * @return {array}  An array of nodes retrieved.\n   */\n  quad.prototype.area = function(rect) {\n    var serialized = JSON.stringify(rect),\n        collisionFunc,\n        rectData;\n\n    // Returning cache?\n    if (this._cache.query === serialized)\n      return this._cache.result;\n\n    // Axis aligned ?\n    if (_geom.isAxisAligned(rect)) {\n      collisionFunc = _quadIndexes;\n      rectData = _geom.axisAlignedTopPoints(rect);\n    }\n    else {\n      collisionFunc = _quadCollision;\n      rectData = _geom.rectangleCorners(rect);\n    }\n\n    // Retrieving nodes\n    var nodes = this._tree ?\n      _quadRetrieveArea(\n        rectData,\n        this._tree,\n        collisionFunc\n      ) :\n      [];\n\n    // Object to array\n    var nodesArray = [];\n    for (var i in nodes)\n      nodesArray.push(nodes[i]);\n\n    // Caching\n    this._cache.query = serialized;\n    this._cache.result = nodesArray;\n\n    return nodesArray;\n  };\n\n\n  /**\n   * EXPORT:\n   * *******\n   */\n  if (typeof this.sigma !== 'undefined') {\n    this.sigma.classes = this.sigma.classes || {};\n    this.sigma.classes.quad = quad;\n  } else if (true) {\n    if ( true && module.exports)\n      exports = module.exports = quad;\n    exports.quad = quad;\n  } else\n    {}\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  /**\n   * Sigma Quadtree Module for edges\n   * ===============================\n   *\n   * Author: Sbastien Heymann,\n   *   from the quad of Guillaume Plique (Yomguithereal)\n   * Version: 0.2\n   */\n\n\n\n  /**\n   * Quad Geometric Operations\n   * -------------------------\n   *\n   * A useful batch of geometric operations used by the quadtree.\n   */\n\n  var _geom = {\n\n    /**\n     * Transforms a graph node with x, y and size into an\n     * axis-aligned square.\n     *\n     * @param  {object} A graph node with at least a point (x, y) and a size.\n     * @return {object} A square: two points (x1, y1), (x2, y2) and height.\n     */\n    pointToSquare: function(n) {\n      return {\n        x1: n.x - n.size,\n        y1: n.y - n.size,\n        x2: n.x + n.size,\n        y2: n.y - n.size,\n        height: n.size * 2\n      };\n    },\n\n    /**\n     * Transforms a graph edge with x1, y1, x2, y2 and size into an\n     * axis-aligned square.\n     *\n     * @param  {object} A graph edge with at least two points\n     *                  (x1, y1), (x2, y2) and a size.\n     * @return {object} A square: two points (x1, y1), (x2, y2) and height.\n     */\n    lineToSquare: function(e) {\n      if (e.y1 < e.y2) {\n        // (e.x1, e.y1) on top\n        if (e.x1 < e.x2) {\n          // (e.x1, e.y1) on left\n          return {\n            x1: e.x1 - e.size,\n            y1: e.y1 - e.size,\n            x2: e.x2 + e.size,\n            y2: e.y1 - e.size,\n            height: e.y2 - e.y1 + e.size * 2\n          };\n        }\n        // (e.x1, e.y1) on right\n        return {\n          x1: e.x2 - e.size,\n          y1: e.y1 - e.size,\n          x2: e.x1 + e.size,\n          y2: e.y1 - e.size,\n          height: e.y2 - e.y1 + e.size * 2\n        };\n      }\n\n      // (e.x2, e.y2) on top\n      if (e.x1 < e.x2) {\n        // (e.x1, e.y1) on left\n        return {\n          x1: e.x1 - e.size,\n          y1: e.y2 - e.size,\n          x2: e.x2 + e.size,\n          y2: e.y2 - e.size,\n          height: e.y1 - e.y2 + e.size * 2\n        };\n      }\n      // (e.x2, e.y2) on right\n      return {\n        x1: e.x2 - e.size,\n        y1: e.y2 - e.size,\n        x2: e.x1 + e.size,\n        y2: e.y2 - e.size,\n        height: e.y1 - e.y2 + e.size * 2\n      };\n    },\n\n    /**\n     * Transforms a graph edge of type 'curve' with x1, y1, x2, y2,\n     * control point and size into an axis-aligned square.\n     *\n     * @param  {object} e  A graph edge with at least two points\n     *                     (x1, y1), (x2, y2) and a size.\n     * @param  {object} cp A control point (x,y).\n     * @return {object}    A square: two points (x1, y1), (x2, y2) and height.\n     */\n    quadraticCurveToSquare: function(e, cp) {\n      var pt = sigma.utils.getPointOnQuadraticCurve(\n        0.5,\n        e.x1,\n        e.y1,\n        e.x2,\n        e.y2,\n        cp.x,\n        cp.y\n      );\n\n      // Bounding box of the two points and the point at the middle of the\n      // curve:\n      var minX = Math.min(e.x1, e.x2, pt.x),\n          maxX = Math.max(e.x1, e.x2, pt.x),\n          minY = Math.min(e.y1, e.y2, pt.y),\n          maxY = Math.max(e.y1, e.y2, pt.y);\n\n      return {\n        x1: minX - e.size,\n        y1: minY - e.size,\n        x2: maxX + e.size,\n        y2: minY - e.size,\n        height: maxY - minY + e.size * 2\n      };\n    },\n\n    /**\n     * Transforms a graph self loop into an axis-aligned square.\n     *\n     * @param  {object} n A graph node with a point (x, y) and a size.\n     * @return {object}   A square: two points (x1, y1), (x2, y2) and height.\n     */\n    selfLoopToSquare: function(n) {\n      // Fitting to the curve is too costly, we compute a larger bounding box\n      // using the control points:\n      var cp = sigma.utils.getSelfLoopControlPoints(n.x, n.y, n.size);\n\n      // Bounding box of the point and the two control points:\n      var minX = Math.min(n.x, cp.x1, cp.x2),\n          maxX = Math.max(n.x, cp.x1, cp.x2),\n          minY = Math.min(n.y, cp.y1, cp.y2),\n          maxY = Math.max(n.y, cp.y1, cp.y2);\n\n      return {\n        x1: minX - n.size,\n        y1: minY - n.size,\n        x2: maxX + n.size,\n        y2: minY - n.size,\n        height: maxY - minY + n.size * 2\n      };\n    },\n\n    /**\n     * Checks whether a rectangle is axis-aligned.\n     *\n     * @param  {object}  A rectangle defined by two points\n     *                   (x1, y1) and (x2, y2).\n     * @return {boolean} True if the rectangle is axis-aligned.\n     */\n    isAxisAligned: function(r) {\n      return r.x1 === r.x2 || r.y1 === r.y2;\n    },\n\n    /**\n     * Compute top points of an axis-aligned rectangle. This is useful in\n     * cases when the rectangle has been rotated (left, right or bottom up) and\n     * later operations need to know the top points.\n     *\n     * @param  {object} An axis-aligned rectangle defined by two points\n     *                  (x1, y1), (x2, y2) and height.\n     * @return {object} A rectangle: two points (x1, y1), (x2, y2) and height.\n     */\n    axisAlignedTopPoints: function(r) {\n\n      // Basic\n      if (r.y1 === r.y2 && r.x1 < r.x2)\n        return r;\n\n      // Rotated to right\n      if (r.x1 === r.x2 && r.y2 > r.y1)\n        return {\n          x1: r.x1 - r.height, y1: r.y1,\n          x2: r.x1, y2: r.y1,\n          height: r.height\n        };\n\n      // Rotated to left\n      if (r.x1 === r.x2 && r.y2 < r.y1)\n        return {\n          x1: r.x1, y1: r.y2,\n          x2: r.x2 + r.height, y2: r.y2,\n          height: r.height\n        };\n\n      // Bottom's up\n      return {\n        x1: r.x2, y1: r.y1 - r.height,\n        x2: r.x1, y2: r.y1 - r.height,\n        height: r.height\n      };\n    },\n\n    /**\n     * Get coordinates of a rectangle's lower left corner from its top points.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @return {object} Coordinates of the corner (x, y).\n     */\n    lowerLeftCoor: function(r) {\n      var width = (\n        Math.sqrt(\n          Math.pow(r.x2 - r.x1, 2) +\n          Math.pow(r.y2 - r.y1, 2)\n        )\n      );\n\n      return {\n        x: r.x1 - (r.y2 - r.y1) * r.height / width,\n        y: r.y1 + (r.x2 - r.x1) * r.height / width\n      };\n    },\n\n    /**\n     * Get coordinates of a rectangle's lower right corner from its top points\n     * and its lower left corner.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @param  {object} A corner's coordinates (x, y).\n     * @return {object} Coordinates of the corner (x, y).\n     */\n    lowerRightCoor: function(r, llc) {\n      return {\n        x: llc.x - r.x1 + r.x2,\n        y: llc.y - r.y1 + r.y2\n      };\n    },\n\n    /**\n     * Get the coordinates of all the corners of a rectangle from its top point.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @return {array}  An array of the four corners' coordinates (x, y).\n     */\n    rectangleCorners: function(r) {\n      var llc = this.lowerLeftCoor(r),\n          lrc = this.lowerRightCoor(r, llc);\n\n      return [\n        {x: r.x1, y: r.y1},\n        {x: r.x2, y: r.y2},\n        {x: llc.x, y: llc.y},\n        {x: lrc.x, y: lrc.y}\n      ];\n    },\n\n    /**\n     * Split a square defined by its boundaries into four.\n     *\n     * @param  {object} Boundaries of the square (x, y, width, height).\n     * @return {array}  An array containing the four new squares, themselves\n     *                  defined by an array of their four corners (x, y).\n     */\n    splitSquare: function(b) {\n      return [\n        [\n          {x: b.x, y: b.y},\n          {x: b.x + b.width / 2, y: b.y},\n          {x: b.x, y: b.y + b.height / 2},\n          {x: b.x + b.width / 2, y: b.y + b.height / 2}\n        ],\n        [\n          {x: b.x + b.width / 2, y: b.y},\n          {x: b.x + b.width, y: b.y},\n          {x: b.x + b.width / 2, y: b.y + b.height / 2},\n          {x: b.x + b.width, y: b.y + b.height / 2}\n        ],\n        [\n          {x: b.x, y: b.y + b.height / 2},\n          {x: b.x + b.width / 2, y: b.y + b.height / 2},\n          {x: b.x, y: b.y + b.height},\n          {x: b.x + b.width / 2, y: b.y + b.height}\n        ],\n        [\n          {x: b.x + b.width / 2, y: b.y + b.height / 2},\n          {x: b.x + b.width, y: b.y + b.height / 2},\n          {x: b.x + b.width / 2, y: b.y + b.height},\n          {x: b.x + b.width, y: b.y + b.height}\n        ]\n      ];\n    },\n\n    /**\n     * Compute the four axis between corners of rectangle A and corners of\n     * rectangle B. This is needed later to check an eventual collision.\n     *\n     * @param  {array} An array of rectangle A's four corners (x, y).\n     * @param  {array} An array of rectangle B's four corners (x, y).\n     * @return {array} An array of four axis defined by their coordinates (x,y).\n     */\n    axis: function(c1, c2) {\n      return [\n        {x: c1[1].x - c1[0].x, y: c1[1].y - c1[0].y},\n        {x: c1[1].x - c1[3].x, y: c1[1].y - c1[3].y},\n        {x: c2[0].x - c2[2].x, y: c2[0].y - c2[2].y},\n        {x: c2[0].x - c2[1].x, y: c2[0].y - c2[1].y}\n      ];\n    },\n\n    /**\n     * Project a rectangle's corner on an axis.\n     *\n     * @param  {object} Coordinates of a corner (x, y).\n     * @param  {object} Coordinates of an axis (x, y).\n     * @return {object} The projection defined by coordinates (x, y).\n     */\n    projection: function(c, a) {\n      var l = (\n        (c.x * a.x + c.y * a.y) /\n        (Math.pow(a.x, 2) + Math.pow(a.y, 2))\n      );\n\n      return {\n        x: l * a.x,\n        y: l * a.y\n      };\n    },\n\n    /**\n     * Check whether two rectangles collide on one particular axis.\n     *\n     * @param  {object}   An axis' coordinates (x, y).\n     * @param  {array}    Rectangle A's corners.\n     * @param  {array}    Rectangle B's corners.\n     * @return {boolean}  True if the rectangles collide on the axis.\n     */\n    axisCollision: function(a, c1, c2) {\n      var sc1 = [],\n          sc2 = [];\n\n      for (var ci = 0; ci < 4; ci++) {\n        var p1 = this.projection(c1[ci], a),\n            p2 = this.projection(c2[ci], a);\n\n        sc1.push(p1.x * a.x + p1.y * a.y);\n        sc2.push(p2.x * a.x + p2.y * a.y);\n      }\n\n      var maxc1 = Math.max.apply(Math, sc1),\n          maxc2 = Math.max.apply(Math, sc2),\n          minc1 = Math.min.apply(Math, sc1),\n          minc2 = Math.min.apply(Math, sc2);\n\n      return (minc2 <= maxc1 && maxc2 >= minc1);\n    },\n\n    /**\n     * Check whether two rectangles collide on each one of their four axis. If\n     * all axis collide, then the two rectangles do collide on the plane.\n     *\n     * @param  {array}    Rectangle A's corners.\n     * @param  {array}    Rectangle B's corners.\n     * @return {boolean}  True if the rectangles collide.\n     */\n    collision: function(c1, c2) {\n      var axis = this.axis(c1, c2),\n          col = true;\n\n      for (var i = 0; i < 4; i++)\n        col = col && this.axisCollision(axis[i], c1, c2);\n\n      return col;\n    }\n  };\n\n\n  /**\n   * Quad Functions\n   * ------------\n   *\n   * The Quadtree functions themselves.\n   * For each of those functions, we consider that in a splitted quad, the\n   * index of each node is the following:\n   * 0: top left\n   * 1: top right\n   * 2: bottom left\n   * 3: bottom right\n   *\n   * Moreover, the hereafter quad's philosophy is to consider that if an element\n   * collides with more than one nodes, this element belongs to each of the\n   * nodes it collides with where other would let it lie on a higher node.\n   */\n\n  /**\n   * Get the index of the node containing the point in the quad\n   *\n   * @param  {object}  point      A point defined by coordinates (x, y).\n   * @param  {object}  quadBounds Boundaries of the quad (x, y, width, heigth).\n   * @return {integer}            The index of the node containing the point.\n   */\n  function _quadIndex(point, quadBounds) {\n    var xmp = quadBounds.x + quadBounds.width / 2,\n        ymp = quadBounds.y + quadBounds.height / 2,\n        top = (point.y < ymp),\n        left = (point.x < xmp);\n\n    if (top) {\n      if (left)\n        return 0;\n      else\n        return 1;\n    }\n    else {\n      if (left)\n        return 2;\n      else\n        return 3;\n    }\n  }\n\n  /**\n   * Get a list of indexes of nodes containing an axis-aligned rectangle\n   *\n   * @param  {object}  rectangle   A rectangle defined by two points (x1, y1),\n   *                               (x2, y2) and height.\n   * @param  {array}   quadCorners An array of the quad nodes' corners.\n   * @return {array}               An array of indexes containing one to\n   *                               four integers.\n   */\n  function _quadIndexes(rectangle, quadCorners) {\n    var indexes = [];\n\n    // Iterating through quads\n    for (var i = 0; i < 4; i++)\n      if ((rectangle.x2 >= quadCorners[i][0].x) &&\n          (rectangle.x1 <= quadCorners[i][1].x) &&\n          (rectangle.y1 + rectangle.height >= quadCorners[i][0].y) &&\n          (rectangle.y1 <= quadCorners[i][2].y))\n        indexes.push(i);\n\n    return indexes;\n  }\n\n  /**\n   * Get a list of indexes of nodes containing a non-axis-aligned rectangle\n   *\n   * @param  {array}  corners      An array containing each corner of the\n   *                               rectangle defined by its coordinates (x, y).\n   * @param  {array}  quadCorners  An array of the quad nodes' corners.\n   * @return {array}               An array of indexes containing one to\n   *                               four integers.\n   */\n  function _quadCollision(corners, quadCorners) {\n    var indexes = [];\n\n    // Iterating through quads\n    for (var i = 0; i < 4; i++)\n      if (_geom.collision(corners, quadCorners[i]))\n        indexes.push(i);\n\n    return indexes;\n  }\n\n  /**\n   * Subdivide a quad by creating a node at a precise index. The function does\n   * not generate all four nodes not to potentially create unused nodes.\n   *\n   * @param  {integer}  index The index of the node to create.\n   * @param  {object}   quad  The quad object to subdivide.\n   * @return {object}         A new quad representing the node created.\n   */\n  function _quadSubdivide(index, quad) {\n    var next = quad.level + 1,\n        subw = Math.round(quad.bounds.width / 2),\n        subh = Math.round(quad.bounds.height / 2),\n        qx = Math.round(quad.bounds.x),\n        qy = Math.round(quad.bounds.y),\n        x,\n        y;\n\n    switch (index) {\n      case 0:\n        x = qx;\n        y = qy;\n        break;\n      case 1:\n        x = qx + subw;\n        y = qy;\n        break;\n      case 2:\n        x = qx;\n        y = qy + subh;\n        break;\n      case 3:\n        x = qx + subw;\n        y = qy + subh;\n        break;\n    }\n\n    return _quadTree(\n      {x: x, y: y, width: subw, height: subh},\n      next,\n      quad.maxElements,\n      quad.maxLevel\n    );\n  }\n\n  /**\n   * Recursively insert an element into the quadtree. Only points\n   * with size, i.e. axis-aligned squares, may be inserted with this\n   * method.\n   *\n   * @param  {object}  el         The element to insert in the quadtree.\n   * @param  {object}  sizedPoint A sized point defined by two top points\n   *                              (x1, y1), (x2, y2) and height.\n   * @param  {object}  quad       The quad in which to insert the element.\n   * @return {undefined}          The function does not return anything.\n   */\n  function _quadInsert(el, sizedPoint, quad) {\n    if (quad.level < quad.maxLevel) {\n\n      // Searching appropriate quads\n      var indexes = _quadIndexes(sizedPoint, quad.corners);\n\n      // Iterating\n      for (var i = 0, l = indexes.length; i < l; i++) {\n\n        // Subdividing if necessary\n        if (quad.nodes[indexes[i]] === undefined)\n          quad.nodes[indexes[i]] = _quadSubdivide(indexes[i], quad);\n\n        // Recursion\n        _quadInsert(el, sizedPoint, quad.nodes[indexes[i]]);\n      }\n    }\n    else {\n\n      // Pushing the element in a leaf node\n      quad.elements.push(el);\n    }\n  }\n\n  /**\n   * Recursively retrieve every elements held by the node containing the\n   * searched point.\n   *\n   * @param  {object}  point The searched point (x, y).\n   * @param  {object}  quad  The searched quad.\n   * @return {array}         An array of elements contained in the relevant\n   *                         node.\n   */\n  function _quadRetrievePoint(point, quad) {\n    if (quad.level < quad.maxLevel) {\n      var index = _quadIndex(point, quad.bounds);\n\n      // If node does not exist we return an empty list\n      if (quad.nodes[index] !== undefined) {\n        return _quadRetrievePoint(point, quad.nodes[index]);\n      }\n      else {\n        return [];\n      }\n    }\n    else {\n      return quad.elements;\n    }\n  }\n\n  /**\n   * Recursively retrieve every elements contained within an rectangular area\n   * that may or may not be axis-aligned.\n   *\n   * @param  {object|array} rectData       The searched area defined either by\n   *                                       an array of four corners (x, y) in\n   *                                       the case of a non-axis-aligned\n   *                                       rectangle or an object with two top\n   *                                       points (x1, y1), (x2, y2) and height.\n   * @param  {object}       quad           The searched quad.\n   * @param  {function}     collisionFunc  The collision function used to search\n   *                                       for node indexes.\n   * @param  {array?}       els            The retrieved elements.\n   * @return {array}                       An array of elements contained in the\n   *                                       area.\n   */\n  function _quadRetrieveArea(rectData, quad, collisionFunc, els) {\n    els = els || {};\n\n    if (quad.level < quad.maxLevel) {\n      var indexes = collisionFunc(rectData, quad.corners);\n\n      for (var i = 0, l = indexes.length; i < l; i++)\n        if (quad.nodes[indexes[i]] !== undefined)\n          _quadRetrieveArea(\n            rectData,\n            quad.nodes[indexes[i]],\n            collisionFunc,\n            els\n          );\n    } else\n      for (var j = 0, m = quad.elements.length; j < m; j++)\n        if (els[quad.elements[j].id] === undefined)\n          els[quad.elements[j].id] = quad.elements[j];\n\n    return els;\n  }\n\n  /**\n   * Creates the quadtree object itself.\n   *\n   * @param  {object}   bounds       The boundaries of the quad defined by an\n   *                                 origin (x, y), width and heigth.\n   * @param  {integer}  level        The level of the quad in the tree.\n   * @param  {integer}  maxElements  The max number of element in a leaf node.\n   * @param  {integer}  maxLevel     The max recursion level of the tree.\n   * @return {object}                The quadtree object.\n   */\n  function _quadTree(bounds, level, maxElements, maxLevel) {\n    return {\n      level: level || 0,\n      bounds: bounds,\n      corners: _geom.splitSquare(bounds),\n      maxElements: maxElements || 40,\n      maxLevel: maxLevel || 8,\n      elements: [],\n      nodes: []\n    };\n  }\n\n\n  /**\n   * Sigma Quad Constructor\n   * ----------------------\n   *\n   * The edgequad API as exposed to sigma.\n   */\n\n  /**\n   * The edgequad core that will become the sigma interface with the quadtree.\n   *\n   * property {object} _tree     Property holding the quadtree object.\n   * property {object} _geom     Exposition of the _geom namespace for testing.\n   * property {object} _cache    Cache for the area method.\n   * property {boolean} _enabled Can index and retreive elements.\n   */\n  var edgequad = function() {\n    this._geom = _geom;\n    this._tree = null;\n    this._cache = {\n      query: false,\n      result: false\n    };\n    this._enabled = true;\n  };\n\n  /**\n   * Index a graph by inserting its edges into the quadtree.\n   *\n   * @param  {object} graph   A graph instance.\n   * @param  {object} params  An object of parameters with at least the quad\n   *                          bounds.\n   * @return {object}         The quadtree object.\n   *\n   * Parameters:\n   * ----------\n   * bounds:      {object}   boundaries of the quad defined by its origin (x, y)\n   *                         width and heigth.\n   * prefix:      {string?}  a prefix for edge geometric attributes.\n   * maxElements: {integer?} the max number of elements in a leaf node.\n   * maxLevel:    {integer?} the max recursion level of the tree.\n   */\n  edgequad.prototype.index = function(graph, params) {\n    if (!this._enabled)\n      return this._tree;\n\n    // Enforcing presence of boundaries\n    if (!params.bounds)\n      throw 'sigma.classes.edgequad.index: bounds information not given.';\n\n    // Prefix\n    var prefix = params.prefix || '',\n        cp,\n        source,\n        target,\n        n,\n        e;\n\n    // Building the tree\n    this._tree = _quadTree(\n      params.bounds,\n      0,\n      params.maxElements,\n      params.maxLevel\n    );\n\n    var edges = graph.edges();\n\n    // Inserting graph edges into the tree\n    for (var i = 0, l = edges.length; i < l; i++) {\n      source = graph.nodes(edges[i].source);\n      target = graph.nodes(edges[i].target);\n      e = {\n        x1: source[prefix + 'x'],\n        y1: source[prefix + 'y'],\n        x2: target[prefix + 'x'],\n        y2: target[prefix + 'y'],\n        size: edges[i][prefix + 'size'] || 0\n      };\n\n      // Inserting edge\n      if (edges[i].type === 'curve' || edges[i].type === 'curvedArrow') {\n        if (source.id === target.id) {\n          n = {\n            x: source[prefix + 'x'],\n            y: source[prefix + 'y'],\n            size: source[prefix + 'size'] || 0\n          };\n          _quadInsert(\n            edges[i],\n            _geom.selfLoopToSquare(n),\n            this._tree);\n        }\n        else {\n          cp = sigma.utils.getQuadraticControlPoint(e.x1, e.y1, e.x2, e.y2);\n          _quadInsert(\n            edges[i],\n            _geom.quadraticCurveToSquare(e, cp),\n            this._tree);\n        }\n      }\n      else {\n        _quadInsert(\n          edges[i],\n          _geom.lineToSquare(e),\n          this._tree);\n      }\n    }\n\n    // Reset cache:\n    this._cache = {\n      query: false,\n      result: false\n    };\n\n    // remove?\n    return this._tree;\n  };\n\n  /**\n   * Retrieve every graph edges held by the quadtree node containing the\n   * searched point.\n   *\n   * @param  {number} x of the point.\n   * @param  {number} y of the point.\n   * @return {array}  An array of edges retrieved.\n   */\n  edgequad.prototype.point = function(x, y) {\n    if (!this._enabled)\n      return [];\n\n    return this._tree ?\n      _quadRetrievePoint({x: x, y: y}, this._tree) || [] :\n      [];\n  };\n\n  /**\n   * Retrieve every graph edges within a rectangular area. The methods keep the\n   * last area queried in cache for optimization reason and will act differently\n   * for the same reason if the area is axis-aligned or not.\n   *\n   * @param  {object} A rectangle defined by two top points (x1, y1), (x2, y2)\n   *                  and height.\n   * @return {array}  An array of edges retrieved.\n   */\n  edgequad.prototype.area = function(rect) {\n    if (!this._enabled)\n      return [];\n\n    var serialized = JSON.stringify(rect),\n        collisionFunc,\n        rectData;\n\n    // Returning cache?\n    if (this._cache.query === serialized)\n      return this._cache.result;\n\n    // Axis aligned ?\n    if (_geom.isAxisAligned(rect)) {\n      collisionFunc = _quadIndexes;\n      rectData = _geom.axisAlignedTopPoints(rect);\n    }\n    else {\n      collisionFunc = _quadCollision;\n      rectData = _geom.rectangleCorners(rect);\n    }\n\n    // Retrieving edges\n    var edges = this._tree ?\n      _quadRetrieveArea(\n        rectData,\n        this._tree,\n        collisionFunc\n      ) :\n      [];\n\n    // Object to array\n    var edgesArray = [];\n    for (var i in edges)\n      edgesArray.push(edges[i]);\n\n    // Caching\n    this._cache.query = serialized;\n    this._cache.result = edgesArray;\n\n    return edgesArray;\n  };\n\n\n  /**\n   * EXPORT:\n   * *******\n   */\n  if (typeof this.sigma !== 'undefined') {\n    this.sigma.classes = this.sigma.classes || {};\n    this.sigma.classes.edgequad = edgequad;\n  } else if (true) {\n    if ( true && module.exports)\n      exports = module.exports = edgequad;\n    exports.edgequad = edgequad;\n  } else\n    {}\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.captors');\n\n  /**\n   * The user inputs default captor. It deals with mouse events, keyboards\n   * events and touch events.\n   *\n   * @param  {DOMElement}   target   The DOM element where the listeners will be\n   *                                 bound.\n   * @param  {camera}       camera   The camera related to the target.\n   * @param  {configurable} settings The settings function.\n   * @return {sigma.captor}          The fresh new captor instance.\n   */\n  sigma.captors.mouse = function(target, camera, settings) {\n    var _self = this,\n        _target = target,\n        _camera = camera,\n        _settings = settings,\n\n        // CAMERA MANAGEMENT:\n        // ******************\n        // The camera position when the user starts dragging:\n        _startCameraX,\n        _startCameraY,\n        _startCameraAngle,\n\n        // The latest stage position:\n        _lastCameraX,\n        _lastCameraY,\n        _lastCameraAngle,\n        _lastCameraRatio,\n\n        // MOUSE MANAGEMENT:\n        // *****************\n        // The mouse position when the user starts dragging:\n        _startMouseX,\n        _startMouseY,\n\n        _isMouseDown,\n        _isMoving,\n        _hasDragged,\n        _downStartTime,\n        _movingTimeoutId;\n\n    sigma.classes.dispatcher.extend(this);\n\n    sigma.utils.doubleClick(_target, 'click', _doubleClickHandler);\n    _target.addEventListener('DOMMouseScroll', _wheelHandler, false);\n    _target.addEventListener('mousewheel', _wheelHandler, false);\n    _target.addEventListener('mousemove', _moveHandler, false);\n    _target.addEventListener('mousedown', _downHandler, false);\n    _target.addEventListener('click', _clickHandler, false);\n    _target.addEventListener('mouseout', _outHandler, false);\n    document.addEventListener('mouseup', _upHandler, false);\n\n\n\n\n    /**\n     * This method unbinds every handlers that makes the captor work.\n     */\n    this.kill = function() {\n      sigma.utils.unbindDoubleClick(_target, 'click');\n      _target.removeEventListener('DOMMouseScroll', _wheelHandler);\n      _target.removeEventListener('mousewheel', _wheelHandler);\n      _target.removeEventListener('mousemove', _moveHandler);\n      _target.removeEventListener('mousedown', _downHandler);\n      _target.removeEventListener('click', _clickHandler);\n      _target.removeEventListener('mouseout', _outHandler);\n      document.removeEventListener('mouseup', _upHandler);\n    };\n\n\n\n\n    // MOUSE EVENTS:\n    // *************\n\n    /**\n     * The handler listening to the 'move' mouse event. It will effectively\n     * drag the graph.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _moveHandler(e) {\n      var x,\n          y,\n          pos;\n\n      // Dispatch event:\n      if (_settings('mouseEnabled')) {\n        _self.dispatchEvent('mousemove',\n          sigma.utils.mouseCoords(e));\n\n        if (_isMouseDown) {\n          _isMoving = true;\n          _hasDragged = true;\n\n          if (_movingTimeoutId)\n            clearTimeout(_movingTimeoutId);\n\n          _movingTimeoutId = setTimeout(function() {\n            _isMoving = false;\n          }, _settings('dragTimeout'));\n\n          sigma.misc.animation.killAll(_camera);\n\n          _camera.isMoving = true;\n          pos = _camera.cameraPosition(\n            sigma.utils.getX(e) - _startMouseX,\n            sigma.utils.getY(e) - _startMouseY,\n            true\n          );\n\n          x = _startCameraX - pos.x;\n          y = _startCameraY - pos.y;\n\n          if (x !== _camera.x || y !== _camera.y) {\n            _lastCameraX = _camera.x;\n            _lastCameraY = _camera.y;\n\n            _camera.goTo({\n              x: x,\n              y: y\n            });\n          }\n\n          if (e.preventDefault)\n            e.preventDefault();\n          else\n            e.returnValue = false;\n\n          e.stopPropagation();\n          return false;\n        }\n      }\n    }\n\n    /**\n     * The handler listening to the 'up' mouse event. It will stop dragging the\n     * graph.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _upHandler(e) {\n      if (_settings('mouseEnabled') && _isMouseDown) {\n        _isMouseDown = false;\n        if (_movingTimeoutId)\n          clearTimeout(_movingTimeoutId);\n\n        _camera.isMoving = false;\n\n        var x = sigma.utils.getX(e),\n            y = sigma.utils.getY(e);\n\n        if (_isMoving) {\n          sigma.misc.animation.killAll(_camera);\n          sigma.misc.animation.camera(\n            _camera,\n            {\n              x: _camera.x +\n                _settings('mouseInertiaRatio') * (_camera.x - _lastCameraX),\n              y: _camera.y +\n                _settings('mouseInertiaRatio') * (_camera.y - _lastCameraY)\n            },\n            {\n              easing: 'quadraticOut',\n              duration: _settings('mouseInertiaDuration')\n            }\n          );\n        } else if (\n          _startMouseX !== x ||\n          _startMouseY !== y\n        )\n          _camera.goTo({\n            x: _camera.x,\n            y: _camera.y\n          });\n\n        _self.dispatchEvent('mouseup',\n          sigma.utils.mouseCoords(e));\n\n        // Update _isMoving flag:\n        _isMoving = false;\n      }\n    }\n\n    /**\n     * The handler listening to the 'down' mouse event. It will start observing\n     * the mouse position for dragging the graph.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _downHandler(e) {\n      if (_settings('mouseEnabled')) {\n        _startCameraX = _camera.x;\n        _startCameraY = _camera.y;\n\n        _lastCameraX = _camera.x;\n        _lastCameraY = _camera.y;\n\n        _startMouseX = sigma.utils.getX(e);\n        _startMouseY = sigma.utils.getY(e);\n\n        _hasDragged = false;\n        _downStartTime = (new Date()).getTime();\n\n        switch (e.which) {\n          case 2:\n            // Middle mouse button pressed\n            // Do nothing.\n            break;\n          case 3:\n            // Right mouse button pressed\n            _self.dispatchEvent('rightclick',\n              sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));\n            break;\n          // case 1:\n          default:\n            // Left mouse button pressed\n            _isMouseDown = true;\n\n            _self.dispatchEvent('mousedown',\n              sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));\n        }\n      }\n    }\n\n    /**\n     * The handler listening to the 'out' mouse event. It will just redispatch\n     * the event.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _outHandler(e) {\n      if (_settings('mouseEnabled'))\n        _self.dispatchEvent('mouseout');\n    }\n\n    /**\n     * The handler listening to the 'click' mouse event. It will redispatch the\n     * click event, but with normalized X and Y coordinates.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _clickHandler(e) {\n      if (_settings('mouseEnabled')) {\n        var event = sigma.utils.mouseCoords(e);\n        event.isDragging =\n          (((new Date()).getTime() - _downStartTime) > 100) && _hasDragged;\n        _self.dispatchEvent('click', event);\n      }\n\n      if (e.preventDefault)\n        e.preventDefault();\n      else\n        e.returnValue = false;\n\n      e.stopPropagation();\n      return false;\n    }\n\n    /**\n     * The handler listening to the double click custom event. It will\n     * basically zoom into the graph.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _doubleClickHandler(e) {\n      var pos,\n          ratio,\n          animation;\n\n      if (_settings('mouseEnabled')) {\n        ratio = 1 / _settings('doubleClickZoomingRatio');\n\n        _self.dispatchEvent('doubleclick',\n            sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));\n\n        if (_settings('doubleClickEnabled')) {\n          pos = _camera.cameraPosition(\n            sigma.utils.getX(e) - sigma.utils.getCenter(e).x,\n            sigma.utils.getY(e) - sigma.utils.getCenter(e).y,\n            true\n          );\n\n          animation = {\n            duration: _settings('doubleClickZoomDuration')\n          };\n\n          sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);\n        }\n\n        if (e.preventDefault)\n          e.preventDefault();\n        else\n          e.returnValue = false;\n\n        e.stopPropagation();\n        return false;\n      }\n    }\n\n    /**\n     * The handler listening to the 'wheel' mouse event. It will basically zoom\n     * in or not into the graph.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _wheelHandler(e) {\n      var pos,\n          ratio,\n          animation,\n          wheelDelta = sigma.utils.getDelta(e);\n\n      if (_settings('mouseEnabled') && _settings('mouseWheelEnabled') && wheelDelta !== 0) {\n        ratio = wheelDelta > 0 ?\n          1 / _settings('zoomingRatio') :\n          _settings('zoomingRatio');\n\n        pos = _camera.cameraPosition(\n          sigma.utils.getX(e) - sigma.utils.getCenter(e).x,\n          sigma.utils.getY(e) - sigma.utils.getCenter(e).y,\n          true\n        );\n\n        animation = {\n          duration: _settings('mouseZoomDuration')\n        };\n\n        sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);\n\n        if (e.preventDefault)\n          e.preventDefault();\n        else\n          e.returnValue = false;\n\n        e.stopPropagation();\n        return false;\n      }\n    }\n  };\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.captors');\n\n  /**\n   * The user inputs default captor. It deals with mouse events, keyboards\n   * events and touch events.\n   *\n   * @param  {DOMElement}   target   The DOM element where the listeners will be\n   *                                 bound.\n   * @param  {camera}       camera   The camera related to the target.\n   * @param  {configurable} settings The settings function.\n   * @return {sigma.captor}          The fresh new captor instance.\n   */\n  sigma.captors.touch = function(target, camera, settings) {\n    var _self = this,\n        _target = target,\n        _camera = camera,\n        _settings = settings,\n\n        // CAMERA MANAGEMENT:\n        // ******************\n        // The camera position when the user starts dragging:\n        _startCameraX,\n        _startCameraY,\n        _startCameraAngle,\n        _startCameraRatio,\n\n        // The latest stage position:\n        _lastCameraX,\n        _lastCameraY,\n        _lastCameraAngle,\n        _lastCameraRatio,\n\n        // TOUCH MANAGEMENT:\n        // *****************\n        // Touches that are down:\n        _downTouches = [],\n\n        _startTouchX0,\n        _startTouchY0,\n        _startTouchX1,\n        _startTouchY1,\n        _startTouchAngle,\n        _startTouchDistance,\n\n        _touchMode,\n\n        _isMoving,\n        _doubleTap,\n        _movingTimeoutId;\n\n    sigma.classes.dispatcher.extend(this);\n\n    sigma.utils.doubleClick(_target, 'touchstart', _doubleTapHandler);\n    _target.addEventListener('touchstart', _handleStart, false);\n    _target.addEventListener('touchend', _handleLeave, false);\n    _target.addEventListener('touchcancel', _handleLeave, false);\n    _target.addEventListener('touchleave', _handleLeave, false);\n    _target.addEventListener('touchmove', _handleMove, false);\n\n    function position(e) {\n      var offset = sigma.utils.getOffset(_target);\n\n      return {\n        x: e.pageX - offset.left,\n        y: e.pageY - offset.top\n      };\n    }\n\n    /**\n     * This method unbinds every handlers that makes the captor work.\n     */\n    this.kill = function() {\n      sigma.utils.unbindDoubleClick(_target, 'touchstart');\n      _target.addEventListener('touchstart', _handleStart);\n      _target.addEventListener('touchend', _handleLeave);\n      _target.addEventListener('touchcancel', _handleLeave);\n      _target.addEventListener('touchleave', _handleLeave);\n      _target.addEventListener('touchmove', _handleMove);\n    };\n\n    // TOUCH EVENTS:\n    // *************\n    /**\n     * The handler listening to the 'touchstart' event. It will set the touch\n     * mode (\"_touchMode\") and start observing the user touch moves.\n     *\n     * @param {event} e A touch event.\n     */\n    function _handleStart(e) {\n      if (_settings('touchEnabled')) {\n        var x0,\n            x1,\n            y0,\n            y1,\n            pos0,\n            pos1;\n\n        _downTouches = e.touches;\n\n        switch (_downTouches.length) {\n          case 1:\n            _camera.isMoving = true;\n            _touchMode = 1;\n\n            _startCameraX = _camera.x;\n            _startCameraY = _camera.y;\n\n            _lastCameraX = _camera.x;\n            _lastCameraY = _camera.y;\n\n            pos0 = position(_downTouches[0]);\n            _startTouchX0 = pos0.x;\n            _startTouchY0 = pos0.y;\n\n            break;\n          case 2:\n            _camera.isMoving = true;\n            _touchMode = 2;\n\n            pos0 = position(_downTouches[0]);\n            pos1 = position(_downTouches[1]);\n            x0 = pos0.x;\n            y0 = pos0.y;\n            x1 = pos1.x;\n            y1 = pos1.y;\n\n            _lastCameraX = _camera.x;\n            _lastCameraY = _camera.y;\n\n            _startCameraAngle = _camera.angle;\n            _startCameraRatio = _camera.ratio;\n\n            _startCameraX = _camera.x;\n            _startCameraY = _camera.y;\n\n            _startTouchX0 = x0;\n            _startTouchY0 = y0;\n            _startTouchX1 = x1;\n            _startTouchY1 = y1;\n\n            _startTouchAngle = Math.atan2(\n              _startTouchY1 - _startTouchY0,\n              _startTouchX1 - _startTouchX0\n            );\n            _startTouchDistance = Math.sqrt(\n              (_startTouchY1 - _startTouchY0) *\n                (_startTouchY1 - _startTouchY0) +\n              (_startTouchX1 - _startTouchX0) *\n                (_startTouchX1 - _startTouchX0)\n            );\n\n            e.preventDefault();\n            return false;\n        }\n      }\n    }\n\n    /**\n     * The handler listening to the 'touchend', 'touchcancel' and 'touchleave'\n     * event. It will update the touch mode if there are still at least one\n     * finger, and stop dragging else.\n     *\n     * @param {event} e A touch event.\n     */\n    function _handleLeave(e) {\n      if (_settings('touchEnabled')) {\n        _downTouches = e.touches;\n        var inertiaRatio = _settings('touchInertiaRatio');\n\n        if (_movingTimeoutId) {\n          _isMoving = false;\n          clearTimeout(_movingTimeoutId);\n        }\n\n        switch (_touchMode) {\n          case 2:\n            if (e.touches.length === 1) {\n              _handleStart(e);\n\n              e.preventDefault();\n              break;\n            }\n            /* falls through */\n          case 1:\n            _camera.isMoving = false;\n            _self.dispatchEvent('stopDrag');\n\n            if (_isMoving) {\n              _doubleTap = false;\n              sigma.misc.animation.camera(\n                _camera,\n                {\n                  x: _camera.x +\n                    inertiaRatio * (_camera.x - _lastCameraX),\n                  y: _camera.y +\n                    inertiaRatio * (_camera.y - _lastCameraY)\n                },\n                {\n                  easing: 'quadraticOut',\n                  duration: _settings('touchInertiaDuration')\n                }\n              );\n            }\n\n            _isMoving = false;\n            _touchMode = 0;\n            break;\n        }\n      }\n    }\n\n    /**\n     * The handler listening to the 'touchmove' event. It will effectively drag\n     * the graph, and eventually zooms and turn it if the user is using two\n     * fingers.\n     *\n     * @param {event} e A touch event.\n     */\n    function _handleMove(e) {\n      if (!_doubleTap && _settings('touchEnabled')) {\n        var x0,\n            x1,\n            y0,\n            y1,\n            cos,\n            sin,\n            end,\n            pos0,\n            pos1,\n            diff,\n            start,\n            dAngle,\n            dRatio,\n            newStageX,\n            newStageY,\n            newStageRatio,\n            newStageAngle;\n\n        _downTouches = e.touches;\n        _isMoving = true;\n\n        if (_movingTimeoutId)\n          clearTimeout(_movingTimeoutId);\n\n        _movingTimeoutId = setTimeout(function() {\n          _isMoving = false;\n        }, _settings('dragTimeout'));\n\n        switch (_touchMode) {\n          case 1:\n            pos0 = position(_downTouches[0]);\n            x0 = pos0.x;\n            y0 = pos0.y;\n\n            diff = _camera.cameraPosition(\n              x0 - _startTouchX0,\n              y0 - _startTouchY0,\n              true\n            );\n\n            newStageX = _startCameraX - diff.x;\n            newStageY = _startCameraY - diff.y;\n\n            if (newStageX !== _camera.x || newStageY !== _camera.y) {\n              _lastCameraX = _camera.x;\n              _lastCameraY = _camera.y;\n\n              _camera.goTo({\n                x: newStageX,\n                y: newStageY\n              });\n\n              _self.dispatchEvent('mousemove',\n                sigma.utils.mouseCoords(e, pos0.x, pos0.y));\n\n              _self.dispatchEvent('drag');\n            }\n            break;\n          case 2:\n            pos0 = position(_downTouches[0]);\n            pos1 = position(_downTouches[1]);\n            x0 = pos0.x;\n            y0 = pos0.y;\n            x1 = pos1.x;\n            y1 = pos1.y;\n\n            start = _camera.cameraPosition(\n              (_startTouchX0 + _startTouchX1) / 2 -\n                sigma.utils.getCenter(e).x,\n              (_startTouchY0 + _startTouchY1) / 2 -\n                sigma.utils.getCenter(e).y,\n              true\n            );\n            end = _camera.cameraPosition(\n              (x0 + x1) / 2 - sigma.utils.getCenter(e).x,\n              (y0 + y1) / 2 - sigma.utils.getCenter(e).y,\n              true\n            );\n\n            dAngle = Math.atan2(y1 - y0, x1 - x0) - _startTouchAngle;\n            dRatio = Math.sqrt(\n              (y1 - y0) * (y1 - y0) + (x1 - x0) * (x1 - x0)\n            ) / _startTouchDistance;\n\n            // Translation:\n            x0 = start.x;\n            y0 = start.y;\n\n            // Homothetic transformation:\n            newStageRatio = _startCameraRatio / dRatio;\n            x0 = x0 * dRatio;\n            y0 = y0 * dRatio;\n\n            // Rotation:\n            newStageAngle = _startCameraAngle - dAngle;\n            cos = Math.cos(-dAngle);\n            sin = Math.sin(-dAngle);\n            x1 = x0 * cos + y0 * sin;\n            y1 = y0 * cos - x0 * sin;\n            x0 = x1;\n            y0 = y1;\n\n            // Finalize:\n            newStageX = x0 - end.x + _startCameraX;\n            newStageY = y0 - end.y + _startCameraY;\n\n            if (\n              newStageRatio !== _camera.ratio ||\n              newStageAngle !== _camera.angle ||\n              newStageX !== _camera.x ||\n              newStageY !== _camera.y\n            ) {\n              _lastCameraX = _camera.x;\n              _lastCameraY = _camera.y;\n              _lastCameraAngle = _camera.angle;\n              _lastCameraRatio = _camera.ratio;\n\n              _camera.goTo({\n                x: newStageX,\n                y: newStageY,\n                angle: newStageAngle,\n                ratio: newStageRatio\n              });\n\n              _self.dispatchEvent('drag');\n            }\n\n            break;\n        }\n\n        e.preventDefault();\n        return false;\n      }\n    }\n\n    /**\n     * The handler listening to the double tap custom event. It will\n     * basically zoom into the graph.\n     *\n     * @param {event} e A touch event.\n     */\n    function _doubleTapHandler(e) {\n      var pos,\n          ratio,\n          animation;\n\n      if (e.touches && e.touches.length === 1 && _settings('touchEnabled')) {\n        _doubleTap = true;\n\n        ratio = 1 / _settings('doubleClickZoomingRatio');\n\n        pos = position(e.touches[0]);\n        _self.dispatchEvent('doubleclick',\n          sigma.utils.mouseCoords(e, pos.x, pos.y));\n\n        if (_settings('doubleClickEnabled')) {\n          pos = _camera.cameraPosition(\n            pos.x - sigma.utils.getCenter(e).x,\n            pos.y - sigma.utils.getCenter(e).y,\n            true\n          );\n\n          animation = {\n            duration: _settings('doubleClickZoomDuration'),\n            onComplete: function() {\n              _doubleTap = false;\n            }\n          };\n\n          sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);\n        }\n\n        if (e.preventDefault)\n          e.preventDefault();\n        else\n          e.returnValue = false;\n\n        e.stopPropagation();\n        return false;\n      }\n    }\n  };\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  if (typeof conrad === 'undefined')\n    throw 'conrad is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.renderers');\n\n  /**\n   * This function is the constructor of the canvas sigma's renderer.\n   *\n   * @param  {sigma.classes.graph}            graph    The graph to render.\n   * @param  {sigma.classes.camera}           camera   The camera.\n   * @param  {configurable}           settings The sigma instance settings\n   *                                           function.\n   * @param  {object}                 object   The options object.\n   * @return {sigma.renderers.canvas}          The renderer instance.\n   */\n  sigma.renderers.canvas = function(graph, camera, settings, options) {\n    if (typeof options !== 'object')\n      throw 'sigma.renderers.canvas: Wrong arguments.';\n\n    if (!(options.container instanceof HTMLElement))\n      throw 'Container not found.';\n\n    var k,\n        i,\n        l,\n        a,\n        fn,\n        self = this;\n\n    sigma.classes.dispatcher.extend(this);\n\n    // Initialize main attributes:\n    Object.defineProperty(this, 'conradId', {\n      value: sigma.utils.id()\n    });\n    this.graph = graph;\n    this.camera = camera;\n    this.contexts = {};\n    this.domElements = {};\n    this.options = options;\n    this.container = this.options.container;\n    this.settings = (\n        typeof options.settings === 'object' &&\n        options.settings\n      ) ?\n        settings.embedObjects(options.settings) :\n        settings;\n\n    // Node indexes:\n    this.nodesOnScreen = [];\n    this.edgesOnScreen = [];\n\n    // Conrad related attributes:\n    this.jobs = {};\n\n    // Find the prefix:\n    this.options.prefix = 'renderer' + this.conradId + ':';\n\n    // Initialize the DOM elements:\n    if (\n      !this.settings('batchEdgesDrawing')\n    ) {\n      this.initDOM('canvas', 'scene');\n      this.contexts.edges = this.contexts.scene;\n      this.contexts.nodes = this.contexts.scene;\n      this.contexts.labels = this.contexts.scene;\n    } else {\n      this.initDOM('canvas', 'edges');\n      this.initDOM('canvas', 'scene');\n      this.contexts.nodes = this.contexts.scene;\n      this.contexts.labels = this.contexts.scene;\n    }\n\n    this.initDOM('canvas', 'mouse');\n    this.contexts.hover = this.contexts.mouse;\n\n    // Initialize captors:\n    this.captors = [];\n    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];\n    for (i = 0, l = a.length; i < l; i++) {\n      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];\n      this.captors.push(\n        new fn(\n          this.domElements.mouse,\n          this.camera,\n          this.settings\n        )\n      );\n    }\n\n    // Deal with sigma events:\n    sigma.misc.bindEvents.call(this, this.options.prefix);\n    sigma.misc.drawHovers.call(this, this.options.prefix);\n\n    this.resize(false);\n  };\n\n\n\n\n  /**\n   * This method renders the graph on the canvases.\n   *\n   * @param  {?object}                options Eventually an object of options.\n   * @return {sigma.renderers.canvas}         Returns the instance itself.\n   */\n  sigma.renderers.canvas.prototype.render = function(options) {\n    options = options || {};\n\n    var a,\n        i,\n        k,\n        l,\n        o,\n        id,\n        end,\n        job,\n        start,\n        edges,\n        renderers,\n        rendererType,\n        batchSize,\n        tempGCO,\n        index = {},\n        graph = this.graph,\n        nodes = this.graph.nodes,\n        prefix = this.options.prefix || '',\n        drawEdges = this.settings(options, 'drawEdges'),\n        drawNodes = this.settings(options, 'drawNodes'),\n        drawLabels = this.settings(options, 'drawLabels'),\n        drawEdgeLabels = this.settings(options, 'drawEdgeLabels'),\n        embedSettings = this.settings.embedObjects(options, {\n          prefix: this.options.prefix\n        });\n\n    // Call the resize function:\n    this.resize(false);\n\n    // Check the 'hideEdgesOnMove' setting:\n    if (this.settings(options, 'hideEdgesOnMove'))\n      if (this.camera.isAnimated || this.camera.isMoving)\n        drawEdges = false;\n\n    // Apply the camera's view:\n    this.camera.applyView(\n      undefined,\n      this.options.prefix,\n      {\n        width: this.width,\n        height: this.height\n      }\n    );\n\n    // Clear canvases:\n    this.clear();\n\n    // Kill running jobs:\n    for (k in this.jobs)\n      if (conrad.hasJob(k))\n        conrad.killJob(k);\n\n    // Find which nodes are on screen:\n    this.edgesOnScreen = [];\n    this.nodesOnScreen = this.camera.quadtree.area(\n      this.camera.getRectangle(this.width, this.height)\n    );\n\n    for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)\n      index[a[i].id] = a[i];\n\n    // Draw edges:\n    // - If settings('batchEdgesDrawing') is true, the edges are displayed per\n    //   batches. If not, they are drawn in one frame.\n    if (drawEdges) {\n      // First, let's identify which edges to draw. To do this, we just keep\n      // every edges that have at least one extremity displayed according to\n      // the quadtree and the \"hidden\" attribute. We also do not keep hidden\n      // edges.\n      for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {\n        o = a[i];\n        if (\n          (index[o.source] || index[o.target]) &&\n          (!o.hidden && !nodes(o.source).hidden && !nodes(o.target).hidden)\n        )\n          this.edgesOnScreen.push(o);\n      }\n\n      // If the \"batchEdgesDrawing\" settings is true, edges are batched:\n      if (this.settings(options, 'batchEdgesDrawing')) {\n        id = 'edges_' + this.conradId;\n        batchSize = embedSettings('canvasEdgesBatchSize');\n\n        edges = this.edgesOnScreen;\n        l = edges.length;\n\n        start = 0;\n        end = Math.min(edges.length, start + batchSize);\n\n        job = function() {\n          tempGCO = this.contexts.edges.globalCompositeOperation;\n          this.contexts.edges.globalCompositeOperation = 'destination-over';\n\n          renderers = sigma.canvas.edges;\n          for (i = start; i < end; i++) {\n            o = edges[i];\n            (renderers[\n              o.type || this.settings(options, 'defaultEdgeType')\n            ] || renderers.def)(\n              o,\n              graph.nodes(o.source),\n              graph.nodes(o.target),\n              this.contexts.edges,\n              embedSettings\n            );\n          }\n\n          // Draw edge labels:\n          if (drawEdgeLabels) {\n            renderers = sigma.canvas.edges.labels;\n            for (i = start; i < end; i++) {\n              o = edges[i];\n              if (!o.hidden)\n                (renderers[\n                  o.type || this.settings(options, 'defaultEdgeType')\n                ] || renderers.def)(\n                  o,\n                  graph.nodes(o.source),\n                  graph.nodes(o.target),\n                  this.contexts.labels,\n                  embedSettings\n                );\n            }\n          }\n\n          // Restore original globalCompositeOperation:\n          this.contexts.edges.globalCompositeOperation = tempGCO;\n\n          // Catch job's end:\n          if (end === edges.length) {\n            delete this.jobs[id];\n            return false;\n          }\n\n          start = end + 1;\n          end = Math.min(edges.length, start + batchSize);\n          return true;\n        };\n\n        this.jobs[id] = job;\n        conrad.addJob(id, job.bind(this));\n\n      // If not, they are drawn in one frame:\n      } else {\n        renderers = sigma.canvas.edges;\n        for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {\n          o = a[i];\n          (renderers[\n            o.type || this.settings(options, 'defaultEdgeType')\n          ] || renderers.def)(\n            o,\n            graph.nodes(o.source),\n            graph.nodes(o.target),\n            this.contexts.edges,\n            embedSettings\n          );\n        }\n\n        // Draw edge labels:\n        // - No batching\n        if (drawEdgeLabels) {\n          renderers = sigma.canvas.edges.labels;\n          for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++)\n            if (!a[i].hidden)\n              (renderers[\n                a[i].type || this.settings(options, 'defaultEdgeType')\n              ] || renderers.def)(\n                a[i],\n                graph.nodes(a[i].source),\n                graph.nodes(a[i].target),\n                this.contexts.labels,\n                embedSettings\n              );\n        }\n      }\n    }\n\n    // Draw nodes:\n    // - No batching\n    if (drawNodes) {\n      renderers = sigma.canvas.nodes;\n      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)\n        if (!a[i].hidden)\n          (renderers[\n            a[i].type || this.settings(options, 'defaultNodeType')\n          ] || renderers.def)(\n            a[i],\n            this.contexts.nodes,\n            embedSettings\n          );\n    }\n\n    // Draw labels:\n    // - No batching\n    if (drawLabels) {\n      renderers = sigma.canvas.labels;\n      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)\n        if (!a[i].hidden)\n          (renderers[\n            a[i].type || this.settings(options, 'defaultNodeType')\n          ] || renderers.def)(\n            a[i],\n            this.contexts.labels,\n            embedSettings\n          );\n    }\n\n    this.dispatchEvent('render');\n\n    return this;\n  };\n\n  /**\n   * This method creates a DOM element of the specified type, switches its\n   * position to \"absolute\", references it to the domElements attribute, and\n   * finally appends it to the container.\n   *\n   * @param  {string} tag The label tag.\n   * @param  {string} id  The id of the element (to store it in \"domElements\").\n   */\n  sigma.renderers.canvas.prototype.initDOM = function(tag, id) {\n    var dom = document.createElement(tag);\n\n    dom.style.position = 'absolute';\n    dom.setAttribute('class', 'sigma-' + id);\n\n    this.domElements[id] = dom;\n    this.container.appendChild(dom);\n\n    if (tag.toLowerCase() === 'canvas')\n      this.contexts[id] = dom.getContext('2d');\n  };\n\n  /**\n   * This method resizes each DOM elements in the container and stores the new\n   * dimensions. Then, it renders the graph.\n   *\n   * @param  {?number}                width  The new width of the container.\n   * @param  {?number}                height The new height of the container.\n   * @return {sigma.renderers.canvas}        Returns the instance itself.\n   */\n  sigma.renderers.canvas.prototype.resize = function(w, h) {\n    var k,\n        oldWidth = this.width,\n        oldHeight = this.height,\n        pixelRatio = sigma.utils.getPixelRatio();\n\n    if (w !== undefined && h !== undefined) {\n      this.width = w;\n      this.height = h;\n    } else {\n      this.width = this.container.offsetWidth;\n      this.height = this.container.offsetHeight;\n\n      w = this.width;\n      h = this.height;\n    }\n\n    if (oldWidth !== this.width || oldHeight !== this.height) {\n      for (k in this.domElements) {\n        this.domElements[k].style.width = w + 'px';\n        this.domElements[k].style.height = h + 'px';\n\n        if (this.domElements[k].tagName.toLowerCase() === 'canvas') {\n          this.domElements[k].setAttribute('width', (w * pixelRatio) + 'px');\n          this.domElements[k].setAttribute('height', (h * pixelRatio) + 'px');\n\n          if (pixelRatio !== 1)\n            this.contexts[k].scale(pixelRatio, pixelRatio);\n        }\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * This method clears each canvas.\n   *\n   * @return {sigma.renderers.canvas} Returns the instance itself.\n   */\n  sigma.renderers.canvas.prototype.clear = function() {\n    for (var k in this.contexts) {\n      this.contexts[k].clearRect(0, 0, this.width, this.height);\n    }\n\n    return this;\n  };\n\n  /**\n   * This method kills contexts and other attributes.\n   */\n  sigma.renderers.canvas.prototype.kill = function() {\n    var k,\n        captor;\n\n    // Kill captors:\n    while ((captor = this.captors.pop()))\n      captor.kill();\n    delete this.captors;\n\n    // Kill contexts:\n    for (k in this.domElements) {\n      this.domElements[k].parentNode.removeChild(this.domElements[k]);\n      delete this.domElements[k];\n      delete this.contexts[k];\n    }\n    delete this.domElements;\n    delete this.contexts;\n  };\n\n\n\n\n  /**\n   * The labels, nodes and edges renderers are stored in the three following\n   * objects. When an element is drawn, its type will be checked and if a\n   * renderer with the same name exists, it will be used. If not found, the\n   * default renderer will be used instead.\n   *\n   * They are stored in different files, in the \"./canvas\" folder.\n   */\n  sigma.utils.pkg('sigma.canvas.nodes');\n  sigma.utils.pkg('sigma.canvas.edges');\n  sigma.utils.pkg('sigma.canvas.labels');\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.renderers');\n\n  /**\n   * This function is the constructor of the canvas sigma's renderer.\n   *\n   * @param  {sigma.classes.graph}            graph    The graph to render.\n   * @param  {sigma.classes.camera}           camera   The camera.\n   * @param  {configurable}           settings The sigma instance settings\n   *                                           function.\n   * @param  {object}                 object   The options object.\n   * @return {sigma.renderers.canvas}          The renderer instance.\n   */\n  sigma.renderers.webgl = function(graph, camera, settings, options) {\n    if (typeof options !== 'object')\n      throw 'sigma.renderers.webgl: Wrong arguments.';\n\n    if (!(options.container instanceof HTMLElement))\n      throw 'Container not found.';\n\n    var k,\n        i,\n        l,\n        a,\n        fn,\n        _self = this;\n\n    sigma.classes.dispatcher.extend(this);\n\n    // Conrad related attributes:\n    this.jobs = {};\n\n    Object.defineProperty(this, 'conradId', {\n      value: sigma.utils.id()\n    });\n\n    // Initialize main attributes:\n    this.graph = graph;\n    this.camera = camera;\n    this.contexts = {};\n    this.domElements = {};\n    this.options = options;\n    this.container = this.options.container;\n    this.settings = (\n        typeof options.settings === 'object' &&\n        options.settings\n      ) ?\n        settings.embedObjects(options.settings) :\n        settings;\n\n    // Find the prefix:\n    this.options.prefix = this.camera.readPrefix;\n\n    // Initialize programs hash\n    Object.defineProperty(this, 'nodePrograms', {\n      value: {}\n    });\n    Object.defineProperty(this, 'edgePrograms', {\n      value: {}\n    });\n    Object.defineProperty(this, 'nodeFloatArrays', {\n      value: {}\n    });\n    Object.defineProperty(this, 'edgeFloatArrays', {\n      value: {}\n    });\n    Object.defineProperty(this, 'edgeIndicesArrays', {\n      value: {}\n    });\n\n    // Initialize the DOM elements:\n    if (this.settings(options, 'batchEdgesDrawing')) {\n      this.initDOM('canvas', 'edges', true);\n      this.initDOM('canvas', 'nodes', true);\n    } else {\n      this.initDOM('canvas', 'scene', true);\n      this.contexts.nodes = this.contexts.scene;\n      this.contexts.edges = this.contexts.scene;\n    }\n\n    this.initDOM('canvas', 'labels');\n    this.initDOM('canvas', 'mouse');\n    this.contexts.hover = this.contexts.mouse;\n\n    // Initialize captors:\n    this.captors = [];\n    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];\n    for (i = 0, l = a.length; i < l; i++) {\n      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];\n      this.captors.push(\n        new fn(\n          this.domElements.mouse,\n          this.camera,\n          this.settings\n        )\n      );\n    }\n\n    // Deal with sigma events:\n    sigma.misc.bindEvents.call(this, this.camera.prefix);\n    sigma.misc.drawHovers.call(this, this.camera.prefix);\n\n    this.resize();\n  };\n\n\n\n\n  /**\n   * This method will generate the nodes and edges float arrays. This step is\n   * separated from the \"render\" method, because to keep WebGL efficient, since\n   * all the camera and middlewares are modelised as matrices and they do not\n   * require the float arrays to be regenerated.\n   *\n   * Basically, when the user moves the camera or applies some specific linear\n   * transformations, this process step will be skipped, and the \"render\"\n   * method will efficiently refresh the rendering.\n   *\n   * And when the user modifies the graph colors or positions (applying a new\n   * layout or filtering the colors, for instance), this \"process\" step will be\n   * required to regenerate the float arrays.\n   *\n   * @return {sigma.renderers.webgl} Returns the instance itself.\n   */\n  sigma.renderers.webgl.prototype.process = function() {\n    var a,\n        i,\n        l,\n        k,\n        type,\n        renderer,\n        graph = this.graph,\n        options = sigma.utils.extend(options, this.options),\n        defaultEdgeType = this.settings(options, 'defaultEdgeType'),\n        defaultNodeType = this.settings(options, 'defaultNodeType');\n\n    // Empty float arrays:\n    for (k in this.nodeFloatArrays)\n      delete this.nodeFloatArrays[k];\n\n    for (k in this.edgeFloatArrays)\n      delete this.edgeFloatArrays[k];\n\n    for (k in this.edgeIndicesArrays)\n      delete this.edgeIndicesArrays[k];\n\n    // Sort edges and nodes per types:\n    for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {\n      type = a[i].type || defaultEdgeType;\n      k = (type && sigma.webgl.edges[type]) ? type : 'def';\n\n      if (!this.edgeFloatArrays[k])\n        this.edgeFloatArrays[k] = {\n          edges: []\n        };\n\n      this.edgeFloatArrays[k].edges.push(a[i]);\n    }\n\n    for (a = graph.nodes(), i = 0, l = a.length; i < l; i++) {\n      type = a[i].type || defaultNodeType;\n      k = (type && sigma.webgl.nodes[type]) ? type : 'def';\n\n      if (!this.nodeFloatArrays[k])\n        this.nodeFloatArrays[k] = {\n          nodes: []\n        };\n\n      this.nodeFloatArrays[k].nodes.push(a[i]);\n    }\n\n    // Push edges:\n    for (k in this.edgeFloatArrays) {\n      renderer = sigma.webgl.edges[k];\n      a = this.edgeFloatArrays[k].edges;\n\n      // Creating the necessary arrays\n      this.edgeFloatArrays[k].array = new Float32Array(\n        a.length * renderer.POINTS * renderer.ATTRIBUTES\n      );\n\n      for (i = 0, l = a.length; i < l; i++) {\n\n        // Just check that the edge and both its extremities are visible:\n        if (\n          !a[i].hidden &&\n          !graph.nodes(a[i].source).hidden &&\n          !graph.nodes(a[i].target).hidden\n        )\n          renderer.addEdge(\n            a[i],\n            graph.nodes(a[i].source),\n            graph.nodes(a[i].target),\n            this.edgeFloatArrays[k].array,\n            i * renderer.POINTS * renderer.ATTRIBUTES,\n            options.prefix,\n            this.settings\n          );\n      }\n\n      if (typeof renderer.computeIndices === 'function')\n        this.edgeIndicesArrays[k] = renderer.computeIndices(\n          this.edgeFloatArrays[k].array\n        );\n    }\n\n    // Push nodes:\n    for (k in this.nodeFloatArrays) {\n      renderer = sigma.webgl.nodes[k];\n      a = this.nodeFloatArrays[k].nodes;\n\n      // Creating the necessary arrays\n      this.nodeFloatArrays[k].array = new Float32Array(\n        a.length * renderer.POINTS * renderer.ATTRIBUTES\n      );\n\n      for (i = 0, l = a.length; i < l; i++) {\n        if (!this.nodeFloatArrays[k].array)\n          this.nodeFloatArrays[k].array = new Float32Array(\n            a.length * renderer.POINTS * renderer.ATTRIBUTES\n          );\n\n        // Just check that the edge and both its extremities are visible:\n        if (\n          !a[i].hidden\n        )\n          renderer.addNode(\n            a[i],\n            this.nodeFloatArrays[k].array,\n            i * renderer.POINTS * renderer.ATTRIBUTES,\n            options.prefix,\n            this.settings\n          );\n      }\n    }\n\n    return this;\n  };\n\n\n\n\n  /**\n   * This method renders the graph. It basically calls each program (and\n   * generate them if they do not exist yet) to render nodes and edges, batched\n   * per renderer.\n   *\n   * As in the canvas renderer, it is possible to display edges, nodes and / or\n   * labels in batches, to make the whole thing way more scalable.\n   *\n   * @param  {?object}               params Eventually an object of options.\n   * @return {sigma.renderers.webgl}        Returns the instance itself.\n   */\n  sigma.renderers.webgl.prototype.render = function(params) {\n    var a,\n        i,\n        l,\n        k,\n        o,\n        program,\n        renderer,\n        self = this,\n        graph = this.graph,\n        nodesGl = this.contexts.nodes,\n        edgesGl = this.contexts.edges,\n        matrix = this.camera.getMatrix(),\n        options = sigma.utils.extend(params, this.options),\n        drawLabels = this.settings(options, 'drawLabels'),\n        drawEdges = this.settings(options, 'drawEdges'),\n        drawNodes = this.settings(options, 'drawNodes');\n\n    // Call the resize function:\n    this.resize(false);\n\n    // Check the 'hideEdgesOnMove' setting:\n    if (this.settings(options, 'hideEdgesOnMove'))\n      if (this.camera.isAnimated || this.camera.isMoving)\n        drawEdges = false;\n\n    // Clear canvases:\n    this.clear();\n\n    // Translate matrix to [width/2, height/2]:\n    matrix = sigma.utils.matrices.multiply(\n      matrix,\n      sigma.utils.matrices.translation(this.width / 2, this.height / 2)\n    );\n\n    // Kill running jobs:\n    for (k in this.jobs)\n      if (conrad.hasJob(k))\n        conrad.killJob(k);\n\n    if (drawEdges) {\n      if (this.settings(options, 'batchEdgesDrawing'))\n        (function() {\n          var a,\n              k,\n              i,\n              id,\n              job,\n              arr,\n              end,\n              start,\n              indices,\n              renderer,\n              batchSize,\n              currentProgram;\n\n          id = 'edges_' + this.conradId;\n          batchSize = this.settings(options, 'webglEdgesBatchSize');\n          a = Object.keys(this.edgeFloatArrays);\n\n          if (!a.length)\n            return;\n          i = 0;\n          renderer = sigma.webgl.edges[a[i]];\n          arr = this.edgeFloatArrays[a[i]].array;\n          indices = this.edgeIndicesArrays[a[i]];\n          start = 0;\n          end = Math.min(\n            start + batchSize * renderer.POINTS,\n            arr.length / renderer.ATTRIBUTES\n          );\n\n          job = function() {\n            // Check program:\n            if (!this.edgePrograms[a[i]])\n              this.edgePrograms[a[i]] = renderer.initProgram(edgesGl);\n\n            if (start < end) {\n              edgesGl.useProgram(this.edgePrograms[a[i]]);\n              renderer.render(\n                edgesGl,\n                this.edgePrograms[a[i]],\n                arr,\n                {\n                  settings: this.settings,\n                  matrix: matrix,\n                  width: this.width,\n                  height: this.height,\n                  ratio: this.camera.ratio,\n                  scalingRatio: this.settings(\n                    options,\n                    'webglOversamplingRatio'\n                  ),\n                  start: start,\n                  count: end - start,\n                  indicesData: indices\n                }\n              );\n            }\n\n            // Catch job's end:\n            if (\n              end >= arr.length / renderer.ATTRIBUTES &&\n              i === a.length - 1\n            ) {\n              delete this.jobs[id];\n              return false;\n            }\n\n            if (end >= arr.length / renderer.ATTRIBUTES) {\n              i++;\n              arr = this.edgeFloatArrays[a[i]].array;\n              renderer = sigma.webgl.edges[a[i]];\n              start = 0;\n              end = Math.min(\n                start + batchSize * renderer.POINTS,\n                arr.length / renderer.ATTRIBUTES\n              );\n            } else {\n              start = end;\n              end = Math.min(\n                start + batchSize * renderer.POINTS,\n                arr.length / renderer.ATTRIBUTES\n              );\n            }\n\n            return true;\n          };\n\n          this.jobs[id] = job;\n          conrad.addJob(id, job.bind(this));\n        }).call(this);\n      else {\n        for (k in this.edgeFloatArrays) {\n          renderer = sigma.webgl.edges[k];\n\n          // Check program:\n          if (!this.edgePrograms[k])\n            this.edgePrograms[k] = renderer.initProgram(edgesGl);\n\n          // Render\n          if (this.edgeFloatArrays[k]) {\n            edgesGl.useProgram(this.edgePrograms[k]);\n            renderer.render(\n              edgesGl,\n              this.edgePrograms[k],\n              this.edgeFloatArrays[k].array,\n              {\n                settings: this.settings,\n                matrix: matrix,\n                width: this.width,\n                height: this.height,\n                ratio: this.camera.ratio,\n                scalingRatio: this.settings(options, 'webglOversamplingRatio'),\n                indicesData: this.edgeIndicesArrays[k]\n              }\n            );\n          }\n        }\n      }\n    }\n\n    if (drawNodes) {\n      // Enable blending:\n      nodesGl.blendFunc(nodesGl.SRC_ALPHA, nodesGl.ONE_MINUS_SRC_ALPHA);\n      nodesGl.enable(nodesGl.BLEND);\n\n      for (k in this.nodeFloatArrays) {\n        renderer = sigma.webgl.nodes[k];\n\n        // Check program:\n        if (!this.nodePrograms[k])\n          this.nodePrograms[k] = renderer.initProgram(nodesGl);\n\n        // Render\n        if (this.nodeFloatArrays[k]) {\n          nodesGl.useProgram(this.nodePrograms[k]);\n          renderer.render(\n            nodesGl,\n            this.nodePrograms[k],\n            this.nodeFloatArrays[k].array,\n            {\n              settings: this.settings,\n              matrix: matrix,\n              width: this.width,\n              height: this.height,\n              ratio: this.camera.ratio,\n              scalingRatio: this.settings(options, 'webglOversamplingRatio')\n            }\n          );\n        }\n      }\n    }\n\n    if (drawLabels) {\n      a = this.camera.quadtree.area(\n        this.camera.getRectangle(this.width, this.height)\n      );\n\n      // Apply camera view to these nodes:\n      this.camera.applyView(\n        undefined,\n        undefined,\n        {\n          nodes: a,\n          edges: [],\n          width: this.width,\n          height: this.height\n        }\n      );\n\n      o = function(key) {\n        return self.settings({\n          prefix: self.camera.prefix\n        }, key);\n      };\n\n      for (i = 0, l = a.length; i < l; i++)\n        if (!a[i].hidden)\n          (\n            sigma.canvas.labels[\n              a[i].type ||\n              this.settings(options, 'defaultNodeType')\n            ] || sigma.canvas.labels.def\n          )(a[i], this.contexts.labels, o);\n    }\n\n    this.dispatchEvent('render');\n\n    return this;\n  };\n\n\n\n\n  /**\n   * This method creates a DOM element of the specified type, switches its\n   * position to \"absolute\", references it to the domElements attribute, and\n   * finally appends it to the container.\n   *\n   * @param  {string}   tag   The label tag.\n   * @param  {string}   id    The id of the element (to store it in\n   *                          \"domElements\").\n   * @param  {?boolean} webgl Will init the WebGL context if true.\n   */\n  sigma.renderers.webgl.prototype.initDOM = function(tag, id, webgl) {\n    var gl,\n        dom = document.createElement(tag),\n        self = this;\n\n    dom.style.position = 'absolute';\n    dom.setAttribute('class', 'sigma-' + id);\n\n    this.domElements[id] = dom;\n    this.container.appendChild(dom);\n\n    if (tag.toLowerCase() === 'canvas') {\n      this.contexts[id] = dom.getContext(webgl ? 'experimental-webgl' : '2d', {\n        preserveDrawingBuffer: true\n      });\n\n      // Adding webgl context loss listeners\n      if (webgl) {\n        dom.addEventListener('webglcontextlost', function(e) {\n          e.preventDefault();\n        }, false);\n\n        dom.addEventListener('webglcontextrestored', function(e) {\n          self.render();\n        }, false);\n      }\n    }\n  };\n\n  /**\n   * This method resizes each DOM elements in the container and stores the new\n   * dimensions. Then, it renders the graph.\n   *\n   * @param  {?number}               width  The new width of the container.\n   * @param  {?number}               height The new height of the container.\n   * @return {sigma.renderers.webgl}        Returns the instance itself.\n   */\n  sigma.renderers.webgl.prototype.resize = function(w, h) {\n    var k,\n        oldWidth = this.width,\n        oldHeight = this.height,\n        pixelRatio = sigma.utils.getPixelRatio();\n\n    if (w !== undefined && h !== undefined) {\n      this.width = w;\n      this.height = h;\n    } else {\n      this.width = this.container.offsetWidth;\n      this.height = this.container.offsetHeight;\n\n      w = this.width;\n      h = this.height;\n    }\n\n    if (oldWidth !== this.width || oldHeight !== this.height) {\n      for (k in this.domElements) {\n        this.domElements[k].style.width = w + 'px';\n        this.domElements[k].style.height = h + 'px';\n\n        if (this.domElements[k].tagName.toLowerCase() === 'canvas') {\n          // If simple 2D canvas:\n          if (this.contexts[k] && this.contexts[k].scale) {\n            this.domElements[k].setAttribute('width', (w * pixelRatio) + 'px');\n            this.domElements[k].setAttribute('height', (h * pixelRatio) + 'px');\n\n            if (pixelRatio !== 1)\n              this.contexts[k].scale(pixelRatio, pixelRatio);\n          } else {\n            this.domElements[k].setAttribute(\n              'width',\n              (w * this.settings('webglOversamplingRatio')) + 'px'\n            );\n            this.domElements[k].setAttribute(\n              'height',\n              (h * this.settings('webglOversamplingRatio')) + 'px'\n            );\n          }\n        }\n      }\n    }\n\n    // Scale:\n    for (k in this.contexts)\n      if (this.contexts[k] && this.contexts[k].viewport)\n        this.contexts[k].viewport(\n          0,\n          0,\n          this.width * this.settings('webglOversamplingRatio'),\n          this.height * this.settings('webglOversamplingRatio')\n        );\n\n    return this;\n  };\n\n  /**\n   * This method clears each canvas.\n   *\n   * @return {sigma.renderers.webgl} Returns the instance itself.\n   */\n  sigma.renderers.webgl.prototype.clear = function() {\n    this.contexts.labels.clearRect(0, 0, this.width, this.height);\n    this.contexts.nodes.clear(this.contexts.nodes.COLOR_BUFFER_BIT);\n    this.contexts.edges.clear(this.contexts.edges.COLOR_BUFFER_BIT);\n\n    return this;\n  };\n\n  /**\n   * This method kills contexts and other attributes.\n   */\n  sigma.renderers.webgl.prototype.kill = function() {\n    var k,\n        captor;\n\n    // Kill captors:\n    while ((captor = this.captors.pop()))\n      captor.kill();\n    delete this.captors;\n\n    // Kill contexts:\n    for (k in this.domElements) {\n      this.domElements[k].parentNode.removeChild(this.domElements[k]);\n      delete this.domElements[k];\n      delete this.contexts[k];\n    }\n    delete this.domElements;\n    delete this.contexts;\n  };\n\n\n\n\n  /**\n   * The object \"sigma.webgl.nodes\" contains the different WebGL node\n   * renderers. The default one draw nodes as discs. Here are the attributes\n   * any node renderer must have:\n   *\n   * {number}   POINTS      The number of points required to draw a node.\n   * {number}   ATTRIBUTES  The number of attributes needed to draw one point.\n   * {function} addNode     A function that adds a node to the data stack that\n   *                        will be given to the buffer. Here is the arguments:\n   *                        > {object}       node\n   *                        > {number}       index   The node index in the\n   *                                                 nodes array.\n   *                        > {Float32Array} data    The stack.\n   *                        > {object}       options Some options.\n   * {function} render      The function that will effectively render the nodes\n   *                        into the buffer.\n   *                        > {WebGLRenderingContext} gl\n   *                        > {WebGLProgram}          program\n   *                        > {Float32Array} data    The stack to give to the\n   *                                                 buffer.\n   *                        > {object}       params  An object containing some\n   *                                                 options, like width,\n   *                                                 height, the camera ratio.\n   * {function} initProgram The function that will initiate the program, with\n   *                        the relevant shaders and parameters. It must return\n   *                        the newly created program.\n   *\n   * Check sigma.webgl.nodes.def or sigma.webgl.nodes.fast to see how it\n   * works more precisely.\n   */\n  sigma.utils.pkg('sigma.webgl.nodes');\n\n\n\n\n  /**\n   * The object \"sigma.webgl.edges\" contains the different WebGL edge\n   * renderers. The default one draw edges as direct lines. Here are the\n   * attributes any edge renderer must have:\n   *\n   * {number}   POINTS      The number of points required to draw an edge.\n   * {number}   ATTRIBUTES  The number of attributes needed to draw one point.\n   * {function} addEdge     A function that adds an edge to the data stack that\n   *                        will be given to the buffer. Here is the arguments:\n   *                        > {object}       edge\n   *                        > {object}       source\n   *                        > {object}       target\n   *                        > {Float32Array} data    The stack.\n   *                        > {object}       options Some options.\n   * {function} render      The function that will effectively render the edges\n   *                        into the buffer.\n   *                        > {WebGLRenderingContext} gl\n   *                        > {WebGLProgram}          program\n   *                        > {Float32Array} data    The stack to give to the\n   *                                                 buffer.\n   *                        > {object}       params  An object containing some\n   *                                                 options, like width,\n   *                                                 height, the camera ratio.\n   * {function} initProgram The function that will initiate the program, with\n   *                        the relevant shaders and parameters. It must return\n   *                        the newly created program.\n   *\n   * Check sigma.webgl.edges.def or sigma.webgl.edges.fast to see how it\n   * works more precisely.\n   */\n  sigma.utils.pkg('sigma.webgl.edges');\n\n\n\n\n  /**\n   * The object \"sigma.canvas.labels\" contains the different\n   * label renderers for the WebGL renderer. Since displaying texts in WebGL is\n   * definitely painful and since there a way less labels to display than nodes\n   * or edges, the default renderer simply renders them in a canvas.\n   *\n   * A labels renderer is a simple function, taking as arguments the related\n   * node, the renderer and a settings function.\n   */\n  sigma.utils.pkg('sigma.canvas.labels');\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  if (typeof conrad === 'undefined')\n    throw 'conrad is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.renderers');\n\n  /**\n   * This function is the constructor of the svg sigma's renderer.\n   *\n   * @param  {sigma.classes.graph}            graph    The graph to render.\n   * @param  {sigma.classes.camera}           camera   The camera.\n   * @param  {configurable}           settings The sigma instance settings\n   *                                           function.\n   * @param  {object}                 object   The options object.\n   * @return {sigma.renderers.svg}             The renderer instance.\n   */\n  sigma.renderers.svg = function(graph, camera, settings, options) {\n    if (typeof options !== 'object')\n      throw 'sigma.renderers.svg: Wrong arguments.';\n\n    if (!(options.container instanceof HTMLElement))\n      throw 'Container not found.';\n\n    var i,\n        l,\n        a,\n        fn,\n        self = this;\n\n    sigma.classes.dispatcher.extend(this);\n\n    // Initialize main attributes:\n    this.graph = graph;\n    this.camera = camera;\n    this.domElements = {\n      graph: null,\n      groups: {},\n      nodes: {},\n      edges: {},\n      labels: {},\n      hovers: {}\n    };\n    this.measurementCanvas = null;\n    this.options = options;\n    this.container = this.options.container;\n    this.settings = (\n        typeof options.settings === 'object' &&\n        options.settings\n      ) ?\n        settings.embedObjects(options.settings) :\n        settings;\n\n    // Is the renderer meant to be freestyle?\n    this.settings('freeStyle', !!this.options.freeStyle);\n\n    // SVG xmlns\n    this.settings('xmlns', 'http://www.w3.org/2000/svg');\n\n    // Indexes:\n    this.nodesOnScreen = [];\n    this.edgesOnScreen = [];\n\n    // Find the prefix:\n    this.options.prefix = 'renderer' + sigma.utils.id() + ':';\n\n    // Initialize the DOM elements\n    this.initDOM('svg');\n\n    // Initialize captors:\n    this.captors = [];\n    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];\n    for (i = 0, l = a.length; i < l; i++) {\n      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];\n      this.captors.push(\n        new fn(\n          this.domElements.graph,\n          this.camera,\n          this.settings\n        )\n      );\n    }\n\n    // Bind resize:\n    window.addEventListener('resize', function() {\n      self.resize();\n    });\n\n    // Deal with sigma events:\n    // TODO: keep an option to override the DOM events?\n    sigma.misc.bindDOMEvents.call(this, this.domElements.graph);\n    this.bindHovers(this.options.prefix);\n\n    // Resize\n    this.resize(false);\n  };\n\n  /**\n   * This method renders the graph on the svg scene.\n   *\n   * @param  {?object}                options Eventually an object of options.\n   * @return {sigma.renderers.svg}            Returns the instance itself.\n   */\n  sigma.renderers.svg.prototype.render = function(options) {\n    options = options || {};\n\n    var a,\n        i,\n        k,\n        e,\n        l,\n        o,\n        source,\n        target,\n        start,\n        edges,\n        renderers,\n        subrenderers,\n        index = {},\n        graph = this.graph,\n        nodes = this.graph.nodes,\n        prefix = this.options.prefix || '',\n        drawEdges = this.settings(options, 'drawEdges'),\n        drawNodes = this.settings(options, 'drawNodes'),\n        drawLabels = this.settings(options, 'drawLabels'),\n        embedSettings = this.settings.embedObjects(options, {\n          prefix: this.options.prefix,\n          forceLabels: this.options.forceLabels\n        });\n\n    // Check the 'hideEdgesOnMove' setting:\n    if (this.settings(options, 'hideEdgesOnMove'))\n      if (this.camera.isAnimated || this.camera.isMoving)\n        drawEdges = false;\n\n    // Apply the camera's view:\n    this.camera.applyView(\n      undefined,\n      this.options.prefix,\n      {\n        width: this.width,\n        height: this.height\n      }\n    );\n\n    // Hiding everything\n    // TODO: find a more sensible way to perform this operation\n    this.hideDOMElements(this.domElements.nodes);\n    this.hideDOMElements(this.domElements.edges);\n    this.hideDOMElements(this.domElements.labels);\n\n    // Find which nodes are on screen\n    this.edgesOnScreen = [];\n    this.nodesOnScreen = this.camera.quadtree.area(\n      this.camera.getRectangle(this.width, this.height)\n    );\n\n    // Node index\n    for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)\n      index[a[i].id] = a[i];\n\n    // Find which edges are on screen\n    for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {\n      o = a[i];\n      if (\n        (index[o.source] || index[o.target]) &&\n        (!o.hidden && !nodes(o.source).hidden && !nodes(o.target).hidden)\n      )\n        this.edgesOnScreen.push(o);\n    }\n\n    // Display nodes\n    //---------------\n    renderers = sigma.svg.nodes;\n    subrenderers = sigma.svg.labels;\n\n    //-- First we create the nodes which are not already created\n    if (drawNodes)\n      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++) {\n        if (!a[i].hidden && !this.domElements.nodes[a[i].id]) {\n\n          // Node\n          e = (renderers[a[i].type] || renderers.def).create(\n            a[i],\n            embedSettings\n          );\n\n          this.domElements.nodes[a[i].id] = e;\n          this.domElements.groups.nodes.appendChild(e);\n\n          // Label\n          e = (subrenderers[a[i].type] || subrenderers.def).create(\n            a[i],\n            embedSettings\n          );\n\n          this.domElements.labels[a[i].id] = e;\n          this.domElements.groups.labels.appendChild(e);\n        }\n      }\n\n    //-- Second we update the nodes\n    if (drawNodes)\n      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++) {\n\n        if (a[i].hidden)\n          continue;\n\n        // Node\n        (renderers[a[i].type] || renderers.def).update(\n          a[i],\n          this.domElements.nodes[a[i].id],\n          embedSettings\n        );\n\n        // Label\n        (subrenderers[a[i].type] || subrenderers.def).update(\n          a[i],\n          this.domElements.labels[a[i].id],\n          embedSettings\n        );\n      }\n\n    // Display edges\n    //---------------\n    renderers = sigma.svg.edges;\n\n    //-- First we create the edges which are not already created\n    if (drawEdges)\n      for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {\n        if (!this.domElements.edges[a[i].id]) {\n          source = nodes(a[i].source);\n          target = nodes(a[i].target);\n\n          e = (renderers[a[i].type] || renderers.def).create(\n            a[i],\n            source,\n            target,\n            embedSettings\n          );\n\n          this.domElements.edges[a[i].id] = e;\n          this.domElements.groups.edges.appendChild(e);\n        }\n       }\n\n    //-- Second we update the edges\n    if (drawEdges)\n      for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {\n        source = nodes(a[i].source);\n        target = nodes(a[i].target);\n\n        (renderers[a[i].type] || renderers.def).update(\n          a[i],\n          this.domElements.edges[a[i].id],\n          source,\n          target,\n          embedSettings\n        );\n       }\n\n    this.dispatchEvent('render');\n\n    return this;\n  };\n\n  /**\n   * This method creates a DOM element of the specified type, switches its\n   * position to \"absolute\", references it to the domElements attribute, and\n   * finally appends it to the container.\n   *\n   * @param  {string} tag The label tag.\n   * @param  {string} id  The id of the element (to store it in \"domElements\").\n   */\n  sigma.renderers.svg.prototype.initDOM = function(tag) {\n    var dom = document.createElementNS(this.settings('xmlns'), tag),\n        c = this.settings('classPrefix'),\n        g,\n        l,\n        i;\n\n    dom.style.position = 'absolute';\n    dom.setAttribute('class', c + '-svg');\n\n    // Setting SVG namespace\n    dom.setAttribute('xmlns', this.settings('xmlns'));\n    dom.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');\n    dom.setAttribute('version', '1.1');\n\n    // Creating the measurement canvas\n    var canvas = document.createElement('canvas');\n    canvas.setAttribute('class', c + '-measurement-canvas');\n\n    // Appending elements\n    this.domElements.graph = this.container.appendChild(dom);\n\n    // Creating groups\n    var groups = ['edges', 'nodes', 'labels', 'hovers'];\n    for (i = 0, l = groups.length; i < l; i++) {\n      g = document.createElementNS(this.settings('xmlns'), 'g');\n\n      g.setAttributeNS(null, 'id', c + '-group-' + groups[i]);\n      g.setAttributeNS(null, 'class', c + '-group');\n\n      this.domElements.groups[groups[i]] =\n        this.domElements.graph.appendChild(g);\n    }\n\n    // Appending measurement canvas\n    this.container.appendChild(canvas);\n    this.measurementCanvas = canvas.getContext('2d');\n  };\n\n  /**\n   * This method hides a batch of SVG DOM elements.\n   *\n   * @param  {array}                  elements  An array of elements to hide.\n   * @param  {object}                 renderer  The renderer to use.\n   * @return {sigma.renderers.svg}              Returns the instance itself.\n   */\n  sigma.renderers.svg.prototype.hideDOMElements = function(elements) {\n    var o,\n        i;\n\n    for (i in elements) {\n      o = elements[i];\n      sigma.svg.utils.hide(o);\n    }\n\n    return this;\n  };\n\n  /**\n   * This method binds the hover events to the renderer.\n   *\n   * @param  {string} prefix The renderer prefix.\n   */\n  // TODO: add option about whether to display hovers or not\n  sigma.renderers.svg.prototype.bindHovers = function(prefix) {\n    var renderers = sigma.svg.hovers,\n        self = this,\n        hoveredNode;\n\n    function overNode(e) {\n      var node = e.data.node,\n          embedSettings = self.settings.embedObjects({\n            prefix: prefix\n          });\n\n      if (!embedSettings('enableHovering'))\n        return;\n\n      var hover = (renderers[node.type] || renderers.def).create(\n        node,\n        self.domElements.nodes[node.id],\n        self.measurementCanvas,\n        embedSettings\n      );\n\n      self.domElements.hovers[node.id] = hover;\n\n      // Inserting the hover in the dom\n      self.domElements.groups.hovers.appendChild(hover);\n      hoveredNode = node;\n    }\n\n    function outNode(e) {\n      var node = e.data.node,\n          embedSettings = self.settings.embedObjects({\n            prefix: prefix\n          });\n\n      if (!embedSettings('enableHovering'))\n        return;\n\n      // Deleting element\n      self.domElements.groups.hovers.removeChild(\n        self.domElements.hovers[node.id]\n      );\n      hoveredNode = null;\n      delete self.domElements.hovers[node.id];\n\n      // Reinstate\n      self.domElements.groups.nodes.appendChild(\n        self.domElements.nodes[node.id]\n      );\n    }\n\n    // OPTIMIZE: perform a real update rather than a deletion\n    function update() {\n      if (!hoveredNode)\n        return;\n\n      var embedSettings = self.settings.embedObjects({\n            prefix: prefix\n          });\n\n      // Deleting element before update\n      self.domElements.groups.hovers.removeChild(\n        self.domElements.hovers[hoveredNode.id]\n      );\n      delete self.domElements.hovers[hoveredNode.id];\n\n      var hover = (renderers[hoveredNode.type] || renderers.def).create(\n        hoveredNode,\n        self.domElements.nodes[hoveredNode.id],\n        self.measurementCanvas,\n        embedSettings\n      );\n\n      self.domElements.hovers[hoveredNode.id] = hover;\n\n      // Inserting the hover in the dom\n      self.domElements.groups.hovers.appendChild(hover);\n    }\n\n    // Binding events\n    this.bind('overNode', overNode);\n    this.bind('outNode', outNode);\n\n    // Update on render\n    this.bind('render', update);\n  };\n\n  /**\n   * This method resizes each DOM elements in the container and stores the new\n   * dimensions. Then, it renders the graph.\n   *\n   * @param  {?number}                width  The new width of the container.\n   * @param  {?number}                height The new height of the container.\n   * @return {sigma.renderers.svg}           Returns the instance itself.\n   */\n  sigma.renderers.svg.prototype.resize = function(w, h) {\n    var oldWidth = this.width,\n        oldHeight = this.height,\n        pixelRatio = 1;\n\n    if (w !== undefined && h !== undefined) {\n      this.width = w;\n      this.height = h;\n    } else {\n      this.width = this.container.offsetWidth;\n      this.height = this.container.offsetHeight;\n\n      w = this.width;\n      h = this.height;\n    }\n\n    if (oldWidth !== this.width || oldHeight !== this.height) {\n      this.domElements.graph.style.width = w + 'px';\n      this.domElements.graph.style.height = h + 'px';\n\n      if (this.domElements.graph.tagName.toLowerCase() === 'svg') {\n        this.domElements.graph.setAttribute('width', (w * pixelRatio));\n        this.domElements.graph.setAttribute('height', (h * pixelRatio));\n      }\n    }\n\n    return this;\n  };\n\n\n  /**\n   * The labels, nodes and edges renderers are stored in the three following\n   * objects. When an element is drawn, its type will be checked and if a\n   * renderer with the same name exists, it will be used. If not found, the\n   * default renderer will be used instead.\n   *\n   * They are stored in different files, in the \"./svg\" folder.\n   */\n  sigma.utils.pkg('sigma.svg.nodes');\n  sigma.utils.pkg('sigma.svg.edges');\n  sigma.utils.pkg('sigma.svg.labels');\n}).call(this);\n\n;(function(global) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.renderers');\n\n  // Check if WebGL is enabled:\n  var canvas,\n      webgl = !!global.WebGLRenderingContext;\n  if (webgl) {\n    canvas = document.createElement('canvas');\n    try {\n      webgl = !!(\n        canvas.getContext('webgl') ||\n        canvas.getContext('experimental-webgl')\n      );\n    } catch (e) {\n      webgl = false;\n    }\n  }\n\n  // Copy the good renderer:\n  sigma.renderers.def = webgl ?\n    sigma.renderers.webgl :\n    sigma.renderers.canvas;\n})(this);\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.webgl.nodes');\n\n  /**\n   * This node renderer will display nodes as discs, shaped in triangles with\n   * the gl.TRIANGLES display mode. So, to be more precise, to draw one node,\n   * it will store three times the center of node, with the color and the size,\n   * and an angle indicating which \"corner\" of the triangle to draw.\n   *\n   * The fragment shader does not deal with anti-aliasing, so make sure that\n   * you deal with it somewhere else in the code (by default, the WebGL\n   * renderer will oversample the rendering through the webglOversamplingRatio\n   * value).\n   */\n  sigma.webgl.nodes.def = {\n    POINTS: 3,\n    ATTRIBUTES: 5,\n    addNode: function(node, data, i, prefix, settings) {\n      var color = sigma.utils.floatColor(\n        node.color || settings('defaultNodeColor')\n      );\n\n      data[i++] = node[prefix + 'x'];\n      data[i++] = node[prefix + 'y'];\n      data[i++] = node[prefix + 'size'];\n      data[i++] = color;\n      data[i++] = 0;\n\n      data[i++] = node[prefix + 'x'];\n      data[i++] = node[prefix + 'y'];\n      data[i++] = node[prefix + 'size'];\n      data[i++] = color;\n      data[i++] = 2 * Math.PI / 3;\n\n      data[i++] = node[prefix + 'x'];\n      data[i++] = node[prefix + 'y'];\n      data[i++] = node[prefix + 'size'];\n      data[i++] = color;\n      data[i++] = 4 * Math.PI / 3;\n    },\n    render: function(gl, program, data, params) {\n      var buffer;\n\n      // Define attributes:\n      var positionLocation =\n            gl.getAttribLocation(program, 'a_position'),\n          sizeLocation =\n            gl.getAttribLocation(program, 'a_size'),\n          colorLocation =\n            gl.getAttribLocation(program, 'a_color'),\n          angleLocation =\n            gl.getAttribLocation(program, 'a_angle'),\n          resolutionLocation =\n            gl.getUniformLocation(program, 'u_resolution'),\n          matrixLocation =\n            gl.getUniformLocation(program, 'u_matrix'),\n          ratioLocation =\n            gl.getUniformLocation(program, 'u_ratio'),\n          scaleLocation =\n            gl.getUniformLocation(program, 'u_scale');\n\n      buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);\n\n      gl.uniform2f(resolutionLocation, params.width, params.height);\n      gl.uniform1f(\n        ratioLocation,\n        1 / Math.pow(params.ratio, params.settings('nodesPowRatio'))\n      );\n      gl.uniform1f(scaleLocation, params.scalingRatio);\n      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);\n\n      gl.enableVertexAttribArray(positionLocation);\n      gl.enableVertexAttribArray(sizeLocation);\n      gl.enableVertexAttribArray(colorLocation);\n      gl.enableVertexAttribArray(angleLocation);\n\n      gl.vertexAttribPointer(\n        positionLocation,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        0\n      );\n      gl.vertexAttribPointer(\n        sizeLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        8\n      );\n      gl.vertexAttribPointer(\n        colorLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        12\n      );\n      gl.vertexAttribPointer(\n        angleLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        16\n      );\n\n      gl.drawArrays(\n        gl.TRIANGLES,\n        params.start || 0,\n        params.count || (data.length / this.ATTRIBUTES)\n      );\n    },\n    initProgram: function(gl) {\n      var vertexShader,\n          fragmentShader,\n          program;\n\n      vertexShader = sigma.utils.loadShader(\n        gl,\n        [\n          'attribute vec2 a_position;',\n          'attribute float a_size;',\n          'attribute float a_color;',\n          'attribute float a_angle;',\n\n          'uniform vec2 u_resolution;',\n          'uniform float u_ratio;',\n          'uniform float u_scale;',\n          'uniform mat3 u_matrix;',\n\n          'varying vec4 color;',\n          'varying vec2 center;',\n          'varying float radius;',\n\n          'void main() {',\n            // Multiply the point size twice:\n            'radius = a_size * u_ratio;',\n\n            // Scale from [[-1 1] [-1 1]] to the container:\n            'vec2 position = (u_matrix * vec3(a_position, 1)).xy;',\n            // 'center = (position / u_resolution * 2.0 - 1.0) * vec2(1, -1);',\n            'center = position * u_scale;',\n            'center = vec2(center.x, u_scale * u_resolution.y - center.y);',\n\n            'position = position +',\n              '2.0 * radius * vec2(cos(a_angle), sin(a_angle));',\n            'position = (position / u_resolution * 2.0 - 1.0) * vec2(1, -1);',\n\n            'radius = radius * u_scale;',\n\n            'gl_Position = vec4(position, 0, 1);',\n\n            // Extract the color:\n            'float c = a_color;',\n            'color.b = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.g = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',\n            'color.a = 1.0;',\n          '}'\n        ].join('\\n'),\n        gl.VERTEX_SHADER\n      );\n\n      fragmentShader = sigma.utils.loadShader(\n        gl,\n        [\n          'precision mediump float;',\n\n          'varying vec4 color;',\n          'varying vec2 center;',\n          'varying float radius;',\n\n          'void main(void) {',\n            'vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);',\n\n            'vec2 m = gl_FragCoord.xy - center;',\n            'float diff = radius - sqrt(m.x * m.x + m.y * m.y);',\n\n            // Here is how we draw a disc instead of a square:\n            'if (diff > 0.0)',\n              'gl_FragColor = color;',\n            'else',\n              'gl_FragColor = color0;',\n          '}'\n        ].join('\\n'),\n        gl.FRAGMENT_SHADER\n      );\n\n      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);\n\n      return program;\n    }\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.webgl.nodes');\n\n  /**\n   * This node renderer will display nodes in the fastest way: Nodes are basic\n   * squares, drawn through the gl.POINTS drawing method. The size of the nodes\n   * are represented with the \"gl_PointSize\" value in the vertex shader.\n   *\n   * It is the fastest node renderer here since the buffer just takes one line\n   * to draw each node (with attributes \"x\", \"y\", \"size\" and \"color\").\n   *\n   * Nevertheless, this method has some problems, especially due to some issues\n   * with the gl.POINTS:\n   *  - First, if the center of a node is outside the scene, the point will not\n   *    be drawn, even if it should be partly on screen.\n   *  - I tried applying a fragment shader similar to the one in the default\n   *    node renderer to display them as discs, but it did not work fine on\n   *    some computers settings, filling the discs with weird gradients not\n   *    depending on the actual color.\n   */\n  sigma.webgl.nodes.fast = {\n    POINTS: 1,\n    ATTRIBUTES: 4,\n    addNode: function(node, data, i, prefix, settings) {\n      data[i++] = node[prefix + 'x'];\n      data[i++] = node[prefix + 'y'];\n      data[i++] = node[prefix + 'size'];\n      data[i++] = sigma.utils.floatColor(\n        node.color || settings('defaultNodeColor')\n      );\n    },\n    render: function(gl, program, data, params) {\n      var buffer;\n\n      // Define attributes:\n      var positionLocation =\n            gl.getAttribLocation(program, 'a_position'),\n          sizeLocation =\n            gl.getAttribLocation(program, 'a_size'),\n          colorLocation =\n            gl.getAttribLocation(program, 'a_color'),\n          resolutionLocation =\n            gl.getUniformLocation(program, 'u_resolution'),\n          matrixLocation =\n            gl.getUniformLocation(program, 'u_matrix'),\n          ratioLocation =\n            gl.getUniformLocation(program, 'u_ratio'),\n          scaleLocation =\n            gl.getUniformLocation(program, 'u_scale');\n\n      buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);\n\n      gl.uniform2f(resolutionLocation, params.width, params.height);\n      gl.uniform1f(\n        ratioLocation,\n        1 / Math.pow(params.ratio, params.settings('nodesPowRatio'))\n      );\n      gl.uniform1f(scaleLocation, params.scalingRatio);\n      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);\n\n      gl.enableVertexAttribArray(positionLocation);\n      gl.enableVertexAttribArray(sizeLocation);\n      gl.enableVertexAttribArray(colorLocation);\n\n      gl.vertexAttribPointer(\n        positionLocation,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        0\n      );\n      gl.vertexAttribPointer(\n        sizeLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        8\n      );\n      gl.vertexAttribPointer(\n        colorLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        12\n      );\n\n      gl.drawArrays(\n        gl.POINTS,\n        params.start || 0,\n        params.count || (data.length / this.ATTRIBUTES)\n      );\n    },\n    initProgram: function(gl) {\n      var vertexShader,\n          fragmentShader,\n          program;\n\n      vertexShader = sigma.utils.loadShader(\n        gl,\n        [\n          'attribute vec2 a_position;',\n          'attribute float a_size;',\n          'attribute float a_color;',\n\n          'uniform vec2 u_resolution;',\n          'uniform float u_ratio;',\n          'uniform float u_scale;',\n          'uniform mat3 u_matrix;',\n\n          'varying vec4 color;',\n\n          'void main() {',\n            // Scale from [[-1 1] [-1 1]] to the container:\n            'gl_Position = vec4(',\n              '((u_matrix * vec3(a_position, 1)).xy /',\n                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',\n              '0,',\n              '1',\n            ');',\n\n            // Multiply the point size twice:\n            //  - x SCALING_RATIO to correct the canvas scaling\n            //  - x 2 to correct the formulae\n            'gl_PointSize = a_size * u_ratio * u_scale * 2.0;',\n\n            // Extract the color:\n            'float c = a_color;',\n            'color.b = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.g = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',\n            'color.a = 1.0;',\n          '}'\n        ].join('\\n'),\n        gl.VERTEX_SHADER\n      );\n\n      fragmentShader = sigma.utils.loadShader(\n        gl,\n        [\n          'precision mediump float;',\n\n          'varying vec4 color;',\n\n          'void main(void) {',\n            'float border = 0.01;',\n            'float radius = 0.5;',\n\n            'vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);',\n            'vec2 m = gl_PointCoord - vec2(0.5, 0.5);',\n            'float dist = radius - sqrt(m.x * m.x + m.y * m.y);',\n\n            'float t = 0.0;',\n            'if (dist > border)',\n              't = 1.0;',\n            'else if (dist > 0.0)',\n              't = dist / border;',\n\n            'gl_FragColor = mix(color0, color, t);',\n          '}'\n        ].join('\\n'),\n        gl.FRAGMENT_SHADER\n      );\n\n      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);\n\n      return program;\n    }\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.webgl.edges');\n\n  /**\n   * This edge renderer will display edges as lines going from the source node\n   * to the target node. To deal with edge thicknesses, the lines are made of\n   * two triangles forming rectangles, with the gl.TRIANGLES drawing mode.\n   *\n   * It is expensive, since drawing a single edge requires 6 points, each\n   * having 7 attributes (source position, target position, thickness, color\n   * and a flag indicating which vertice of the rectangle it is).\n   */\n  sigma.webgl.edges.def = {\n    POINTS: 6,\n    ATTRIBUTES: 7,\n    addEdge: function(edge, source, target, data, i, prefix, settings) {\n      var w = (edge[prefix + 'size'] || 1) / 2,\n          x1 = source[prefix + 'x'],\n          y1 = source[prefix + 'y'],\n          x2 = target[prefix + 'x'],\n          y2 = target[prefix + 'y'],\n          color = edge.color;\n\n      if (!color)\n        switch (settings('edgeColor')) {\n          case 'source':\n            color = source.color || settings('defaultNodeColor');\n            break;\n          case 'target':\n            color = target.color || settings('defaultNodeColor');\n            break;\n          default:\n            color = settings('defaultEdgeColor');\n            break;\n        }\n\n      // Normalize color:\n      color = sigma.utils.floatColor(color);\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = 1.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = 1.0;\n      data[i++] = color;\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = 0.0;\n      data[i++] = color;\n    },\n    render: function(gl, program, data, params) {\n      var buffer;\n\n      // Define attributes:\n      var colorLocation =\n            gl.getAttribLocation(program, 'a_color'),\n          positionLocation1 =\n            gl.getAttribLocation(program, 'a_position1'),\n          positionLocation2 =\n            gl.getAttribLocation(program, 'a_position2'),\n          thicknessLocation =\n            gl.getAttribLocation(program, 'a_thickness'),\n          minusLocation =\n            gl.getAttribLocation(program, 'a_minus'),\n          resolutionLocation =\n            gl.getUniformLocation(program, 'u_resolution'),\n          matrixLocation =\n            gl.getUniformLocation(program, 'u_matrix'),\n          matrixHalfPiLocation =\n            gl.getUniformLocation(program, 'u_matrixHalfPi'),\n          matrixHalfPiMinusLocation =\n            gl.getUniformLocation(program, 'u_matrixHalfPiMinus'),\n          ratioLocation =\n            gl.getUniformLocation(program, 'u_ratio'),\n          scaleLocation =\n            gl.getUniformLocation(program, 'u_scale');\n\n      buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);\n\n      gl.uniform2f(resolutionLocation, params.width, params.height);\n      gl.uniform1f(\n        ratioLocation,\n        params.ratio / Math.pow(params.ratio, params.settings('edgesPowRatio'))\n      );\n      gl.uniform1f(scaleLocation, params.scalingRatio);\n      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);\n      gl.uniformMatrix2fv(\n        matrixHalfPiLocation,\n        false,\n        sigma.utils.matrices.rotation(Math.PI / 2, true)\n      );\n      gl.uniformMatrix2fv(\n        matrixHalfPiMinusLocation,\n        false,\n        sigma.utils.matrices.rotation(-Math.PI / 2, true)\n      );\n\n      gl.enableVertexAttribArray(colorLocation);\n      gl.enableVertexAttribArray(positionLocation1);\n      gl.enableVertexAttribArray(positionLocation2);\n      gl.enableVertexAttribArray(thicknessLocation);\n      gl.enableVertexAttribArray(minusLocation);\n\n      gl.vertexAttribPointer(positionLocation1,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        0\n      );\n      gl.vertexAttribPointer(positionLocation2,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        8\n      );\n      gl.vertexAttribPointer(thicknessLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        16\n      );\n      gl.vertexAttribPointer(minusLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        20\n      );\n      gl.vertexAttribPointer(colorLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        24\n      );\n\n      gl.drawArrays(\n        gl.TRIANGLES,\n        params.start || 0,\n        params.count || (data.length / this.ATTRIBUTES)\n      );\n    },\n    initProgram: function(gl) {\n      var vertexShader,\n          fragmentShader,\n          program;\n\n      vertexShader = sigma.utils.loadShader(\n        gl,\n        [\n          'attribute vec2 a_position1;',\n          'attribute vec2 a_position2;',\n          'attribute float a_thickness;',\n          'attribute float a_minus;',\n          'attribute float a_color;',\n\n          'uniform vec2 u_resolution;',\n          'uniform float u_ratio;',\n          'uniform float u_scale;',\n          'uniform mat3 u_matrix;',\n          'uniform mat2 u_matrixHalfPi;',\n          'uniform mat2 u_matrixHalfPiMinus;',\n\n          'varying vec4 color;',\n\n          'void main() {',\n            // Find the good point:\n            'vec2 position = a_thickness * u_ratio *',\n              'normalize(a_position2 - a_position1);',\n\n            'mat2 matrix = a_minus * u_matrixHalfPiMinus +',\n              '(1.0 - a_minus) * u_matrixHalfPi;',\n\n            'position = matrix * position + a_position1;',\n\n            // Scale from [[-1 1] [-1 1]] to the container:\n            'gl_Position = vec4(',\n              '((u_matrix * vec3(position, 1)).xy /',\n                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',\n              '0,',\n              '1',\n            ');',\n\n            // Extract the color:\n            'float c = a_color;',\n            'color.b = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.g = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',\n            'color.a = 1.0;',\n          '}'\n        ].join('\\n'),\n        gl.VERTEX_SHADER\n      );\n\n      fragmentShader = sigma.utils.loadShader(\n        gl,\n        [\n          'precision mediump float;',\n\n          'varying vec4 color;',\n\n          'void main(void) {',\n            'gl_FragColor = color;',\n          '}'\n        ].join('\\n'),\n        gl.FRAGMENT_SHADER\n      );\n\n      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);\n\n      return program;\n    }\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.webgl.edges');\n\n  /**\n   * This edge renderer will display edges as lines with the gl.LINES display\n   * mode. Since this mode does not support well thickness, edges are all drawn\n   * with the same thickness (3px), independantly of the edge attributes or the\n   * zooming ratio.\n   */\n  sigma.webgl.edges.fast = {\n    POINTS: 2,\n    ATTRIBUTES: 3,\n    addEdge: function(edge, source, target, data, i, prefix, settings) {\n      var w = (edge[prefix + 'size'] || 1) / 2,\n          x1 = source[prefix + 'x'],\n          y1 = source[prefix + 'y'],\n          x2 = target[prefix + 'x'],\n          y2 = target[prefix + 'y'],\n          color = edge.color;\n\n      if (!color)\n        switch (settings('edgeColor')) {\n          case 'source':\n            color = source.color || settings('defaultNodeColor');\n            break;\n          case 'target':\n            color = target.color || settings('defaultNodeColor');\n            break;\n          default:\n            color = settings('defaultEdgeColor');\n            break;\n        }\n\n      // Normalize color:\n      color = sigma.utils.floatColor(color);\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = color;\n    },\n    render: function(gl, program, data, params) {\n      var buffer;\n\n      // Define attributes:\n      var colorLocation =\n            gl.getAttribLocation(program, 'a_color'),\n          positionLocation =\n            gl.getAttribLocation(program, 'a_position'),\n          resolutionLocation =\n            gl.getUniformLocation(program, 'u_resolution'),\n          matrixLocation =\n            gl.getUniformLocation(program, 'u_matrix');\n\n      buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);\n\n      gl.uniform2f(resolutionLocation, params.width, params.height);\n      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);\n\n      gl.enableVertexAttribArray(positionLocation);\n      gl.enableVertexAttribArray(colorLocation);\n\n      gl.vertexAttribPointer(positionLocation,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        0\n      );\n      gl.vertexAttribPointer(colorLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        8\n      );\n\n      gl.lineWidth(3);\n      gl.drawArrays(\n        gl.LINES,\n        params.start || 0,\n        params.count || (data.length / this.ATTRIBUTES)\n      );\n    },\n    initProgram: function(gl) {\n      var vertexShader,\n          fragmentShader,\n          program;\n\n      vertexShader = sigma.utils.loadShader(\n        gl,\n        [\n          'attribute vec2 a_position;',\n          'attribute float a_color;',\n\n          'uniform vec2 u_resolution;',\n          'uniform mat3 u_matrix;',\n\n          'varying vec4 color;',\n\n          'void main() {',\n            // Scale from [[-1 1] [-1 1]] to the container:\n            'gl_Position = vec4(',\n              '((u_matrix * vec3(a_position, 1)).xy /',\n                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',\n              '0,',\n              '1',\n            ');',\n\n            // Extract the color:\n            'float c = a_color;',\n            'color.b = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.g = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',\n            'color.a = 1.0;',\n          '}'\n        ].join('\\n'),\n        gl.VERTEX_SHADER\n      );\n\n      fragmentShader = sigma.utils.loadShader(\n        gl,\n        [\n          'precision mediump float;',\n\n          'varying vec4 color;',\n\n          'void main(void) {',\n            'gl_FragColor = color;',\n          '}'\n        ].join('\\n'),\n        gl.FRAGMENT_SHADER\n      );\n\n      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);\n\n      return program;\n    }\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.webgl.edges');\n\n  /**\n   * This edge renderer will display edges as arrows going from the source node\n   * to the target node. To deal with edge thicknesses, the lines are made of\n   * three triangles: two forming rectangles, with the gl.TRIANGLES drawing\n   * mode.\n   *\n   * It is expensive, since drawing a single edge requires 9 points, each\n   * having a lot of attributes.\n   */\n  sigma.webgl.edges.arrow = {\n    POINTS: 9,\n    ATTRIBUTES: 11,\n    addEdge: function(edge, source, target, data, i, prefix, settings) {\n      var w = (edge[prefix + 'size'] || 1) / 2,\n          x1 = source[prefix + 'x'],\n          y1 = source[prefix + 'y'],\n          x2 = target[prefix + 'x'],\n          y2 = target[prefix + 'y'],\n          targetSize = target[prefix + 'size'],\n          color = edge.color;\n\n      if (!color)\n        switch (settings('edgeColor')) {\n          case 'source':\n            color = source.color || settings('defaultNodeColor');\n            break;\n          case 'target':\n            color = target.color || settings('defaultNodeColor');\n            break;\n          default:\n            color = settings('defaultEdgeColor');\n            break;\n        }\n\n      // Normalize color:\n      color = sigma.utils.floatColor(color);\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 0.0;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      // Arrow head:\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 1.0;\n      data[i++] = -1.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 1.0;\n      data[i++] = 1.0;\n      data[i++] = color;\n    },\n    render: function(gl, program, data, params) {\n      var buffer;\n\n      // Define attributes:\n      var positionLocation1 =\n            gl.getAttribLocation(program, 'a_pos1'),\n          positionLocation2 =\n            gl.getAttribLocation(program, 'a_pos2'),\n          thicknessLocation =\n            gl.getAttribLocation(program, 'a_thickness'),\n          targetSizeLocation =\n            gl.getAttribLocation(program, 'a_tSize'),\n          delayLocation =\n            gl.getAttribLocation(program, 'a_delay'),\n          minusLocation =\n            gl.getAttribLocation(program, 'a_minus'),\n          headLocation =\n            gl.getAttribLocation(program, 'a_head'),\n          headPositionLocation =\n            gl.getAttribLocation(program, 'a_headPosition'),\n          colorLocation =\n            gl.getAttribLocation(program, 'a_color'),\n          resolutionLocation =\n            gl.getUniformLocation(program, 'u_resolution'),\n          matrixLocation =\n            gl.getUniformLocation(program, 'u_matrix'),\n          matrixHalfPiLocation =\n            gl.getUniformLocation(program, 'u_matrixHalfPi'),\n          matrixHalfPiMinusLocation =\n            gl.getUniformLocation(program, 'u_matrixHalfPiMinus'),\n          ratioLocation =\n            gl.getUniformLocation(program, 'u_ratio'),\n          nodeRatioLocation =\n            gl.getUniformLocation(program, 'u_nodeRatio'),\n          arrowHeadLocation =\n            gl.getUniformLocation(program, 'u_arrowHead'),\n          scaleLocation =\n            gl.getUniformLocation(program, 'u_scale');\n\n      buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);\n\n      gl.uniform2f(resolutionLocation, params.width, params.height);\n      gl.uniform1f(\n        ratioLocation,\n        params.ratio / Math.pow(params.ratio, params.settings('edgesPowRatio'))\n      );\n      gl.uniform1f(\n        nodeRatioLocation,\n        Math.pow(params.ratio, params.settings('nodesPowRatio')) /\n        params.ratio\n      );\n      gl.uniform1f(arrowHeadLocation, 5.0);\n      gl.uniform1f(scaleLocation, params.scalingRatio);\n      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);\n      gl.uniformMatrix2fv(\n        matrixHalfPiLocation,\n        false,\n        sigma.utils.matrices.rotation(Math.PI / 2, true)\n      );\n      gl.uniformMatrix2fv(\n        matrixHalfPiMinusLocation,\n        false,\n        sigma.utils.matrices.rotation(-Math.PI / 2, true)\n      );\n\n      gl.enableVertexAttribArray(positionLocation1);\n      gl.enableVertexAttribArray(positionLocation2);\n      gl.enableVertexAttribArray(thicknessLocation);\n      gl.enableVertexAttribArray(targetSizeLocation);\n      gl.enableVertexAttribArray(delayLocation);\n      gl.enableVertexAttribArray(minusLocation);\n      gl.enableVertexAttribArray(headLocation);\n      gl.enableVertexAttribArray(headPositionLocation);\n      gl.enableVertexAttribArray(colorLocation);\n\n      gl.vertexAttribPointer(positionLocation1,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        0\n      );\n      gl.vertexAttribPointer(positionLocation2,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        8\n      );\n      gl.vertexAttribPointer(thicknessLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        16\n      );\n      gl.vertexAttribPointer(targetSizeLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        20\n      );\n      gl.vertexAttribPointer(delayLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        24\n      );\n      gl.vertexAttribPointer(minusLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        28\n      );\n      gl.vertexAttribPointer(headLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        32\n      );\n      gl.vertexAttribPointer(headPositionLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        36\n      );\n      gl.vertexAttribPointer(colorLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        40\n      );\n\n      gl.drawArrays(\n        gl.TRIANGLES,\n        params.start || 0,\n        params.count || (data.length / this.ATTRIBUTES)\n      );\n    },\n    initProgram: function(gl) {\n      var vertexShader,\n          fragmentShader,\n          program;\n\n      vertexShader = sigma.utils.loadShader(\n        gl,\n        [\n          'attribute vec2 a_pos1;',\n          'attribute vec2 a_pos2;',\n          'attribute float a_thickness;',\n          'attribute float a_tSize;',\n          'attribute float a_delay;',\n          'attribute float a_minus;',\n          'attribute float a_head;',\n          'attribute float a_headPosition;',\n          'attribute float a_color;',\n\n          'uniform vec2 u_resolution;',\n          'uniform float u_ratio;',\n          'uniform float u_nodeRatio;',\n          'uniform float u_arrowHead;',\n          'uniform float u_scale;',\n          'uniform mat3 u_matrix;',\n          'uniform mat2 u_matrixHalfPi;',\n          'uniform mat2 u_matrixHalfPiMinus;',\n\n          'varying vec4 color;',\n\n          'void main() {',\n            // Find the good point:\n            'vec2 pos = normalize(a_pos2 - a_pos1);',\n\n            'mat2 matrix = (1.0 - a_head) *',\n              '(',\n                'a_minus * u_matrixHalfPiMinus +',\n                '(1.0 - a_minus) * u_matrixHalfPi',\n              ') + a_head * (',\n                'a_headPosition * u_matrixHalfPiMinus * 0.6 +',\n                '(a_headPosition * a_headPosition - 1.0) * mat2(1.0)',\n              ');',\n\n            'pos = a_pos1 + (',\n              // Deal with body:\n              '(1.0 - a_head) * a_thickness * u_ratio * matrix * pos +',\n              // Deal with head:\n              'a_head * u_arrowHead * a_thickness * u_ratio * matrix * pos +',\n              // Deal with delay:\n              'a_delay * pos * (',\n                'a_tSize / u_nodeRatio +',\n                'u_arrowHead * a_thickness * u_ratio',\n              ')',\n            ');',\n\n            // Scale from [[-1 1] [-1 1]] to the container:\n            'gl_Position = vec4(',\n              '((u_matrix * vec3(pos, 1)).xy /',\n                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',\n              '0,',\n              '1',\n            ');',\n\n            // Extract the color:\n            'float c = a_color;',\n            'color.b = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.g = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',\n            'color.a = 1.0;',\n          '}'\n        ].join('\\n'),\n        gl.VERTEX_SHADER\n      );\n\n      fragmentShader = sigma.utils.loadShader(\n        gl,\n        [\n          'precision mediump float;',\n\n          'varying vec4 color;',\n\n          'void main(void) {',\n            'gl_FragColor = color;',\n          '}'\n        ].join('\\n'),\n        gl.FRAGMENT_SHADER\n      );\n\n      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);\n\n      return program;\n    }\n  };\n})();\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.canvas.labels');\n\n  /**\n   * This label renderer will just display the label on the right of the node.\n   *\n   * @param  {object}                   node     The node object.\n   * @param  {CanvasRenderingContext2D} context  The canvas context.\n   * @param  {configurable}             settings The settings function.\n   */\n  sigma.canvas.labels.def = function(node, context, settings) {\n    var fontSize,\n        prefix = settings('prefix') || '',\n        size = node[prefix + 'size'];\n\n    if (size < settings('labelThreshold'))\n      return;\n\n    if (!node.label || typeof node.label !== 'string')\n      return;\n\n    fontSize = (settings('labelSize') === 'fixed') ?\n      settings('defaultLabelSize') :\n      settings('labelSizeRatio') * size;\n\n    context.font = (settings('fontStyle') ? settings('fontStyle') + ' ' : '') +\n      fontSize + 'px ' + settings('font');\n    context.fillStyle = (settings('labelColor') === 'node') ?\n      (node.color || settings('defaultNodeColor')) :\n      settings('defaultLabelColor');\n\n    context.fillText(\n      node.label,\n      Math.round(node[prefix + 'x'] + size + 3),\n      Math.round(node[prefix + 'y'] + fontSize / 3)\n    );\n  };\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.canvas.hovers');\n\n  /**\n   * This hover renderer will basically display the label with a background.\n   *\n   * @param  {object}                   node     The node object.\n   * @param  {CanvasRenderingContext2D} context  The canvas context.\n   * @param  {configurable}             settings The settings function.\n   */\n  sigma.canvas.hovers.def = function(node, context, settings) {\n    var x,\n        y,\n        w,\n        h,\n        e,\n        fontStyle = settings('hoverFontStyle') || settings('fontStyle'),\n        prefix = settings('prefix') || '',\n        size = node[prefix + 'size'],\n        fontSize = (settings('labelSize') === 'fixed') ?\n          settings('defaultLabelSize') :\n          settings('labelSizeRatio') * size;\n\n    // Label background:\n    context.font = (fontStyle ? fontStyle + ' ' : '') +\n      fontSize + 'px ' + (settings('hoverFont') || settings('font'));\n\n    context.beginPath();\n    context.fillStyle = settings('labelHoverBGColor') === 'node' ?\n      (node.color || settings('defaultNodeColor')) :\n      settings('defaultHoverLabelBGColor');\n\n    if (node.label && settings('labelHoverShadow')) {\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n      context.shadowBlur = 8;\n      context.shadowColor = settings('labelHoverShadowColor');\n    }\n\n    if (node.label && typeof node.label === 'string') {\n      x = Math.round(node[prefix + 'x'] - fontSize / 2 - 2);\n      y = Math.round(node[prefix + 'y'] - fontSize / 2 - 2);\n      w = Math.round(\n        context.measureText(node.label).width + fontSize / 2 + size + 7\n      );\n      h = Math.round(fontSize + 4);\n      e = Math.round(fontSize / 2 + 2);\n\n      context.moveTo(x, y + e);\n      context.arcTo(x, y, x + e, y, e);\n      context.lineTo(x + w, y);\n      context.lineTo(x + w, y + h);\n      context.lineTo(x + e, y + h);\n      context.arcTo(x, y + h, x, y + h - e, e);\n      context.lineTo(x, y + e);\n\n      context.closePath();\n      context.fill();\n\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n      context.shadowBlur = 0;\n    }\n\n    // Node border:\n    if (settings('borderSize') > 0) {\n      context.beginPath();\n      context.fillStyle = settings('nodeBorderColor') === 'node' ?\n        (node.color || settings('defaultNodeColor')) :\n        settings('defaultNodeBorderColor');\n      context.arc(\n        node[prefix + 'x'],\n        node[prefix + 'y'],\n        size + settings('borderSize'),\n        0,\n        Math.PI * 2,\n        true\n      );\n      context.closePath();\n      context.fill();\n    }\n\n    // Node:\n    var nodeRenderer = sigma.canvas.nodes[node.type] || sigma.canvas.nodes.def;\n    nodeRenderer(node, context, settings);\n\n    // Display the label:\n    if (node.label && typeof node.label === 'string') {\n      context.fillStyle = (settings('labelHoverColor') === 'node') ?\n        (node.color || settings('defaultNodeColor')) :\n        settings('defaultLabelHoverColor');\n\n      context.fillText(\n        node.label,\n        Math.round(node[prefix + 'x'] + size + 3),\n        Math.round(node[prefix + 'y'] + fontSize / 3)\n      );\n    }\n  };\n}).call(this);\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.nodes');\n\n  /**\n   * The default node renderer. It renders the node as a simple disc.\n   *\n   * @param  {object}                   node     The node object.\n   * @param  {CanvasRenderingContext2D} context  The canvas context.\n   * @param  {configurable}             settings The settings function.\n   */\n  sigma.canvas.nodes.def = function(node, context, settings) {\n    var prefix = settings('prefix') || '';\n\n    context.fillStyle = node.color || settings('defaultNodeColor');\n    context.beginPath();\n    context.arc(\n      node[prefix + 'x'],\n      node[prefix + 'y'],\n      node[prefix + 'size'],\n      0,\n      Math.PI * 2,\n      true\n    );\n\n    context.closePath();\n    context.fill();\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edges');\n\n  /**\n   * The default edge renderer. It renders the edge as a simple line.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edges.def = function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        size = edge[prefix + 'size'] || 1,\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor');\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(\n      source[prefix + 'x'],\n      source[prefix + 'y']\n    );\n    context.lineTo(\n      target[prefix + 'x'],\n      target[prefix + 'y']\n    );\n    context.stroke();\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edges');\n\n  /**\n   * This edge renderer will display edges as arrows going from the source node\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edges.arrow = function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        size = edge[prefix + 'size'] || 1,\n        tSize = target[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'],\n        aSize = Math.max(size * 2.5, settings('minArrowSize')),\n        d = Math.sqrt(Math.pow(tX - sX, 2) + Math.pow(tY - sY, 2)),\n        aX = sX + (tX - sX) * (d - aSize - tSize) / d,\n        aY = sY + (tY - sY) * (d - aSize - tSize) / d,\n        vX = (tX - sX) * aSize / d,\n        vY = (tY - sY) * aSize / d;\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n    context.lineTo(\n      aX,\n      aY\n    );\n    context.stroke();\n\n    context.fillStyle = color;\n    context.beginPath();\n    context.moveTo(aX + vX, aY + vY);\n    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);\n    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);\n    context.lineTo(aX + vX, aY + vY);\n    context.closePath();\n    context.fill();\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edgehovers');\n\n  /**\n   * This hover renderer will display the edge with a different color or size.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edgehovers.def =\n    function(edge, source, target, context, settings) {\n      var color = edge.color,\n        prefix = settings('prefix') || '',\n        size = edge[prefix + 'size'] || 1,\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor');\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    if (settings('edgeHoverColor') === 'edge') {\n      color = edge.hover_color || color;\n    } else {\n      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;\n    }\n    size *= settings('edgeHoverSizeRatio');\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(\n      source[prefix + 'x'],\n      source[prefix + 'y']\n    );\n    context.lineTo(\n      target[prefix + 'x'],\n      target[prefix + 'y']\n    );\n    context.stroke();\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edgehovers');\n\n  /**\n   * This hover renderer will display the edge with a different color or size.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edgehovers.curve =\n    function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        size = settings('edgeHoverSizeRatio') * (edge[prefix + 'size'] || 1),\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        cp = {},\n        sSize = source[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'];\n\n    cp = (source.id === target.id) ?\n      sigma.utils.getSelfLoopControlPoints(sX, sY, sSize) :\n      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY);\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    if (settings('edgeHoverColor') === 'edge') {\n      color = edge.hover_color || color;\n    } else {\n      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;\n    }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n    if (source.id === target.id) {\n      context.bezierCurveTo(cp.x1, cp.y1, cp.x2, cp.y2, tX, tY);\n    } else {\n      context.quadraticCurveTo(cp.x, cp.y, tX, tY);\n    }\n    context.stroke();\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edgehovers');\n\n  /**\n   * This hover renderer will display the edge with a different color or size.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edgehovers.arrow =\n    function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        size = edge[prefix + 'size'] || 1,\n        tSize = target[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'];\n\n    size = (edge.hover) ?\n      settings('edgeHoverSizeRatio') * size : size;\n    var aSize = size * 2.5,\n        d = Math.sqrt(Math.pow(tX - sX, 2) + Math.pow(tY - sY, 2)),\n        aX = sX + (tX - sX) * (d - aSize - tSize) / d,\n        aY = sY + (tY - sY) * (d - aSize - tSize) / d,\n        vX = (tX - sX) * aSize / d,\n        vY = (tY - sY) * aSize / d;\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    if (settings('edgeHoverColor') === 'edge') {\n      color = edge.hover_color || color;\n    } else {\n      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;\n    }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n    context.lineTo(\n      aX,\n      aY\n    );\n    context.stroke();\n\n    context.fillStyle = color;\n    context.beginPath();\n    context.moveTo(aX + vX, aY + vY);\n    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);\n    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);\n    context.lineTo(aX + vX, aY + vY);\n    context.closePath();\n    context.fill();\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edgehovers');\n\n  /**\n   * This hover renderer will display the edge with a different color or size.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edgehovers.curvedArrow =\n    function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        cp = {},\n        size = settings('edgeHoverSizeRatio') * (edge[prefix + 'size'] || 1),\n        tSize = target[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'],\n        d,\n        aSize,\n        aX,\n        aY,\n        vX,\n        vY;\n\n    cp = (source.id === target.id) ?\n      sigma.utils.getSelfLoopControlPoints(sX, sY, tSize) :\n      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY);\n\n    if (source.id === target.id) {\n      d = Math.sqrt(Math.pow(tX - cp.x1, 2) + Math.pow(tY - cp.y1, 2));\n      aSize = size * 2.5;\n      aX = cp.x1 + (tX - cp.x1) * (d - aSize - tSize) / d;\n      aY = cp.y1 + (tY - cp.y1) * (d - aSize - tSize) / d;\n      vX = (tX - cp.x1) * aSize / d;\n      vY = (tY - cp.y1) * aSize / d;\n    }\n    else {\n      d = Math.sqrt(Math.pow(tX - cp.x, 2) + Math.pow(tY - cp.y, 2));\n      aSize = size * 2.5;\n      aX = cp.x + (tX - cp.x) * (d - aSize - tSize) / d;\n      aY = cp.y + (tY - cp.y) * (d - aSize - tSize) / d;\n      vX = (tX - cp.x) * aSize / d;\n      vY = (tY - cp.y) * aSize / d;\n    }\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    if (settings('edgeHoverColor') === 'edge') {\n      color = edge.hover_color || color;\n    } else {\n      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;\n    }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n    if (source.id === target.id) {\n      context.bezierCurveTo(cp.x2, cp.y2, cp.x1, cp.y1, aX, aY);\n    } else {\n      context.quadraticCurveTo(cp.x, cp.y, aX, aY);\n    }\n    context.stroke();\n\n    context.fillStyle = color;\n    context.beginPath();\n    context.moveTo(aX + vX, aY + vY);\n    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);\n    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);\n    context.lineTo(aX + vX, aY + vY);\n    context.closePath();\n    context.fill();\n  };\n})();\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.canvas.extremities');\n\n  /**\n   * The default renderer for hovered edge extremities. It renders the edge\n   * extremities as hovered.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.extremities.def =\n    function(edge, source, target, context, settings) {\n    // Source Node:\n    (\n      sigma.canvas.hovers[source.type] ||\n      sigma.canvas.hovers.def\n    ) (\n      source, context, settings\n    );\n\n    // Target Node:\n    (\n      sigma.canvas.hovers[target.type] ||\n      sigma.canvas.hovers.def\n    ) (\n      target, context, settings\n    );\n  };\n}).call(this);\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.svg.utils');\n\n  /**\n   * Some useful functions used by sigma's SVG renderer.\n   */\n  sigma.svg.utils = {\n\n    /**\n     * SVG Element show.\n     *\n     * @param  {DOMElement}               element   The DOM element to show.\n     */\n    show: function(element) {\n      element.style.display = '';\n      return this;\n    },\n\n    /**\n     * SVG Element hide.\n     *\n     * @param  {DOMElement}               element   The DOM element to hide.\n     */\n    hide: function(element) {\n      element.style.display = 'none';\n      return this;\n    }\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.svg.nodes');\n\n  /**\n   * The default node renderer. It renders the node as a simple disc.\n   */\n  sigma.svg.nodes.def = {\n\n    /**\n     * SVG Element creation.\n     *\n     * @param  {object}                   node     The node object.\n     * @param  {configurable}             settings The settings function.\n     */\n    create: function(node, settings) {\n      var prefix = settings('prefix') || '',\n          circle = document.createElementNS(settings('xmlns'), 'circle');\n\n      // Defining the node's circle\n      circle.setAttributeNS(null, 'data-node-id', node.id);\n      circle.setAttributeNS(null, 'class', settings('classPrefix') + '-node');\n      circle.setAttributeNS(\n        null, 'fill', node.color || settings('defaultNodeColor'));\n\n      // Returning the DOM Element\n      return circle;\n    },\n\n    /**\n     * SVG Element update.\n     *\n     * @param  {object}                   node     The node object.\n     * @param  {DOMElement}               circle   The node DOM element.\n     * @param  {configurable}             settings The settings function.\n     */\n    update: function(node, circle, settings) {\n      var prefix = settings('prefix') || '';\n\n      // Applying changes\n      // TODO: optimize - check if necessary\n      circle.setAttributeNS(null, 'cx', node[prefix + 'x']);\n      circle.setAttributeNS(null, 'cy', node[prefix + 'y']);\n      circle.setAttributeNS(null, 'r', node[prefix + 'size']);\n\n      // Updating only if not freestyle\n      if (!settings('freeStyle'))\n        circle.setAttributeNS(\n          null, 'fill', node.color || settings('defaultNodeColor'));\n\n      // Showing\n      circle.style.display = '';\n\n      return this;\n    }\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.svg.edges');\n\n  /**\n   * The default edge renderer. It renders the node as a simple line.\n   */\n  sigma.svg.edges.def = {\n\n    /**\n     * SVG Element creation.\n     *\n     * @param  {object}                   edge       The edge object.\n     * @param  {object}                   source     The source node object.\n     * @param  {object}                   target     The target node object.\n     * @param  {configurable}             settings   The settings function.\n     */\n    create: function(edge, source, target, settings) {\n      var color = edge.color,\n          prefix = settings('prefix') || '',\n          edgeColor = settings('edgeColor'),\n          defaultNodeColor = settings('defaultNodeColor'),\n          defaultEdgeColor = settings('defaultEdgeColor');\n\n      if (!color)\n        switch (edgeColor) {\n          case 'source':\n            color = source.color || defaultNodeColor;\n            break;\n          case 'target':\n            color = target.color || defaultNodeColor;\n            break;\n          default:\n            color = defaultEdgeColor;\n            break;\n        }\n\n      var line = document.createElementNS(settings('xmlns'), 'line');\n\n      // Attributes\n      line.setAttributeNS(null, 'data-edge-id', edge.id);\n      line.setAttributeNS(null, 'class', settings('classPrefix') + '-edge');\n      line.setAttributeNS(null, 'stroke', color);\n\n      return line;\n    },\n\n    /**\n     * SVG Element update.\n     *\n     * @param  {object}                   edge       The edge object.\n     * @param  {DOMElement}               line       The line DOM Element.\n     * @param  {object}                   source     The source node object.\n     * @param  {object}                   target     The target node object.\n     * @param  {configurable}             settings   The settings function.\n     */\n    update: function(edge, line, source, target, settings) {\n      var prefix = settings('prefix') || '';\n\n      line.setAttributeNS(null, 'stroke-width', edge[prefix + 'size'] || 1);\n      line.setAttributeNS(null, 'x1', source[prefix + 'x']);\n      line.setAttributeNS(null, 'y1', source[prefix + 'y']);\n      line.setAttributeNS(null, 'x2', target[prefix + 'x']);\n      line.setAttributeNS(null, 'y2', target[prefix + 'y']);\n\n      // Showing\n      line.style.display = '';\n\n      return this;\n    }\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.svg.edges');\n\n  /**\n   * The curve edge renderer. It renders the node as a bezier curve.\n   */\n  sigma.svg.edges.curve = {\n\n    /**\n     * SVG Element creation.\n     *\n     * @param  {object}                   edge       The edge object.\n     * @param  {object}                   source     The source node object.\n     * @param  {object}                   target     The target node object.\n     * @param  {configurable}             settings   The settings function.\n     */\n    create: function(edge, source, target, settings) {\n      var color = edge.color,\n          prefix = settings('prefix') || '',\n          edgeColor = settings('edgeColor'),\n          defaultNodeColor = settings('defaultNodeColor'),\n          defaultEdgeColor = settings('defaultEdgeColor');\n\n      if (!color)\n        switch (edgeColor) {\n          case 'source':\n            color = source.color || defaultNodeColor;\n            break;\n          case 'target':\n            color = target.color || defaultNodeColor;\n            break;\n          default:\n            color = defaultEdgeColor;\n            break;\n        }\n\n      var path = document.createElementNS(settings('xmlns'), 'path');\n\n      // Attributes\n      path.setAttributeNS(null, 'data-edge-id', edge.id);\n      path.setAttributeNS(null, 'class', settings('classPrefix') + '-edge');\n      path.setAttributeNS(null, 'stroke', color);\n\n      return path;\n    },\n\n    /**\n     * SVG Element update.\n     *\n     * @param  {object}                   edge       The edge object.\n     * @param  {DOMElement}               line       The line DOM Element.\n     * @param  {object}                   source     The source node object.\n     * @param  {object}                   target     The target node object.\n     * @param  {configurable}             settings   The settings function.\n     */\n    update: function(edge, path, source, target, settings) {\n      var prefix = settings('prefix') || '';\n\n      path.setAttributeNS(null, 'stroke-width', edge[prefix + 'size'] || 1);\n\n      // Control point\n      var cx = (source[prefix + 'x'] + target[prefix + 'x']) / 2 +\n        (target[prefix + 'y'] - source[prefix + 'y']) / 4,\n          cy = (source[prefix + 'y'] + target[prefix + 'y']) / 2 +\n        (source[prefix + 'x'] - target[prefix + 'x']) / 4;\n\n      // Path\n      var p = 'M' + source[prefix + 'x'] + ',' + source[prefix + 'y'] + ' ' +\n              'Q' + cx + ',' + cy + ' ' +\n              target[prefix + 'x'] + ',' + target[prefix + 'y'];\n\n      // Updating attributes\n      path.setAttributeNS(null, 'd', p);\n      path.setAttributeNS(null, 'fill', 'none');\n\n      // Showing\n      path.style.display = '';\n\n      return this;\n    }\n  };\n})();\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.svg.labels');\n\n  /**\n   * The default label renderer. It renders the label as a simple text.\n   */\n  sigma.svg.labels.def = {\n\n    /**\n     * SVG Element creation.\n     *\n     * @param  {object}                   node       The node object.\n     * @param  {configurable}             settings   The settings function.\n     */\n    create: function(node, settings) {\n      var prefix = settings('prefix') || '',\n          size = node[prefix + 'size'],\n          text = document.createElementNS(settings('xmlns'), 'text');\n\n      var fontSize = (settings('labelSize') === 'fixed') ?\n        settings('defaultLabelSize') :\n        settings('labelSizeRatio') * size;\n\n      var fontColor = (settings('labelColor') === 'node') ?\n        (node.color || settings('defaultNodeColor')) :\n        settings('defaultLabelColor');\n\n      text.setAttributeNS(null, 'data-label-target', node.id);\n      text.setAttributeNS(null, 'class', settings('classPrefix') + '-label');\n      text.setAttributeNS(null, 'font-size', fontSize);\n      text.setAttributeNS(null, 'font-family', settings('font'));\n      text.setAttributeNS(null, 'fill', fontColor);\n\n      text.innerHTML = node.label;\n      text.textContent = node.label;\n\n      return text;\n    },\n\n    /**\n     * SVG Element update.\n     *\n     * @param  {object}                   node     The node object.\n     * @param  {DOMElement}               text     The label DOM element.\n     * @param  {configurable}             settings The settings function.\n     */\n    update: function(node, text, settings) {\n      var prefix = settings('prefix') || '',\n          size = node[prefix + 'size'];\n\n      var fontSize = (settings('labelSize') === 'fixed') ?\n        settings('defaultLabelSize') :\n        settings('labelSizeRatio') * size;\n\n      // Case when we don't want to display the label\n      if (!settings('forceLabels') && size < settings('labelThreshold'))\n        return;\n\n      if (typeof node.label !== 'string')\n        return;\n\n      // Updating\n      text.setAttributeNS(null, 'x',\n        Math.round(node[prefix + 'x'] + size + 3));\n      text.setAttributeNS(null, 'y',\n        Math.round(node[prefix + 'y'] + fontSize / 3));\n\n      // Showing\n      text.style.display = '';\n\n      return this;\n    }\n  };\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.svg.hovers');\n\n  /**\n   * The default hover renderer.\n   */\n  sigma.svg.hovers.def = {\n\n    /**\n     * SVG Element creation.\n     *\n     * @param  {object}           node               The node object.\n     * @param  {CanvasElement}    measurementCanvas  A fake canvas handled by\n     *                            the svg to perform some measurements and\n     *                            passed by the renderer.\n     * @param  {DOMElement}       nodeCircle         The node DOM Element.\n     * @param  {configurable}     settings           The settings function.\n     */\n    create: function(node, nodeCircle, measurementCanvas, settings) {\n\n      // Defining visual properties\n      var x,\n          y,\n          w,\n          h,\n          e,\n          d,\n          fontStyle = settings('hoverFontStyle') || settings('fontStyle'),\n          prefix = settings('prefix') || '',\n          size = node[prefix + 'size'],\n          fontSize = (settings('labelSize') === 'fixed') ?\n            settings('defaultLabelSize') :\n            settings('labelSizeRatio') * size,\n          fontColor = (settings('labelHoverColor') === 'node') ?\n                        (node.color || settings('defaultNodeColor')) :\n                        settings('defaultLabelHoverColor');\n\n      // Creating elements\n      var group = document.createElementNS(settings('xmlns'), 'g'),\n          rectangle = document.createElementNS(settings('xmlns'), 'rect'),\n          circle = document.createElementNS(settings('xmlns'), 'circle'),\n          text = document.createElementNS(settings('xmlns'), 'text');\n\n      // Defining properties\n      group.setAttributeNS(null, 'class', settings('classPrefix') + '-hover');\n      group.setAttributeNS(null, 'data-node-id', node.id);\n\n      if (typeof node.label === 'string') {\n\n        // Text\n        text.innerHTML = node.label;\n        text.textContent = node.label;\n        text.setAttributeNS(\n            null,\n            'class',\n            settings('classPrefix') + '-hover-label');\n        text.setAttributeNS(null, 'font-size', fontSize);\n        text.setAttributeNS(null, 'font-family', settings('font'));\n        text.setAttributeNS(null, 'fill', fontColor);\n        text.setAttributeNS(null, 'x',\n          Math.round(node[prefix + 'x'] + size + 3));\n        text.setAttributeNS(null, 'y',\n          Math.round(node[prefix + 'y'] + fontSize / 3));\n\n        // Measures\n        // OPTIMIZE: Find a better way than a measurement canvas\n        x = Math.round(node[prefix + 'x'] - fontSize / 2 - 2);\n        y = Math.round(node[prefix + 'y'] - fontSize / 2 - 2);\n        w = Math.round(\n          measurementCanvas.measureText(node.label).width +\n            fontSize / 2 + size + 9\n        );\n        h = Math.round(fontSize + 4);\n        e = Math.round(fontSize / 2 + 2);\n\n        // Circle\n        circle.setAttributeNS(\n            null,\n            'class',\n            settings('classPrefix') + '-hover-area');\n        circle.setAttributeNS(null, 'fill', '#fff');\n        circle.setAttributeNS(null, 'cx', node[prefix + 'x']);\n        circle.setAttributeNS(null, 'cy', node[prefix + 'y']);\n        circle.setAttributeNS(null, 'r', e);\n\n        // Rectangle\n        rectangle.setAttributeNS(\n            null,\n            'class',\n            settings('classPrefix') + '-hover-area');\n        rectangle.setAttributeNS(null, 'fill', '#fff');\n        rectangle.setAttributeNS(null, 'x', node[prefix + 'x'] + e / 4);\n        rectangle.setAttributeNS(null, 'y', node[prefix + 'y'] - e);\n        rectangle.setAttributeNS(null, 'width', w);\n        rectangle.setAttributeNS(null, 'height', h);\n      }\n\n      // Appending childs\n      group.appendChild(circle);\n      group.appendChild(rectangle);\n      group.appendChild(text);\n      group.appendChild(nodeCircle);\n\n      return group;\n    }\n  };\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.middlewares');\n  sigma.utils.pkg('sigma.utils');\n\n  /**\n   * This middleware will rescale the graph such that it takes an optimal space\n   * on the renderer.\n   *\n   * As each middleware, this function is executed in the scope of the sigma\n   * instance.\n   *\n   * @param {?string} readPrefix  The read prefix.\n   * @param {?string} writePrefix The write prefix.\n   * @param {object}  options     The parameters.\n   */\n  sigma.middlewares.rescale = function(readPrefix, writePrefix, options) {\n    var i,\n        l,\n        a,\n        b,\n        c,\n        d,\n        scale,\n        margin,\n        n = this.graph.nodes(),\n        e = this.graph.edges(),\n        settings = this.settings.embedObjects(options || {}),\n        bounds = settings('bounds') || sigma.utils.getBoundaries(\n          this.graph,\n          readPrefix,\n          true\n        ),\n        minX = bounds.minX,\n        minY = bounds.minY,\n        maxX = bounds.maxX,\n        maxY = bounds.maxY,\n        sizeMax = bounds.sizeMax,\n        weightMax = bounds.weightMax,\n        w = settings('width') || 1,\n        h = settings('height') || 1,\n        rescaleSettings = settings('autoRescale'),\n        validSettings = {\n          nodePosition: 1,\n          nodeSize: 1,\n          edgeSize: 1\n        };\n\n    /**\n     * What elements should we rescale?\n     */\n    if (!(rescaleSettings instanceof Array))\n      rescaleSettings = ['nodePosition', 'nodeSize', 'edgeSize'];\n\n    for (i = 0, l = rescaleSettings.length; i < l; i++)\n      if (!validSettings[rescaleSettings[i]])\n        throw new Error(\n          'The rescale setting \"' + rescaleSettings[i] + '\" is not recognized.'\n        );\n\n    var np = ~rescaleSettings.indexOf('nodePosition'),\n        ns = ~rescaleSettings.indexOf('nodeSize'),\n        es = ~rescaleSettings.indexOf('edgeSize');\n\n    /**\n     * First, we compute the scaling ratio, without considering the sizes\n     * of the nodes : Each node will have its center in the canvas, but might\n     * be partially out of it.\n     */\n    scale = settings('scalingMode') === 'outside' ?\n      Math.max(\n        w / Math.max(maxX - minX, 1),\n        h / Math.max(maxY - minY, 1)\n      ) :\n      Math.min(\n        w / Math.max(maxX - minX, 1),\n        h / Math.max(maxY - minY, 1)\n      );\n\n    /**\n     * Then, we correct that scaling ratio considering a margin, which is\n     * basically the size of the biggest node.\n     * This has to be done as a correction since to compare the size of the\n     * biggest node to the X and Y values, we have to first get an\n     * approximation of the scaling ratio.\n     **/\n    margin =\n      (\n        settings('rescaleIgnoreSize') ?\n          0 :\n          (settings('maxNodeSize') || sizeMax) / scale\n      ) +\n      (settings('sideMargin') || 0);\n    maxX += margin;\n    minX -= margin;\n    maxY += margin;\n    minY -= margin;\n\n    // Fix the scaling with the new extrema:\n    scale = settings('scalingMode') === 'outside' ?\n      Math.max(\n        w / Math.max(maxX - minX, 1),\n        h / Math.max(maxY - minY, 1)\n      ) :\n      Math.min(\n        w / Math.max(maxX - minX, 1),\n        h / Math.max(maxY - minY, 1)\n      );\n\n    // Size homothetic parameters:\n    if (!settings('maxNodeSize') && !settings('minNodeSize')) {\n      a = 1;\n      b = 0;\n    } else if (settings('maxNodeSize') === settings('minNodeSize')) {\n      a = 0;\n      b = +settings('maxNodeSize');\n    } else {\n      a = (settings('maxNodeSize') - settings('minNodeSize')) / sizeMax;\n      b = +settings('minNodeSize');\n    }\n\n    if (!settings('maxEdgeSize') && !settings('minEdgeSize')) {\n      c = 1;\n      d = 0;\n    } else if (settings('maxEdgeSize') === settings('minEdgeSize')) {\n      c = 0;\n      d = +settings('minEdgeSize');\n    } else {\n      c = (settings('maxEdgeSize') - settings('minEdgeSize')) / weightMax;\n      d = +settings('minEdgeSize');\n    }\n\n    // Rescale the nodes and edges:\n    for (i = 0, l = e.length; i < l; i++)\n      e[i][writePrefix + 'size'] =\n        e[i][readPrefix + 'size'] * (es ? c : 1) + (es ? d : 0);\n\n    for (i = 0, l = n.length; i < l; i++) {\n      n[i][writePrefix + 'size'] =\n        n[i][readPrefix + 'size'] * (ns ? a : 1) + (ns ? b : 0);\n      n[i][writePrefix + 'x'] =\n        (n[i][readPrefix + 'x'] - (maxX + minX) / 2) * (np ? scale : 1);\n      n[i][writePrefix + 'y'] =\n        (n[i][readPrefix + 'y'] - (maxY + minY) / 2) * (np ? scale : 1);\n    }\n  };\n\n  sigma.utils.getBoundaries = function(graph, prefix, doEdges) {\n    var i,\n        l,\n        e = graph.edges(),\n        n = graph.nodes(),\n        weightMax = -Infinity,\n        sizeMax = -Infinity,\n        minX = Infinity,\n        minY = Infinity,\n        maxX = -Infinity,\n        maxY = -Infinity;\n\n    if (doEdges)\n      for (i = 0, l = e.length; i < l; i++)\n        weightMax = Math.max(e[i][prefix + 'size'], weightMax);\n\n    for (i = 0, l = n.length; i < l; i++) {\n      sizeMax = Math.max(n[i][prefix + 'size'], sizeMax);\n      maxX = Math.max(n[i][prefix + 'x'], maxX);\n      minX = Math.min(n[i][prefix + 'x'], minX);\n      maxY = Math.max(n[i][prefix + 'y'], maxY);\n      minY = Math.min(n[i][prefix + 'y'], minY);\n    }\n\n    weightMax = weightMax || 1;\n    sizeMax = sizeMax || 1;\n\n    return {\n      weightMax: weightMax,\n      sizeMax: sizeMax,\n      minX: minX,\n      minY: minY,\n      maxX: maxX,\n      maxY: maxY\n    };\n  };\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.middlewares');\n\n  /**\n   * This middleware will just copy the graphic properties.\n   *\n   * @param {?string} readPrefix  The read prefix.\n   * @param {?string} writePrefix The write prefix.\n   */\n  sigma.middlewares.copy = function(readPrefix, writePrefix) {\n    var i,\n        l,\n        a;\n\n    if (writePrefix + '' === readPrefix + '')\n      return;\n\n    a = this.graph.nodes();\n    for (i = 0, l = a.length; i < l; i++) {\n      a[i][writePrefix + 'x'] = a[i][readPrefix + 'x'];\n      a[i][writePrefix + 'y'] = a[i][readPrefix + 'y'];\n      a[i][writePrefix + 'size'] = a[i][readPrefix + 'size'];\n    }\n\n    a = this.graph.edges();\n    for (i = 0, l = a.length; i < l; i++)\n      a[i][writePrefix + 'size'] = a[i][readPrefix + 'size'];\n  };\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.misc.animation.running');\n\n  /**\n   * Generates a unique ID for the animation.\n   *\n   * @return {string} Returns the new ID.\n   */\n  var _getID = (function() {\n    var id = 0;\n    return function() {\n      return '' + (++id);\n    };\n  })();\n\n  /**\n   * This function animates a camera. It has to be called with the camera to\n   * animate, the values of the coordinates to reach and eventually some\n   * options. It returns a number id, that you can use to kill the animation,\n   * with the method sigma.misc.animation.kill(id).\n   *\n   * The available options are:\n   *\n   *   {?number}            duration   The duration of the animation.\n   *   {?function}          onNewFrame A callback to execute when the animation\n   *                                   enter a new frame.\n   *   {?function}          onComplete A callback to execute when the animation\n   *                                   is completed or killed.\n   *   {?(string|function)} easing     The name of a function from the package\n   *                                   sigma.utils.easings, or a custom easing\n   *                                   function.\n   *\n   * @param  {camera}  camera  The camera to animate.\n   * @param  {object}  target  The coordinates to reach.\n   * @param  {?object} options Eventually an object to specify some options to\n   *                           the function. The available options are\n   *                           presented in the description of the function.\n   * @return {number}          The animation id, to make it easy to kill\n   *                           through the method \"sigma.misc.animation.kill\".\n   */\n  sigma.misc.animation.camera = function(camera, val, options) {\n    if (\n      !(camera instanceof sigma.classes.camera) ||\n      typeof val !== 'object' ||\n      !val\n    )\n      throw 'animation.camera: Wrong arguments.';\n\n    if (\n      typeof val.x !== 'number' &&\n      typeof val.y !== 'number' &&\n      typeof val.ratio !== 'number' &&\n      typeof val.angle !== 'number'\n    )\n      throw 'There must be at least one valid coordinate in the given val.';\n\n    var fn,\n        id,\n        anim,\n        easing,\n        duration,\n        initialVal,\n        o = options || {},\n        start = sigma.utils.dateNow();\n\n    // Store initial values:\n    initialVal = {\n      x: camera.x,\n      y: camera.y,\n      ratio: camera.ratio,\n      angle: camera.angle\n    };\n\n    duration = o.duration;\n    easing = typeof o.easing !== 'function' ?\n      sigma.utils.easings[o.easing || 'quadraticInOut'] :\n      o.easing;\n\n    fn = function() {\n      var coef,\n          t = o.duration ? (sigma.utils.dateNow() - start) / o.duration : 1;\n\n      // If the animation is over:\n      if (t >= 1) {\n        camera.isAnimated = false;\n        camera.goTo({\n          x: val.x !== undefined ? val.x : initialVal.x,\n          y: val.y !== undefined ? val.y : initialVal.y,\n          ratio: val.ratio !== undefined ? val.ratio : initialVal.ratio,\n          angle: val.angle !== undefined ? val.angle : initialVal.angle\n        });\n\n        cancelAnimationFrame(id);\n        delete sigma.misc.animation.running[id];\n\n        // Check callbacks:\n        if (typeof o.onComplete === 'function')\n          o.onComplete();\n\n      // Else, let's keep going:\n      } else {\n        coef = easing(t);\n        camera.isAnimated = true;\n        camera.goTo({\n          x: val.x !== undefined ?\n            initialVal.x + (val.x - initialVal.x) * coef :\n            initialVal.x,\n          y: val.y !== undefined ?\n            initialVal.y + (val.y - initialVal.y) * coef :\n            initialVal.y,\n          ratio: val.ratio !== undefined ?\n            initialVal.ratio + (val.ratio - initialVal.ratio) * coef :\n            initialVal.ratio,\n          angle: val.angle !== undefined ?\n            initialVal.angle + (val.angle - initialVal.angle) * coef :\n            initialVal.angle\n        });\n\n        // Check callbacks:\n        if (typeof o.onNewFrame === 'function')\n          o.onNewFrame();\n\n        anim.frameId = requestAnimationFrame(fn);\n      }\n    };\n\n    id = _getID();\n    anim = {\n      frameId: requestAnimationFrame(fn),\n      target: camera,\n      type: 'camera',\n      options: o,\n      fn: fn\n    };\n    sigma.misc.animation.running[id] = anim;\n\n    return id;\n  };\n\n  /**\n   * Kills a running animation. It triggers the eventual onComplete callback.\n   *\n   * @param  {number} id  The id of the animation to kill.\n   * @return {object}     Returns the sigma.misc.animation package.\n   */\n  sigma.misc.animation.kill = function(id) {\n    if (arguments.length !== 1 || typeof id !== 'number')\n      throw 'animation.kill: Wrong arguments.';\n\n    var o = sigma.misc.animation.running[id];\n\n    if (o) {\n      cancelAnimationFrame(id);\n      delete sigma.misc.animation.running[o.frameId];\n\n      if (o.type === 'camera')\n        o.target.isAnimated = false;\n\n      // Check callbacks:\n      if (typeof (o.options || {}).onComplete === 'function')\n        o.options.onComplete();\n    }\n\n    return this;\n  };\n\n  /**\n   * Kills every running animations, or only the one with the specified type,\n   * if a string parameter is given.\n   *\n   * @param  {?(string|object)} filter A string to filter the animations to kill\n   *                                   on their type (example: \"camera\"), or an\n   *                                   object to filter on their target.\n   * @return {number}                  Returns the number of animations killed\n   *                                   that way.\n   */\n  sigma.misc.animation.killAll = function(filter) {\n    var o,\n        id,\n        count = 0,\n        type = typeof filter === 'string' ? filter : null,\n        target = typeof filter === 'object' ? filter : null,\n        running = sigma.misc.animation.running;\n\n    for (id in running)\n      if (\n        (!type || running[id].type === type) &&\n        (!target || running[id].target === target)\n      ) {\n        o = sigma.misc.animation.running[id];\n        cancelAnimationFrame(o.frameId);\n        delete sigma.misc.animation.running[id];\n\n        if (o.type === 'camera')\n          o.target.isAnimated = false;\n\n        // Increment counter:\n        count++;\n\n        // Check callbacks:\n        if (typeof (o.options || {}).onComplete === 'function')\n          o.options.onComplete();\n      }\n\n    return count;\n  };\n\n  /**\n   * Returns \"true\" if any animation that is currently still running matches\n   * the filter given to the function.\n   *\n   * @param  {string|object} filter A string to filter the animations to kill\n   *                                on their type (example: \"camera\"), or an\n   *                                object to filter on their target.\n   * @return {boolean}              Returns true if any running animation\n   *                                matches.\n   */\n  sigma.misc.animation.has = function(filter) {\n    var id,\n        type = typeof filter === 'string' ? filter : null,\n        target = typeof filter === 'object' ? filter : null,\n        running = sigma.misc.animation.running;\n\n    for (id in running)\n      if (\n        (!type || running[id].type === type) &&\n        (!target || running[id].target === target)\n      )\n        return true;\n\n    return false;\n  };\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.misc');\n\n  /**\n   * This helper will bind any no-DOM renderer (for instance canvas or WebGL)\n   * to its captors, to properly dispatch the good events to the sigma instance\n   * to manage clicking, hovering etc...\n   *\n   * It has to be called in the scope of the related renderer.\n   */\n  sigma.misc.bindEvents = function(prefix) {\n    var i,\n        l,\n        mX,\n        mY,\n        captor,\n        self = this;\n\n    function getNodes(e) {\n      if (e) {\n        mX = 'x' in e.data ? e.data.x : mX;\n        mY = 'y' in e.data ? e.data.y : mY;\n      }\n\n      var i,\n          j,\n          l,\n          n,\n          x,\n          y,\n          s,\n          inserted,\n          selected = [],\n          modifiedX = mX + self.width / 2,\n          modifiedY = mY + self.height / 2,\n          point = self.camera.cameraPosition(\n            mX,\n            mY\n          ),\n          nodes = self.camera.quadtree.point(\n            point.x,\n            point.y\n          );\n\n      if (nodes.length)\n        for (i = 0, l = nodes.length; i < l; i++) {\n          n = nodes[i];\n          x = n[prefix + 'x'];\n          y = n[prefix + 'y'];\n          s = n[prefix + 'size'];\n\n          if (\n            !n.hidden &&\n            modifiedX > x - s &&\n            modifiedX < x + s &&\n            modifiedY > y - s &&\n            modifiedY < y + s &&\n            Math.sqrt(\n              Math.pow(modifiedX - x, 2) +\n              Math.pow(modifiedY - y, 2)\n            ) < s\n          ) {\n            // Insert the node:\n            inserted = false;\n\n            for (j = 0; j < selected.length; j++)\n              if (n.size > selected[j].size) {\n                selected.splice(j, 0, n);\n                inserted = true;\n                break;\n              }\n\n            if (!inserted)\n              selected.push(n);\n          }\n        }\n\n      return selected;\n    }\n\n\n    function getEdges(e) {\n      if (!self.settings('enableEdgeHovering')) {\n        // No event if the setting is off:\n        return [];\n      }\n\n      var isCanvas = (\n        sigma.renderers.canvas && self instanceof sigma.renderers.canvas);\n\n      if (!isCanvas) {\n        // A quick hardcoded rule to prevent people from using this feature\n        // with the WebGL renderer (which is not good enough at the moment):\n        throw new Error(\n          'The edge events feature is not compatible with the WebGL renderer'\n        );\n      }\n\n      if (e) {\n        mX = 'x' in e.data ? e.data.x : mX;\n        mY = 'y' in e.data ? e.data.y : mY;\n      }\n\n      var i,\n          j,\n          l,\n          a,\n          edge,\n          s,\n          maxEpsilon = self.settings('edgeHoverPrecision'),\n          source,\n          target,\n          cp,\n          nodeIndex = {},\n          inserted,\n          selected = [],\n          modifiedX = mX + self.width / 2,\n          modifiedY = mY + self.height / 2,\n          point = self.camera.cameraPosition(\n            mX,\n            mY\n          ),\n          edges = [];\n\n      if (isCanvas) {\n        var nodesOnScreen = self.camera.quadtree.area(\n          self.camera.getRectangle(self.width, self.height)\n        );\n        for (a = nodesOnScreen, i = 0, l = a.length; i < l; i++)\n          nodeIndex[a[i].id] = a[i];\n      }\n\n      if (self.camera.edgequadtree !== undefined) {\n        edges = self.camera.edgequadtree.point(\n          point.x,\n          point.y\n        );\n      }\n\n      function insertEdge(selected, edge) {\n        inserted = false;\n\n        for (j = 0; j < selected.length; j++)\n          if (edge.size > selected[j].size) {\n            selected.splice(j, 0, edge);\n            inserted = true;\n            break;\n          }\n\n        if (!inserted)\n          selected.push(edge);\n      }\n\n      if (edges.length)\n        for (i = 0, l = edges.length; i < l; i++) {\n          edge = edges[i];\n          source = self.graph.nodes(edge.source);\n          target = self.graph.nodes(edge.target);\n          // (HACK) we can't get edge[prefix + 'size'] on WebGL renderer:\n          s = edge[prefix + 'size'] ||\n              edge['read_' + prefix + 'size'];\n\n          // First, let's identify which edges are drawn. To do this, we keep\n          // every edges that have at least one extremity displayed according to\n          // the quadtree and the \"hidden\" attribute. We also do not keep hidden\n          // edges.\n          // Then, let's check if the mouse is on the edge (we suppose that it\n          // is a line segment).\n\n          if (\n            !edge.hidden &&\n            !source.hidden && !target.hidden &&\n            (!isCanvas ||\n              (nodeIndex[edge.source] || nodeIndex[edge.target])) &&\n            sigma.utils.getDistance(\n              source[prefix + 'x'],\n              source[prefix + 'y'],\n              modifiedX,\n              modifiedY) > source[prefix + 'size'] &&\n            sigma.utils.getDistance(\n              target[prefix + 'x'],\n              target[prefix + 'y'],\n              modifiedX,\n              modifiedY) > target[prefix + 'size']\n          ) {\n            if (edge.type == 'curve' || edge.type == 'curvedArrow') {\n              if (source.id === target.id) {\n                cp = sigma.utils.getSelfLoopControlPoints(\n                  source[prefix + 'x'],\n                  source[prefix + 'y'],\n                  source[prefix + 'size']\n                );\n                if (\n                  sigma.utils.isPointOnBezierCurve(\n                  modifiedX,\n                  modifiedY,\n                  source[prefix + 'x'],\n                  source[prefix + 'y'],\n                  target[prefix + 'x'],\n                  target[prefix + 'y'],\n                  cp.x1,\n                  cp.y1,\n                  cp.x2,\n                  cp.y2,\n                  Math.max(s, maxEpsilon)\n                )) {\n                  insertEdge(selected, edge);\n                }\n              }\n              else {\n                cp = sigma.utils.getQuadraticControlPoint(\n                  source[prefix + 'x'],\n                  source[prefix + 'y'],\n                  target[prefix + 'x'],\n                  target[prefix + 'y']);\n                if (\n                  sigma.utils.isPointOnQuadraticCurve(\n                  modifiedX,\n                  modifiedY,\n                  source[prefix + 'x'],\n                  source[prefix + 'y'],\n                  target[prefix + 'x'],\n                  target[prefix + 'y'],\n                  cp.x,\n                  cp.y,\n                  Math.max(s, maxEpsilon)\n                )) {\n                  insertEdge(selected, edge);\n                }\n              }\n            } else if (\n                sigma.utils.isPointOnSegment(\n                modifiedX,\n                modifiedY,\n                source[prefix + 'x'],\n                source[prefix + 'y'],\n                target[prefix + 'x'],\n                target[prefix + 'y'],\n                Math.max(s, maxEpsilon)\n              )) {\n              insertEdge(selected, edge);\n            }\n          }\n        }\n\n      return selected;\n    }\n\n\n    function bindCaptor(captor) {\n      var nodes,\n          edges,\n          overNodes = {},\n          overEdges = {};\n\n      function onClick(e) {\n        if (!self.settings('eventsEnabled'))\n          return;\n\n        self.dispatchEvent('click', e.data);\n\n        nodes = getNodes(e);\n        edges = getEdges(e);\n\n        if (nodes.length) {\n          self.dispatchEvent('clickNode', {\n            node: nodes[0],\n            captor: e.data\n          });\n          self.dispatchEvent('clickNodes', {\n            node: nodes,\n            captor: e.data\n          });\n        } else if (edges.length) {\n          self.dispatchEvent('clickEdge', {\n            edge: edges[0],\n            captor: e.data\n          });\n          self.dispatchEvent('clickEdges', {\n            edge: edges,\n            captor: e.data\n          });\n        } else\n          self.dispatchEvent('clickStage', {captor: e.data});\n      }\n\n      function onDoubleClick(e) {\n        if (!self.settings('eventsEnabled'))\n          return;\n\n        self.dispatchEvent('doubleClick', e.data);\n\n        nodes = getNodes(e);\n        edges = getEdges(e);\n\n        if (nodes.length) {\n          self.dispatchEvent('doubleClickNode', {\n            node: nodes[0],\n            captor: e.data\n          });\n          self.dispatchEvent('doubleClickNodes', {\n            node: nodes,\n            captor: e.data\n          });\n        } else if (edges.length) {\n          self.dispatchEvent('doubleClickEdge', {\n            edge: edges[0],\n            captor: e.data\n          });\n          self.dispatchEvent('doubleClickEdges', {\n            edge: edges,\n            captor: e.data\n          });\n        } else\n          self.dispatchEvent('doubleClickStage', {captor: e.data});\n      }\n\n      function onRightClick(e) {\n        if (!self.settings('eventsEnabled'))\n          return;\n\n        self.dispatchEvent('rightClick', e.data);\n\n        nodes = getNodes(e);\n        edges = getEdges(e);\n\n        if (nodes.length) {\n          self.dispatchEvent('rightClickNode', {\n            node: nodes[0],\n            captor: e.data\n          });\n          self.dispatchEvent('rightClickNodes', {\n            node: nodes,\n            captor: e.data\n          });\n        } else if (edges.length) {\n          self.dispatchEvent('rightClickEdge', {\n            edge: edges[0],\n            captor: e.data\n          });\n          self.dispatchEvent('rightClickEdges', {\n            edge: edges,\n            captor: e.data\n          });\n        } else\n          self.dispatchEvent('rightClickStage', {captor: e.data});\n      }\n\n      function onOut(e) {\n        if (!self.settings('eventsEnabled'))\n          return;\n\n        var k,\n            i,\n            l,\n            le,\n            outNodes = [],\n            outEdges = [];\n\n        for (k in overNodes)\n          outNodes.push(overNodes[k]);\n\n        overNodes = {};\n        // Dispatch both single and multi events:\n        for (i = 0, l = outNodes.length; i < l; i++)\n          self.dispatchEvent('outNode', {\n            node: outNodes[i],\n            captor: e.data\n          });\n        if (outNodes.length)\n          self.dispatchEvent('outNodes', {\n            nodes: outNodes,\n            captor: e.data\n          });\n\n        overEdges = {};\n        // Dispatch both single and multi events:\n        for (i = 0, le = outEdges.length; i < le; i++)\n          self.dispatchEvent('outEdge', {\n            edge: outEdges[i],\n            captor: e.data\n          });\n        if (outEdges.length)\n          self.dispatchEvent('outEdges', {\n            edges: outEdges,\n            captor: e.data\n          });\n      }\n\n      function onMove(e) {\n        if (!self.settings('eventsEnabled'))\n          return;\n\n        nodes = getNodes(e);\n        edges = getEdges(e);\n\n        var i,\n            k,\n            node,\n            edge,\n            newOutNodes = [],\n            newOverNodes = [],\n            currentOverNodes = {},\n            l = nodes.length,\n            newOutEdges = [],\n            newOverEdges = [],\n            currentOverEdges = {},\n            le = edges.length;\n\n        // Check newly overred nodes:\n        for (i = 0; i < l; i++) {\n          node = nodes[i];\n          currentOverNodes[node.id] = node;\n          if (!overNodes[node.id]) {\n            newOverNodes.push(node);\n            overNodes[node.id] = node;\n          }\n        }\n\n        // Check no more overred nodes:\n        for (k in overNodes)\n          if (!currentOverNodes[k]) {\n            newOutNodes.push(overNodes[k]);\n            delete overNodes[k];\n          }\n\n        // Dispatch both single and multi events:\n        for (i = 0, l = newOverNodes.length; i < l; i++)\n          self.dispatchEvent('overNode', {\n            node: newOverNodes[i],\n            captor: e.data\n          });\n        for (i = 0, l = newOutNodes.length; i < l; i++)\n          self.dispatchEvent('outNode', {\n            node: newOutNodes[i],\n            captor: e.data\n          });\n        if (newOverNodes.length)\n          self.dispatchEvent('overNodes', {\n            nodes: newOverNodes,\n            captor: e.data\n          });\n        if (newOutNodes.length)\n          self.dispatchEvent('outNodes', {\n            nodes: newOutNodes,\n            captor: e.data\n          });\n\n        // Check newly overred edges:\n        for (i = 0; i < le; i++) {\n          edge = edges[i];\n          currentOverEdges[edge.id] = edge;\n          if (!overEdges[edge.id]) {\n            newOverEdges.push(edge);\n            overEdges[edge.id] = edge;\n          }\n        }\n\n        // Check no more overred edges:\n        for (k in overEdges)\n          if (!currentOverEdges[k]) {\n            newOutEdges.push(overEdges[k]);\n            delete overEdges[k];\n          }\n\n        // Dispatch both single and multi events:\n        for (i = 0, le = newOverEdges.length; i < le; i++)\n          self.dispatchEvent('overEdge', {\n            edge: newOverEdges[i],\n            captor: e.data\n          });\n        for (i = 0, le = newOutEdges.length; i < le; i++)\n          self.dispatchEvent('outEdge', {\n            edge: newOutEdges[i],\n            captor: e.data\n          });\n        if (newOverEdges.length)\n          self.dispatchEvent('overEdges', {\n            edges: newOverEdges,\n            captor: e.data\n          });\n        if (newOutEdges.length)\n          self.dispatchEvent('outEdges', {\n            edges: newOutEdges,\n            captor: e.data\n          });\n      }\n\n      // Bind events:\n      captor.bind('click', onClick);\n      captor.bind('mousedown', onMove);\n      captor.bind('mouseup', onMove);\n      captor.bind('mousemove', onMove);\n      captor.bind('mouseout', onOut);\n      captor.bind('doubleclick', onDoubleClick);\n      captor.bind('rightclick', onRightClick);\n      self.bind('render', onMove);\n    }\n\n    for (i = 0, l = this.captors.length; i < l; i++)\n      bindCaptor(this.captors[i]);\n  };\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.misc');\n\n  /**\n   * This helper will bind any DOM renderer (for instance svg)\n   * to its captors, to properly dispatch the good events to the sigma instance\n   * to manage clicking, hovering etc...\n   *\n   * It has to be called in the scope of the related renderer.\n   */\n  sigma.misc.bindDOMEvents = function(container) {\n    var self = this,\n        graph = this.graph;\n\n    // DOMElement abstraction\n    function Element(domElement) {\n\n      // Helpers\n      this.attr = function(attrName) {\n        return domElement.getAttributeNS(null, attrName);\n      };\n\n      // Properties\n      this.tag = domElement.tagName;\n      this.class = this.attr('class');\n      this.id = this.attr('id');\n\n      // Methods\n      this.isNode = function() {\n        return !!~this.class.indexOf(self.settings('classPrefix') + '-node');\n      };\n\n      this.isEdge = function() {\n        return !!~this.class.indexOf(self.settings('classPrefix') + '-edge');\n      };\n\n      this.isHover = function() {\n        return !!~this.class.indexOf(self.settings('classPrefix') + '-hover');\n      };\n    }\n\n    // Click\n    function click(e) {\n      if (!self.settings('eventsEnabled'))\n        return;\n\n      // Generic event\n      self.dispatchEvent('click', e);\n\n      // Are we on a node?\n      var element = new Element(e.target);\n\n      if (element.isNode())\n        self.dispatchEvent('clickNode', {\n          node: graph.nodes(element.attr('data-node-id'))\n        });\n      else\n        self.dispatchEvent('clickStage');\n\n      e.preventDefault();\n      e.stopPropagation();\n    }\n\n    // Double click\n    function doubleClick(e) {\n      if (!self.settings('eventsEnabled'))\n        return;\n\n      // Generic event\n      self.dispatchEvent('doubleClick', e);\n\n      // Are we on a node?\n      var element = new Element(e.target);\n\n      if (element.isNode())\n        self.dispatchEvent('doubleClickNode', {\n          node: graph.nodes(element.attr('data-node-id'))\n        });\n      else\n        self.dispatchEvent('doubleClickStage');\n\n      e.preventDefault();\n      e.stopPropagation();\n    }\n\n    // On over\n    function onOver(e) {\n      var target = e.toElement || e.target;\n\n      if (!self.settings('eventsEnabled') || !target)\n        return;\n\n      var el = new Element(target);\n\n      if (el.isNode()) {\n        self.dispatchEvent('overNode', {\n          node: graph.nodes(el.attr('data-node-id'))\n        });\n      }\n      else if (el.isEdge()) {\n        var edge = graph.edges(el.attr('data-edge-id'));\n        self.dispatchEvent('overEdge', {\n          edge: edge,\n          source: graph.nodes(edge.source),\n          target: graph.nodes(edge.target)\n        });\n      }\n    }\n\n    // On out\n    function onOut(e) {\n      var target = e.fromElement || e.originalTarget;\n\n      if (!self.settings('eventsEnabled'))\n        return;\n\n      var el = new Element(target);\n\n      if (el.isNode()) {\n        self.dispatchEvent('outNode', {\n          node: graph.nodes(el.attr('data-node-id'))\n        });\n      }\n      else if (el.isEdge()) {\n        var edge = graph.edges(el.attr('data-edge-id'));\n        self.dispatchEvent('outEdge', {\n          edge: edge,\n          source: graph.nodes(edge.source),\n          target: graph.nodes(edge.target)\n        });\n      }\n    }\n\n    // Registering Events:\n\n    // Click\n    container.addEventListener('click', click, false);\n    sigma.utils.doubleClick(container, 'click', doubleClick);\n\n    // Touch counterparts\n    container.addEventListener('touchstart', click, false);\n    sigma.utils.doubleClick(container, 'touchstart', doubleClick);\n\n    // Mouseover\n    container.addEventListener('mouseover', onOver, true);\n\n    // Mouseout\n    container.addEventListener('mouseout', onOut, true);\n  };\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.misc');\n\n  /**\n   * This method listens to \"overNode\", \"outNode\", \"overEdge\" and \"outEdge\"\n   * events from a renderer and renders the nodes differently on the top layer.\n   * The goal is to make any node label readable with the mouse, and to\n   * highlight hovered nodes and edges.\n   *\n   * It has to be called in the scope of the related renderer.\n   */\n  sigma.misc.drawHovers = function(prefix) {\n    var self = this,\n        hoveredNodes = {},\n        hoveredEdges = {};\n\n    this.bind('overNode', function(event) {\n      var node = event.data.node;\n      if (!node.hidden) {\n        hoveredNodes[node.id] = node;\n        draw();\n      }\n    });\n\n    this.bind('outNode', function(event) {\n      delete hoveredNodes[event.data.node.id];\n      draw();\n    });\n\n    this.bind('overEdge', function(event) {\n      var edge = event.data.edge;\n      if (!edge.hidden) {\n        hoveredEdges[edge.id] = edge;\n        draw();\n      }\n    });\n\n    this.bind('outEdge', function(event) {\n      delete hoveredEdges[event.data.edge.id];\n      draw();\n    });\n\n    this.bind('render', function(event) {\n      draw();\n    });\n\n    function draw() {\n\n      var k,\n          source,\n          target,\n          hoveredNode,\n          hoveredEdge,\n          c = self.contexts.hover.canvas,\n          defaultNodeType = self.settings('defaultNodeType'),\n          defaultEdgeType = self.settings('defaultEdgeType'),\n          nodeRenderers = sigma.canvas.hovers,\n          edgeRenderers = sigma.canvas.edgehovers,\n          extremitiesRenderers = sigma.canvas.extremities,\n          embedSettings = self.settings.embedObjects({\n            prefix: prefix\n          });\n\n      // Clear self.contexts.hover:\n      self.contexts.hover.clearRect(0, 0, c.width, c.height);\n\n      // Node render: single hover\n      if (\n        embedSettings('enableHovering') &&\n        embedSettings('singleHover') &&\n        Object.keys(hoveredNodes).length\n      ) {\n        hoveredNode = hoveredNodes[Object.keys(hoveredNodes)[0]];\n        (\n          nodeRenderers[hoveredNode.type] ||\n          nodeRenderers[defaultNodeType] ||\n          nodeRenderers.def\n        )(\n          hoveredNode,\n          self.contexts.hover,\n          embedSettings\n        );\n      }\n\n      // Node render: multiple hover\n      if (\n        embedSettings('enableHovering') &&\n        !embedSettings('singleHover')\n      )\n        for (k in hoveredNodes)\n          (\n            nodeRenderers[hoveredNodes[k].type] ||\n            nodeRenderers[defaultNodeType] ||\n            nodeRenderers.def\n          )(\n            hoveredNodes[k],\n            self.contexts.hover,\n            embedSettings\n          );\n\n      // Edge render: single hover\n      if (\n        embedSettings('enableEdgeHovering') &&\n        embedSettings('singleHover') &&\n        Object.keys(hoveredEdges).length\n      ) {\n        hoveredEdge = hoveredEdges[Object.keys(hoveredEdges)[0]];\n        source = self.graph.nodes(hoveredEdge.source);\n        target = self.graph.nodes(hoveredEdge.target);\n\n        if (! hoveredEdge.hidden) {\n          (\n            edgeRenderers[hoveredEdge.type] ||\n            edgeRenderers[defaultEdgeType] ||\n            edgeRenderers.def\n          ) (\n            hoveredEdge,\n            source,\n            target,\n            self.contexts.hover,\n            embedSettings\n          );\n\n          if (embedSettings('edgeHoverExtremities')) {\n            (\n              extremitiesRenderers[hoveredEdge.type] ||\n              extremitiesRenderers.def\n            )(\n              hoveredEdge,\n              source,\n              target,\n              self.contexts.hover,\n              embedSettings\n            );\n\n          } else {\n            // Avoid edges rendered over nodes:\n            (\n              sigma.canvas.nodes[source.type] ||\n              sigma.canvas.nodes.def\n            ) (\n              source,\n              self.contexts.hover,\n              embedSettings\n            );\n            (\n              sigma.canvas.nodes[target.type] ||\n              sigma.canvas.nodes.def\n            ) (\n              target,\n              self.contexts.hover,\n              embedSettings\n            );\n          }\n        }\n      }\n\n      // Edge render: multiple hover\n      if (\n        embedSettings('enableEdgeHovering') &&\n        !embedSettings('singleHover')\n      ) {\n        for (k in hoveredEdges) {\n          hoveredEdge = hoveredEdges[k];\n          source = self.graph.nodes(hoveredEdge.source);\n          target = self.graph.nodes(hoveredEdge.target);\n\n          if (!hoveredEdge.hidden) {\n            (\n              edgeRenderers[hoveredEdge.type] ||\n              edgeRenderers[defaultEdgeType] ||\n              edgeRenderers.def\n            ) (\n              hoveredEdge,\n              source,\n              target,\n              self.contexts.hover,\n              embedSettings\n            );\n\n            if (embedSettings('edgeHoverExtremities')) {\n              (\n                extremitiesRenderers[hoveredEdge.type] ||\n                extremitiesRenderers.def\n              )(\n                hoveredEdge,\n                source,\n                target,\n                self.contexts.hover,\n                embedSettings\n              );\n            } else {\n              // Avoid edges rendered over nodes:\n              (\n                sigma.canvas.nodes[source.type] ||\n                sigma.canvas.nodes.def\n              ) (\n                source,\n                self.contexts.hover,\n                embedSettings\n              );\n              (\n                sigma.canvas.nodes[target.type] ||\n                sigma.canvas.nodes.def\n              ) (\n                target,\n                self.contexts.hover,\n                embedSettings\n              );\n            }\n          }\n        }\n      }\n    }\n  };\n}).call(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2lnbWEvYnVpbGQvc2lnbWEucmVxdWlyZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zaWdtYS9idWlsZC9zaWdtYS5yZXF1aXJlLmpzP2UyYjAiXSwic291cmNlc0NvbnRlbnQiOlsiOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBfX2luc3RhbmNlcyA9IHt9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBzaWdtYSBpbnN0YW5jZXMgY29uc3RydWN0b3IuIE9uZSBpbnN0YW5jZSBvZiBzaWdtYSByZXByZXNlbnRcbiAgICogb25lIGdyYXBoLiBJdCBpcyBwb3NzaWJsZSB0byByZXByZXNlbnQgdGhpcyBncmFwxKUgd2l0aCBzZXZlcmFsIHJlbmRlcmVyc1xuICAgKiBhdCB0aGUgc2FtZSB0aW1lLiBCeSBkZWZhdWx0LCB0aGUgZGVmYXVsdCByZW5kZXJlciAoV2ViR0wgKyBDYW52YXNcbiAgICogcG9seWZpbGwpIHdpbGwgYmUgdXNlZCBhcyB0aGUgb25seSByZW5kZXJlciwgd2l0aCB0aGUgY29udGFpbmVyIHNwZWNpZmllZFxuICAgKiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtICB7Pyp9ICAgIGNvbmYgVGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIGluc3RhbmNlLiBUaGVyZSBhcmUgYSBsb3Qgb2ZcbiAgICogICAgICAgICAgICAgICAgICAgICAgZGlmZmVyZW50IHJlY29nbml6ZWQgZm9ybXMgdG8gaW5zdGFudGlhdGUgc2lnbWEsIGNoZWNrXG4gICAqICAgICAgICAgICAgICAgICAgICAgIGV4YW1wbGUgZmlsZXMsIGRvY3VtZW50YXRpb24gaW4gdGhpcyBmaWxlIGFuZCB1bml0XG4gICAqICAgICAgICAgICAgICAgICAgICAgIHRlc3RzIHRvIGtub3cgbW9yZS5cbiAgICogQHJldHVybiB7c2lnbWF9ICAgICAgVGhlIGZyZXNoIG5ldyBzaWdtYSBpbnN0YW5jZS5cbiAgICpcbiAgICogSW5zdGFuY2lhdGluZyBzaWdtYTpcbiAgICogKioqKioqKioqKioqKioqKioqKipcbiAgICogSWYgbm8gcGFyYW1ldGVyIGlzIGdpdmVuIHRvIHRoZSBjb25zdHJ1Y3RvciwgdGhlIGluc3RhbmNlIHdpbGwgYmUgY3JlYXRlZFxuICAgKiB3aXRob3V0IGFueSByZW5kZXJlciBvciBjYW1lcmEuIEl0IHdpbGwganVzdCBpbnN0YW50aWF0ZSB0aGUgZ3JhcGgsIGFuZFxuICAgKiBvdGhlciBtb2R1bGVzIHdpbGwgaGF2ZSB0byBiZSBpbnN0YW50aWF0ZWQgdGhyb3VnaCB0aGUgcHVibGljIG1ldGhvZHMsXG4gICAqIGxpa2UgXCJhZGRSZW5kZXJlclwiIGV0YzpcbiAgICpcbiAgICogID4gczAgPSBuZXcgc2lnbWEoKTtcbiAgICogID4gczAuYWRkUmVuZGVyZXIoe1xuICAgKiAgPiAgIHR5cGU6ICdjYW52YXMnLFxuICAgKiAgPiAgIGNvbnRhaW5lcjogJ215LWNvbnRhaW5lci1pZCdcbiAgICogID4gfSk7XG4gICAqXG4gICAqIEluIG1vc3Qgb2YgdGhlIGNhc2VzLCBzaWdtYSB3aWxsIHNpbXBseSBiZSB1c2VkIHdpdGggdGhlIGRlZmF1bHQgcmVuZGVyZXIuXG4gICAqIFRoZW4sIHNpbmNlIHRoZSBvbmx5IHJlcXVpcmVkIHBhcmFtZXRlciBpcyB0aGUgRE9NIGNvbnRhaW5lciwgdGhlcmUgYXJlXG4gICAqIHNvbWUgc2ltcGxlciB3YXkgdG8gY2FsbCB0aGUgY29uc3RydWN0b3IuIFRoZSBmb3VyIGZvbGxvd2luZyBjYWxscyBkbyB0aGVcbiAgICogZXhhY3Qgc2FtZSB0aGluZ3M6XG4gICAqXG4gICAqICA+IHMxID0gbmV3IHNpZ21hKCdteS1jb250YWluZXItaWQnKTtcbiAgICogID4gczIgPSBuZXcgc2lnbWEoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ215LWNvbnRhaW5lci1pZCcpKTtcbiAgICogID4gczMgPSBuZXcgc2lnbWEoe1xuICAgKiAgPiAgIGNvbnRhaW5lcjogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ215LWNvbnRhaW5lci1pZCcpXG4gICAqICA+IH0pO1xuICAgKiAgPiBzNCA9IG5ldyBzaWdtYSh7XG4gICAqICA+ICAgcmVuZGVyZXJzOiBbe1xuICAgKiAgPiAgICAgY29udGFpbmVyOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbXktY29udGFpbmVyLWlkJylcbiAgICogID4gICB9XVxuICAgKiAgPiB9KTtcbiAgICpcbiAgICogUmVjb2duaXplZCBwYXJhbWV0ZXJzOlxuICAgKiAqKioqKioqKioqKioqKioqKioqKioqXG4gICAqIEhlcmUgaXMgdGhlIGV4aGF1c3RpdmUgbGlzdCBvZiBldmVyeSBhY2NlcHRlZCBwYXJhbWV0ZXJzLCB3aGVuIGNhbGxpbmcgdGhlXG4gICAqIGNvbnN0cnVjdG9yIHdpdGggdG8gdG9wIGxldmVsIGNvbmZpZ3VyYXRpb24gb2JqZWN0IChmb3VydGggY2FzZSBpbiB0aGVcbiAgICogcHJldmlvdXMgZXhhbXBsZXMpOlxuICAgKlxuICAgKiAgIHs/c3RyaW5nfSBpZCAgICAgICAgVGhlIGlkIG9mIHRoZSBpbnN0YW5jZS4gSXQgd2lsbCBiZSBnZW5lcmF0ZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgIGF1dG9tYXRpY2FsbHkgaWYgbm90IHNwZWNpZmllZC5cbiAgICogICB7P2FycmF5fSAgcmVuZGVyZXJzIEFuIGFycmF5IGNvbnRhaW5pbmcgb2JqZWN0cyBkZXNjcmliaW5nIHJlbmRlcmVycy5cbiAgICogICB7P29iamVjdH0gZ3JhcGggICAgIEFuIG9iamVjdCBjb250YWluaW5nIGFuIGFycmF5IG9mIG5vZGVzIGFuZCBhbiBhcnJheVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgb2YgZWRnZXMsIHRvIGF2b2lkIGhhdmluZyB0byBhZGQgdGhlbSBieSBoYW5kIGxhdGVyLlxuICAgKiAgIHs/b2JqZWN0fSBzZXR0aW5ncyAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgaW5zdGFuY2Ugc3BlY2lmaWMgc2V0dGluZ3MgdGhhdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBvdmVycmlkZSB0aGUgZGVmYXVsdCBvbmVzIGRlZmluZWQgaW4gdGhlIG9iamVjdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgc2lnbWEuc2V0dGluZ3MuXG4gICAqL1xuICB2YXIgc2lnbWEgPSBmdW5jdGlvbihjb25mKSB7XG4gICAgLy8gTG9jYWwgdmFyaWFibGVzOlxuICAgIC8vICoqKioqKioqKioqKioqKipcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgYSxcbiAgICAgICAgYyxcbiAgICAgICAgbyxcbiAgICAgICAgaWQ7XG5cbiAgICBzaWdtYS5jbGFzc2VzLmRpc3BhdGNoZXIuZXh0ZW5kKHRoaXMpO1xuXG4gICAgLy8gUHJpdmF0ZSBhdHRyaWJ1dGVzOlxuICAgIC8vICoqKioqKioqKioqKioqKioqKipcbiAgICB2YXIgX3NlbGYgPSB0aGlzLFxuICAgICAgICBfY29uZiA9IGNvbmYgfHwge307XG5cbiAgICAvLyBMaXR0bGUgc2hvcnRjdXQ6XG4gICAgLy8gKioqKioqKioqKioqKioqKlxuICAgIC8vIFRoZSBjb25maWd1cmF0aW9uIGlzIHN1cHBvc2VkIHRvIGhhdmUgYSBsaXN0IG9mIHRoZSBjb25maWd1cmF0aW9uXG4gICAgLy8gb2JqZWN0cyBmb3IgZWFjaCByZW5kZXJlci5cbiAgICAvLyAgLSBJZiB0aGVyZSBhcmUgbm8gY29uZmlndXJhdGlvbiBhdCBhbGwsIHRoZW4gbm90aGluZyBpcyBkb25lLlxuICAgIC8vICAtIElmIHRoZXJlIGFyZSBubyByZW5kZXJlciBsaXN0LCB0aGUgZ2l2ZW4gY29uZmlndXJhdGlvbiBvYmplY3Qgd2lsbCBiZVxuICAgIC8vICAgIGNvbnNpZGVyZWQgYXMgZGVzY3JpYmluZyB0aGUgZmlyc3QgYW5kIG9ubHkgcmVuZGVyZXIuXG4gICAgLy8gIC0gSWYgdGhlcmUgYXJlIG5vIHJlbmRlcmVyIGxpc3Qgbm9yIFwiY29udGFpbmVyXCIgb2JqZWN0LCBpdCB3aWxsIGJlXG4gICAgLy8gICAgY29uc2lkZXJlZCBhcyB0aGUgY29udGFpbmVyIGl0c2VsZiAoYSBET00gZWxlbWVudCkuXG4gICAgLy8gIC0gSWYgdGhlIGFyZ3VtZW50IHBhc3NlZCB0byBzaWdtYSgpIGlzIGEgc3RyaW5nLCBpdCB3aWxsIGJlIGNvbnNpZGVyZWRcbiAgICAvLyAgICBhcyB0aGUgSUQgb2YgdGhlIERPTSBjb250YWluZXIuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIF9jb25mID09PSAnc3RyaW5nJyB8fFxuICAgICAgX2NvbmYgaW5zdGFuY2VvZiBIVE1MRWxlbWVudFxuICAgIClcbiAgICAgIF9jb25mID0ge1xuICAgICAgICByZW5kZXJlcnM6IFtfY29uZl1cbiAgICAgIH07XG4gICAgZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKF9jb25mKSA9PT0gJ1tvYmplY3QgQXJyYXldJylcbiAgICAgIF9jb25mID0ge1xuICAgICAgICByZW5kZXJlcnM6IF9jb25mXG4gICAgICB9O1xuXG4gICAgLy8gQWxzbyBjaGVjayBcInJlbmRlcmVyXCIgYW5kIFwiY29udGFpbmVyXCIga2V5czpcbiAgICBvID0gX2NvbmYucmVuZGVyZXJzIHx8IF9jb25mLnJlbmRlcmVyIHx8IF9jb25mLmNvbnRhaW5lcjtcbiAgICBpZiAoIV9jb25mLnJlbmRlcmVycyB8fCBfY29uZi5yZW5kZXJlcnMubGVuZ3RoID09PSAwKVxuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgbyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgbyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8XG4gICAgICAgICh0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgJ2NvbnRhaW5lcicgaW4gbylcbiAgICAgIClcbiAgICAgICAgX2NvbmYucmVuZGVyZXJzID0gW29dO1xuXG4gICAgLy8gUmVjZW5zZSB0aGUgaW5zdGFuY2U6XG4gICAgaWYgKF9jb25mLmlkKSB7XG4gICAgICBpZiAoX19pbnN0YW5jZXNbX2NvbmYuaWRdKVxuICAgICAgICB0aHJvdyAnc2lnbWE6IEluc3RhbmNlIFwiJyArIF9jb25mLmlkICsgJ1wiIGFscmVhZHkgZXhpc3RzLic7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2lkJywge1xuICAgICAgICB2YWx1ZTogX2NvbmYuaWRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZCA9IDA7XG4gICAgICB3aGlsZSAoX19pbnN0YW5jZXNbaWRdKVxuICAgICAgICBpZCsrO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdpZCcsIHtcbiAgICAgICAgdmFsdWU6ICcnICsgaWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBfX2luc3RhbmNlc1t0aGlzLmlkXSA9IHRoaXM7XG5cbiAgICAvLyBJbml0aWFsaXplIHNldHRpbmdzIGZ1bmN0aW9uOlxuICAgIHRoaXMuc2V0dGluZ3MgPSBuZXcgc2lnbWEuY2xhc3Nlcy5jb25maWd1cmFibGUoXG4gICAgICBzaWdtYS5zZXR0aW5ncyxcbiAgICAgIF9jb25mLnNldHRpbmdzIHx8IHt9XG4gICAgKTtcblxuICAgIC8vIEluaXRpYWxpemUgbG9ja2VkIGF0dHJpYnV0ZXM6XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdncmFwaCcsIHtcbiAgICAgIHZhbHVlOiBuZXcgc2lnbWEuY2xhc3Nlcy5ncmFwaCh0aGlzLnNldHRpbmdzKSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbWlkZGxld2FyZXMnLCB7XG4gICAgICB2YWx1ZTogW10sXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NhbWVyYXMnLCB7XG4gICAgICB2YWx1ZToge30sXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3JlbmRlcmVycycsIHtcbiAgICAgIHZhbHVlOiB7fSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncmVuZGVyZXJzUGVyQ2FtZXJhJywge1xuICAgICAgdmFsdWU6IHt9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjYW1lcmFGcmFtZXMnLCB7XG4gICAgICB2YWx1ZToge30sXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NhbWVyYScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbWVyYXNbMF07XG4gICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdldmVudHMnLCB7XG4gICAgICB2YWx1ZTogW1xuICAgICAgICAnY2xpY2snLFxuICAgICAgICAncmlnaHRDbGljaycsXG4gICAgICAgICdjbGlja1N0YWdlJyxcbiAgICAgICAgJ2RvdWJsZUNsaWNrU3RhZ2UnLFxuICAgICAgICAncmlnaHRDbGlja1N0YWdlJyxcbiAgICAgICAgJ2NsaWNrTm9kZScsXG4gICAgICAgICdjbGlja05vZGVzJyxcbiAgICAgICAgJ2RvdWJsZUNsaWNrTm9kZScsXG4gICAgICAgICdkb3VibGVDbGlja05vZGVzJyxcbiAgICAgICAgJ3JpZ2h0Q2xpY2tOb2RlJyxcbiAgICAgICAgJ3JpZ2h0Q2xpY2tOb2RlcycsXG4gICAgICAgICdvdmVyTm9kZScsXG4gICAgICAgICdvdmVyTm9kZXMnLFxuICAgICAgICAnb3V0Tm9kZScsXG4gICAgICAgICdvdXROb2RlcycsXG4gICAgICAgICdkb3duTm9kZScsXG4gICAgICAgICdkb3duTm9kZXMnLFxuICAgICAgICAndXBOb2RlJyxcbiAgICAgICAgJ3VwTm9kZXMnXG4gICAgICBdLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYSBjdXN0b20gaGFuZGxlciwgdG8gcmVkaXNwYXRjaCBldmVudHMgZnJvbSByZW5kZXJlcnM6XG4gICAgdGhpcy5faGFuZGxlciA9IChmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgayxcbiAgICAgICAgICBkYXRhID0ge307XG5cbiAgICAgIGZvciAoayBpbiBlLmRhdGEpXG4gICAgICAgIGRhdGFba10gPSBlLmRhdGFba107XG5cbiAgICAgIGRhdGEucmVuZGVyZXIgPSBlLnRhcmdldDtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlLnR5cGUsIGRhdGEpO1xuICAgIH0pLmJpbmQodGhpcyk7XG5cbiAgICAvLyBJbml0aWFsaXplIHJlbmRlcmVyczpcbiAgICBhID0gX2NvbmYucmVuZGVyZXJzIHx8IFtdO1xuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIHRoaXMuYWRkUmVuZGVyZXIoYVtpXSk7XG5cbiAgICAvLyBJbml0aWFsaXplIG1pZGRsZXdhcmVzOlxuICAgIGEgPSBfY29uZi5taWRkbGV3YXJlcyB8fCBbXTtcbiAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICB0aGlzLm1pZGRsZXdhcmVzLnB1c2goXG4gICAgICAgIHR5cGVvZiBhW2ldID09PSAnc3RyaW5nJyA/XG4gICAgICAgICAgc2lnbWEubWlkZGxld2FyZXNbYVtpXV0gOlxuICAgICAgICAgIGFbaV1cbiAgICAgICk7XG5cbiAgICAvLyBDaGVjayBpZiB0aGVyZSBpcyBhbHJlYWR5IGEgZ3JhcGggdG8gZmlsbCBpbjpcbiAgICBpZiAodHlwZW9mIF9jb25mLmdyYXBoID09PSAnb2JqZWN0JyAmJiBfY29uZi5ncmFwaCkge1xuICAgICAgdGhpcy5ncmFwaC5yZWFkKF9jb25mLmdyYXBoKTtcblxuICAgICAgLy8gSWYgYSBncmFwaCBpcyBnaXZlbiB0byB0aGUgdG8gdGhlIGluc3RhbmNlLCB0aGUgXCJyZWZyZXNoXCIgbWV0aG9kIGlzXG4gICAgICAvLyBkaXJlY3RseSBjYWxsZWQ6XG4gICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICB9XG5cbiAgICAvLyBEZWFsIHdpdGggcmVzaXplOlxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChfc2VsZi5zZXR0aW5ncylcbiAgICAgICAgX3NlbGYucmVmcmVzaCgpO1xuICAgIH0pO1xuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZHMgd2lsbCBpbnN0YW50aWF0ZSBhbmQgcmVmZXJlbmNlIGEgbmV3IGNhbWVyYS4gSWYgbm8gaWQgaXNcbiAgICogc3BlY2lmaWVkLCB0aGVuIGFuIGF1dG9tYXRpYyBpZCB3aWxsIGJlIGdlbmVyYXRlZC5cbiAgICpcbiAgICogQHBhcmFtICB7P3N0cmluZ30gICAgICAgICAgICAgIGlkIEV2ZW50dWFsbHkgdGhlIGNhbWVyYSBpZC5cbiAgICogQHJldHVybiB7c2lnbWEuY2xhc3Nlcy5jYW1lcmF9ICAgIFRoZSBmcmVzaCBuZXcgY2FtZXJhIGluc3RhbmNlLlxuICAgKi9cbiAgc2lnbWEucHJvdG90eXBlLmFkZENhbWVyYSA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBjYW1lcmE7XG5cbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGlkID0gMDtcbiAgICAgIHdoaWxlICh0aGlzLmNhbWVyYXNbJycgKyBpZF0pXG4gICAgICAgIGlkKys7XG4gICAgICBpZCA9ICcnICsgaWQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY2FtZXJhc1tpZF0pXG4gICAgICB0aHJvdyAnc2lnbWEuYWRkQ2FtZXJhOiBUaGUgY2FtZXJhIFwiJyArIGlkICsgJ1wiIGFscmVhZHkgZXhpc3RzLic7XG5cbiAgICBjYW1lcmEgPSBuZXcgc2lnbWEuY2xhc3Nlcy5jYW1lcmEoaWQsIHRoaXMuZ3JhcGgsIHRoaXMuc2V0dGluZ3MpO1xuICAgIHRoaXMuY2FtZXJhc1tpZF0gPSBjYW1lcmE7XG5cbiAgICAvLyBBZGQgYSBxdWFkdHJlZSB0byB0aGUgY2FtZXJhOlxuICAgIGNhbWVyYS5xdWFkdHJlZSA9IG5ldyBzaWdtYS5jbGFzc2VzLnF1YWQoKTtcblxuICAgIC8vIEFkZCBhbiBlZGdlcXVhZHRyZWUgdG8gdGhlIGNhbWVyYTpcbiAgICBpZiAoc2lnbWEuY2xhc3Nlcy5lZGdlcXVhZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjYW1lcmEuZWRnZXF1YWR0cmVlID0gbmV3IHNpZ21hLmNsYXNzZXMuZWRnZXF1YWQoKTtcbiAgICB9XG5cbiAgICBjYW1lcmEuYmluZCgnY29vcmRpbmF0ZXNVcGRhdGVkJywgZnVuY3Rpb24oZSkge1xuICAgICAgc2VsZi5yZW5kZXJDYW1lcmEoY2FtZXJhLCBjYW1lcmEuaXNBbmltYXRlZCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVtpZF0gPSBbXTtcblxuICAgIHJldHVybiBjYW1lcmE7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGtpbGxzIGEgY2FtZXJhLCBhbmQgZXZlcnkgcmVuZGVyZXIgYXR0YWNoZWQgdG8gaXQuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ3xjYW1lcmF9IHYgVGhlIGNhbWVyYSB0byBraWxsIG9yIGl0cyBJRC5cbiAgICogQHJldHVybiB7c2lnbWF9ICAgICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZS5cbiAgICovXG4gIHNpZ21hLnByb3RvdHlwZS5raWxsQ2FtZXJhID0gZnVuY3Rpb24odikge1xuICAgIHYgPSB0eXBlb2YgdiA9PT0gJ3N0cmluZycgPyB0aGlzLmNhbWVyYXNbdl0gOiB2O1xuXG4gICAgaWYgKCF2KVxuICAgICAgdGhyb3cgJ3NpZ21hLmtpbGxDYW1lcmE6IFRoZSBjYW1lcmEgaXMgdW5kZWZpbmVkLic7XG5cbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgYSA9IHRoaXMucmVuZGVyZXJzUGVyQ2FtZXJhW3YuaWRdO1xuXG4gICAgZm9yIChsID0gYS5sZW5ndGgsIGkgPSBsIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICB0aGlzLmtpbGxSZW5kZXJlcihhW2ldKTtcblxuICAgIGRlbGV0ZSB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVt2LmlkXTtcbiAgICBkZWxldGUgdGhpcy5jYW1lcmFGcmFtZXNbdi5pZF07XG4gICAgZGVsZXRlIHRoaXMuY2FtZXJhc1t2LmlkXTtcblxuICAgIGlmICh2LmtpbGwpXG4gICAgICB2LmtpbGwoKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZHMgd2lsbCBpbnN0YW50aWF0ZSBhbmQgcmVmZXJlbmNlIGEgbmV3IHJlbmRlcmVyLiBUaGUgXCJ0eXBlXCJcbiAgICogYXJndW1lbnQgY2FuIGJlIHRoZSBjb25zdHJ1Y3RvciBvciBpdHMgbmFtZSBpbiB0aGUgXCJzaWdtYS5yZW5kZXJlcnNcIlxuICAgKiBwYWNrYWdlLiBJZiBubyB0eXBlIGlzIHNwZWNpZmllZCwgdGhlbiBcInNpZ21hLnJlbmRlcmVycy5kZWZcIiB3aWxsIGJlIHVzZWQuXG4gICAqIElmIG5vIGlkIGlzIHNwZWNpZmllZCwgdGhlbiBhbiBhdXRvbWF0aWMgaWQgd2lsbCBiZSBnZW5lcmF0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSAgez9vYmplY3R9ICBvcHRpb25zIEV2ZW50dWFsbHkgc29tZSBvcHRpb25zIHRvIGdpdmUgdG8gdGhlIHJlbmRlcmVyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yLlxuICAgKiBAcmV0dXJuIHtyZW5kZXJlcn0gICAgICAgICBUaGUgZnJlc2ggbmV3IHJlbmRlcmVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBSZWNvZ25pemVkIHBhcmFtZXRlcnM6XG4gICAqICoqKioqKioqKioqKioqKioqKioqKipcbiAgICogSGVyZSBpcyB0aGUgZXhoYXVzdGl2ZSBsaXN0IG9mIGV2ZXJ5IGFjY2VwdGVkIHBhcmFtZXRlcnMgaW4gdGhlIFwib3B0aW9uc1wiXG4gICAqIG9iamVjdDpcbiAgICpcbiAgICogICB7P3N0cmluZ30gICAgICAgICAgICBpZCAgICAgRXZlbnR1YWxseSB0aGUgcmVuZGVyZXIgaWQuXG4gICAqICAgez8oZnVuY3Rpb258c3RyaW5nKX0gdHlwZSAgIEV2ZW50dWFsbHkgdGhlIHJlbmRlcmVyIGNvbnN0cnVjdG9yIG9yIGl0c1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lIGluIHRoZSBcInNpZ21hLnJlbmRlcmVyc1wiIHBhY2thZ2UuXG4gICAqICAgez8oY2FtZXJhfHN0cmluZyl9ICAgY2FtZXJhIEV2ZW50dWFsbHkgdGhlIHJlbmRlcmVyIGNhbWVyYSBvciBpdHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQuXG4gICAqL1xuICBzaWdtYS5wcm90b3R5cGUuYWRkUmVuZGVyZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGlkLFxuICAgICAgICBmbixcbiAgICAgICAgY2FtZXJhLFxuICAgICAgICByZW5kZXJlcixcbiAgICAgICAgbyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBQb2x5bW9ycGhpc206XG4gICAgaWYgKHR5cGVvZiBvID09PSAnc3RyaW5nJylcbiAgICAgIG8gPSB7XG4gICAgICAgIGNvbnRhaW5lcjogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobylcbiAgICAgIH07XG4gICAgZWxzZSBpZiAobyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KVxuICAgICAgbyA9IHtcbiAgICAgICAgY29udGFpbmVyOiBvXG4gICAgICB9O1xuXG4gICAgLy8gSWYgdGhlIGNvbnRhaW5lciBzdGlsbCBpcyBhIHN0cmluZywgd2UgZ2V0IGl0IGJ5IGlkXG4gICAgaWYgKHR5cGVvZiBvLmNvbnRhaW5lciA9PT0gJ3N0cmluZycpXG4gICAgICBvLmNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG8uY29udGFpbmVyKTtcblxuICAgIC8vIFJlZmVyZW5jZSB0aGUgbmV3IHJlbmRlcmVyOlxuICAgIGlmICghKCdpZCcgaW4gbykpIHtcbiAgICAgIGlkID0gMDtcbiAgICAgIHdoaWxlICh0aGlzLnJlbmRlcmVyc1snJyArIGlkXSlcbiAgICAgICAgaWQrKztcbiAgICAgIGlkID0gJycgKyBpZDtcbiAgICB9IGVsc2VcbiAgICAgIGlkID0gby5pZDtcblxuICAgIGlmICh0aGlzLnJlbmRlcmVyc1tpZF0pXG4gICAgICB0aHJvdyAnc2lnbWEuYWRkUmVuZGVyZXI6IFRoZSByZW5kZXJlciBcIicgKyBpZCArICdcIiBhbHJlYWR5IGV4aXN0cy4nO1xuXG4gICAgLy8gRmluZCB0aGUgZ29vZCBjb25zdHJ1Y3RvcjpcbiAgICBmbiA9IHR5cGVvZiBvLnR5cGUgPT09ICdmdW5jdGlvbicgPyBvLnR5cGUgOiBzaWdtYS5yZW5kZXJlcnNbby50eXBlXTtcbiAgICBmbiA9IGZuIHx8IHNpZ21hLnJlbmRlcmVycy5kZWY7XG5cbiAgICAvLyBGaW5kIHRoZSBnb29kIGNhbWVyYTpcbiAgICBjYW1lcmEgPSAnY2FtZXJhJyBpbiBvID9cbiAgICAgIChcbiAgICAgICAgby5jYW1lcmEgaW5zdGFuY2VvZiBzaWdtYS5jbGFzc2VzLmNhbWVyYSA/XG4gICAgICAgICAgby5jYW1lcmEgOlxuICAgICAgICAgIHRoaXMuY2FtZXJhc1tvLmNhbWVyYV0gfHwgdGhpcy5hZGRDYW1lcmEoby5jYW1lcmEpXG4gICAgICApIDpcbiAgICAgIHRoaXMuYWRkQ2FtZXJhKCk7XG5cbiAgICBpZiAodGhpcy5jYW1lcmFzW2NhbWVyYS5pZF0gIT09IGNhbWVyYSlcbiAgICAgIHRocm93ICdzaWdtYS5hZGRSZW5kZXJlcjogVGhlIGNhbWVyYSBpcyBub3QgcHJvcGVybHkgcmVmZXJlbmNlZC4nO1xuXG4gICAgLy8gSW5zdGFudGlhdGU6XG4gICAgcmVuZGVyZXIgPSBuZXcgZm4odGhpcy5ncmFwaCwgY2FtZXJhLCB0aGlzLnNldHRpbmdzLCBvKTtcbiAgICB0aGlzLnJlbmRlcmVyc1tpZF0gPSByZW5kZXJlcjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVuZGVyZXIsICdpZCcsIHtcbiAgICAgIHZhbHVlOiBpZFxuICAgIH0pO1xuXG4gICAgLy8gQmluZCBldmVudHM6XG4gICAgaWYgKHJlbmRlcmVyLmJpbmQpXG4gICAgICByZW5kZXJlci5iaW5kKFxuICAgICAgICBbXG4gICAgICAgICAgJ2NsaWNrJyxcbiAgICAgICAgICAncmlnaHRDbGljaycsXG4gICAgICAgICAgJ2NsaWNrU3RhZ2UnLFxuICAgICAgICAgICdkb3VibGVDbGlja1N0YWdlJyxcbiAgICAgICAgICAncmlnaHRDbGlja1N0YWdlJyxcbiAgICAgICAgICAnY2xpY2tOb2RlJyxcbiAgICAgICAgICAnY2xpY2tOb2RlcycsXG4gICAgICAgICAgJ2NsaWNrRWRnZScsXG4gICAgICAgICAgJ2NsaWNrRWRnZXMnLFxuICAgICAgICAgICdkb3VibGVDbGlja05vZGUnLFxuICAgICAgICAgICdkb3VibGVDbGlja05vZGVzJyxcbiAgICAgICAgICAnZG91YmxlQ2xpY2tFZGdlJyxcbiAgICAgICAgICAnZG91YmxlQ2xpY2tFZGdlcycsXG4gICAgICAgICAgJ3JpZ2h0Q2xpY2tOb2RlJyxcbiAgICAgICAgICAncmlnaHRDbGlja05vZGVzJyxcbiAgICAgICAgICAncmlnaHRDbGlja0VkZ2UnLFxuICAgICAgICAgICdyaWdodENsaWNrRWRnZXMnLFxuICAgICAgICAgICdvdmVyTm9kZScsXG4gICAgICAgICAgJ292ZXJOb2RlcycsXG4gICAgICAgICAgJ292ZXJFZGdlJyxcbiAgICAgICAgICAnb3ZlckVkZ2VzJyxcbiAgICAgICAgICAnb3V0Tm9kZScsXG4gICAgICAgICAgJ291dE5vZGVzJyxcbiAgICAgICAgICAnb3V0RWRnZScsXG4gICAgICAgICAgJ291dEVkZ2VzJyxcbiAgICAgICAgICAnZG93bk5vZGUnLFxuICAgICAgICAgICdkb3duTm9kZXMnLFxuICAgICAgICAgICdkb3duRWRnZScsXG4gICAgICAgICAgJ2Rvd25FZGdlcycsXG4gICAgICAgICAgJ3VwTm9kZScsXG4gICAgICAgICAgJ3VwTm9kZXMnLFxuICAgICAgICAgICd1cEVkZ2UnLFxuICAgICAgICAgICd1cEVkZ2VzJ1xuICAgICAgICBdLFxuICAgICAgICB0aGlzLl9oYW5kbGVyXG4gICAgICApO1xuXG4gICAgLy8gUmVmZXJlbmNlIHRoZSByZW5kZXJlciBieSBpdHMgY2FtZXJhOlxuICAgIHRoaXMucmVuZGVyZXJzUGVyQ2FtZXJhW2NhbWVyYS5pZF0ucHVzaChyZW5kZXJlcik7XG5cbiAgICByZXR1cm4gcmVuZGVyZXI7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGtpbGxzIGEgcmVuZGVyZXIuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ3xyZW5kZXJlcn0gdiBUaGUgcmVuZGVyZXIgdG8ga2lsbCBvciBpdHMgSUQuXG4gICAqIEByZXR1cm4ge3NpZ21hfSAgICAgICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZS5cbiAgICovXG4gIHNpZ21hLnByb3RvdHlwZS5raWxsUmVuZGVyZXIgPSBmdW5jdGlvbih2KSB7XG4gICAgdiA9IHR5cGVvZiB2ID09PSAnc3RyaW5nJyA/IHRoaXMucmVuZGVyZXJzW3ZdIDogdjtcblxuICAgIGlmICghdilcbiAgICAgIHRocm93ICdzaWdtYS5raWxsUmVuZGVyZXI6IFRoZSByZW5kZXJlciBpcyB1bmRlZmluZWQuJztcblxuICAgIHZhciBhID0gdGhpcy5yZW5kZXJlcnNQZXJDYW1lcmFbdi5jYW1lcmEuaWRdLFxuICAgICAgICBpID0gYS5pbmRleE9mKHYpO1xuXG4gICAgaWYgKGkgPj0gMClcbiAgICAgIGEuc3BsaWNlKGksIDEpO1xuXG4gICAgaWYgKHYua2lsbClcbiAgICAgIHYua2lsbCgpO1xuXG4gICAgZGVsZXRlIHRoaXMucmVuZGVyZXJzW3YuaWRdO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGNhbGxzIHRoZSBcInJlbmRlclwiIG1ldGhvZCBvZiBlYWNoIHJlbmRlcmVyLCB3aXRoIHRoZSBzYW1lXG4gICAqIGFyZ3VtZW50cyB0aGFuIHRoZSBcInJlbmRlclwiIG1ldGhvZCwgYnV0IHdpbGwgYWxzbyBjaGVjayBpZiB0aGUgcmVuZGVyZXJcbiAgICogaGFzIGEgXCJwcm9jZXNzXCIgbWV0aG9kLCBhbmQgY2FsbCBpdCBpZiBpdCBleGlzdHMuXG4gICAqXG4gICAqIEl0IGlzIHVzZWZ1bCBmb3IgcXVhZHRyZWVzIG9yIFdlYkdMIHByb2Nlc3NpbmcsIGZvciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtICB7P29iamVjdH0gIG9wdGlvbnMgRXZlbnR1YWxseSBzb21lIG9wdGlvbnMgdG8gZ2l2ZSB0byB0aGUgcmVmcmVzaFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2QuXG4gICAqIEByZXR1cm4ge3NpZ21hfSAgICAgICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICpcbiAgICogUmVjb2duaXplZCBwYXJhbWV0ZXJzOlxuICAgKiAqKioqKioqKioqKioqKioqKioqKioqXG4gICAqIEhlcmUgaXMgdGhlIGV4aGF1c3RpdmUgbGlzdCBvZiBldmVyeSBhY2NlcHRlZCBwYXJhbWV0ZXJzIGluIHRoZSBcIm9wdGlvbnNcIlxuICAgKiBvYmplY3Q6XG4gICAqXG4gICAqICAgez9ib29sZWFufSBza2lwSW5kZXhhdGlvbiBBIGZsYWcgc3BlY2lmeWluZyB3ZXRoZXIgb3Igbm90IHRoZSByZWZyZXNoXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBzaG91bGQgcmVpbmRleCB0aGUgZ3JhcGggaW4gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWFkdHJlZXMgb3Igbm90IChkZWZhdWx0OiBmYWxzZSkuXG4gICAqL1xuICBzaWdtYS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgayxcbiAgICAgICAgYSxcbiAgICAgICAgYyxcbiAgICAgICAgYm91bmRzLFxuICAgICAgICBwcmVmaXggPSAwO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBDYWxsIGVhY2ggbWlkZGxld2FyZTpcbiAgICBhID0gdGhpcy5taWRkbGV3YXJlcyB8fCBbXTtcbiAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICBhW2ldLmNhbGwoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIChpID09PSAwKSA/ICcnIDogJ3RtcCcgKyBwcmVmaXggKyAnOicsXG4gICAgICAgIChpID09PSBsIC0gMSkgPyAncmVhZHk6JyA6ICgndG1wJyArICgrK3ByZWZpeCkgKyAnOicpXG4gICAgICApO1xuXG4gICAgLy8gVGhlbiwgZm9yIGVhY2ggY2FtZXJhLCBjYWxsIHRoZSBcInJlc2NhbGVcIiBtaWRkbGV3YXJlLCB1bmxlc3MgdGhlXG4gICAgLy8gc2V0dGluZ3Mgc3BlY2lmeSBub3QgdG86XG4gICAgZm9yIChrIGluIHRoaXMuY2FtZXJhcykge1xuICAgICAgYyA9IHRoaXMuY2FtZXJhc1trXTtcbiAgICAgIGlmIChcbiAgICAgICAgYy5zZXR0aW5ncygnYXV0b1Jlc2NhbGUnKSAmJlxuICAgICAgICB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVtjLmlkXSAmJlxuICAgICAgICB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVtjLmlkXS5sZW5ndGhcbiAgICAgIClcbiAgICAgICAgc2lnbWEubWlkZGxld2FyZXMucmVzY2FsZS5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgYS5sZW5ndGggPyAncmVhZHk6JyA6ICcnLFxuICAgICAgICAgIGMucmVhZFByZWZpeCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy5yZW5kZXJlcnNQZXJDYW1lcmFbYy5pZF1bMF0ud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMucmVuZGVyZXJzUGVyQ2FtZXJhW2MuaWRdWzBdLmhlaWdodFxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIGVsc2VcbiAgICAgICAgc2lnbWEubWlkZGxld2FyZXMuY29weS5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgYS5sZW5ndGggPyAncmVhZHk6JyA6ICcnLFxuICAgICAgICAgIGMucmVhZFByZWZpeFxuICAgICAgICApO1xuXG4gICAgICBpZiAoIW9wdGlvbnMuc2tpcEluZGV4YXRpb24pIHtcbiAgICAgICAgLy8gRmluZCBncmFwaCBib3VuZGFyaWVzOlxuICAgICAgICBib3VuZHMgPSBzaWdtYS51dGlscy5nZXRCb3VuZGFyaWVzKFxuICAgICAgICAgIHRoaXMuZ3JhcGgsXG4gICAgICAgICAgYy5yZWFkUHJlZml4XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gUmVmcmVzaCBxdWFkdHJlZTpcbiAgICAgICAgYy5xdWFkdHJlZS5pbmRleCh0aGlzLmdyYXBoLm5vZGVzKCksIHtcbiAgICAgICAgICBwcmVmaXg6IGMucmVhZFByZWZpeCxcbiAgICAgICAgICBib3VuZHM6IHtcbiAgICAgICAgICAgIHg6IGJvdW5kcy5taW5YLFxuICAgICAgICAgICAgeTogYm91bmRzLm1pblksXG4gICAgICAgICAgICB3aWR0aDogYm91bmRzLm1heFggLSBib3VuZHMubWluWCxcbiAgICAgICAgICAgIGhlaWdodDogYm91bmRzLm1heFkgLSBib3VuZHMubWluWVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmVmcmVzaCBlZGdlcXVhZHRyZWU6XG4gICAgICAgIGlmIChcbiAgICAgICAgICBjLmVkZ2VxdWFkdHJlZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgYy5zZXR0aW5ncygnZHJhd0VkZ2VzJykgJiZcbiAgICAgICAgICBjLnNldHRpbmdzKCdlbmFibGVFZGdlSG92ZXJpbmcnKVxuICAgICAgICApIHtcbiAgICAgICAgICBjLmVkZ2VxdWFkdHJlZS5pbmRleCh0aGlzLmdyYXBoLCB7XG4gICAgICAgICAgICBwcmVmaXg6IGMucmVhZFByZWZpeCxcbiAgICAgICAgICAgIGJvdW5kczoge1xuICAgICAgICAgICAgICB4OiBib3VuZHMubWluWCxcbiAgICAgICAgICAgICAgeTogYm91bmRzLm1pblksXG4gICAgICAgICAgICAgIHdpZHRoOiBib3VuZHMubWF4WCAtIGJvdW5kcy5taW5YLFxuICAgICAgICAgICAgICBoZWlnaHQ6IGJvdW5kcy5tYXhZIC0gYm91bmRzLm1pbllcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENhbGwgZWFjaCByZW5kZXJlcjpcbiAgICBhID0gT2JqZWN0LmtleXModGhpcy5yZW5kZXJlcnMpO1xuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIGlmICh0aGlzLnJlbmRlcmVyc1thW2ldXS5wcm9jZXNzKSB7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzKCdza2lwRXJyb3JzJykpXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXJzW2FbaV1dLnByb2Nlc3MoKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgJ1dhcm5pbmc6IFRoZSByZW5kZXJlciBcIicgKyBhW2ldICsgJ1wiIGNyYXNoZWQgb24gXCIucHJvY2VzcygpXCInXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRoaXMucmVuZGVyZXJzW2FbaV1dLnByb2Nlc3MoKTtcbiAgICAgIH1cblxuICAgIHRoaXMucmVuZGVyKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY2FsbHMgdGhlIFwicmVuZGVyXCIgbWV0aG9kIG9mIGVhY2ggcmVuZGVyZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge3NpZ21hfSBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBzaWdtYS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIGEsXG4gICAgICAgIHByZWZpeCA9IDA7XG5cbiAgICAvLyBDYWxsIGVhY2ggcmVuZGVyZXI6XG4gICAgYSA9IE9iamVjdC5rZXlzKHRoaXMucmVuZGVyZXJzKTtcbiAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncygnc2tpcEVycm9ycycpKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMucmVuZGVyZXJzW2FbaV1dLnJlbmRlcigpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MoJ3ZlcmJvc2UnKSlcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAnV2FybmluZzogVGhlIHJlbmRlcmVyIFwiJyArIGFbaV0gKyAnXCIgY3Jhc2hlZCBvbiBcIi5yZW5kZXIoKVwiJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgZWxzZVxuICAgICAgICB0aGlzLnJlbmRlcmVyc1thW2ldXS5yZW5kZXIoKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBjYWxscyB0aGUgXCJyZW5kZXJcIiBtZXRob2Qgb2YgZWFjaCByZW5kZXJlciB0aGF0IGlzIGJvdW5kIHRvXG4gICAqIHRoZSBzcGVjaWZpZWQgY2FtZXJhLiBUbyBpbXByb3ZlIHRoZSBwZXJmb3JtYW5jZXMsIGlmIHRoaXMgbWV0aG9kIGlzXG4gICAqIGNhbGxlZCB0b28gb2Z0ZW4sIHRoZSBudW1iZXIgb2YgZWZmZWN0aXZlIHJlbmRlcmluZ3MgaXMgbGltaXRhdGVkIHRvIG9uZVxuICAgKiBwZXIgZnJhbWUsIHVubGVzcyB5b3UgYXJlIHVzaW5nIHRoZSBcImZvcmNlXCIgZmxhZy5cbiAgICpcbiAgICogQHBhcmFtICB7c2lnbWEuY2xhc3Nlcy5jYW1lcmF9IGNhbWVyYSBUaGUgY2FtZXJhIHRvIHJlbmRlci5cbiAgICogQHBhcmFtICB7P2Jvb2xlYW59ICAgICAgICAgICAgIGZvcmNlICBJZiB0cnVlLCB3aWxsIHJlbmRlciB0aGUgY2FtZXJhXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0bHkuXG4gICAqIEByZXR1cm4ge3NpZ21hfSAgICAgICAgICAgICAgICAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgc2lnbWEucHJvdG90eXBlLnJlbmRlckNhbWVyYSA9IGZ1bmN0aW9uKGNhbWVyYSwgZm9yY2UpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgYSxcbiAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoZm9yY2UpIHtcbiAgICAgIGEgPSB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVtjYW1lcmEuaWRdO1xuICAgICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncygnc2tpcEVycm9ycycpKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhW2ldLnJlbmRlcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzKCd2ZXJib3NlJykpXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgICdXYXJuaW5nOiBUaGUgcmVuZGVyZXIgXCInICsgYVtpXS5pZCArICdcIiBjcmFzaGVkIG9uIFwiLnJlbmRlcigpXCInXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgYVtpXS5yZW5kZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLmNhbWVyYUZyYW1lc1tjYW1lcmEuaWRdKSB7XG4gICAgICAgIGEgPSB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVtjYW1lcmEuaWRdO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MoJ3NraXBFcnJvcnMnKSlcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGFbaV0ucmVuZGVyKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzKCd2ZXJib3NlJykpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgICAnV2FybmluZzogVGhlIHJlbmRlcmVyIFwiJyArXG4gICAgICAgICAgICAgICAgICAgIGFbaV0uaWQgK1xuICAgICAgICAgICAgICAgICAgICAnXCIgY3Jhc2hlZCBvbiBcIi5yZW5kZXIoKVwiJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgYVtpXS5yZW5kZXIoKTtcblxuICAgICAgICB0aGlzLmNhbWVyYUZyYW1lc1tjYW1lcmEuaWRdID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGRlbGV0ZSBzZWxmLmNhbWVyYUZyYW1lc1tjYW1lcmEuaWRdO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY2FsbHMgdGhlIFwia2lsbFwiIG1ldGhvZCBvZiBlYWNoIG1vZHVsZSBhbmQgZGVzdHJveXMgYW55XG4gICAqIHJlZmVyZW5jZSBmcm9tIHRoZSBpbnN0YW5jZS5cbiAgICovXG4gIHNpZ21hLnByb3RvdHlwZS5raWxsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGs7XG5cbiAgICAvLyBEaXNwYXRjaGluZyBldmVudFxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgna2lsbCcpO1xuXG4gICAgLy8gS2lsbCBncmFwaDpcbiAgICB0aGlzLmdyYXBoLmtpbGwoKTtcblxuICAgIC8vIEtpbGwgbWlkZGxld2FyZXM6XG4gICAgZGVsZXRlIHRoaXMubWlkZGxld2FyZXM7XG5cbiAgICAvLyBLaWxsIGVhY2ggcmVuZGVyZXI6XG4gICAgZm9yIChrIGluIHRoaXMucmVuZGVyZXJzKVxuICAgICAgdGhpcy5raWxsUmVuZGVyZXIodGhpcy5yZW5kZXJlcnNba10pO1xuXG4gICAgLy8gS2lsbCBlYWNoIGNhbWVyYTpcbiAgICBmb3IgKGsgaW4gdGhpcy5jYW1lcmFzKVxuICAgICAgdGhpcy5raWxsQ2FtZXJhKHRoaXMuY2FtZXJhc1trXSk7XG5cbiAgICBkZWxldGUgdGhpcy5yZW5kZXJlcnM7XG4gICAgZGVsZXRlIHRoaXMuY2FtZXJhcztcblxuICAgIC8vIEtpbGwgZXZlcnl0aGluZyBlbHNlOlxuICAgIGZvciAoayBpbiB0aGlzKVxuICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoaykpXG4gICAgICAgIGRlbGV0ZSB0aGlzW2tdO1xuXG4gICAgZGVsZXRlIF9faW5zdGFuY2VzW3RoaXMuaWRdO1xuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIGluc3RhbmNlcyBvYmplY3Qgb3IgYSBzcGVjaWZpYyBydW5uaW5nIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0gIHs/c3RyaW5nfSBpZCBFdmVudHVhbGx5IGFuIGluc3RhbmNlIElELlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICBUaGUgcmVsYXRlZCBpbnN0YW5jZSBvciBhIGNsb25lIG9mIHRoZSBpbnN0YW5jZXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LlxuICAgKi9cbiAgc2lnbWEuaW5zdGFuY2VzID0gZnVuY3Rpb24oaWQpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/XG4gICAgICBfX2luc3RhbmNlc1tpZF0gOlxuICAgICAgc2lnbWEudXRpbHMuZXh0ZW5kKHt9LCBfX2luc3RhbmNlcyk7XG4gIH07XG5cblxuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIHNpZ21hOlxuICAgKi9cbiAgc2lnbWEudmVyc2lvbiA9ICcxLjIuMSc7XG5cblxuXG5cbiAgLyoqXG4gICAqIEVYUE9SVDpcbiAgICogKioqKioqKlxuICAgKi9cbiAgaWYgKHR5cGVvZiB0aGlzLnNpZ21hICE9PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnQW4gb2JqZWN0IGNhbGxlZCBzaWdtYSBpcyBhbHJlYWR5IGluIHRoZSBnbG9iYWwgc2NvcGUuJztcblxuICB0aGlzLnNpZ21hID0gc2lnbWE7XG5cbn0pLmNhbGwodGhpcyk7XG5cbi8qKlxuICogY29ucmFkLmpzIGlzIGEgdGlueSBKYXZhU2NyaXB0IGpvYnMgc2NoZWR1bGVyLFxuICpcbiAqIFZlcnNpb246IDAuMS4wXG4gKiBTb3VyY2VzOiBodHRwOi8vZ2l0aHViLmNvbS9qYWNvbXlhbC9jb25yYWQuanNcbiAqIERvYzogICAgIGh0dHA6Ly9naXRodWIuY29tL2phY29teWFsL2NvbnJhZC5qcyNyZWFkbWVcbiAqXG4gKiBMaWNlbnNlOlxuICogLS0tLS0tLS1cbiAqIENvcHlyaWdodCDCqSAyMDEzIEFsZXhpcyBKYWNvbXksIFNjaWVuY2VzLVBvIG3DqWRpYWxhYlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvXG4gKiBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuICogcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4gKiBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVGhlIFNvZnR3YXJlIGlzIHByb3ZpZGVkIFwiYXMgaXNcIiwgd2l0aG91dCB3YXJyYW50eSBvZiBhbnkga2luZCwgZXhwcmVzcyBvclxuICogaW1wbGllZCwgaW5jbHVkaW5nIGJ1dCBub3QgbGltaXRlZCB0byB0aGUgd2FycmFudGllcyBvZiBtZXJjaGFudGFiaWxpdHksXG4gKiBmaXRuZXNzIGZvciBhIHBhcnRpY3VsYXIgcHVycG9zZSBhbmQgbm9uaW5mcmluZ2VtZW50LiBJbiBubyBldmVudCBzaGFsbCB0aGVcbiAqIGF1dGhvcnMgb3IgY29weXJpZ2h0IGhvbGRlcnMgYmUgbGlhYmxlIGZvciBhbnkgY2xhaW0sIGRhbWFnZXMgb3Igb3RoZXJcbiAqIGxpYWJpbGl0eSwgd2hldGhlciBpbiBhbiBhY3Rpb24gb2YgY29udHJhY3QsIHRvcnQgb3Igb3RoZXJ3aXNlLCBhcmlzaW5nXG4gKiBmcm9tLCBvdXQgb2Ygb3IgaW4gY29ubmVjdGlvbiB3aXRoIHRoZSBzb2Z0d2FyZSBvciB0aGUgdXNlIG9yIG90aGVyIGRlYWxpbmdzXG4gKiBpbiB0aGUgU29mdHdhcmUuXG4gKi9cbihmdW5jdGlvbihnbG9iYWwpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIENoZWNrIHRoYXQgY29ucmFkLmpzIGhhcyBub3QgYmVlbiBsb2FkZWQgeWV0OlxuICBpZiAoZ2xvYmFsLmNvbnJhZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnJhZCBhbHJlYWR5IGV4aXN0cycpO1xuXG5cbiAgLyoqXG4gICAqIFBSSVZBVEUgVkFSSUFCTEVTOlxuICAgKiAqKioqKioqKioqKioqKioqKipcbiAgICovXG5cbiAgLyoqXG4gICAqIEEgZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgY29ucmFkIGlzIHJ1bm5pbmcgb3Igbm90LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgdmFyIF9sYXN0RnJhbWVUaW1lO1xuXG4gIC8qKlxuICAgKiBBIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIGNvbnJhZCBpcyBydW5uaW5nIG9yIG5vdC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICB2YXIgX2lzUnVubmluZyA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBUaGUgaGFzaCBvZiByZWdpc3RlcmVkIGpvYnMuIEVhY2ggam9iIG11c3QgYXQgbGVhc3QgaGF2ZSBhIHVuaXF1ZSBJRFxuICAgKiB1bmRlciB0aGUga2V5IFwiaWRcIiBhbmQgYSBmdW5jdGlvbiB1bmRlciB0aGUga2V5IFwiam9iXCIuIFRoaXMgaGFzaFxuICAgKiBjb250YWlucyBlYWNoIHJ1bm5pbmcgam9iIGFuZCBlYWNoIHdhaXRpbmcgam9iLlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgdmFyIF9qb2JzID0ge307XG5cbiAgLyoqXG4gICAqIFRoZSBoYXNoIG9mIGN1cnJlbnRseSBydW5uaW5nIGpvYnMuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB2YXIgX3J1bm5pbmdKb2JzID0ge307XG5cbiAgLyoqXG4gICAqIFRoZSBhcnJheSBvZiBjdXJyZW50bHkgcnVubmluZyBqb2JzLCBzb3J0ZWQgYnkgcHJpb3JpdHkuXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheX1cbiAgICovXG4gIHZhciBfc29ydGVkQnlQcmlvcml0eUpvYnMgPSBbXTtcblxuICAvKipcbiAgICogVGhlIGFycmF5IG9mIGN1cnJlbnRseSB3YWl0aW5nIGpvYnMuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB2YXIgX3dhaXRpbmdKb2JzID0ge307XG5cbiAgLyoqXG4gICAqIFRoZSBhcnJheSBvZiBmaW5pc2hlZCBqb2JzLiBUaGV5IGFyZSBzdG9yZWQgaW4gYW4gYXJyYXksIHNpbmNlIHR3byBqb2JzXG4gICAqIHdpdGggdGhlIHNhbWUgXCJpZFwiIGNhbiBoYXBwZW4gYXQgdHdvIGRpZmZlcmVudCB0aW1lcy5cbiAgICpcbiAgICogQHR5cGUge0FycmF5fVxuICAgKi9cbiAgdmFyIF9kb25lSm9icyA9IFtdO1xuXG4gIC8qKlxuICAgKiBBIGRpcnR5IGZsYWcgdG8ga2VlcCBjb25yYWQgZnJvbSBzdGFydGluZzogSW5kZWVkLCB3aGVuIGFkZEpvYigpIGlzIGNhbGxlZFxuICAgKiB3aXRoIHNldmVyYWwgam9icywgY29ucmFkIG11c3QgYmUgc3RhcnRlZCBvbmx5IGF0IHRoZSBlbmQuIFRoaXMgZmxhZyBrZWVwc1xuICAgKiBtZSBmcm9tIGR1cGxpY2F0aW5nIHRoZSBjb2RlIHRoYXQgZWZmZWN0aXZlbHkgYWRkcyBhIGpvYi5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICB2YXIgX25vU3RhcnQgPSBmYWxzZTtcblxuICAvKipcbiAgICogQW4gaGFzaCBjb250YWluaW5nIHNvbWUgZ2xvYmFsIHNldHRpbmdzIGFib3V0IGhvdyBjb25yYWQuanMgc2hvdWxkXG4gICAqIGJlaGF2ZS5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHZhciBfcGFyYW1ldGVycyA9IHtcbiAgICBmcmFtZUR1cmF0aW9uOiAyMCxcbiAgICBoaXN0b3J5OiB0cnVlXG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgb2JqZWN0IGNvbnRhaW5zIGV2ZXJ5IGhhbmRsZXJzIGJvdW5kIHRvIGNvbnJhZCBldmVudHMuIEl0IGRvZXMgbm90XG4gICAqIHJlcXVpcmVhIGFueSBET00gaW1wbGVtZW50YXRpb24sIHNpbmNlIHRoZSBldmVudHMgYXJlIGFsbCBKYXZhU2NyaXB0LlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgdmFyIF9oYW5kbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cblxuICAvKipcbiAgICogUFJJVkFURSBGVU5DVElPTlM6XG4gICAqICoqKioqKioqKioqKioqKioqKlxuICAgKi9cblxuICAvKipcbiAgICogV2lsbCBleGVjdXRlIHRoZSBoYW5kbGVyIGV2ZXJ5dGltZSB0aGF0IHRoZSBpbmRpY2F0ZWQgZXZlbnQgKG9yIHRoZVxuICAgKiBpbmRpY2F0ZWQgZXZlbnRzKSB3aWxsIGJlIHRyaWdnZXJlZC5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfGFycmF5fG9iamVjdH0gZXZlbnRzICBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgKG9yIHRoZSBldmVudHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0ZWQgYnkgc3BhY2VzKS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb24oT2JqZWN0KX0gICAgaGFuZGxlciBUaGUgaGFuZGxlciB0byBiaW5kLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgIFJldHVybnMgY29ucmFkLlxuICAgKi9cbiAgZnVuY3Rpb24gX2JpbmQoZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGlfZW5kLFxuICAgICAgICBldmVudCxcbiAgICAgICAgZUFycmF5O1xuXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuICAgIGVsc2UgaWYgKFxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgT2JqZWN0KGFyZ3VtZW50c1swXSkgPT09IGFyZ3VtZW50c1swXVxuICAgIClcbiAgICAgIGZvciAoZXZlbnRzIGluIGFyZ3VtZW50c1swXSlcbiAgICAgICAgX2JpbmQoZXZlbnRzLCBhcmd1bWVudHNbMF1bZXZlbnRzXSk7XG4gICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGVBcnJheSA9XG4gICAgICAgIEFycmF5LmlzQXJyYXkoZXZlbnRzKSA/XG4gICAgICAgICAgZXZlbnRzIDpcbiAgICAgICAgICBldmVudHMuc3BsaXQoLyAvKTtcblxuICAgICAgZm9yIChpID0gMCwgaV9lbmQgPSBlQXJyYXkubGVuZ3RoOyBpICE9PSBpX2VuZDsgaSArPSAxKSB7XG4gICAgICAgIGV2ZW50ID0gZUFycmF5W2ldO1xuXG4gICAgICAgIGlmICghX2hhbmRsZXJzW2V2ZW50XSlcbiAgICAgICAgICBfaGFuZGxlcnNbZXZlbnRdID0gW107XG5cbiAgICAgICAgLy8gVXNpbmcgYW4gb2JqZWN0IGluc3RlYWQgb2YgZGlyZWN0bHkgdGhlIGhhbmRsZXIgd2lsbCBtYWtlIHBvc3NpYmxlXG4gICAgICAgIC8vIGxhdGVyIHRvIGFkZCBmbGFnc1xuICAgICAgICBfaGFuZGxlcnNbZXZlbnRdLnB1c2goe1xuICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGhhbmRsZXIgZnJvbSBhIHNwZWNpZmllZCBldmVudCAob3Igc3BlY2lmaWVkIGV2ZW50cykuXG4gICAqXG4gICAqIEBwYXJhbSAgez9zdHJpbmd9ICAgICAgICAgICBldmVudHMgIFRoZSBuYW1lIG9mIHRoZSBldmVudCAob3IgdGhlIGV2ZW50c1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0ZWQgYnkgc3BhY2VzKS4gSWYgdW5kZWZpbmVkLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVuIGFsbCBoYW5kbGVycyBhcmUgcmVtb3ZlZC5cbiAgICogQHBhcmFtICB7P2Z1bmN0aW9uKE9iamVjdCl9IGhhbmRsZXIgVGhlIGhhbmRsZXIgdG8gdW5iaW5kLiBJZiB1bmRlZmluZWQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhY2ggaGFuZGxlciBib3VuZCB0byB0aGUgZXZlbnQgb3IgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cyB3aWxsIGJlIHJlbW92ZWQuXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICBSZXR1cm5zIGNvbnJhZC5cbiAgICovXG4gIGZ1bmN0aW9uIF91bmJpbmQoZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGlfZW5kLFxuICAgICAgICBqLFxuICAgICAgICBqX2VuZCxcbiAgICAgICAgYSxcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIGVBcnJheSA9IEFycmF5LmlzQXJyYXkoZXZlbnRzKSA/XG4gICAgICAgICAgICAgICAgICAgZXZlbnRzIDpcbiAgICAgICAgICAgICAgICAgICBldmVudHMuc3BsaXQoLyAvKTtcblxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgIF9oYW5kbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZWxzZSBpZiAoaGFuZGxlcikge1xuICAgICAgZm9yIChpID0gMCwgaV9lbmQgPSBlQXJyYXkubGVuZ3RoOyBpICE9PSBpX2VuZDsgaSArPSAxKSB7XG4gICAgICAgIGV2ZW50ID0gZUFycmF5W2ldO1xuICAgICAgICBpZiAoX2hhbmRsZXJzW2V2ZW50XSkge1xuICAgICAgICAgIGEgPSBbXTtcbiAgICAgICAgICBmb3IgKGogPSAwLCBqX2VuZCA9IF9oYW5kbGVyc1tldmVudF0ubGVuZ3RoOyBqICE9PSBqX2VuZDsgaiArPSAxKVxuICAgICAgICAgICAgaWYgKF9oYW5kbGVyc1tldmVudF1bal0uaGFuZGxlciAhPT0gaGFuZGxlcilcbiAgICAgICAgICAgICAgYS5wdXNoKF9oYW5kbGVyc1tldmVudF1bal0pO1xuXG4gICAgICAgICAgX2hhbmRsZXJzW2V2ZW50XSA9IGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2hhbmRsZXJzW2V2ZW50XSAmJiBfaGFuZGxlcnNbZXZlbnRdLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICBkZWxldGUgX2hhbmRsZXJzW2V2ZW50XTtcbiAgICAgIH1cbiAgICB9IGVsc2VcbiAgICAgIGZvciAoaSA9IDAsIGlfZW5kID0gZUFycmF5Lmxlbmd0aDsgaSAhPT0gaV9lbmQ7IGkgKz0gMSlcbiAgICAgICAgZGVsZXRlIF9oYW5kbGVyc1tlQXJyYXlbaV1dO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGVhY2ggaGFuZGxlciBib3VuZCB0byB0aGUgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gIGV2ZW50cyBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgKG9yIHRoZSBldmVudHMgc2VwYXJhdGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBieSBzcGFjZXMpLlxuICAgKiBAcGFyYW0gIHs/T2JqZWN0fSBkYXRhICAgVGhlIGNvbnRlbnQgb2YgdGhlIGV2ZW50IChvcHRpb25hbCkuXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICBSZXR1cm5zIGNvbnJhZC5cbiAgICovXG4gIGZ1bmN0aW9uIF9kaXNwYXRjaChldmVudHMsIGRhdGEpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgaixcbiAgICAgICAgaV9lbmQsXG4gICAgICAgIGpfZW5kLFxuICAgICAgICBldmVudCxcbiAgICAgICAgZXZlbnROYW1lLFxuICAgICAgICBlQXJyYXkgPSBBcnJheS5pc0FycmF5KGV2ZW50cykgP1xuICAgICAgICAgICAgICAgICAgIGV2ZW50cyA6XG4gICAgICAgICAgICAgICAgICAgZXZlbnRzLnNwbGl0KC8gLyk7XG5cbiAgICBkYXRhID0gZGF0YSA9PT0gdW5kZWZpbmVkID8ge30gOiBkYXRhO1xuXG4gICAgZm9yIChpID0gMCwgaV9lbmQgPSBlQXJyYXkubGVuZ3RoOyBpICE9PSBpX2VuZDsgaSArPSAxKSB7XG4gICAgICBldmVudE5hbWUgPSBlQXJyYXlbaV07XG5cbiAgICAgIGlmIChfaGFuZGxlcnNbZXZlbnROYW1lXSkge1xuICAgICAgICBldmVudCA9IHtcbiAgICAgICAgICB0eXBlOiBldmVudE5hbWUsXG4gICAgICAgICAgZGF0YTogZGF0YSB8fCB7fVxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAoaiA9IDAsIGpfZW5kID0gX2hhbmRsZXJzW2V2ZW50TmFtZV0ubGVuZ3RoOyBqICE9PSBqX2VuZDsgaiArPSAxKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBfaGFuZGxlcnNbZXZlbnROYW1lXVtqXS5oYW5kbGVyKGV2ZW50KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyB0aGUgbW9zdCBwcmlvcml0YXJ5IGpvYiBvbmNlLCBhbmQgZGVhbHMgd2l0aCBmaWxsaW5nIHRoZSBzdGF0c1xuICAgKiAoZG9uZSwgdGltZSwgYXZlcmFnZVRpbWUsIGN1cnJlbnRUaW1lLCBldGMuLi4pLlxuICAgKlxuICAgKiBAcmV0dXJuIHs/T2JqZWN0fSBSZXR1cm5zIHRoZSBqb2Igb2JqZWN0IGlmIGl0IGhhcyB0byBiZSBraWxsZWQsIG51bGwgZWxzZS5cbiAgICovXG4gIGZ1bmN0aW9uIF9leGVjdXRlRmlyc3RKb2IoKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIHRlc3QsXG4gICAgICAgIGtpbGwsXG4gICAgICAgIHB1c2hlZCA9IGZhbHNlLFxuICAgICAgICB0aW1lID0gX19kYXRlTm93KCksXG4gICAgICAgIGpvYiA9IF9zb3J0ZWRCeVByaW9yaXR5Sm9icy5zaGlmdCgpO1xuXG4gICAgLy8gRXhlY3V0ZSB0aGUgam9iIGFuZCBsb29rIGF0IHRoZSByZXN1bHQ6XG4gICAgdGVzdCA9IGpvYi5qb2IoKTtcblxuICAgIC8vIERlYWwgd2l0aCBzdGF0czpcbiAgICB0aW1lID0gX19kYXRlTm93KCkgLSB0aW1lO1xuICAgIGpvYi5kb25lKys7XG4gICAgam9iLnRpbWUgKz0gdGltZTtcbiAgICBqb2IuY3VycmVudFRpbWUgKz0gdGltZTtcbiAgICBqb2Iud2VpZ2h0VGltZSA9IGpvYi5jdXJyZW50VGltZSAvIChqb2Iud2VpZ2h0IHx8IDEpO1xuICAgIGpvYi5hdmVyYWdlVGltZSA9IGpvYi50aW1lIC8gam9iLmRvbmU7XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgam9iIGhhcyB0byBiZSBraWxsZWQ6XG4gICAga2lsbCA9IGpvYi5jb3VudCA/IChqb2IuY291bnQgPD0gam9iLmRvbmUpIDogIXRlc3Q7XG5cbiAgICAvLyBSZXNldCBwcmlvcml0aWVzOlxuICAgIGlmICgha2lsbCkge1xuICAgICAgZm9yIChpID0gMCwgbCA9IF9zb3J0ZWRCeVByaW9yaXR5Sm9icy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIGlmIChfc29ydGVkQnlQcmlvcml0eUpvYnNbaV0ud2VpZ2h0VGltZSA+IGpvYi53ZWlnaHRUaW1lKSB7XG4gICAgICAgICAgX3NvcnRlZEJ5UHJpb3JpdHlKb2JzLnNwbGljZShpLCAwLCBqb2IpO1xuICAgICAgICAgIHB1c2hlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgaWYgKCFwdXNoZWQpXG4gICAgICAgIF9zb3J0ZWRCeVByaW9yaXR5Sm9icy5wdXNoKGpvYik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtpbGwgPyBqb2IgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlcyBhIGpvYiwgYnkgYWRkaW5nIGl0IHRvIHRoZSBfcnVubmluZ0pvYnMgb2JqZWN0IGFuZCB0aGVcbiAgICogX3NvcnRlZEJ5UHJpb3JpdHlKb2JzIGFycmF5LiBJdCBhbHNvIGluaXRpYWxpemVzIGl0cyBjdXJyZW50VGltZSB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBqb2IgVGhlIGpvYiB0byBhY3RpdmF0ZS5cbiAgICovXG4gIGZ1bmN0aW9uIF9hY3RpdmF0ZUpvYihqb2IpIHtcbiAgICB2YXIgbCA9IF9zb3J0ZWRCeVByaW9yaXR5Sm9icy5sZW5ndGg7XG5cbiAgICAvLyBBZGQgdGhlIGpvYiB0byB0aGUgcnVubmluZyBqb2JzOlxuICAgIF9ydW5uaW5nSm9ic1tqb2IuaWRdID0gam9iO1xuICAgIGpvYi5zdGF0dXMgPSAncnVubmluZyc7XG5cbiAgICAvLyBBZGQgdGhlIGpvYiB0byB0aGUgcHJpb3JpdGllczpcbiAgICBpZiAobCkge1xuICAgICAgam9iLndlaWdodFRpbWUgPSBfc29ydGVkQnlQcmlvcml0eUpvYnNbbCAtIDFdLndlaWdodFRpbWU7XG4gICAgICBqb2IuY3VycmVudFRpbWUgPSBqb2Iud2VpZ2h0VGltZSAqIChqb2Iud2VpZ2h0IHx8IDEpO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgdGhlIGpvYiBhbmQgZGlzcGF0Y2g6XG4gICAgam9iLnN0YXJ0VGltZSA9IF9fZGF0ZU5vdygpO1xuICAgIF9kaXNwYXRjaCgnam9iU3RhcnRlZCcsIF9fY2xvbmUoam9iKSk7XG5cbiAgICBfc29ydGVkQnlQcmlvcml0eUpvYnMucHVzaChqb2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBtYWluIGxvb3Agb2YgY29ucmFkLmpzOlxuICAgKiAgLiBJdCBleGVjdXRlcyBqb2Igc3VjaCB0aGF0IHRoZXkgYWxsIG9jY3VwYXRlIHRoZSBzYW1lIHByb2Nlc3NpbmcgdGltZS5cbiAgICogIC4gSXQgc3RvcHMgam9icyB0aGF0IGRvIG5vdCBuZWVkIHRvIGJlIGV4ZWN1dGVkIGFueW1vcmUuXG4gICAqICAuIEl0IHRyaWdnZXJzIGNhbGxiYWNrcyB3aGVuIGl0IGlzIHJlbGV2YW50LlxuICAgKiAgLiBJdCBzdGFydHMgd2FpdGluZyBqb2JzIHdoZW4gdGhleSBuZWVkIHRvIGJlIHN0YXJ0ZWQuXG4gICAqICAuIEl0IGluamVjdHMgZnJhbWVzIHRvIGtlZXAgYSBjb25zdGFudCBmcmFwZXMgcGVyIHNlY29uZCByYXRpby5cbiAgICogIC4gSXQgc3RvcHMgaXRzZWxmIHdoZW4gdGhlcmUgYXJlIG5vIG1vcmUgam9icyB0byBleGVjdXRlLlxuICAgKi9cbiAgZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgdmFyIGssXG4gICAgICAgIG8sXG4gICAgICAgIGwsXG4gICAgICAgIGpvYixcbiAgICAgICAgdGltZSxcbiAgICAgICAgZGVhZEpvYjtcblxuICAgIC8vIERlYWwgd2l0aCB0aGUgbmV3bHkgYWRkZWQgam9icyAodGhlIF9qb2JzIG9iamVjdCk6XG4gICAgZm9yIChrIGluIF9qb2JzKSB7XG4gICAgICBqb2IgPSBfam9ic1trXTtcblxuICAgICAgaWYgKGpvYi5hZnRlcilcbiAgICAgICAgX3dhaXRpbmdKb2JzW2tdID0gam9iO1xuICAgICAgZWxzZVxuICAgICAgICBfYWN0aXZhdGVKb2Ioam9iKTtcblxuICAgICAgZGVsZXRlIF9qb2JzW2tdO1xuICAgIH1cblxuICAgIC8vIFNldCB0aGUgX2lzUnVubmluZyBmbGFnIHRvIGZhbHNlIGlmIHRoZXJlIGFyZSBubyBydW5uaW5nIGpvYjpcbiAgICBfaXNSdW5uaW5nID0gISFfc29ydGVkQnlQcmlvcml0eUpvYnMubGVuZ3RoO1xuXG4gICAgLy8gRGVhbCB3aXRoIHRoZSBydW5uaW5nIGpvYnMgKHRoZSBfcnVubmluZ0pvYnMgb2JqZWN0KTpcbiAgICB3aGlsZSAoXG4gICAgICBfc29ydGVkQnlQcmlvcml0eUpvYnMubGVuZ3RoICYmXG4gICAgICBfX2RhdGVOb3coKSAtIF9sYXN0RnJhbWVUaW1lIDwgX3BhcmFtZXRlcnMuZnJhbWVEdXJhdGlvblxuICAgICkge1xuICAgICAgZGVhZEpvYiA9IF9leGVjdXRlRmlyc3RKb2IoKTtcblxuICAgICAgLy8gRGVhbCB3aXRoIHRoZSBjYXNlIHdoZXJlIHRoZSBqb2IgaGFzIGVuZGVkOlxuICAgICAgaWYgKGRlYWRKb2IpIHtcbiAgICAgICAgX2tpbGxKb2IoZGVhZEpvYi5pZCk7XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIHdhaXRpbmcgam9iczpcbiAgICAgICAgZm9yIChrIGluIF93YWl0aW5nSm9icylcbiAgICAgICAgICBpZiAoX3dhaXRpbmdKb2JzW2tdLmFmdGVyID09PSBkZWFkSm9iLmlkKSB7XG4gICAgICAgICAgICBfYWN0aXZhdGVKb2IoX3dhaXRpbmdKb2JzW2tdKTtcbiAgICAgICAgICAgIGRlbGV0ZSBfd2FpdGluZ0pvYnNba107XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGNvbnJhZCBzdGlsbCBoYXMgam9icyB0byBkZWFsIHdpdGgsIGFuZCBraWxsIGl0IGlmIG5vdDpcbiAgICBpZiAoX2lzUnVubmluZykge1xuICAgICAgLy8gVXBkYXRlIHRoZSBfbGFzdEZyYW1lVGltZTpcbiAgICAgIF9sYXN0RnJhbWVUaW1lID0gX19kYXRlTm93KCk7XG5cbiAgICAgIF9kaXNwYXRjaCgnZW50ZXJGcmFtZScpO1xuICAgICAgc2V0VGltZW91dChfbG9vcCwgMCk7XG4gICAgfSBlbHNlXG4gICAgICBfZGlzcGF0Y2goJ3N0b3AnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIG9uZSBvciBtb3JlIGpvYnMsIGFuZCBzdGFydHMgdGhlIGxvb3AgaWYgbm8gam9iIHdhcyBydW5uaW5nIGJlZm9yZS4gQVxuICAgKiBqb2IgaXMgYXQgbGVhc3QgYSB1bmlxdWUgc3RyaW5nIFwiaWRcIiBhbmQgYSBmdW5jdGlvbiwgYW5kIHRoZXJlIGFyZSBzb21lXG4gICAqIHBhcmFtZXRlcnMgdGhhdCB5b3UgY2FuIHNwZWNpZnkgZm9yIGVhY2ggam9iIHRvIG1vZGlmeSB0aGUgd2F5IGNvbnJhZCB3aWxsXG4gICAqIGV4ZWN1dGUgaXQuIElmIGEgam9iIGlzIGFkZGVkIHdpdGggdGhlIFwiaWRcIiBvZiBhbm90aGVyIGpvYiB0aGF0IGlzIHdhaXRpbmdcbiAgICogb3Igc3RpbGwgcnVubmluZywgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gICAqXG4gICAqIFdoZW4gYSBqb2IgaXMgYWRkZWQsIGl0IGlzIHJlZmVyZW5jZWQgaW4gdGhlIF9qb2JzIG9iamVjdCwgYnkgaXRzIGlkLlxuICAgKiBUaGVuLCBpZiBpdCBoYXMgdG8gYmUgZXhlY3V0ZWQgcmlnaHQgbm93LCBpdCB3aWxsIGJlIGFsc28gcmVmZXJlbmNlZCBpblxuICAgKiB0aGUgX3J1bm5pbmdKb2JzIG9iamVjdC4gSWYgaXQgaGFzIHRvIHdhaXQsIHRoZW4gaXQgd2lsbCBiZSBhZGRlZCBpbnRvIHRoZVxuICAgKiBfd2FpdGluZ0pvYnMgb2JqZWN0LCB1bnRpbCBpdCBjYW4gc3RhcnQuXG4gICAqXG4gICAqIEtlZXAgcmVhZGluZyB0aGlzIGRvY3VtZW50YXRpb24gdG8gc2VlIGhvdyB0byBjYWxsIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgY29ucmFkLlxuICAgKlxuICAgKiBBZGRpbmcgb25lIGpvYjpcbiAgICogKioqKioqKioqKioqKioqXG4gICAqIEJhc2ljYWxseSwgYSBqb2IgaXMgZGVmaW5lZCBieSBpdHMgc3RyaW5nIGlkIGFuZCBhIGZ1bmN0aW9uICh0aGUgam9iKS4gSXRcbiAgICogaXMgYWxzbyBwb3NzaWJsZSB0byBhZGQgc29tZSBwYXJhbWV0ZXJzOlxuICAgKlxuICAgKiAgPiBjb25yYWQuYWRkSm9iKCdteUpvYklkJywgbXlKb2JGdW5jdGlvbik7XG4gICAqICA+IGNvbnJhZC5hZGRKb2IoJ215Sm9iSWQnLCB7XG4gICAqICA+ICAgam9iOiBteUpvYkZ1bmN0aW9uLFxuICAgKiAgPiAgIHNvbWVQYXJhbWV0ZXI6IHNvbWVWYWx1ZVxuICAgKiAgPiB9KTtcbiAgICogID4gY29ucmFkLmFkZEpvYih7XG4gICAqICA+ICAgaWQ6ICdteUpvYklkJyxcbiAgICogID4gICBqb2I6IG15Sm9iRnVuY3Rpb24sXG4gICAqICA+ICAgc29tZVBhcmFtZXRlcjogc29tZVZhbHVlXG4gICAqICA+IH0pO1xuICAgKlxuICAgKiBBZGRpbmcgc2V2ZXJhbCBqb2JzOlxuICAgKiAqKioqKioqKioqKioqKioqKioqKlxuICAgKiBXaGVuIGFkZGluZyBzZXZlcmFsIGpvYnMgYXQgdGhlIHNhbWUgdGltZSwgaXQgaXMgcG9zc2libGUgdG8gc3BlY2lmeVxuICAgKiBwYXJhbWV0ZXJzIGZvciBlYWNoIG9uZSBpbmRpdmlkdWFsbHkgb3IgZm9yIGFsbDpcbiAgICpcbiAgICogID4gY29ucmFkLmFkZEpvYihbXG4gICAqICA+ICAge1xuICAgKiAgPiAgICAgaWQ6ICdteUpvYklkMScsXG4gICAqICA+ICAgICBqb2I6IG15Sm9iRnVuY3Rpb24xLFxuICAgKiAgPiAgICAgc29tZVBhcmFtZXRlcjE6IHNvbWVWYWx1ZTFcbiAgICogID4gICB9LFxuICAgKiAgPiAgIHtcbiAgICogID4gICAgIGlkOiAnbXlKb2JJZDInLFxuICAgKiAgPiAgICAgam9iOiBteUpvYkZ1bmN0aW9uMixcbiAgICogID4gICAgIHNvbWVQYXJhbWV0ZXIyOiBzb21lVmFsdWUyXG4gICAqICA+ICAgfVxuICAgKiAgPiBdLCB7XG4gICAqICA+ICAgc29tZUNvbW1vblBhcmFtZXRlcjogc29tZUNvbW1vblZhbHVlXG4gICAqICA+IH0pO1xuICAgKiAgPiBjb25yYWQuYWRkSm9iKHtcbiAgICogID4gICBteUpvYklkMTogeyxcbiAgICogID4gICAgIGpvYjogbXlKb2JGdW5jdGlvbjEsXG4gICAqICA+ICAgICBzb21lUGFyYW1ldGVyMTogc29tZVZhbHVlMVxuICAgKiAgPiAgIH0sXG4gICAqICA+ICAgbXlKb2JJZDI6IHssXG4gICAqICA+ICAgICBqb2I6IG15Sm9iRnVuY3Rpb24yLFxuICAgKiAgPiAgICAgc29tZVBhcmFtZXRlcjI6IHNvbWVWYWx1ZTJcbiAgICogID4gICB9XG4gICAqICA+IH0sIHtcbiAgICogID4gICBzb21lQ29tbW9uUGFyYW1ldGVyOiBzb21lQ29tbW9uVmFsdWVcbiAgICogID4gfSk7XG4gICAqICA+IGNvbnJhZC5hZGRKb2Ioe1xuICAgKiAgPiAgIG15Sm9iSWQxOiBteUpvYkZ1bmN0aW9uMSxcbiAgICogID4gICBteUpvYklkMjogbXlKb2JGdW5jdGlvbjJcbiAgICogID4gfSwge1xuICAgKiAgPiAgIHNvbWVDb21tb25QYXJhbWV0ZXI6IHNvbWVDb21tb25WYWx1ZVxuICAgKiAgPiB9KTtcbiAgICpcbiAgICogIFJlY29nbml6ZWQgcGFyYW1ldGVyczpcbiAgICogICoqKioqKioqKioqKioqKioqKioqKipcbiAgICogIEhlcmUgaXMgdGhlIGV4aGF1c3RpdmUgbGlzdCBvZiBldmVyeSBhY2NlcHRlZCBwYXJhbWV0ZXJzOlxuICAgKlxuICAgKiAgICB7P0Z1bmN0aW9ufSBlbmQgICAgICBBIGNhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiB0aGUgam9iIGlzIGVuZGVkLiBJdCBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBub3QgZXhlY3V0ZWQgaWYgdGhlIGpvYiBpcyBraWxsZWQgaW5zdGVhZCBvZiBlbmRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBcIm5hdHVyYWxseVwiLlxuICAgKiAgICB7P0ludGVnZXJ9ICBjb3VudCAgICBUaGUgbnVtYmVyIG9mIHRpbWUgdGhlIGpvYiBoYXMgdG8gYmUgZXhlY3V0ZWQuXG4gICAqICAgIHs/TnVtYmVyfSAgIHdlaWdodCAgIElmIHNwZWNpZmllZCwgdGhlIGpvYiB3aWxsIGJlIGV4ZWN1dGVkIGFzIGl0IHdhc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBhZGRlZCBcIndlaWdodFwiIHRpbWVzLlxuICAgKiAgICB7P1N0cmluZ30gICBhZnRlciAgICBUaGUgaWQgb2YgYW5vdGhlciBqb2IgKGV2ZW50dWFsbHkgbm90IGFkZGVkIHlldCkuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIElmIHNwZWNpZmllZCwgdGhpcyBqb2Igd2lsbCBzdGFydCBvbmx5IHdoZW4gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpZmllZCBcImFmdGVyXCIgam9iIGlzIGVuZGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gX2FkZEpvYih2MSwgdjIpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgbztcblxuICAgIC8vIEFycmF5IG9mIGpvYnM6XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodjEpKSB7XG4gICAgICAvLyBLZWVwIGNvbnJhZCB0byBzdGFydCB1bnRpbCB0aGUgbGFzdCBqb2IgaXMgYWRkZWQ6XG4gICAgICBfbm9TdGFydCA9IHRydWU7XG5cbiAgICAgIGZvciAoaSA9IDAsIGwgPSB2MS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIF9hZGRKb2IodjFbaV0uaWQsIF9fZXh0ZW5kKHYxW2ldLCB2MikpO1xuXG4gICAgICBfbm9TdGFydCA9IGZhbHNlO1xuICAgICAgaWYgKCFfaXNSdW5uaW5nKSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgX2xhc3RGcmFtZVRpbWU6XG4gICAgICAgIF9sYXN0RnJhbWVUaW1lID0gX19kYXRlTm93KCk7XG5cbiAgICAgICAgX2Rpc3BhdGNoKCdzdGFydCcpO1xuICAgICAgICBfbG9vcCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYxID09PSAnb2JqZWN0Jykge1xuICAgICAgLy8gT25lIGpvYiAob2JqZWN0KTpcbiAgICAgIGlmICh0eXBlb2YgdjEuaWQgPT09ICdzdHJpbmcnKVxuICAgICAgICBfYWRkSm9iKHYxLmlkLCB2MSk7XG5cbiAgICAgIC8vIEhhc2ggb2Ygam9iczpcbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBLZWVwIGNvbnJhZCB0byBzdGFydCB1bnRpbCB0aGUgbGFzdCBqb2IgaXMgYWRkZWQ6XG4gICAgICAgIF9ub1N0YXJ0ID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKGkgaW4gdjEpXG4gICAgICAgICAgaWYgKHR5cGVvZiB2MVtpXSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIF9hZGRKb2IoaSwgX19leHRlbmQoe1xuICAgICAgICAgICAgICBqb2I6IHYxW2ldXG4gICAgICAgICAgICB9LCB2MikpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIF9hZGRKb2IoaSwgX19leHRlbmQodjFbaV0sIHYyKSk7XG5cbiAgICAgICAgX25vU3RhcnQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFfaXNSdW5uaW5nKSB7XG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSBfbGFzdEZyYW1lVGltZTpcbiAgICAgICAgICBfbGFzdEZyYW1lVGltZSA9IF9fZGF0ZU5vdygpO1xuXG4gICAgICAgICAgX2Rpc3BhdGNoKCdzdGFydCcpO1xuICAgICAgICAgIF9sb29wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIC8vIE9uZSBqb2IgKHN0cmluZywgKik6XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdjEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoX2hhc0pvYih2MSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnW2NvbnJhZC5hZGRKb2JdIEpvYiB3aXRoIGlkIFwiJyArIHYxICsgJ1wiIGFscmVhZHkgZXhpc3RzLidcbiAgICAgICAgKTtcblxuICAgICAgLy8gT25lIGpvYiAoc3RyaW5nLCBmdW5jdGlvbik6XG4gICAgICBpZiAodHlwZW9mIHYyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG8gPSB7XG4gICAgICAgICAgaWQ6IHYxLFxuICAgICAgICAgIGRvbmU6IDAsXG4gICAgICAgICAgdGltZTogMCxcbiAgICAgICAgICBzdGF0dXM6ICd3YWl0aW5nJyxcbiAgICAgICAgICBjdXJyZW50VGltZTogMCxcbiAgICAgICAgICBhdmVyYWdlVGltZTogMCxcbiAgICAgICAgICB3ZWlnaHRUaW1lOiAwLFxuICAgICAgICAgIGpvYjogdjJcbiAgICAgICAgfTtcblxuICAgICAgLy8gT25lIGpvYiAoc3RyaW5nLCBvYmplY3QpOlxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdjIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG8gPSBfX2V4dGVuZChcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZDogdjEsXG4gICAgICAgICAgICBkb25lOiAwLFxuICAgICAgICAgICAgdGltZTogMCxcbiAgICAgICAgICAgIHN0YXR1czogJ3dhaXRpbmcnLFxuICAgICAgICAgICAgY3VycmVudFRpbWU6IDAsXG4gICAgICAgICAgICBhdmVyYWdlVGltZTogMCxcbiAgICAgICAgICAgIHdlaWdodFRpbWU6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHYyXG4gICAgICAgICk7XG5cbiAgICAgIC8vIElmIG5vbmUgb2YgdGhvc2UgY2FzZXMsIHRocm93IGFuIGVycm9yOlxuICAgICAgfSBlbHNlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignW2NvbnJhZC5hZGRKb2JdIFdyb25nIGFyZ3VtZW50cy4nKTtcblxuICAgICAgLy8gRWZmZWN0aXZlbHkgYWRkIHRoZSBqb2I6XG4gICAgICBfam9ic1t2MV0gPSBvO1xuICAgICAgX2Rpc3BhdGNoKCdqb2JBZGRlZCcsIF9fY2xvbmUobykpO1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgbG9vcCBoYXMgdG8gYmUgc3RhcnRlZDpcbiAgICAgIGlmICghX2lzUnVubmluZyAmJiAhX25vU3RhcnQpIHtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBfbGFzdEZyYW1lVGltZTpcbiAgICAgICAgX2xhc3RGcmFtZVRpbWUgPSBfX2RhdGVOb3coKTtcblxuICAgICAgICBfZGlzcGF0Y2goJ3N0YXJ0Jyk7XG4gICAgICAgIF9sb29wKCk7XG4gICAgICB9XG5cbiAgICAvLyBJZiBub25lIG9mIHRob3NlIGNhc2VzLCB0aHJvdyBhbiBlcnJvcjpcbiAgICB9IGVsc2VcbiAgICAgIHRocm93IG5ldyBFcnJvcignW2NvbnJhZC5hZGRKb2JdIFdyb25nIGFyZ3VtZW50cy4nKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEtpbGxzIG9uZSBvciBtb3JlIGpvYnMsIGluZGljYXRlZCBieSB0aGVpciBpZHMuIEl0IGlzIG9ubHkgcG9zc2libGUgdG9cbiAgICoga2lsbCBydW5uaW5nIGpvYnMgb3Igd2FpdGluZyBqb2JzLiBJZiB5b3UgdHJ5IHRvIGtpbGwgYSBqb2IgdGhhdCBkb2VzIG5vdFxuICAgKiBleGlzdCBvciB0aGF0IGlzIGFscmVhZHkga2lsbGVkLCBhIHdhcm5pbmcgd2lsbCBiZSB0aHJvd24uXG4gICAqXG4gICAqIEBwYXJhbSAge0FycmF5fFN0cmluZ30gdjEgQSBzdHJpbmcgam9iIGlkIG9yIGFuIGFycmF5IG9mIGpvYiBpZHMuXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgUmV0dXJucyBjb25yYWQuXG4gICAqL1xuICBmdW5jdGlvbiBfa2lsbEpvYih2MSkge1xuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICBrLFxuICAgICAgICBhLFxuICAgICAgICBqb2IsXG4gICAgICAgIGZvdW5kID0gZmFsc2U7XG5cbiAgICAvLyBBcnJheSBvZiBqb2IgaWRzOlxuICAgIGlmIChBcnJheS5pc0FycmF5KHYxKSlcbiAgICAgIGZvciAoaSA9IDAsIGwgPSB2MS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIF9raWxsSm9iKHYxW2ldKTtcblxuICAgIC8vIE9uZSBqb2IncyBpZDpcbiAgICBlbHNlIGlmICh0eXBlb2YgdjEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBhID0gW19ydW5uaW5nSm9icywgX3dhaXRpbmdKb2JzLCBfam9ic107XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgam9iIGZyb20gdGhlIGhhc2hlczpcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgaWYgKHYxIGluIGFbaV0pIHtcbiAgICAgICAgICBqb2IgPSBhW2ldW3YxXTtcblxuICAgICAgICAgIGlmIChfcGFyYW1ldGVycy5oaXN0b3J5KSB7XG4gICAgICAgICAgICBqb2Iuc3RhdHVzID0gJ2RvbmUnO1xuICAgICAgICAgICAgX2RvbmVKb2JzLnB1c2goam9iKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfZGlzcGF0Y2goJ2pvYkVuZGVkJywgX19jbG9uZShqb2IpKTtcbiAgICAgICAgICBkZWxldGUgYVtpXVt2MV07XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGpvYi5lbmQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBqb2IuZW5kKCk7XG5cbiAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHRoZSBwcmlvcml0aWVzIGFycmF5OlxuICAgICAgYSA9IF9zb3J0ZWRCeVByaW9yaXR5Sm9icztcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgaWYgKGFbaV0uaWQgPT09IHYxKSB7XG4gICAgICAgICAgYS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbY29ucmFkLmtpbGxKb2JdIEpvYiBcIicgKyB2MSArICdcIiBub3QgZm91bmQuJyk7XG5cbiAgICAvLyBJZiBub25lIG9mIHRob3NlIGNhc2VzLCB0aHJvdyBhbiBlcnJvcjpcbiAgICB9IGVsc2VcbiAgICAgIHRocm93IG5ldyBFcnJvcignW2NvbnJhZC5raWxsSm9iXSBXcm9uZyBhcmd1bWVudHMuJyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBLaWxscyBldmVyeSBydW5uaW5nLCB3YWl0aW5nLCBhbmQganVzdCBhZGRlZCBqb2JzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgY29ucmFkLlxuICAgKi9cbiAgZnVuY3Rpb24gX2tpbGxBbGwoKSB7XG4gICAgdmFyIGssXG4gICAgICAgIGpvYnMgPSBfX2V4dGVuZChfam9icywgX3J1bm5pbmdKb2JzLCBfd2FpdGluZ0pvYnMpO1xuXG4gICAgLy8gVGFrZSBldmVyeSBqb2JzIGFuZCBwdXNoIHRoZW0gaW50byB0aGUgX2RvbmVKb2JzIG9iamVjdDpcbiAgICBpZiAoX3BhcmFtZXRlcnMuaGlzdG9yeSlcbiAgICAgIGZvciAoayBpbiBqb2JzKSB7XG4gICAgICAgIGpvYnNba10uc3RhdHVzID0gJ2RvbmUnO1xuICAgICAgICBfZG9uZUpvYnMucHVzaChqb2JzW2tdKTtcblxuICAgICAgICBpZiAodHlwZW9mIGpvYnNba10uZW5kID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgIGpvYnNba10uZW5kKCk7XG4gICAgICB9XG5cbiAgICAvLyBSZWluaXRpYWxpemUgdGhlIGRpZmZlcmVudCBqb2JzIGxpc3RzOlxuICAgIF9qb2JzID0ge307XG4gICAgX3dhaXRpbmdKb2JzID0ge307XG4gICAgX3J1bm5pbmdKb2JzID0ge307XG4gICAgX3NvcnRlZEJ5UHJpb3JpdHlKb2JzID0gW107XG5cbiAgICAvLyBJbiBjYXNlIHNvbWUgam9icyBhcmUgYWRkZWQgcmlnaHQgYWZ0ZXIgdGhlIGtpbGw6XG4gICAgX2lzUnVubmluZyA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGEgam9iIHdpdGggdGhlIHNwZWNpZmllZCBpZCBpcyBjdXJyZW50bHkgcnVubmluZyBvclxuICAgKiB3YWl0aW5nLCBhbmQgZmFsc2UgZWxzZS5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgaWQgVGhlIGlkIG9mIHRoZSBqb2IuXG4gICAqIEByZXR1cm4gez9PYmplY3R9IFJldHVybnMgdGhlIGpvYiBvYmplY3QgaWYgaXQgZXhpc3RzLlxuICAgKi9cbiAgZnVuY3Rpb24gX2hhc0pvYihpZCkge1xuICAgIHZhciBqb2IgPSBfam9ic1tpZF0gfHwgX3J1bm5pbmdKb2JzW2lkXSB8fCBfd2FpdGluZ0pvYnNbaWRdO1xuICAgIHJldHVybiBqb2IgPyBfX2V4dGVuZChqb2IpIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIHNldCB0aGUgc2V0dGluZyBzcGVjaWZpZWQgYnkgXCJ2MVwiIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcbiAgICogYnkgXCJ2MlwiIGlmIGJvdGggYXJlIGdpdmVuLCBhbmQgZWxzZSByZXR1cm4gdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlXG4gICAqIHNldHRpbmdzIFwidjFcIi5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgIHYxIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS5cbiAgICogQHBhcmFtICB7Pyp9ICAgICAgIHYyIEV2ZW50dWFsbHksIGEgdmFsdWUgdG8gc2V0IHRvIHRoZSBzcGVjaWZpZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5LlxuICAgKiBAcmV0dXJuIHtPYmplY3R8Kn0gUmV0dXJucyB0aGUgc3BlY2lmaWVkIHNldHRpbmdzIHZhbHVlIGlmIFwidjJcIiBpcyBub3RcbiAgICogICAgICAgICAgICAgICAgICAgIGdpdmVuLCBhbmQgY29ucmFkIGVsc2UuXG4gICAqL1xuICBmdW5jdGlvbiBfc2V0dGluZ3ModjEsIHYyKSB7XG4gICAgdmFyIG87XG5cbiAgICBpZiAodHlwZW9mIGExID09PSAnc3RyaW5nJyAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAxKVxuICAgICAgcmV0dXJuIF9wYXJhbWV0ZXJzW2ExXTtcbiAgICBlbHNlIHtcbiAgICAgIG8gPSAodHlwZW9mIGExID09PSAnb2JqZWN0JyAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAxKSA/XG4gICAgICAgIGExIHx8IHt9IDpcbiAgICAgICAge307XG4gICAgICBpZiAodHlwZW9mIGExID09PSAnc3RyaW5nJylcbiAgICAgICAgb1thMV0gPSBhMjtcblxuICAgICAgZm9yICh2YXIgayBpbiBvKVxuICAgICAgICBpZiAob1trXSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIF9wYXJhbWV0ZXJzW2tdID0gb1trXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGRlbGV0ZSBfcGFyYW1ldGVyc1trXTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBjb25yYWQgaXMgY3VycmVudGx5IHJ1bm5pbmcsIGFuZCBmYWxzZSBlbHNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIF9pc1J1bm5pbmcuXG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0SXNSdW5uaW5nKCkge1xuICAgIHJldHVybiBfaXNSdW5uaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucmVmZXJlbmNlIGV2ZXJ5IGpvYiB0aGF0IGlzIHN0b3JlZCBpbiB0aGUgX2RvbmVKb2JzIG9iamVjdC4gSXQgd2lsbFxuICAgKiBub3QgYmUgcG9zc2libGUgYW55bW9yZSB0byBnZXQgc3RhdHMgYWJvdXQgdGhlc2Ugam9icywgYnV0IGl0IHdpbGwgcmVsZWFzZVxuICAgKiB0aGUgbWVtb3J5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgY29ucmFkLlxuICAgKi9cbiAgZnVuY3Rpb24gX2NsZWFySGlzdG9yeSgpIHtcbiAgICBfZG9uZUpvYnMgPSBbXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc25hcHNob3Qgb2YgZXZlcnkgZGF0YSBhYm91dCBqb2JzIHRoYXQgd2FpdCB0byBiZSBzdGFydGVkLCBhcmVcbiAgICogY3VycmVudGx5IHJ1bm5pbmcgb3IgYXJlIGRvbmUuXG4gICAqXG4gICAqIEl0IGlzIHBvc3NpYmxlIHRvIGdldCBvbmx5IHJ1bm5pbmcsIHdhaXRpbmcgb3IgZG9uZSBqb2JzIGJ5IGdpdmluZ1xuICAgKiBcInJ1bm5pbmdcIiwgXCJ3YWl0aW5nXCIgb3IgXCJkb25lXCIgYXMgZmlzdCBhcmd1bWVudC5cbiAgICpcbiAgICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byBnZXQgZXZlcnkgam9iIHdpdGggYSBzcGVjaWZpZWQgaWQgYnkgZ2l2aW5nIGl0IGFzXG4gICAqIGZpcnN0IGFyZ3VtZW50LiBBbHNvLCB1c2luZyBhIFJlZ0V4cCBpbnN0ZWFkIG9mIGFuIGlkIHdpbGwgcmV0dXJuIGV2ZXJ5XG4gICAqIGpvYnMgd2hvc2UgaWRzIG1hdGNoIHRoZSBSZWdFeHAuIEFuZCB0aGVzZSB0d28gbGFzdCB1c2UgY2FzZXMgd29yayBhcyB3ZWxsXG4gICAqIGJ5IGdpdmluZyBiZWZvcmUgXCJydW5uaW5nXCIsIFwid2FpdGluZ1wiIG9yIFwiZG9uZVwiLlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGFycmF5IG9mIHRoZSBtYXRjaGluZyBqb2JzLlxuICAgKlxuICAgKiBTb21lIGNhbGwgZXhhbXBsZXM6XG4gICAqICoqKioqKioqKioqKioqKioqKipcbiAgICogID4gY29ucmFkLmdldFN0YXRzKCdydW5uaW5nJylcbiAgICogID4gY29ucmFkLmdldFN0YXRzKCd3YWl0aW5nJylcbiAgICogID4gY29ucmFkLmdldFN0YXRzKCdkb25lJylcbiAgICogID4gY29ucmFkLmdldFN0YXRzKCdteUpvYicpXG4gICAqICA+IGNvbnJhZC5nZXRTdGF0cygvdGVzdC8pXG4gICAqICA+IGNvbnJhZC5nZXRTdGF0cygncnVubmluZycsICdteVJ1bm5pbmdKb2InKVxuICAgKiAgPiBjb25yYWQuZ2V0U3RhdHMoJ3J1bm5pbmcnLCAvdGVzdC8pXG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0U3RhdHModjEsIHYyKSB7XG4gICAgdmFyIGEsXG4gICAgICAgIGssXG4gICAgICAgIGksXG4gICAgICAgIGwsXG4gICAgICAgIHN0YXRzLFxuICAgICAgICBwYXR0ZXJuLFxuICAgICAgICBpc1BhdHRlcm5TdHJpbmc7XG5cbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHN0YXRzID0gW107XG5cbiAgICAgIGZvciAoayBpbiBfam9icylcbiAgICAgICAgc3RhdHMucHVzaChfam9ic1trXSk7XG5cbiAgICAgIGZvciAoayBpbiBfd2FpdGluZ0pvYnMpXG4gICAgICAgIHN0YXRzLnB1c2goX3dhaXRpbmdKb2JzW2tdKTtcblxuICAgICAgZm9yIChrIGluIF9ydW5uaW5nSm9icylcbiAgICAgICAgc3RhdHMucHVzaChfcnVubmluZ0pvYnNba10pO1xuXG4gICAgICBzdGF0cyA9IHN0YXRzLmNvbmNhdChfZG9uZUpvYnMpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdjEgPT09ICdzdHJpbmcnKVxuICAgICAgc3dpdGNoICh2MSkge1xuICAgICAgICBjYXNlICd3YWl0aW5nJzpcbiAgICAgICAgICBzdGF0cyA9IF9fb2JqZWN0VmFsdWVzKF93YWl0aW5nSm9icyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3J1bm5pbmcnOlxuICAgICAgICAgIHN0YXRzID0gX19vYmplY3RWYWx1ZXMoX3J1bm5pbmdKb2JzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZG9uZSc6XG4gICAgICAgICAgc3RhdHMgPSBfZG9uZUpvYnM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcGF0dGVybiA9IHYxO1xuICAgICAgfVxuXG4gICAgaWYgKHYxIGluc3RhbmNlb2YgUmVnRXhwKVxuICAgICAgcGF0dGVybiA9IHYxO1xuXG4gICAgaWYgKCFwYXR0ZXJuICYmICh0eXBlb2YgdjIgPT09ICdzdHJpbmcnIHx8IHYyIGluc3RhbmNlb2YgUmVnRXhwKSlcbiAgICAgIHBhdHRlcm4gPSB2MjtcblxuICAgIC8vIEZpbHRlciBqb2JzIGlmIGEgcGF0dGVybiBpcyBnaXZlbjpcbiAgICBpZiAocGF0dGVybikge1xuICAgICAgaXNQYXR0ZXJuU3RyaW5nID0gdHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnO1xuXG4gICAgICBpZiAoc3RhdHMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBhID0gc3RhdHM7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdGF0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYSA9IFtdO1xuXG4gICAgICAgIGZvciAoayBpbiBzdGF0cylcbiAgICAgICAgICBhID0gYS5jb25jYXQoc3RhdHNba10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYSA9IFtdO1xuXG4gICAgICAgIGZvciAoayBpbiBfam9icylcbiAgICAgICAgICBhLnB1c2goX2pvYnNba10pO1xuXG4gICAgICAgIGZvciAoayBpbiBfd2FpdGluZ0pvYnMpXG4gICAgICAgICAgYS5wdXNoKF93YWl0aW5nSm9ic1trXSk7XG5cbiAgICAgICAgZm9yIChrIGluIF9ydW5uaW5nSm9icylcbiAgICAgICAgICBhLnB1c2goX3J1bm5pbmdKb2JzW2tdKTtcblxuICAgICAgICBhID0gYS5jb25jYXQoX2RvbmVKb2JzKTtcbiAgICAgIH1cblxuICAgICAgc3RhdHMgPSBbXTtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgaWYgKGlzUGF0dGVyblN0cmluZyA/IGFbaV0uaWQgPT09IHBhdHRlcm4gOiBhW2ldLmlkLm1hdGNoKHBhdHRlcm4pKVxuICAgICAgICAgIHN0YXRzLnB1c2goYVtpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9fY2xvbmUoc3RhdHMpO1xuICB9XG5cblxuICAvKipcbiAgICogVE9PTFMgRlVOQ1RJT05TOlxuICAgKiAqKioqKioqKioqKioqKioqXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGFueSBudW1iZXIgb2Ygb2JqZWN0cyBhcyBhcmd1bWVudHMsIGNvcGllcyBmcm9tIGVhY2hcbiAgICogb2YgdGhlc2Ugb2JqZWN0cyBlYWNoIHBhaXIga2V5L3ZhbHVlIGludG8gYSBuZXcgb2JqZWN0LCBhbmQgZmluYWxseVxuICAgKiByZXR1cm5zIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBUaGUgYXJndW1lbnRzIGFyZSBwYXJzZWQgZnJvbSB0aGUgbGFzdCBvbmUgdG8gdGhlIGZpcnN0IG9uZSwgc3VjaCB0aGF0XG4gICAqIHdoZW4gdHdvIG9iamVjdHMgaGF2ZSBrZXlzIGluIGNvbW1vbiwgdGhlIFwiZWFybGllc3RcIiBvYmplY3Qgd2lucy5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICogKioqKioqKipcbiAgICogID4gdmFyIG8xID0ge1xuICAgKiAgPiAgICAgICBhOiAxLFxuICAgKiAgPiAgICAgICBiOiAyLFxuICAgKiAgPiAgICAgICBjOiAnMydcbiAgICogID4gICAgIH0sXG4gICAqICA+ICAgICBvMiA9IHtcbiAgICogID4gICAgICAgYzogJzQnLFxuICAgKiAgPiAgICAgICBkOiBbIDUgXVxuICAgKiAgPiAgICAgfTtcbiAgICogID4gX19leHRlbmQobzEsIG8yKTtcbiAgICogID4gLy8gUmV0dXJuczoge1xuICAgKiAgPiAvLyAgIGE6IDEsXG4gICAqICA+IC8vICAgYjogMixcbiAgICogID4gLy8gICBjOiAnMycsXG4gICAqICA+IC8vICAgZDogWyA1IF1cbiAgICogID4gLy8gfTtcbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0K30gQW55IG51bWJlciBvZiBvYmplY3RzLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICBUaGUgbWVyZ2VkIG9iamVjdC5cbiAgICovXG4gIGZ1bmN0aW9uIF9fZXh0ZW5kKCkge1xuICAgIHZhciBpLFxuICAgICAgICBrLFxuICAgICAgICByZXMgPSB7fSxcbiAgICAgICAgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSBsIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICBmb3IgKGsgaW4gYXJndW1lbnRzW2ldKVxuICAgICAgICByZXNba10gPSBhcmd1bWVudHNbaV1ba107XG5cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gc2ltcGx5IGNsb25lcyBhbiBvYmplY3QuIFRoaXMgb2JqZWN0IG11c3QgY29udGFpbiBvbmx5XG4gICAqIG9iamVjdHMsIGFycmF5cyBhbmQgaW1tdXRhYmxlIHZhbHVlcy4gU2luY2UgaXQgaXMgbm90IHB1YmxpYywgaXQgZG9lcyBub3RcbiAgICogZGVhbCB3aXRoIGN5Y2xpYyByZWZlcmVuY2VzLCBET00gZWxlbWVudHMgYW5kIGluc3RhbnRpYXRlZCBvYmplY3RzIC0gc29cbiAgICogdXNlIGl0IGNhcmVmdWxseS5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbG9uZS5cbiAgICovXG4gIGZ1bmN0aW9uIF9fY2xvbmUoaXRlbSkge1xuICAgIHZhciByZXN1bHQsIGksIGssIGw7XG5cbiAgICBpZiAoIWl0ZW0pXG4gICAgICByZXR1cm4gaXRlbTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBpdGVtLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgcmVzdWx0LnB1c2goX19jbG9uZShpdGVtW2ldKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgZm9yIChpIGluIGl0ZW0pXG4gICAgICAgIHJlc3VsdFtpXSA9IF9fY2xvbmUoaXRlbVtpXSk7XG4gICAgfSBlbHNlXG4gICAgICByZXN1bHQgPSBpdGVtO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHZhbHVlcyBvZiBhbiBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gVGhlIG9iamVjdC5cbiAgICogQHJldHVybiB7QXJyYXl9ICBUaGUgYXJyYXkgb2YgdmFsdWVzLlxuICAgKi9cbiAgZnVuY3Rpb24gX19vYmplY3RWYWx1ZXMobykge1xuICAgIHZhciBrLFxuICAgICAgICBhID0gW107XG5cbiAgICBmb3IgKGsgaW4gbylcbiAgICAgIGEucHVzaChvW2tdKTtcblxuICAgIHJldHVybiBhO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc2hvcnQgXCJEYXRlLm5vdygpXCIgcG9seWZpbGwuXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGN1cnJlbnQgdGltZSAoaW4gbXMpLlxuICAgKi9cbiAgZnVuY3Rpb24gX19kYXRlTm93KCkge1xuICAgIHJldHVybiBEYXRlLm5vdyA/IERhdGUubm93KCkgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQb2x5ZmlsbCBmb3IgdGhlIEFycmF5LmlzQXJyYXkgZnVuY3Rpb246XG4gICAqL1xuICBpZiAoIUFycmF5LmlzQXJyYXkpXG4gICAgQXJyYXkuaXNBcnJheSA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfTtcblxuXG4gIC8qKlxuICAgKiBFWFBPUlQgUFVCTElDIEFQSTpcbiAgICogKioqKioqKioqKioqKioqKioqXG4gICAqL1xuICB2YXIgY29ucmFkID0ge1xuICAgIGhhc0pvYjogX2hhc0pvYixcbiAgICBhZGRKb2I6IF9hZGRKb2IsXG4gICAga2lsbEpvYjogX2tpbGxKb2IsXG4gICAga2lsbEFsbDogX2tpbGxBbGwsXG4gICAgc2V0dGluZ3M6IF9zZXR0aW5ncyxcbiAgICBnZXRTdGF0czogX2dldFN0YXRzLFxuICAgIGlzUnVubmluZzogX2dldElzUnVubmluZyxcbiAgICBjbGVhckhpc3Rvcnk6IF9jbGVhckhpc3RvcnksXG5cbiAgICAvLyBFdmVudHMgbWFuYWdlbWVudDpcbiAgICBiaW5kOiBfYmluZCxcbiAgICB1bmJpbmQ6IF91bmJpbmQsXG5cbiAgICAvLyBWZXJzaW9uOlxuICAgIHZlcnNpb246ICcwLjEuMCdcbiAgfTtcblxuICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKVxuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY29ucmFkO1xuICAgIGV4cG9ydHMuY29ucmFkID0gY29ucmFkO1xuICB9XG4gIGdsb2JhbC5jb25yYWQgPSBjb25yYWQ7XG59KSh0aGlzKTtcblxuLy8gSGFyZGNvZGVkIGV4cG9ydCBmb3IgdGhlIG5vZGUuanMgdmVyc2lvbjpcbnZhciBzaWdtYSA9IHRoaXMuc2lnbWEsXG4gICAgY29ucmFkID0gdGhpcy5jb25yYWQ7XG5cbnNpZ21hLmNvbnJhZCA9IGNvbnJhZDtcblxuLy8gRGlydHkgcG9seWZpbGxzIHRvIHBlcm1pdCBzaWdtYSB1c2FnZSBpbiBub2RlXG5pZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSAndW5kZWZpbmVkJylcbiAgSFRNTEVsZW1lbnQgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpXG4gIHdpbmRvdyA9IHtcbiAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbigpIHt9XG4gIH07XG5cbmlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKVxuICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHNpZ21hO1xuICBleHBvcnRzLnNpZ21hID0gc2lnbWE7XG59XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICB2YXIgX3Jvb3QgPSB0aGlzO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzID0gc2lnbWEudXRpbHMgfHwge307XG5cbiAgLyoqXG4gICAqIE1JU0MgVVRJTFM6XG4gICAqL1xuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiB0YWtlcyBhbnkgbnVtYmVyIG9mIG9iamVjdHMgYXMgYXJndW1lbnRzLCBjb3BpZXMgZnJvbSBlYWNoXG4gICAqIG9mIHRoZXNlIG9iamVjdHMgZWFjaCBwYWlyIGtleS92YWx1ZSBpbnRvIGEgbmV3IG9iamVjdCwgYW5kIGZpbmFsbHlcbiAgICogcmV0dXJucyB0aGlzIG9iamVjdC5cbiAgICpcbiAgICogVGhlIGFyZ3VtZW50cyBhcmUgcGFyc2VkIGZyb20gdGhlIGxhc3Qgb25lIHRvIHRoZSBmaXJzdCBvbmUsIHN1Y2ggdGhhdFxuICAgKiB3aGVuIHNldmVyYWwgb2JqZWN0cyBoYXZlIGtleXMgaW4gY29tbW9uLCB0aGUgXCJlYXJsaWVzdFwiIG9iamVjdCB3aW5zLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKiAqKioqKioqKlxuICAgKiAgPiB2YXIgbzEgPSB7XG4gICAqICA+ICAgICAgIGE6IDEsXG4gICAqICA+ICAgICAgIGI6IDIsXG4gICAqICA+ICAgICAgIGM6ICczJ1xuICAgKiAgPiAgICAgfSxcbiAgICogID4gICAgIG8yID0ge1xuICAgKiAgPiAgICAgICBjOiAnNCcsXG4gICAqICA+ICAgICAgIGQ6IFsgNSBdXG4gICAqICA+ICAgICB9O1xuICAgKiAgPiBzaWdtYS51dGlscy5leHRlbmQobzEsIG8yKTtcbiAgICogID4gLy8gUmV0dXJuczoge1xuICAgKiAgPiAvLyAgIGE6IDEsXG4gICAqICA+IC8vICAgYjogMixcbiAgICogID4gLy8gICBjOiAnMycsXG4gICAqICA+IC8vICAgZDogWyA1IF1cbiAgICogID4gLy8gfTtcbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0K30gQW55IG51bWJlciBvZiBvYmplY3RzLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICBUaGUgbWVyZ2VkIG9iamVjdC5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpLFxuICAgICAgICBrLFxuICAgICAgICByZXMgPSB7fSxcbiAgICAgICAgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSBsIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICBmb3IgKGsgaW4gYXJndW1lbnRzW2ldKVxuICAgICAgICByZXNba10gPSBhcmd1bWVudHNbaV1ba107XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIHNob3J0IFwiRGF0ZS5ub3coKVwiIHBvbHlmaWxsLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBjdXJyZW50IHRpbWUgKGluIG1zKS5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmRhdGVOb3cgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3cgPyBEYXRlLm5vdygpIDogbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRha2VzIGEgcGFja2FnZSBuYW1lIGFzIHBhcmFtZXRlciBhbmQgY2hlY2tzIGF0IGVhY2ggbGViZWwgaWYgaXQgZXhpc3RzLFxuICAgKiBhbmQgaWYgaXQgZG9lcyBub3QsIGNyZWF0ZXMgaXQuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqICoqKioqKioqXG4gICAqICA+IHNpZ21hLnV0aWxzLnBrZygnYS5iLmMnKTtcbiAgICogID4gYS5iLmM7XG4gICAqICA+IC8vIE9iamVjdCB7fTtcbiAgICogID5cbiAgICogID4gc2lnbWEudXRpbHMucGtnKCdhLmIuZCcpO1xuICAgKiAgPiBhLmI7XG4gICAqICA+IC8vIE9iamVjdCB7IGM6IHt9LCBkOiB7fSB9O1xuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHBrZ05hbWUgVGhlIG5hbWUgb2YgdGhlIHBhY2thZ2UgdG8gY3JlYXRlL2ZpbmQuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICBUaGUgcmVsYXRlZCBwYWNrYWdlLlxuICAgKi9cbiAgc2lnbWEudXRpbHMucGtnID0gZnVuY3Rpb24ocGtnTmFtZSkge1xuICAgIHJldHVybiAocGtnTmFtZSB8fCAnJykuc3BsaXQoJy4nKS5yZWR1Y2UoZnVuY3Rpb24oY29udGV4dCwgb2JqTmFtZSkge1xuICAgICAgcmV0dXJuIChvYmpOYW1lIGluIGNvbnRleHQpID9cbiAgICAgICAgY29udGV4dFtvYmpOYW1lXSA6XG4gICAgICAgIChjb250ZXh0W29iak5hbWVdID0ge30pO1xuICAgIH0sIF9yb290KTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIHVuaXF1ZSBpbmNyZW1lbnRhbCBudW1iZXIgSUQuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqICoqKioqKioqXG4gICAqICA+IHNpZ21hLnV0aWxzLmlkKCk7XG4gICAqICA+IC8vIDE7XG4gICAqICA+XG4gICAqICA+IHNpZ21hLnV0aWxzLmlkKCk7XG4gICAqICA+IC8vIDI7XG4gICAqICA+XG4gICAqICA+IHNpZ21hLnV0aWxzLmlkKCk7XG4gICAqICA+IC8vIDM7XG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gcGtnTmFtZSBUaGUgbmFtZSBvZiB0aGUgcGFja2FnZSB0byBjcmVhdGUvZmluZC5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgIFRoZSByZWxhdGVkIHBhY2thZ2UuXG4gICAqL1xuICBzaWdtYS51dGlscy5pZCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICsraTtcbiAgICB9O1xuICB9KSgpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGFuIGhleGEgY29sb3IgKGZvciBpbnN0YW5jZSBcIiNmZmNjMDBcIiBvciBcIiNmYzBcIikgb3IgYVxuICAgKiByZ2IgLyByZ2JhIGNvbG9yIChsaWtlIFwicmdiKDI1NSwyNTUsMTIpXCIgb3IgXCJyZ2JhKDI1NSwyNTUsMTIsMSlcIikgYW5kXG4gICAqIHJldHVybnMgYW4gaW50ZWdlciBlcXVhbCB0byBcInIgKiAyNTUgKiAyNTUgKyBnICogMjU1ICsgYlwiLCB0byBnYWluIHNvbWVcbiAgICogbWVtb3J5IGluIHRoZSBkYXRhIGdpdmVuIHRvIFdlYkdMIHNoYWRlcnMuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgZnVuY3Rpb24gYWN0dWFsbHkgY2FjaGVzIGl0cyByZXN1bHRzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gdmFsIFRoZSBoZXhhIG9yIHJnYmEgY29sb3IuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgIFRoZSBudW1iZXIgdmFsdWUuXG4gICAqL1xuICB2YXIgZmxvYXRDb2xvckNhY2hlID0ge307XG5cbiAgc2lnbWEudXRpbHMuZmxvYXRDb2xvciA9IGZ1bmN0aW9uKHZhbCkge1xuXG4gICAgLy8gSXMgdGhlIGNvbG9yIGFscmVhZHkgY29tcHV0ZWQ/XG4gICAgaWYgKGZsb2F0Q29sb3JDYWNoZVt2YWxdKVxuICAgICAgcmV0dXJuIGZsb2F0Q29sb3JDYWNoZVt2YWxdO1xuXG4gICAgdmFyIG9yaWdpbmFsID0gdmFsLFxuICAgICAgICByID0gMCxcbiAgICAgICAgZyA9IDAsXG4gICAgICAgIGIgPSAwO1xuXG4gICAgaWYgKHZhbFswXSA9PT0gJyMnKSB7XG4gICAgICB2YWwgPSB2YWwuc2xpY2UoMSk7XG5cbiAgICAgIGlmICh2YWwubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIHIgPSBwYXJzZUludCh2YWwuY2hhckF0KDApICsgdmFsLmNoYXJBdCgwKSwgMTYpO1xuICAgICAgICBnID0gcGFyc2VJbnQodmFsLmNoYXJBdCgxKSArIHZhbC5jaGFyQXQoMSksIDE2KTtcbiAgICAgICAgYiA9IHBhcnNlSW50KHZhbC5jaGFyQXQoMikgKyB2YWwuY2hhckF0KDIpLCAxNik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgciA9IHBhcnNlSW50KHZhbC5jaGFyQXQoMCkgKyB2YWwuY2hhckF0KDEpLCAxNik7XG4gICAgICAgIGcgPSBwYXJzZUludCh2YWwuY2hhckF0KDIpICsgdmFsLmNoYXJBdCgzKSwgMTYpO1xuICAgICAgICBiID0gcGFyc2VJbnQodmFsLmNoYXJBdCg0KSArIHZhbC5jaGFyQXQoNSksIDE2KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZhbC5tYXRjaCgvXiAqcmdiYT8gKlxcKC8pKSB7XG4gICAgICB2YWwgPSB2YWwubWF0Y2goXG4gICAgICAgIC9eICpyZ2JhPyAqXFwoICooWzAtOV0qKSAqLCAqKFswLTldKikgKiwgKihbMC05XSopICooLC4qKT9cXCkgKiQvXG4gICAgICApO1xuICAgICAgciA9ICt2YWxbMV07XG4gICAgICBnID0gK3ZhbFsyXTtcbiAgICAgIGIgPSArdmFsWzNdO1xuICAgIH1cblxuICAgIHZhciBjb2xvciA9IChcbiAgICAgIHIgKiAyNTYgKiAyNTYgK1xuICAgICAgZyAqIDI1NiArXG4gICAgICBiXG4gICAgKTtcblxuICAgIC8vIENhY2hpbmcgdGhlIGNvbG9yXG4gICAgZmxvYXRDb2xvckNhY2hlW29yaWdpbmFsXSA9IGNvbG9yO1xuXG4gICAgcmV0dXJuIGNvbG9yO1xuICB9O1xuXG4gICAgLyoqXG4gICAqIFBlcmZvcm0gYSB6b29tIGludG8gYSBjYW1lcmEsIHdpdGggb3Igd2l0aG91dCBhbmltYXRpb24sIHRvIHRoZVxuICAgKiBjb29yZGluYXRlcyBpbmRpY2F0ZWQgdXNpbmcgYSBzcGVjaWZpZWQgcmF0aW8uXG4gICAqXG4gICAqIFJlY29nbml6ZWQgcGFyYW1ldGVyczpcbiAgICogKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBIZXJlIGlzIHRoZSBleGhhdXN0aXZlIGxpc3Qgb2YgZXZlcnkgYWNjZXB0ZWQgcGFyYW1ldGVycyBpbiB0aGUgYW5pbWF0aW9uXG4gICAqIG9iamVjdDpcbiAgICpcbiAgICogICB7P251bWJlcn0gZHVyYXRpb24gICAgIEFuIGFtb3VudCBvZiB0aW1lIHRoYXQgbWVhbnMgdGhlIGR1cmF0aW9uIG9mIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLiBJZiB0aGlzIHBhcmFtZXRlciBkb2Vzbid0IGV4aXN0IHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgem9vbSB3aWxsIGJlIHBlcmZvcm1lZCB3aXRob3V0IGFuaW1hdGlvbi5cbiAgICogICB7P2Z1bmN0aW9ufSBvbkNvbXBsZXRlIEEgZnVuY3Rpb24gdG8gcGVyZm9ybSBpdCBhZnRlciB0aGUgYW5pbWF0aW9uLiBJdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBiZSBwZXJmb3JtZWQgZXZlbiBpZiB0aGVyZSBpcyBubyBkdXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtjYW1lcmF9ICAgICBUaGUgY2FtZXJhIHdoZXJlIHBlcmZvcm0gdGhlIHpvb20uXG4gICAqIEBwYXJhbSB7eH0gICAgICAgICAgVGhlIFggY29vcmRpYW50aW9uIHdoZXJlIHRoZSB6b29tIGdvZXMuXG4gICAqIEBwYXJhbSB7eX0gICAgICAgICAgVGhlIFkgY29vcmRpYW50aW9uIHdoZXJlIHRoZSB6b29tIGdvZXMuXG4gICAqIEBwYXJhbSB7cmF0aW99ICAgICAgVGhlIHJhdGlvIHRvIGFwcGx5IGl0IHRvIHRoZSBjdXJyZW50IGNhbWVyYSByYXRpby5cbiAgICogQHBhcmFtIHs/YW5pbWF0aW9ufSBBIGRpY3Rpb25hcnkgd2l0aCBvcHRpb25zIGZvciBhIHBvc3NpYmxlIGFuaW1hdGlvbi5cbiAgICovXG4gIHNpZ21hLnV0aWxzLnpvb21UbyA9IGZ1bmN0aW9uKGNhbWVyYSwgeCwgeSwgcmF0aW8sIGFuaW1hdGlvbikge1xuICAgIHZhciBzZXR0aW5ncyA9IGNhbWVyYS5zZXR0aW5ncyxcbiAgICAgICAgY291bnQsXG4gICAgICAgIG5ld1JhdGlvLFxuICAgICAgICBhbmltYXRpb25TZXR0aW5ncyxcbiAgICAgICAgY29vcmRpbmF0ZXM7XG5cbiAgICAvLyBDcmVhdGUgdGhlIG5ld1JhdGlvIGRlYWxpbmcgd2l0aCBtaW4gLyBtYXg6XG4gICAgbmV3UmF0aW8gPSBNYXRoLm1heChcbiAgICAgIHNldHRpbmdzKCd6b29tTWluJyksXG4gICAgICBNYXRoLm1pbihcbiAgICAgICAgc2V0dGluZ3MoJ3pvb21NYXgnKSxcbiAgICAgICAgY2FtZXJhLnJhdGlvICogcmF0aW9cbiAgICAgIClcbiAgICApO1xuXG4gICAgLy8gQ2hlY2sgdGhhdCB0aGUgbmV3IHJhdGlvIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBpbml0aWFsIG9uZTpcbiAgICBpZiAobmV3UmF0aW8gIT09IGNhbWVyYS5yYXRpbykge1xuICAgICAgLy8gQ3JlYXRlIHRoZSBjb29yZGluYXRlcyB2YXJpYWJsZTpcbiAgICAgIHJhdGlvID0gbmV3UmF0aW8gLyBjYW1lcmEucmF0aW87XG4gICAgICBjb29yZGluYXRlcyA9IHtcbiAgICAgICAgeDogeCAqICgxIC0gcmF0aW8pICsgY2FtZXJhLngsXG4gICAgICAgIHk6IHkgKiAoMSAtIHJhdGlvKSArIGNhbWVyYS55LFxuICAgICAgICByYXRpbzogbmV3UmF0aW9cbiAgICAgIH07XG5cbiAgICAgIGlmIChhbmltYXRpb24gJiYgYW5pbWF0aW9uLmR1cmF0aW9uKSB7XG4gICAgICAgIC8vIENvbXBsZXRlIHRoZSBhbmltYXRpb24gc2V0aW5nczpcbiAgICAgICAgY291bnQgPSBzaWdtYS5taXNjLmFuaW1hdGlvbi5raWxsQWxsKGNhbWVyYSk7XG4gICAgICAgIGFuaW1hdGlvbiA9IHNpZ21hLnV0aWxzLmV4dGVuZChcbiAgICAgICAgICBhbmltYXRpb24sXG4gICAgICAgICAge1xuICAgICAgICAgICAgZWFzaW5nOiBjb3VudCA/ICdxdWFkcmF0aWNPdXQnIDogJ3F1YWRyYXRpY0luT3V0J1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICBzaWdtYS5taXNjLmFuaW1hdGlvbi5jYW1lcmEoY2FtZXJhLCBjb29yZGluYXRlcywgYW5pbWF0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbWVyYS5nb1RvKGNvb3JkaW5hdGVzKTtcbiAgICAgICAgaWYgKGFuaW1hdGlvbiAmJiBhbmltYXRpb24ub25Db21wbGV0ZSlcbiAgICAgICAgICBhbmltYXRpb24ub25Db21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjb250cm9sIHBvaW50IGNvb3JkaW5hdGVzIGZvciBhIHF1YWRyYXRpYyBiZXppZXIgY3VydmUuXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0geDEgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHN0YXJ0IHBvaW50LlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkxICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBzdGFydCBwb2ludC5cbiAgICogQHBhcmFtICB7bnVtYmVyfSB4MiAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgZW5kIHBvaW50LlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBlbmQgcG9pbnQuXG4gICAqIEByZXR1cm4ge3gseX0gICAgICAgIFRoZSBjb250cm9sIHBvaW50IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZ2V0UXVhZHJhdGljQ29udHJvbFBvaW50ID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogKHgxICsgeDIpIC8gMiArICh5MiAtIHkxKSAvIDQsXG4gICAgICB5OiAoeTEgKyB5MikgLyAyICsgKHgxIC0geDIpIC8gNFxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAgKiBDb21wdXRlIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgcG9zaXRpb25lZFxuICAgICogYXQgbGVuZ3RoIHQgaW4gdGhlIHF1YWRyYXRpYyBiZXppZXIgY3VydmUuXG4gICAgKlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB0ICBJbiBbMCwxXSB0aGUgc3RlcCBwZXJjZW50YWdlIHRvIHJlYWNoXG4gICAgKiAgICAgICAgICAgICAgICAgICAgIHRoZSBwb2ludCBpbiB0aGUgY3VydmUgZnJvbSB0aGUgY29udGV4dCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geDEgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY29udGV4dCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geTEgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY29udGV4dCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geDIgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgZW5kaW5nIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5MiBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBlbmRpbmcgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHhpIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNvbnRyb2wgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlpIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGNvbnRyb2wgcG9pbnQuXG4gICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgIHt4LHl9LlxuICAqL1xuICBzaWdtYS51dGlscy5nZXRQb2ludE9uUXVhZHJhdGljQ3VydmUgPSBmdW5jdGlvbih0LCB4MSwgeTEsIHgyLCB5MiwgeGksIHlpKSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTYzNDUyOFxuICAgIHJldHVybiB7XG4gICAgICB4OiBNYXRoLnBvdygxIC0gdCwgMikgKiB4MSArIDIgKiAoMSAtIHQpICogdCAqIHhpICsgTWF0aC5wb3codCwgMikgKiB4MixcbiAgICAgIHk6IE1hdGgucG93KDEgLSB0LCAyKSAqIHkxICsgMiAqICgxIC0gdCkgKiB0ICogeWkgKyBNYXRoLnBvdyh0LCAyKSAqIHkyXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICAqIENvbXB1dGUgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludCBwb3NpdGlvbmVkXG4gICAgKiBhdCBsZW5ndGggdCBpbiB0aGUgY3ViaWMgYmV6aWVyIGN1cnZlLlxuICAgICpcbiAgICAqIEBwYXJhbSAge251bWJlcn0gdCAgSW4gWzAsMV0gdGhlIHN0ZXAgcGVyY2VudGFnZSB0byByZWFjaFxuICAgICogICAgICAgICAgICAgICAgICAgICB0aGUgcG9pbnQgaW4gdGhlIGN1cnZlIGZyb20gdGhlIGNvbnRleHQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNvbnRleHQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkxIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGNvbnRleHQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geTIgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgZW5kIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBjeCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBjb250cm9sIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBjeSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBjb250cm9sIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBkeCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0gZHkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQuXG4gICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgIHt4LHl9IFRoZSBwb2ludCBhdCB0LlxuICAqL1xuICBzaWdtYS51dGlscy5nZXRQb2ludE9uQmV6aWVyQ3VydmUgPVxuICAgIGZ1bmN0aW9uKHQsIHgxLCB5MSwgeDIsIHkyLCBjeCwgY3ksIGR4LCBkeSkge1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE1Mzk3NTk2XG4gICAgLy8gQmxlbmRpbmcgZnVuY3Rpb25zOlxuICAgIHZhciBCMF90ID0gTWF0aC5wb3coMSAtIHQsIDMpLFxuICAgICAgICBCMV90ID0gMyAqIHQgKiBNYXRoLnBvdygxIC0gdCwgMiksXG4gICAgICAgIEIyX3QgPSAzICogTWF0aC5wb3codCwgMikgKiAoMSAtIHQpLFxuICAgICAgICBCM190ID0gTWF0aC5wb3codCwgMyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogKEIwX3QgKiB4MSkgKyAoQjFfdCAqIGN4KSArIChCMl90ICogZHgpICsgKEIzX3QgKiB4MiksXG4gICAgICB5OiAoQjBfdCAqIHkxKSArIChCMV90ICogY3kpICsgKEIyX3QgKiBkeSkgKyAoQjNfdCAqIHkyKVxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIHR3byBjb250cm9sIHBvaW50cyBmb3IgYSBzZWxmIGxvb3AgKGkuZS5cbiAgICogd2hlcmUgdGhlIHN0YXJ0IHBvaW50IGlzIGFsc28gdGhlIGVuZCBwb2ludCkgY29tcHV0ZWQgYXMgYSBjdWJpYyBiZXppZXJcbiAgICogY3VydmUuXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0geCAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBub2RlLlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkgICAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgbm9kZS5cbiAgICogQHBhcmFtICB7bnVtYmVyfSBzaXplIFRoZSBub2RlIHNpemUuXG4gICAqIEByZXR1cm4ge3gxLHkxLHgyLHkyfSBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHR3byBjb250cm9sIHBvaW50cy5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmdldFNlbGZMb29wQ29udHJvbFBvaW50cyA9IGZ1bmN0aW9uKHggLCB5LCBzaXplKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHgxOiB4IC0gc2l6ZSAqIDcsXG4gICAgICB5MTogeSxcbiAgICAgIHgyOiB4LFxuICAgICAgeTI6IHkgKyBzaXplICogN1xuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cyBvZiBhIHBsYW5lXG4gICAqIHdpdGggYW4gb3J0aG9ub3JtYWwgYmFzaXMuXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0geDEgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IHBvaW50LlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkxICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBwb2ludC5cbiAgICogQHBhcmFtICB7bnVtYmVyfSB4MiAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIHBvaW50LlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgcG9pbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgIFRoZSBldWNsaWRpYW4gZGlzdGFuY2UuXG4gICAqL1xuICBzaWdtYS51dGlscy5nZXREaXN0YW5jZSA9IGZ1bmN0aW9uKHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh4MSAtIHgwLCAyKSArIE1hdGgucG93KHkxIC0geTAsIDIpKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgaW50ZXJzZWN0aW9uIHBvaW50cyBvZiB0d28gY2lyY2xlcy5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4MCAgVGhlIFggY29vcmRpbmF0ZSBvZiBjZW50ZXIgbG9jYXRpb24gb2YgdGhlIGZpcnN0XG4gICAqICAgICAgICAgICAgICAgICAgICAgIGNpcmNsZS5cbiAgICogQHBhcmFtICB7bnVtYmVyfSB5MCAgVGhlIFkgY29vcmRpbmF0ZSBvZiBjZW50ZXIgbG9jYXRpb24gb2YgdGhlIGZpcnN0XG4gICAqICAgICAgICAgICAgICAgICAgICAgIGNpcmNsZS5cbiAgICogQHBhcmFtICB7bnVtYmVyfSByMCAgVGhlIHJhZGl1cyBvZiB0aGUgZmlyc3QgY2lyY2xlLlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxICBUaGUgWCBjb29yZGluYXRlIG9mIGNlbnRlciBsb2NhdGlvbiBvZiB0aGUgc2Vjb25kXG4gICAqICAgICAgICAgICAgICAgICAgICAgIGNpcmNsZS5cbiAgICogQHBhcmFtICB7bnVtYmVyfSB5MSAgVGhlIFkgY29vcmRpbmF0ZSBvZiBjZW50ZXIgbG9jYXRpb24gb2YgdGhlIHNlY29uZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICBjaXJjbGUuXG4gICAqIEBwYXJhbSAge251bWJlcn0gcjEgIFRoZSByYWRpdXMgb2YgdGhlIHNlY29uZCBjaXJjbGUuXG4gICAqIEByZXR1cm4ge3hpLHlpfSAgICAgIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgaW50ZXJzZWN0aW9uIHBvaW50cy5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmdldENpcmNsZUludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKHgwLCB5MCwgcjAsIHgxLCB5MSwgcjEpIHtcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMjIxOTgwMlxuICAgIHZhciBhLCBkeCwgZHksIGQsIGgsIHJ4LCByeSwgeDIsIHkyO1xuXG4gICAgLy8gZHggYW5kIGR5IGFyZSB0aGUgdmVydGljYWwgYW5kIGhvcml6b250YWwgZGlzdGFuY2VzIGJldHdlZW4gdGhlIGNpcmNsZVxuICAgIC8vIGNlbnRlcnM6XG4gICAgZHggPSB4MSAtIHgwO1xuICAgIGR5ID0geTEgLSB5MDtcblxuICAgIC8vIERldGVybWluZSB0aGUgc3RyYWlnaHQtbGluZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBjZW50ZXJzOlxuICAgIGQgPSBNYXRoLnNxcnQoKGR5ICogZHkpICsgKGR4ICogZHgpKTtcblxuICAgIC8vIENoZWNrIGZvciBzb2x2YWJpbGl0eTpcbiAgICBpZiAoZCA+IChyMCArIHIxKSkge1xuICAgICAgICAvLyBObyBzb2x1dGlvbi4gY2lyY2xlcyBkbyBub3QgaW50ZXJzZWN0LlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkIDwgTWF0aC5hYnMocjAgLSByMSkpIHtcbiAgICAgICAgLy8gTm8gc29sdXRpb24uIG9uZSBjaXJjbGUgaXMgY29udGFpbmVkIGluIHRoZSBvdGhlci5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vJ3BvaW50IDInIGlzIHRoZSBwb2ludCB3aGVyZSB0aGUgbGluZSB0aHJvdWdoIHRoZSBjaXJjbGUgaW50ZXJzZWN0aW9uXG4gICAgLy8gcG9pbnRzIGNyb3NzZXMgdGhlIGxpbmUgYmV0d2VlbiB0aGUgY2lyY2xlIGNlbnRlcnMuXG5cbiAgICAvLyBEZXRlcm1pbmUgdGhlIGRpc3RhbmNlIGZyb20gcG9pbnQgMCB0byBwb2ludCAyOlxuICAgIGEgPSAoKHIwICogcjApIC0gKHIxICogcjEpICsgKGQgKiBkKSkgLyAoMi4wICogZCk7XG5cbiAgICAvLyBEZXRlcm1pbmUgdGhlIGNvb3JkaW5hdGVzIG9mIHBvaW50IDI6XG4gICAgeDIgPSB4MCArIChkeCAqIGEgLyBkKTtcbiAgICB5MiA9IHkwICsgKGR5ICogYSAvIGQpO1xuXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBkaXN0YW5jZSBmcm9tIHBvaW50IDIgdG8gZWl0aGVyIG9mIHRoZSBpbnRlcnNlY3Rpb25cbiAgICAvLyBwb2ludHM6XG4gICAgaCA9IE1hdGguc3FydCgocjAgKiByMCkgLSAoYSAqIGEpKTtcblxuICAgIC8vIERldGVybWluZSB0aGUgb2Zmc2V0cyBvZiB0aGUgaW50ZXJzZWN0aW9uIHBvaW50cyBmcm9tIHBvaW50IDI6XG4gICAgcnggPSAtZHkgKiAoaCAvIGQpO1xuICAgIHJ5ID0gZHggKiAoaCAvIGQpO1xuXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBhYnNvbHV0ZSBpbnRlcnNlY3Rpb24gcG9pbnRzOlxuICAgIHZhciB4aSA9IHgyICsgcng7XG4gICAgdmFyIHhpX3ByaW1lID0geDIgLSByeDtcbiAgICB2YXIgeWkgPSB5MiArIHJ5O1xuICAgIHZhciB5aV9wcmltZSA9IHkyIC0gcnk7XG5cbiAgICByZXR1cm4ge3hpOiB4aSwgeGlfcHJpbWU6IHhpX3ByaW1lLCB5aTogeWksIHlpX3ByaW1lOiB5aV9wcmltZX07XG4gIH07XG5cbiAgLyoqXG4gICAgKiBDaGVjayBpZiBhIHBvaW50IGlzIG9uIGEgbGluZSBzZWdtZW50LlxuICAgICpcbiAgICAqIEBwYXJhbSAge251bWJlcn0geCAgICAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byBjaGVjay5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geSAgICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byBjaGVjay5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geDEgICAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBsaW5lIHN0YXJ0IHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5MSAgICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGxpbmUgc3RhcnQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyICAgICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgbGluZSBlbmQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyICAgICAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgbGluZSBlbmQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGVwc2lsb24gVGhlIHByZWNpc2lvbiAoY29uc2lkZXIgdGhlIGxpbmUgdGhpY2tuZXNzKS5cbiAgICAqIEByZXR1cm4ge2Jvb2xlYW59ICAgICAgICBUcnVlIGlmIHBvaW50IGlzIFwiY2xvc2UgdG9cIiB0aGUgbGluZVxuICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnQsIGZhbHNlIG90aGVyd2lzZS5cbiAgKi9cbiAgc2lnbWEudXRpbHMuaXNQb2ludE9uU2VnbWVudCA9IGZ1bmN0aW9uKHgsIHksIHgxLCB5MSwgeDIsIHkyLCBlcHNpbG9uKSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzI4MTIyXG4gICAgdmFyIGNyb3NzUHJvZHVjdCA9IE1hdGguYWJzKCh5IC0geTEpICogKHgyIC0geDEpIC0gKHggLSB4MSkgKiAoeTIgLSB5MSkpLFxuICAgICAgICBkID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpLFxuICAgICAgICBuQ3Jvc3NQcm9kdWN0ID0gY3Jvc3NQcm9kdWN0IC8gZDsgLy8gbm9ybWFsaXplZCBjcm9zcyBwcm9kdWN0XG5cbiAgICByZXR1cm4gKG5Dcm9zc1Byb2R1Y3QgPCBlcHNpbG9uICYmXG4gICAgIE1hdGgubWluKHgxLCB4MikgPD0geCAmJiB4IDw9IE1hdGgubWF4KHgxLCB4MikgJiZcbiAgICAgTWF0aC5taW4oeTEsIHkyKSA8PSB5ICYmIHkgPD0gTWF0aC5tYXgoeTEsIHkyKSk7XG4gIH07XG5cbiAgLyoqXG4gICAgKiBDaGVjayBpZiBhIHBvaW50IGlzIG9uIGEgcXVhZHJhdGljIGJlemllciBjdXJ2ZSBzZWdtZW50IHdpdGggYSB0aGlja25lc3MuXG4gICAgKlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4ICAgICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIGNoZWNrLlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5ICAgICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIGNoZWNrLlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4MSAgICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnZlIHN0YXJ0IHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5MSAgICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnZlIHN0YXJ0IHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4MiAgICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnZlIGVuZCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geTIgICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjdXJ2ZSBlbmQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGNweCAgICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY3VydmUgY29udHJvbCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0gY3B5ICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjdXJ2ZSBjb250cm9sIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBlcHNpbG9uIFRoZSBwcmVjaXNpb24gKGNvbnNpZGVyIHRoZSBsaW5lIHRoaWNrbmVzcykuXG4gICAgKiBAcmV0dXJuIHtib29sZWFufSAgICAgICAgVHJ1ZSBpZiAoeCx5KSBpcyBvbiB0aGUgY3VydmUgc2VnbWVudCxcbiAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSBvdGhlcndpc2UuXG4gICovXG4gIHNpZ21hLnV0aWxzLmlzUG9pbnRPblF1YWRyYXRpY0N1cnZlID1cbiAgICBmdW5jdGlvbih4LCB5LCB4MSwgeTEsIHgyLCB5MiwgY3B4LCBjcHksIGVwc2lsb24pIHtcbiAgICAvLyBGYWlscyBpZiB0aGUgcG9pbnQgaXMgdG9vIGZhciBmcm9tIHRoZSBleHRyZW1pdGllcyBvZiB0aGUgc2VnbWVudCxcbiAgICAvLyBwcmV2ZW50aW5nIGZvciBtb3JlIGNvc3RseSBjb21wdXRhdGlvbjpcbiAgICB2YXIgZFAxUDIgPSBzaWdtYS51dGlscy5nZXREaXN0YW5jZSh4MSwgeTEsIHgyLCB5Mik7XG4gICAgaWYgKE1hdGguYWJzKHggLSB4MSkgPiBkUDFQMiB8fCBNYXRoLmFicyh5IC0geTEpID4gZFAxUDIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZFAxID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeCwgeSwgeDEsIHkxKSxcbiAgICAgICAgZFAyID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeCwgeSwgeDIsIHkyKSxcbiAgICAgICAgdCA9IDAuNSxcbiAgICAgICAgciA9IChkUDEgPCBkUDIpID8gLTAuMDEgOiAwLjAxLFxuICAgICAgICByVGhyZXNob2xkID0gMC4wMDEsXG4gICAgICAgIGkgPSAxMDAsXG4gICAgICAgIHB0ID0gc2lnbWEudXRpbHMuZ2V0UG9pbnRPblF1YWRyYXRpY0N1cnZlKHQsIHgxLCB5MSwgeDIsIHkyLCBjcHgsIGNweSksXG4gICAgICAgIGR0ID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeCwgeSwgcHQueCwgcHQueSksXG4gICAgICAgIG9sZF9kdDtcblxuICAgIC8vIFRoaXMgYWxnb3JpdGhtIG1pbmltaXplcyB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgcG9pbnQgdG8gdGhlIGN1cnZlLiBJdFxuICAgIC8vIGZpbmQgdGhlIG9wdGltYWwgdCB2YWx1ZSB3aGVyZSB0PTAgaXMgdGhlIHN0YXJ0IHBvaW50IGFuZCB0PTEgaXMgdGhlIGVuZFxuICAgIC8vIHBvaW50IG9mIHRoZSBjdXJ2ZSwgc3RhcnRpbmcgZnJvbSB0PTAuNS5cbiAgICAvLyBJdCB0ZXJtaW5hdGVzIGJlY2F1c2UgaXQgcnVucyBhIG1heGltdW0gb2YgaSBpbnRlcmF0aW9ucy5cbiAgICB3aGlsZSAoaS0tID4gMCAmJlxuICAgICAgdCA+PSAwICYmIHQgPD0gMSAmJlxuICAgICAgKGR0ID4gZXBzaWxvbikgJiZcbiAgICAgIChyID4gclRocmVzaG9sZCB8fCByIDwgLXJUaHJlc2hvbGQpKSB7XG4gICAgICBvbGRfZHQgPSBkdDtcbiAgICAgIHB0ID0gc2lnbWEudXRpbHMuZ2V0UG9pbnRPblF1YWRyYXRpY0N1cnZlKHQsIHgxLCB5MSwgeDIsIHkyLCBjcHgsIGNweSk7XG4gICAgICBkdCA9IHNpZ21hLnV0aWxzLmdldERpc3RhbmNlKHgsIHksIHB0LngsIHB0LnkpO1xuXG4gICAgICBpZiAoZHQgPiBvbGRfZHQpIHtcbiAgICAgICAgLy8gbm90IHRoZSByaWdodCBkaXJlY3Rpb246XG4gICAgICAgIC8vIGhhbGZzdGVwIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb25cbiAgICAgICAgciA9IC1yIC8gMjtcbiAgICAgICAgdCArPSByO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodCArIHIgPCAwIHx8IHQgKyByID4gMSkge1xuICAgICAgICAvLyBvb3BzLCB3ZSd2ZSBnb25lIHRvbyBmYXI6XG4gICAgICAgIC8vIHJldmVydCB3aXRoIGEgaGFsZnN0ZXBcbiAgICAgICAgciA9IHIgLyAyO1xuICAgICAgICBkdCA9IG9sZF9kdDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBwcm9ncmVzczpcbiAgICAgICAgdCArPSByO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkdCA8IGVwc2lsb247XG4gIH07XG5cblxuICAvKipcbiAgICAqIENoZWNrIGlmIGEgcG9pbnQgaXMgb24gYSBjdWJpYyBiZXppZXIgY3VydmUgc2VnbWVudCB3aXRoIGEgdGhpY2tuZXNzLlxuICAgICpcbiAgICAqIEBwYXJhbSAge251bWJlcn0geCAgICAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byBjaGVjay5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geSAgICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byBjaGVjay5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geDEgICAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjdXJ2ZSBzdGFydCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geTEgICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjdXJ2ZSBzdGFydCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geDIgICAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjdXJ2ZSBlbmQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyICAgICAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY3VydmUgZW5kIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBjcHgxICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIDFzdCBjdXJ2ZSBjb250cm9sIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBjcHkxICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIDFzdCBjdXJ2ZSBjb250cm9sIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBjcHgyICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIDJuZCBjdXJ2ZSBjb250cm9sIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBjcHkyICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIDJuZCBjdXJ2ZSBjb250cm9sIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBlcHNpbG9uIFRoZSBwcmVjaXNpb24gKGNvbnNpZGVyIHRoZSBsaW5lIHRoaWNrbmVzcykuXG4gICAgKiBAcmV0dXJuIHtib29sZWFufSAgICAgICAgVHJ1ZSBpZiAoeCx5KSBpcyBvbiB0aGUgY3VydmUgc2VnbWVudCxcbiAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSBvdGhlcndpc2UuXG4gICovXG4gIHNpZ21hLnV0aWxzLmlzUG9pbnRPbkJlemllckN1cnZlID1cbiAgICBmdW5jdGlvbih4LCB5LCB4MSwgeTEsIHgyLCB5MiwgY3B4MSwgY3B5MSwgY3B4MiwgY3B5MiwgZXBzaWxvbikge1xuICAgIC8vIEZhaWxzIGlmIHRoZSBwb2ludCBpcyB0b28gZmFyIGZyb20gdGhlIGV4dHJlbWl0aWVzIG9mIHRoZSBzZWdtZW50LFxuICAgIC8vIHByZXZlbnRpbmcgZm9yIG1vcmUgY29zdGx5IGNvbXB1dGF0aW9uOlxuICAgIHZhciBkUDFDUDEgPSBzaWdtYS51dGlscy5nZXREaXN0YW5jZSh4MSwgeTEsIGNweDEsIGNweTEpO1xuICAgIGlmIChNYXRoLmFicyh4IC0geDEpID4gZFAxQ1AxIHx8IE1hdGguYWJzKHkgLSB5MSkgPiBkUDFDUDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZFAxID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeCwgeSwgeDEsIHkxKSxcbiAgICAgICAgZFAyID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeCwgeSwgeDIsIHkyKSxcbiAgICAgICAgdCA9IDAuNSxcbiAgICAgICAgciA9IChkUDEgPCBkUDIpID8gLTAuMDEgOiAwLjAxLFxuICAgICAgICByVGhyZXNob2xkID0gMC4wMDEsXG4gICAgICAgIGkgPSAxMDAsXG4gICAgICAgIHB0ID0gc2lnbWEudXRpbHMuZ2V0UG9pbnRPbkJlemllckN1cnZlKFxuICAgICAgICAgIHQsIHgxLCB5MSwgeDIsIHkyLCBjcHgxLCBjcHkxLCBjcHgyLCBjcHkyKSxcbiAgICAgICAgZHQgPSBzaWdtYS51dGlscy5nZXREaXN0YW5jZSh4LCB5LCBwdC54LCBwdC55KSxcbiAgICAgICAgb2xkX2R0O1xuXG4gICAgLy8gVGhpcyBhbGdvcml0aG0gbWluaW1pemVzIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBwb2ludCB0byB0aGUgY3VydmUuIEl0XG4gICAgLy8gZmluZCB0aGUgb3B0aW1hbCB0IHZhbHVlIHdoZXJlIHQ9MCBpcyB0aGUgc3RhcnQgcG9pbnQgYW5kIHQ9MSBpcyB0aGUgZW5kXG4gICAgLy8gcG9pbnQgb2YgdGhlIGN1cnZlLCBzdGFydGluZyBmcm9tIHQ9MC41LlxuICAgIC8vIEl0IHRlcm1pbmF0ZXMgYmVjYXVzZSBpdCBydW5zIGEgbWF4aW11bSBvZiBpIGludGVyYXRpb25zLlxuICAgIHdoaWxlIChpLS0gPiAwICYmXG4gICAgICB0ID49IDAgJiYgdCA8PSAxICYmXG4gICAgICAoZHQgPiBlcHNpbG9uKSAmJlxuICAgICAgKHIgPiByVGhyZXNob2xkIHx8IHIgPCAtclRocmVzaG9sZCkpIHtcbiAgICAgIG9sZF9kdCA9IGR0O1xuICAgICAgcHQgPSBzaWdtYS51dGlscy5nZXRQb2ludE9uQmV6aWVyQ3VydmUoXG4gICAgICAgIHQsIHgxLCB5MSwgeDIsIHkyLCBjcHgxLCBjcHkxLCBjcHgyLCBjcHkyKTtcbiAgICAgIGR0ID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeCwgeSwgcHQueCwgcHQueSk7XG5cbiAgICAgIGlmIChkdCA+IG9sZF9kdCkge1xuICAgICAgICAvLyBub3QgdGhlIHJpZ2h0IGRpcmVjdGlvbjpcbiAgICAgICAgLy8gaGFsZnN0ZXAgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvblxuICAgICAgICByID0gLXIgLyAyO1xuICAgICAgICB0ICs9IHI7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0ICsgciA8IDAgfHwgdCArIHIgPiAxKSB7XG4gICAgICAgIC8vIG9vcHMsIHdlJ3ZlIGdvbmUgdG9vIGZhcjpcbiAgICAgICAgLy8gcmV2ZXJ0IHdpdGggYSBoYWxmc3RlcFxuICAgICAgICByID0gciAvIDI7XG4gICAgICAgIGR0ID0gb2xkX2R0O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHByb2dyZXNzOlxuICAgICAgICB0ICs9IHI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGR0IDwgZXBzaWxvbjtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiAqKioqKioqKioqKipcbiAgICogRVZFTlRTIFVUSUxTOlxuICAgKiAqKioqKioqKioqKipcbiAgICovXG4gIC8qKlxuICAgKiBIZXJlIGFyZSBzb21lIHVzZWZ1bCBmdW5jdGlvbnMgdG8gdW5pZnkgZXh0cmFjdGlvbiBvZiB0aGUgaW5mb3JtYXRpb24gd2VcbiAgICogbmVlZCB3aXRoIG1vdXNlIGV2ZW50cyBhbmQgdG91Y2ggZXZlbnRzLCBmcm9tIGRpZmZlcmVudCBicm93c2VyczpcbiAgICovXG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgdGhlIGxvY2FsIFggcG9zaXRpb24gZnJvbSBhIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gIHtldmVudH0gIGUgQSBtb3VzZSBvciB0b3VjaCBldmVudC5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgIFRoZSBsb2NhbCBYIHZhbHVlIG9mIHRoZSBtb3VzZS5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmdldFggPSBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIChlLm9mZnNldFggIT09IHVuZGVmaW5lZCAmJiBlLm9mZnNldFgpIHx8XG4gICAgICAoZS5sYXllclggIT09IHVuZGVmaW5lZCAmJiBlLmxheWVyWCkgfHxcbiAgICAgIChlLmNsaWVudFggIT09IHVuZGVmaW5lZCAmJiBlLmNsaWVudFgpXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogRXh0cmFjdCB0aGUgbG9jYWwgWSBwb3NpdGlvbiBmcm9tIGEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge2V2ZW50fSAgZSBBIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgVGhlIGxvY2FsIFkgdmFsdWUgb2YgdGhlIG1vdXNlLlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZ2V0WSA9IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgKGUub2Zmc2V0WSAhPT0gdW5kZWZpbmVkICYmIGUub2Zmc2V0WSkgfHxcbiAgICAgIChlLmxheWVyWSAhPT0gdW5kZWZpbmVkICYmIGUubGF5ZXJZKSB8fFxuICAgICAgKGUuY2xpZW50WSAhPT0gdW5kZWZpbmVkICYmIGUuY2xpZW50WSlcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgcGl4ZWwgcmF0aW8gb2YgdGhlIHNjcmVlbi4gVGFraW5nIHpvb20gaW50byBhY2NvdW50XG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgIFBpeGVsIHJhdGlvIG9mIHRoZSBzY3JlZW5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmdldFBpeGVsUmF0aW8gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmF0aW8gPSAxO1xuICAgIGlmICh3aW5kb3cuc2NyZWVuLmRldmljZVhEUEkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgd2luZG93LnNjcmVlbi5sb2dpY2FsWERQSSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICB3aW5kb3cuc2NyZWVuLmRldmljZVhEUEkgPiB3aW5kb3cuc2NyZWVuLmxvZ2ljYWxYRFBJKSB7XG4gICAgICAgIHJhdGlvID0gd2luZG93LnNjcmVlbi5zeXN0ZW1YRFBJIC8gd2luZG93LnNjcmVlbi5sb2dpY2FsWERQSTtcbiAgICB9XG4gICAgZWxzZSBpZiAod2luZG93LmRldmljZVBpeGVsUmF0aW8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIH1cbiAgICByZXR1cm4gcmF0aW87XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgdGhlIHdpZHRoIGZyb20gYSBtb3VzZSBvciB0b3VjaCBldmVudC5cbiAgICpcbiAgICogQHBhcmFtICB7ZXZlbnR9ICBlIEEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICBUaGUgd2lkdGggb2YgdGhlIGV2ZW50J3MgdGFyZ2V0LlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZ2V0V2lkdGggPSBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHcgPSAoIWUudGFyZ2V0Lm93bmVyU1ZHRWxlbWVudCkgP1xuICAgICAgICAgICAgICBlLnRhcmdldC53aWR0aCA6XG4gICAgICAgICAgICAgIGUudGFyZ2V0Lm93bmVyU1ZHRWxlbWVudC53aWR0aDtcblxuICAgIHJldHVybiAoXG4gICAgICAodHlwZW9mIHcgPT09ICdudW1iZXInICYmIHcpIHx8XG4gICAgICAodyAhPT0gdW5kZWZpbmVkICYmIHcuYmFzZVZhbCAhPT0gdW5kZWZpbmVkICYmIHcuYmFzZVZhbC52YWx1ZSlcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeHRyYWN0IHRoZSBjZW50ZXIgZnJvbSBhIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gIHtldmVudH0gIGUgQSBtb3VzZSBvciB0b3VjaCBldmVudC5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgIFRoZSBjZW50ZXIgb2YgdGhlIGV2ZW50J3MgdGFyZ2V0LlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZ2V0Q2VudGVyID0gZnVuY3Rpb24oZSkge1xuICAgIHZhciByYXRpbyA9IGUudGFyZ2V0Lm5hbWVzcGFjZVVSSS5pbmRleE9mKCdzdmcnKSAhPT0gLTEgPyAxIDpcbiAgICAgICAgc2lnbWEudXRpbHMuZ2V0UGl4ZWxSYXRpbygpO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBzaWdtYS51dGlscy5nZXRXaWR0aChlKSAvICgyICogcmF0aW8pLFxuICAgICAgeTogc2lnbWEudXRpbHMuZ2V0SGVpZ2h0KGUpIC8gKDIgKiByYXRpbylcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0IG1vdXNlIGNvb3JkcyB0byBzaWdtYSBjb29yZHNcbiAgICpcbiAgICogQHBhcmFtICB7ZXZlbnR9ICAgZSBBIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxuICAgKiBAcGFyYW0gIHtudW1iZXI/fSB4IFRoZSB4IGNvb3JkIHRvIGNvbnZlcnRcbiAgICogQHBhcmFtICB7bnVtYmVyP30geCBUaGUgeSBjb29yZCB0byBjb252ZXJ0XG4gICAqXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgVGhlIHN0YW5kYXJkaXplZCBldmVudFxuICAgKi9cbiAgc2lnbWEudXRpbHMubW91c2VDb29yZHMgPSBmdW5jdGlvbihlLCB4LCB5KSB7XG4gICAgeCA9IHggfHwgc2lnbWEudXRpbHMuZ2V0WChlKTtcbiAgICB5ID0geSB8fCBzaWdtYS51dGlscy5nZXRZKGUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggLSBzaWdtYS51dGlscy5nZXRDZW50ZXIoZSkueCxcbiAgICAgICAgeTogeSAtIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS55LFxuICAgICAgICBjbGllbnRYOiBlLmNsaWVudFgsXG4gICAgICAgIGNsaWVudFk6IGUuY2xpZW50WSxcbiAgICAgICAgY3RybEtleTogZS5jdHJsS2V5LFxuICAgICAgICBtZXRhS2V5OiBlLm1ldGFLZXksXG4gICAgICAgIGFsdEtleTogZS5hbHRLZXksXG4gICAgICAgIHNoaWZ0S2V5OiBlLnNoaWZ0S2V5XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogRXh0cmFjdCB0aGUgaGVpZ2h0IGZyb20gYSBtb3VzZSBvciB0b3VjaCBldmVudC5cbiAgICpcbiAgICogQHBhcmFtICB7ZXZlbnR9ICBlIEEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICBUaGUgaGVpZ2h0IG9mIHRoZSBldmVudCdzIHRhcmdldC5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmdldEhlaWdodCA9IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgaCA9ICghZS50YXJnZXQub3duZXJTVkdFbGVtZW50KSA/XG4gICAgICAgICAgICAgIGUudGFyZ2V0LmhlaWdodCA6XG4gICAgICAgICAgICAgIGUudGFyZ2V0Lm93bmVyU1ZHRWxlbWVudC5oZWlnaHQ7XG5cbiAgICByZXR1cm4gKFxuICAgICAgKHR5cGVvZiBoID09PSAnbnVtYmVyJyAmJiBoKSB8fFxuICAgICAgKGggIT09IHVuZGVmaW5lZCAmJiBoLmJhc2VWYWwgIT09IHVuZGVmaW5lZCAmJiBoLmJhc2VWYWwudmFsdWUpXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogRXh0cmFjdCB0aGUgd2hlZWwgZGVsdGEgZnJvbSBhIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gIHtldmVudH0gIGUgQSBtb3VzZSBvciB0b3VjaCBldmVudC5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgIFRoZSB3aGVlbCBkZWx0YSBvZiB0aGUgbW91c2UuXG4gICAqL1xuICBzaWdtYS51dGlscy5nZXREZWx0YSA9IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgKGUud2hlZWxEZWx0YSAhPT0gdW5kZWZpbmVkICYmIGUud2hlZWxEZWx0YSkgfHxcbiAgICAgIChlLmRldGFpbCAhPT0gdW5kZWZpbmVkICYmIC1lLmRldGFpbClcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvZmZzZXQgb2YgYSBET00gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtICB7RE9NRWxlbWVudH0gZG9tIFRoZSBlbGVtZW50IHRvIHJldHJpZXZlIHRoZSBwb3NpdGlvbi5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgIFRoZSBvZmZzZXQgb2YgdGhlIERPTSBlbGVtZW50ICh0b3AsIGxlZnQpLlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZ2V0T2Zmc2V0ID0gZnVuY3Rpb24oZG9tKSB7XG4gICAgdmFyIGxlZnQgPSAwLFxuICAgICAgICB0b3AgPSAwO1xuXG4gICAgd2hpbGUgKGRvbSkge1xuICAgICAgdG9wID0gdG9wICsgcGFyc2VJbnQoZG9tLm9mZnNldFRvcCk7XG4gICAgICBsZWZ0ID0gbGVmdCArIHBhcnNlSW50KGRvbS5vZmZzZXRMZWZ0KTtcbiAgICAgIGRvbSA9IGRvbS5vZmZzZXRQYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogdG9wLFxuICAgICAgbGVmdDogbGVmdFxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIFNpbXVsYXRlcyBhIFwiZG91YmxlIGNsaWNrXCIgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSB0YXJnZXQgICBUaGUgZXZlbnQgdGFyZ2V0LlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgdHlwZSAgICAgVGhlIGV2ZW50IHR5cGUuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSAgICBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gZXhlY3V0ZS5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmRvdWJsZUNsaWNrID0gZnVuY3Rpb24odGFyZ2V0LCB0eXBlLCBjYWxsYmFjaykge1xuICAgIHZhciBjbGlja3MgPSAwLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgaGFuZGxlcnM7XG5cbiAgICB0YXJnZXQuX2RvdWJsZUNsaWNrSGFuZGxlciA9IHRhcmdldC5fZG91YmxlQ2xpY2tIYW5kbGVyIHx8IHt9O1xuICAgIHRhcmdldC5fZG91YmxlQ2xpY2tIYW5kbGVyW3R5cGVdID0gdGFyZ2V0Ll9kb3VibGVDbGlja0hhbmRsZXJbdHlwZV0gfHwgW107XG4gICAgaGFuZGxlcnMgPSB0YXJnZXQuX2RvdWJsZUNsaWNrSGFuZGxlclt0eXBlXTtcblxuICAgIGhhbmRsZXJzLnB1c2goZnVuY3Rpb24oZSkge1xuICAgICAgY2xpY2tzKys7XG5cbiAgICAgIGlmIChjbGlja3MgPT09IDIpIHtcbiAgICAgICAgY2xpY2tzID0gMDtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpO1xuICAgICAgfSBlbHNlIGlmIChjbGlja3MgPT09IDEpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBjbGlja3MgPSAwO1xuICAgICAgICB9LCBzaWdtYS5zZXR0aW5ncy5kb3VibGVDbGlja1RpbWVvdXQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcnNbaGFuZGxlcnMubGVuZ3RoIC0gMV0sIGZhbHNlKTtcbiAgfTtcblxuICAvKipcbiAgICogVW5iaW5kIHNpbXVsYXRlZCBcImRvdWJsZSBjbGlja1wiIGV2ZW50cy5cbiAgICpcbiAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IHRhcmdldCAgIFRoZSBldmVudCB0YXJnZXQuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgICB0eXBlICAgICBUaGUgZXZlbnQgdHlwZS5cbiAgICovXG4gIHNpZ21hLnV0aWxzLnVuYmluZERvdWJsZUNsaWNrID0gZnVuY3Rpb24odGFyZ2V0LCB0eXBlKSB7XG4gICAgdmFyIGhhbmRsZXIsXG4gICAgICAgIGhhbmRsZXJzID0gKHRhcmdldC5fZG91YmxlQ2xpY2tIYW5kbGVyIHx8IHt9KVt0eXBlXSB8fCBbXTtcblxuICAgIHdoaWxlICgoaGFuZGxlciA9IGhhbmRsZXJzLnBvcCgpKSkge1xuICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcik7XG4gICAgfVxuXG4gICAgZGVsZXRlICh0YXJnZXQuX2RvdWJsZUNsaWNrSGFuZGxlciB8fCB7fSlbdHlwZV07XG4gIH07XG5cblxuXG5cbiAgLyoqXG4gICAqIEhlcmUgYXJlIGp1c3Qgc29tZSBvZiB0aGUgbW9zdCBiYXNpYyBlYXNpbmcgZnVuY3Rpb25zLCB1c2VkIGZvciB0aGVcbiAgICogYW5pbWF0ZWQgY2FtZXJhIFwiZ29Ub1wiIGNhbGxzLlxuICAgKlxuICAgKiBJZiB5b3UgbmVlZCBzb21lIG1vcmUgZWFzaW5ncyBmdW5jdGlvbnMsIGRvbid0IGhlc2l0YXRlIHRvIGFkZCB0aGVtIHRvXG4gICAqIHNpZ21hLnV0aWxzLmVhc2luZ3MuIEJ1dCBJIHdpbGwgbm90IGFkZCBzb21lIG1vcmUgaGVyZSBvciBtZXJnZSBQUnNcbiAgICogY29udGFpbmluZywgYmVjYXVzZSBJIGRvIG5vdCB3YW50IHNpZ21hIHNvdXJjZXMgZnVsbCBvZiBvdmVya2lsbCBhbmQgbmV2ZXJcbiAgICogdXNlZCBzdHVmZi4uLlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZWFzaW5ncyA9IHNpZ21hLnV0aWxzLmVhc2luZ3MgfHwge307XG4gIHNpZ21hLnV0aWxzLmVhc2luZ3MubGluZWFyTm9uZSA9IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gaztcbiAgfTtcbiAgc2lnbWEudXRpbHMuZWFzaW5ncy5xdWFkcmF0aWNJbiA9IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gayAqIGs7XG4gIH07XG4gIHNpZ21hLnV0aWxzLmVhc2luZ3MucXVhZHJhdGljT3V0ID0gZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBrICogKDIgLSBrKTtcbiAgfTtcbiAgc2lnbWEudXRpbHMuZWFzaW5ncy5xdWFkcmF0aWNJbk91dCA9IGZ1bmN0aW9uKGspIHtcbiAgICBpZiAoKGsgKj0gMikgPCAxKVxuICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrO1xuICAgIHJldHVybiAtIDAuNSAqICgtLWsgKiAoayAtIDIpIC0gMSk7XG4gIH07XG4gIHNpZ21hLnV0aWxzLmVhc2luZ3MuY3ViaWNJbiA9IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gayAqIGsgKiBrO1xuICB9O1xuICBzaWdtYS51dGlscy5lYXNpbmdzLmN1YmljT3V0ID0gZnVuY3Rpb24oaykge1xuICAgIHJldHVybiAtLWsgKiBrICogayArIDE7XG4gIH07XG4gIHNpZ21hLnV0aWxzLmVhc2luZ3MuY3ViaWNJbk91dCA9IGZ1bmN0aW9uKGspIHtcbiAgICBpZiAoKGsgKj0gMikgPCAxKVxuICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogaztcbiAgICByZXR1cm4gMC41ICogKChrIC09IDIpICogayAqIGsgKyAyKTtcbiAgfTtcblxuXG5cblxuICAvKipcbiAgICogKioqKioqKioqKioqXG4gICAqIFdFQkdMIFVUSUxTOlxuICAgKiAqKioqKioqKioqKipcbiAgICovXG4gIC8qKlxuICAgKiBMb2FkcyBhIFdlYkdMIHNoYWRlciBhbmQgcmV0dXJucyBpdC5cbiAgICpcbiAgICogQHBhcmFtICB7V2ViR0xDb250ZXh0fSAgICAgICAgICAgZ2wgICAgICAgICAgIFRoZSBXZWJHTENvbnRleHQgdG8gdXNlLlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgICAgICAgICAgICBzaGFkZXJTb3VyY2UgVGhlIHNoYWRlciBzb3VyY2UuXG4gICAqIEBwYXJhbSAge251bWJlcn0gICAgICAgICAgICAgICAgIHNoYWRlclR5cGUgICBUaGUgdHlwZSBvZiBzaGFkZXIuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9uKHN0cmluZyk6IHZvaWR9IGVycm9yICAgICAgICBDYWxsYmFjayBmb3IgZXJyb3JzLlxuICAgKiBAcmV0dXJuIHtXZWJHTFNoYWRlcn0gICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGNyZWF0ZWQgc2hhZGVyLlxuICAgKi9cbiAgc2lnbWEudXRpbHMubG9hZFNoYWRlciA9IGZ1bmN0aW9uKGdsLCBzaGFkZXJTb3VyY2UsIHNoYWRlclR5cGUsIGVycm9yKSB7XG4gICAgdmFyIGNvbXBpbGVkLFxuICAgICAgICBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoc2hhZGVyVHlwZSk7XG5cbiAgICAvLyBMb2FkIHRoZSBzaGFkZXIgc291cmNlXG4gICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc2hhZGVyU291cmNlKTtcblxuICAgIC8vIENvbXBpbGUgdGhlIHNoYWRlclxuICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcblxuICAgIC8vIENoZWNrIHRoZSBjb21waWxlIHN0YXR1c1xuICAgIGNvbXBpbGVkID0gZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpO1xuXG4gICAgLy8gSWYgc29tZXRoaW5nIHdlbnQgd3Jvbmc6XG4gICAgaWYgKCFjb21waWxlZCkge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGVycm9yKFxuICAgICAgICAgICdFcnJvciBjb21waWxpbmcgc2hhZGVyIFwiJyArIHNoYWRlciArICdcIjonICtcbiAgICAgICAgICBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcilcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgZ2wuZGVsZXRlU2hhZGVyKHNoYWRlcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gc2hhZGVyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcHJvZ3JhbSwgYXR0YWNoZXMgc2hhZGVycywgYmluZHMgYXR0cmliIGxvY2F0aW9ucywgbGlua3MgdGhlXG4gICAqIHByb2dyYW0gYW5kIGNhbGxzIHVzZVByb2dyYW0uXG4gICAqXG4gICAqIEBwYXJhbSAge0FycmF5LjxXZWJHTFNoYWRlcj59ICAgIHNoYWRlcnMgICBUaGUgc2hhZGVycyB0byBhdHRhY2guXG4gICAqIEBwYXJhbSAge0FycmF5LjxzdHJpbmc+fSAgICAgICAgIGF0dHJpYnMgICBUaGUgYXR0cmlicyBuYW1lcy5cbiAgICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59ICAgICAgICAgbG9jYXRpb25zIFRoZSBsb2NhdGlvbnMgZm9yIHRoZSBhdHRyaWJzLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbihzdHJpbmcpOiB2b2lkfSBlcnJvciAgICAgQ2FsbGJhY2sgZm9yIGVycm9ycy5cbiAgICogQHJldHVybiB7V2ViR0xQcm9ncmFtfSAgICAgICAgICAgICAgICAgICAgIFRoZSBjcmVhdGVkIHByb2dyYW0uXG4gICAqL1xuICBzaWdtYS51dGlscy5sb2FkUHJvZ3JhbSA9IGZ1bmN0aW9uKGdsLCBzaGFkZXJzLCBhdHRyaWJzLCBsb2MsIGVycm9yKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGxpbmtlZCxcbiAgICAgICAgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzaGFkZXJzLmxlbmd0aDsgKytpKVxuICAgICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHNoYWRlcnNbaV0pO1xuXG4gICAgaWYgKGF0dHJpYnMpXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYXR0cmlicy5sZW5ndGg7ICsraSlcbiAgICAgICAgZ2wuYmluZEF0dHJpYkxvY2F0aW9uKFxuICAgICAgICAgIHByb2dyYW0sXG4gICAgICAgICAgbG9jYXRpb25zID8gbG9jYXRpb25zW2ldIDogaSxcbiAgICAgICAgICBvcHRfYXR0cmlic1tpXVxuICAgICAgICApO1xuXG4gICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG5cbiAgICAvLyBDaGVjayB0aGUgbGluayBzdGF0dXNcbiAgICBsaW5rZWQgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKTtcbiAgICBpZiAoIWxpbmtlZCkge1xuICAgICAgaWYgKGVycm9yKVxuICAgICAgICBlcnJvcignRXJyb3IgaW4gcHJvZ3JhbSBsaW5raW5nOiAnICsgZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSkpO1xuXG4gICAgICBnbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb2dyYW07XG4gIH07XG5cblxuXG5cbiAgLyoqXG4gICAqICoqKioqKioqKlxuICAgKiBNQVRSSUNFUzpcbiAgICogKioqKioqKioqXG4gICAqIFRoZSBmb2xsb3dpbmcgdXRpbHMgYXJlIGp1c3QgaGVyZSB0byBoZWxwIGdlbmVyYXRpbmcgdGhlIHRyYW5zZm9ybWF0aW9uXG4gICAqIG1hdHJpY2VzIGZvciB0aGUgV2ViR0wgcmVuZGVyZXJzLlxuICAgKi9cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS51dGlscy5tYXRyaWNlcycpO1xuXG4gIC8qKlxuICAgKiBUaGUgcmV0dXJucyBhIDN4MyB0cmFuc2xhdGlvbiBtYXRyaXguXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0gZHggVGhlIFggdHJhbnNsYXRpb24uXG4gICAqIEBwYXJhbSAge251bWJlcn0gZHkgVGhlIFkgdHJhbnNsYXRpb24uXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgUmV0dXJucyB0aGUgbWF0cml4LlxuICAgKi9cbiAgc2lnbWEudXRpbHMubWF0cmljZXMudHJhbnNsYXRpb24gPSBmdW5jdGlvbihkeCwgZHkpIHtcbiAgICByZXR1cm4gW1xuICAgICAgMSwgMCwgMCxcbiAgICAgIDAsIDEsIDAsXG4gICAgICBkeCwgZHksIDFcbiAgICBdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgcmV0dXJucyBhIDN4MyBvciAyeDIgcm90YXRpb24gbWF0cml4LlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9ICBhbmdsZSBUaGUgcm90YXRpb24gYW5nbGUuXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IG0yICAgIElmIHRydWUsIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiBhIDJ4MiBtYXRyaXguXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgIFJldHVybnMgdGhlIG1hdHJpeC5cbiAgICovXG4gIHNpZ21hLnV0aWxzLm1hdHJpY2VzLnJvdGF0aW9uID0gZnVuY3Rpb24oYW5nbGUsIG0yKSB7XG4gICAgdmFyIGNvcyA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuXG4gICAgcmV0dXJuIG0yID8gW1xuICAgICAgY29zLCAtc2luLFxuICAgICAgc2luLCBjb3NcbiAgICBdIDogW1xuICAgICAgY29zLCAtc2luLCAwLFxuICAgICAgc2luLCBjb3MsIDAsXG4gICAgICAwLCAwLCAxXG4gICAgXTtcbiAgfTtcblxuICAvKipcbiAgICogVGhlIHJldHVybnMgYSAzeDMgb3IgMngyIGhvbW90aGV0aWMgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9ICByYXRpbyBUaGUgc2NhbGluZyByYXRpby5cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gbTIgICAgSWYgdHJ1ZSwgdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGEgMngyIG1hdHJpeC5cbiAgICogQHJldHVybiB7YXJyYXl9ICAgICAgICAgUmV0dXJucyB0aGUgbWF0cml4LlxuICAgKi9cbiAgc2lnbWEudXRpbHMubWF0cmljZXMuc2NhbGUgPSBmdW5jdGlvbihyYXRpbywgbTIpIHtcbiAgICByZXR1cm4gbTIgPyBbXG4gICAgICByYXRpbywgMCxcbiAgICAgIDAsIHJhdGlvXG4gICAgXSA6IFtcbiAgICAgIHJhdGlvLCAwLCAwLFxuICAgICAgMCwgcmF0aW8sIDAsXG4gICAgICAwLCAwLCAxXG4gICAgXTtcbiAgfTtcblxuICAvKipcbiAgICogVGhlIHJldHVybnMgYSAzeDMgb3IgMngyIGhvbW90aGV0aWMgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuICAgKlxuICAgKiBAcGFyYW0gIHthcnJheX0gICBhICBUaGUgZmlyc3QgbWF0cml4LlxuICAgKiBAcGFyYW0gIHthcnJheX0gICBiICBUaGUgc2Vjb25kIG1hdHJpeC5cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gbTIgSWYgdHJ1ZSwgdGhlIGZ1bmN0aW9uIHdpbGwgYXNzdW1lIGJvdGggbWF0cmljZXMgYXJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgIDJ4Mi5cbiAgICogQHJldHVybiB7YXJyYXl9ICAgICAgUmV0dXJucyB0aGUgbWF0cml4LlxuICAgKi9cbiAgc2lnbWEudXRpbHMubWF0cmljZXMubXVsdGlwbHkgPSBmdW5jdGlvbihhLCBiLCBtMikge1xuICAgIHZhciBsID0gbTIgPyAyIDogMyxcbiAgICAgICAgYTAwID0gYVswICogbCArIDBdLFxuICAgICAgICBhMDEgPSBhWzAgKiBsICsgMV0sXG4gICAgICAgIGEwMiA9IGFbMCAqIGwgKyAyXSxcbiAgICAgICAgYTEwID0gYVsxICogbCArIDBdLFxuICAgICAgICBhMTEgPSBhWzEgKiBsICsgMV0sXG4gICAgICAgIGExMiA9IGFbMSAqIGwgKyAyXSxcbiAgICAgICAgYTIwID0gYVsyICogbCArIDBdLFxuICAgICAgICBhMjEgPSBhWzIgKiBsICsgMV0sXG4gICAgICAgIGEyMiA9IGFbMiAqIGwgKyAyXSxcbiAgICAgICAgYjAwID0gYlswICogbCArIDBdLFxuICAgICAgICBiMDEgPSBiWzAgKiBsICsgMV0sXG4gICAgICAgIGIwMiA9IGJbMCAqIGwgKyAyXSxcbiAgICAgICAgYjEwID0gYlsxICogbCArIDBdLFxuICAgICAgICBiMTEgPSBiWzEgKiBsICsgMV0sXG4gICAgICAgIGIxMiA9IGJbMSAqIGwgKyAyXSxcbiAgICAgICAgYjIwID0gYlsyICogbCArIDBdLFxuICAgICAgICBiMjEgPSBiWzIgKiBsICsgMV0sXG4gICAgICAgIGIyMiA9IGJbMiAqIGwgKyAyXTtcblxuICAgIHJldHVybiBtMiA/IFtcbiAgICAgIGEwMCAqIGIwMCArIGEwMSAqIGIxMCxcbiAgICAgIGEwMCAqIGIwMSArIGEwMSAqIGIxMSxcbiAgICAgIGExMCAqIGIwMCArIGExMSAqIGIxMCxcbiAgICAgIGExMCAqIGIwMSArIGExMSAqIGIxMVxuICAgIF0gOiBbXG4gICAgICBhMDAgKiBiMDAgKyBhMDEgKiBiMTAgKyBhMDIgKiBiMjAsXG4gICAgICBhMDAgKiBiMDEgKyBhMDEgKiBiMTEgKyBhMDIgKiBiMjEsXG4gICAgICBhMDAgKiBiMDIgKyBhMDEgKiBiMTIgKyBhMDIgKiBiMjIsXG4gICAgICBhMTAgKiBiMDAgKyBhMTEgKiBiMTAgKyBhMTIgKiBiMjAsXG4gICAgICBhMTAgKiBiMDEgKyBhMTEgKiBiMTEgKyBhMTIgKiBiMjEsXG4gICAgICBhMTAgKiBiMDIgKyBhMTEgKiBiMTIgKyBhMTIgKiBiMjIsXG4gICAgICBhMjAgKiBiMDAgKyBhMjEgKiBiMTAgKyBhMjIgKiBiMjAsXG4gICAgICBhMjAgKiBiMDEgKyBhMjEgKiBiMTEgKyBhMjIgKiBiMjEsXG4gICAgICBhMjAgKiBiMDIgKyBhMjEgKiBiMTIgKyBhMjIgKiBiMjJcbiAgICBdO1xuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbihnbG9iYWwpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBodHRwOi8vcGF1bGlyaXNoLmNvbS8yMDExL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtYW5pbWF0aW5nL1xuICAgKiBodHRwOi8vbXkub3BlcmEuY29tL2Vtb2xsZXIvYmxvZy8yMDExLzEyLzIwL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtZXItYW5pbWF0aW5nXG4gICAqIHJlcXVlc3RBbmltYXRpb25GcmFtZSBwb2x5ZmlsbCBieSBFcmlrIE3DtmxsZXIuXG4gICAqIGZpeGVzIGZyb20gUGF1bCBJcmlzaCBhbmQgVGlubyBaaWpkZWxcbiAgICogTUlUIGxpY2Vuc2VcbiAgICovXG4gIHZhciB4LFxuICAgICAgbGFzdFRpbWUgPSAwLFxuICAgICAgdmVuZG9ycyA9IFsnbXMnLCAnbW96JywgJ3dlYmtpdCcsICdvJ107XG5cbiAgZm9yICh4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICFnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyB4KyspIHtcbiAgICBnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lID1cbiAgICAgIGdsb2JhbFt2ZW5kb3JzW3hdICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICAgIGdsb2JhbC5jYW5jZWxBbmltYXRpb25GcmFtZSA9XG4gICAgICBnbG9iYWxbdmVuZG9yc1t4XSArICdDYW5jZWxBbmltYXRpb25GcmFtZSddIHx8XG4gICAgICBnbG9iYWxbdmVuZG9yc1t4XSArICdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcbiAgfVxuXG4gIGlmICghZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSlcbiAgICBnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oY2FsbGJhY2ssIGVsZW1lbnQpIHtcbiAgICAgIHZhciBjdXJyVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpLFxuICAgICAgICAgIHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtIChjdXJyVGltZSAtIGxhc3RUaW1lKSksXG4gICAgICAgICAgaWQgPSBnbG9iYWwuc2V0VGltZW91dChcbiAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBjYWxsYmFjayhjdXJyVGltZSArIHRpbWVUb0NhbGwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRpbWVUb0NhbGxcbiAgICAgICAgICApO1xuXG4gICAgICBsYXN0VGltZSA9IGN1cnJUaW1lICsgdGltZVRvQ2FsbDtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9O1xuXG4gIGlmICghZ2xvYmFsLmNhbmNlbEFuaW1hdGlvbkZyYW1lKVxuICAgIGdsb2JhbC5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICBjbGVhclRpbWVvdXQoaWQpO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHBvbHlmaWxsIGZvdW5kIG9uIE1ETi5cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYmluZCNDb21wYXRpYmlsaXR5XG4gICAqIFB1YmxpYyBkb21haW5cbiAgICovXG4gIGlmICghRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihvVGhpcykge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAvLyBDbG9zZXN0IHRoaW5nIHBvc3NpYmxlIHRvIHRoZSBFQ01BU2NyaXB0IDUgaW50ZXJuYWwgSXNDYWxsYWJsZVxuICAgICAgICAvLyBmdW5jdGlvbjpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgLSB3aGF0IGlzIHRyeWluZyB0byBiZSBib3VuZCBpcyBub3QgY2FsbGFibGUnXG4gICAgICAgICk7XG5cbiAgICAgIHZhciBhQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG4gICAgICAgICAgZlRvQmluZCA9IHRoaXMsXG4gICAgICAgICAgZk5PUCxcbiAgICAgICAgICBmQm91bmQ7XG5cbiAgICAgIGZOT1AgPSBmdW5jdGlvbigpIHt9O1xuICAgICAgZkJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmVG9CaW5kLmFwcGx5KFxuICAgICAgICAgIHRoaXMgaW5zdGFuY2VvZiBmTk9QICYmIG9UaGlzID9cbiAgICAgICAgICAgIHRoaXMgOlxuICAgICAgICAgICAgb1RoaXMsXG4gICAgICAgICAgYUFyZ3MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICk7XG4gICAgICB9O1xuXG4gICAgICBmTk9QLnByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlO1xuICAgICAgZkJvdW5kLnByb3RvdHlwZSA9IG5ldyBmTk9QKCk7XG5cbiAgICAgIHJldHVybiBmQm91bmQ7XG4gICAgfTtcbn0pKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gUGFja2FnZXMgaW5pdGlhbGl6YXRpb246XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc2V0dGluZ3MnKTtcblxuICB2YXIgc2V0dGluZ3MgPSB7XG4gICAgLyoqXG4gICAgICogR1JBUEggU0VUVElOR1M6XG4gICAgICogKioqKioqKioqKioqKioqXG4gICAgICovXG4gICAgLy8ge2Jvb2xlYW59IEluZGljYXRlcyBpZiB0aGUgZGF0YSBoYXZlIHRvIGJlIGNsb25lZCBpbiBtZXRob2RzIHRvIGFkZFxuICAgIC8vICAgICAgICAgICBub2RlcyBvciBlZGdlcy5cbiAgICBjbG9uZTogdHJ1ZSxcbiAgICAvLyB7Ym9vbGVhbn0gSW5kaWNhdGVzIGlmIG5vZGVzIFwiaWRcIiB2YWx1ZXMgYW5kIGVkZ2VzIFwiaWRcIiwgXCJzb3VyY2VcIiBhbmRcbiAgICAvLyAgICAgICAgICAgXCJ0YXJnZXRcIiB2YWx1ZXMgbXVzdCBiZSBzZXQgYXMgaW1tdXRhYmxlLlxuICAgIGltbXV0YWJsZTogdHJ1ZSxcbiAgICAvLyB7Ym9vbGVhbn0gSW5kaWNhdGVzIGlmIHNpZ21hIGNhbiBsb2cgaXRzIGVycm9ycyBhbmQgd2FybmluZ3MuXG4gICAgdmVyYm9zZTogZmFsc2UsXG5cblxuICAgIC8qKlxuICAgICAqIFJFTkRFUkVSUyBTRVRUSU5HUzpcbiAgICAgKiAqKioqKioqKioqKioqKioqKioqXG4gICAgICovXG4gICAgLy8ge3N0cmluZ31cbiAgICBjbGFzc1ByZWZpeDogJ3NpZ21hJyxcbiAgICAvLyB7c3RyaW5nfVxuICAgIGRlZmF1bHROb2RlVHlwZTogJ2RlZicsXG4gICAgLy8ge3N0cmluZ31cbiAgICBkZWZhdWx0RWRnZVR5cGU6ICdkZWYnLFxuICAgIC8vIHtzdHJpbmd9XG4gICAgZGVmYXVsdExhYmVsQ29sb3I6ICcjMDAwJyxcbiAgICAvLyB7c3RyaW5nfVxuICAgIGRlZmF1bHRFZGdlQ29sb3I6ICcjMDAwJyxcbiAgICAvLyB7c3RyaW5nfVxuICAgIGRlZmF1bHROb2RlQ29sb3I6ICcjMDAwJyxcbiAgICAvLyB7c3RyaW5nfVxuICAgIGRlZmF1bHRMYWJlbFNpemU6IDE0LFxuICAgIC8vIHtzdHJpbmd9IEluZGljYXRlcyBob3cgdG8gY2hvb3NlIHRoZSBlZGdlcyBjb2xvci4gQXZhaWxhYmxlIHZhbHVlczpcbiAgICAvLyAgICAgICAgICBcInNvdXJjZVwiLCBcInRhcmdldFwiLCBcImRlZmF1bHRcIlxuICAgIGVkZ2VDb2xvcjogJ3NvdXJjZScsXG4gICAgLy8ge251bWJlcn0gRGVmaW5lcyB0aGUgbWluaW1hbCBlZGdlJ3MgYXJyb3cgZGlzcGxheSBzaXplLlxuICAgIG1pbkFycm93U2l6ZTogMCxcbiAgICAvLyB7c3RyaW5nfVxuICAgIGZvbnQ6ICdhcmlhbCcsXG4gICAgLy8ge3N0cmluZ30gRXhhbXBsZTogJ2JvbGQnXG4gICAgZm9udFN0eWxlOiAnJyxcbiAgICAvLyB7c3RyaW5nfSBJbmRpY2F0ZXMgaG93IHRvIGNob29zZSB0aGUgbGFiZWxzIGNvbG9yLiBBdmFpbGFibGUgdmFsdWVzOlxuICAgIC8vICAgICAgICAgIFwibm9kZVwiLCBcImRlZmF1bHRcIlxuICAgIGxhYmVsQ29sb3I6ICdkZWZhdWx0JyxcbiAgICAvLyB7c3RyaW5nfSBJbmRpY2F0ZXMgaG93IHRvIGNob29zZSB0aGUgbGFiZWxzIHNpemUuIEF2YWlsYWJsZSB2YWx1ZXM6XG4gICAgLy8gICAgICAgICAgXCJmaXhlZFwiLCBcInByb3BvcnRpb25hbFwiXG4gICAgbGFiZWxTaXplOiAnZml4ZWQnLFxuICAgIC8vIHtzdHJpbmd9IFRoZSByYXRpbyBiZXR3ZWVuIHRoZSBmb250IHNpemUgb2YgdGhlIGxhYmVsIGFuZCB0aGUgbm9kZSBzaXplLlxuICAgIGxhYmVsU2l6ZVJhdGlvOiAxLFxuICAgIC8vIHtudW1iZXJ9IFRoZSBtaW5pbXVtIHNpemUgYSBub2RlIG11c3QgaGF2ZSB0byBzZWUgaXRzIGxhYmVsIGRpc3BsYXllZC5cbiAgICBsYWJlbFRocmVzaG9sZDogOCxcbiAgICAvLyB7bnVtYmVyfSBUaGUgb3ZlcnNhbXBsaW5nIGZhY3RvciB1c2VkIGluIFdlYkdMIHJlbmRlcmVyLlxuICAgIHdlYmdsT3ZlcnNhbXBsaW5nUmF0aW86IDIsXG4gICAgLy8ge251bWJlcn0gVGhlIHNpemUgb2YgdGhlIGJvcmRlciBvZiBob3ZlcmVkIG5vZGVzLlxuICAgIGJvcmRlclNpemU6IDAsXG4gICAgLy8ge251bWJlcn0gVGhlIGRlZmF1bHQgaG92ZXJlZCBub2RlIGJvcmRlcidzIGNvbG9yLlxuICAgIGRlZmF1bHROb2RlQm9yZGVyQ29sb3I6ICcjMDAwJyxcbiAgICAvLyB7bnVtYmVyfSBUaGUgaG92ZXJlZCBub2RlJ3MgbGFiZWwgZm9udC4gSWYgbm90IHNwZWNpZmllZCwgd2lsbCBoZXJpdGF0ZVxuICAgIC8vICAgICAgICAgIHRoZSBcImZvbnRcIiB2YWx1ZS5cbiAgICBob3ZlckZvbnQ6ICcnLFxuICAgIC8vIHtib29sZWFufSBJZiB0cnVlLCB0aGVuIG9ubHkgb25lIG5vZGUgY2FuIGJlIGhvdmVyZWQgYXQgYSB0aW1lLlxuICAgIHNpbmdsZUhvdmVyOiB0cnVlLFxuICAgIC8vIHtzdHJpbmd9IEV4YW1wbGU6ICdib2xkJ1xuICAgIGhvdmVyRm9udFN0eWxlOiAnJyxcbiAgICAvLyB7c3RyaW5nfSBJbmRpY2F0ZXMgaG93IHRvIGNob29zZSB0aGUgaG92ZXJlZCBub2RlcyBzaGFkb3cgY29sb3IuXG4gICAgLy8gICAgICAgICAgQXZhaWxhYmxlIHZhbHVlczogXCJub2RlXCIsIFwiZGVmYXVsdFwiXG4gICAgbGFiZWxIb3ZlclNoYWRvdzogJ2RlZmF1bHQnLFxuICAgIC8vIHtzdHJpbmd9XG4gICAgbGFiZWxIb3ZlclNoYWRvd0NvbG9yOiAnIzAwMCcsXG4gICAgLy8ge3N0cmluZ30gSW5kaWNhdGVzIGhvdyB0byBjaG9vc2UgdGhlIGhvdmVyZWQgbm9kZXMgY29sb3IuXG4gICAgLy8gICAgICAgICAgQXZhaWxhYmxlIHZhbHVlczogXCJub2RlXCIsIFwiZGVmYXVsdFwiXG4gICAgbm9kZUhvdmVyQ29sb3I6ICdub2RlJyxcbiAgICAvLyB7c3RyaW5nfVxuICAgIGRlZmF1bHROb2RlSG92ZXJDb2xvcjogJyMwMDAnLFxuICAgIC8vIHtzdHJpbmd9IEluZGljYXRlcyBob3cgdG8gY2hvb3NlIHRoZSBob3ZlcmVkIG5vZGVzIGJhY2tncm91bmQgY29sb3IuXG4gICAgLy8gICAgICAgICAgQXZhaWxhYmxlIHZhbHVlczogXCJub2RlXCIsIFwiZGVmYXVsdFwiXG4gICAgbGFiZWxIb3ZlckJHQ29sb3I6ICdkZWZhdWx0JyxcbiAgICAvLyB7c3RyaW5nfVxuICAgIGRlZmF1bHRIb3ZlckxhYmVsQkdDb2xvcjogJyNmZmYnLFxuICAgIC8vIHtzdHJpbmd9IEluZGljYXRlcyBob3cgdG8gY2hvb3NlIHRoZSBob3ZlcmVkIGxhYmVscyBjb2xvci5cbiAgICAvLyAgICAgICAgICBBdmFpbGFibGUgdmFsdWVzOiBcIm5vZGVcIiwgXCJkZWZhdWx0XCJcbiAgICBsYWJlbEhvdmVyQ29sb3I6ICdkZWZhdWx0JyxcbiAgICAvLyB7c3RyaW5nfVxuICAgIGRlZmF1bHRMYWJlbEhvdmVyQ29sb3I6ICcjMDAwJyxcbiAgICAvLyB7c3RyaW5nfSBJbmRpY2F0ZXMgaG93IHRvIGNob29zZSB0aGUgZWRnZXMgaG92ZXIgY29sb3IuIEF2YWlsYWJsZSB2YWx1ZXM6XG4gICAgLy8gICAgICAgICAgXCJlZGdlXCIsIFwiZGVmYXVsdFwiXG4gICAgZWRnZUhvdmVyQ29sb3I6ICdlZGdlJyxcbiAgICAvLyB7bnVtYmVyfSBUaGUgc2l6ZSBtdWx0aXBsaWNhdG9yIG9mIGhvdmVyZWQgZWRnZXMuXG4gICAgZWRnZUhvdmVyU2l6ZVJhdGlvOiAxLFxuICAgIC8vIHtzdHJpbmd9XG4gICAgZGVmYXVsdEVkZ2VIb3ZlckNvbG9yOiAnIzAwMCcsXG4gICAgLy8ge2Jvb2xlYW59IEluZGljYXRlcyBpZiB0aGUgZWRnZSBleHRyZW1pdGllcyBtdXN0IGJlIGhvdmVyZWQgd2hlbiB0aGVcbiAgICAvLyAgICAgICAgICAgZWRnZSBpcyBob3ZlcmVkLlxuICAgIGVkZ2VIb3ZlckV4dHJlbWl0aWVzOiBmYWxzZSxcbiAgICAvLyB7Ym9vbGVhbnN9IFRoZSBkaWZmZXJlbnQgZHJhd2luZyBtb2RlczpcbiAgICAvLyAgICAgICAgICAgZmFsc2U6IExheWVyZWQgbm90IGRpc3BsYXllZC5cbiAgICAvLyAgICAgICAgICAgdHJ1ZTogTGF5ZXJlZCBkaXNwbGF5ZWQuXG4gICAgZHJhd0VkZ2VzOiB0cnVlLFxuICAgIGRyYXdOb2RlczogdHJ1ZSxcbiAgICBkcmF3TGFiZWxzOiB0cnVlLFxuICAgIGRyYXdFZGdlTGFiZWxzOiBmYWxzZSxcbiAgICAvLyB7Ym9vbGVhbn0gSW5kaWNhdGVzIGlmIHRoZSBlZGdlcyBtdXN0IGJlIGRyYXduIGluIHNldmVyYWwgZnJhbWVzIG9yIGluXG4gICAgLy8gICAgICAgICAgIG9uZSBmcmFtZSwgYXMgdGhlIG5vZGVzIGFuZCBsYWJlbHMgYXJlIGRyYXduLlxuICAgIGJhdGNoRWRnZXNEcmF3aW5nOiBmYWxzZSxcbiAgICAvLyB7Ym9vbGVhbn0gSW5kaWNhdGVzIGlmIHRoZSBlZGdlcyBtdXN0IGJlIGhpZGRlbiBkdXJpbmcgZHJhZ2dpbmcgYW5kXG4gICAgLy8gICAgICAgICAgIGFuaW1hdGlvbnMuXG4gICAgaGlkZUVkZ2VzT25Nb3ZlOiBmYWxzZSxcbiAgICAvLyB7bnVtYmVyc30gVGhlIGRpZmZlcmVudCBiYXRjaCBzaXplcywgd2hlbiBlbGVtZW50cyBhcmUgZGlzcGxheWVkIGluXG4gICAgLy8gICAgICAgICAgIHNldmVyYWwgZnJhbWVzLlxuICAgIGNhbnZhc0VkZ2VzQmF0Y2hTaXplOiA1MDAsXG4gICAgd2ViZ2xFZGdlc0JhdGNoU2l6ZTogMTAwMCxcblxuXG5cblxuICAgIC8qKlxuICAgICAqIFJFU0NBTEUgU0VUVElOR1M6XG4gICAgICogKioqKioqKioqKioqKioqKipcbiAgICAgKi9cbiAgICAvLyB7c3RyaW5nfSBJbmRpY2F0ZXMgb2YgdG8gc2NhbGUgdGhlIGdyYXBoIHJlbGF0aXZlbHkgdG8gaXRzIGNvbnRhaW5lci5cbiAgICAvLyAgICAgICAgICBBdmFpbGFibGUgdmFsdWVzOiBcImluc2lkZVwiLCBcIm91dHNpZGVcIlxuICAgIHNjYWxpbmdNb2RlOiAnaW5zaWRlJyxcbiAgICAvLyB7bnVtYmVyfSBUaGUgbWFyZ2luIHRvIGtlZXAgYXJvdW5kIHRoZSBncmFwaC5cbiAgICBzaWRlTWFyZ2luOiAwLFxuICAgIC8vIHtudW1iZXJ9IERldGVybWluZSB0aGUgc2l6ZSBvZiB0aGUgc21hbGxlc3QgYW5kIHRoZSBiaWdnZXN0IG5vZGUgLyBlZGdlc1xuICAgIC8vICAgICAgICAgIG9uIHRoZSBzY3JlZW4uIFRoaXMgbWFwcGluZyBtYWtlcyBlYXNpZXIgdG8gZGlzcGxheSB0aGUgZ3JhcGgsXG4gICAgLy8gICAgICAgICAgYXZvaWRpbmcgdG9vIGJpZyBub2RlcyB0aGF0IHRha2UgaGFsZiBvZiB0aGUgc2NyZWVuLCBvciB0b29cbiAgICAvLyAgICAgICAgICBzbWFsbCBvbmVzIHRoYXQgYXJlIG5vdCByZWFkYWJsZS4gSWYgdGhlIHR3byBwYXJhbWV0ZXJzIGFyZVxuICAgIC8vICAgICAgICAgIGVxdWFscywgdGhlbiB0aGUgbWluaW1hbCBkaXNwbGF5IHNpemUgd2lsbCBiZSAwLiBBbmQgaWYgdGhleVxuICAgIC8vICAgICAgICAgIGFyZSBib3RoIGVxdWFsIHRvIDAsIHRoZW4gdGhlcmUgaXMgbm8gbWFwcGluZywgYW5kIHRoZSByYWRpdXNcbiAgICAvLyAgICAgICAgICBvZiB0aGUgbm9kZXMgd2lsbCBiZSB0aGVpciBzaXplLlxuICAgIG1pbkVkZ2VTaXplOiAwLjUsXG4gICAgbWF4RWRnZVNpemU6IDEsXG4gICAgbWluTm9kZVNpemU6IDEsXG4gICAgbWF4Tm9kZVNpemU6IDgsXG5cblxuXG5cbiAgICAvKipcbiAgICAgKiBDQVBUT1JTIFNFVFRJTkdTOlxuICAgICAqICoqKioqKioqKioqKioqKioqXG4gICAgICovXG4gICAgLy8ge2Jvb2xlYW59XG4gICAgdG91Y2hFbmFibGVkOiB0cnVlLFxuICAgIC8vIHtib29sZWFufVxuICAgIG1vdXNlRW5hYmxlZDogdHJ1ZSxcbiAgICAvLyB7Ym9vbGVhbn1cbiAgICBtb3VzZVdoZWVsRW5hYmxlZDogdHJ1ZSxcbiAgICAvLyB7Ym9vbGVhbn1cbiAgICBkb3VibGVDbGlja0VuYWJsZWQ6IHRydWUsXG4gICAgLy8ge2Jvb2xlYW59IERlZmluZXMgd2hldGhlciB0aGUgY3VzdG9tIGV2ZW50cyBzdWNoIGFzIFwiY2xpY2tOb2RlXCIgY2FuIGJlXG4gICAgLy8gICAgICAgICAgIHVzZWQuXG4gICAgZXZlbnRzRW5hYmxlZDogdHJ1ZSxcbiAgICAvLyB7bnVtYmVyfSBEZWZpbmVzIGJ5IGhvdyBtdWNoIG11bHRpcGxpY2F0aW5nIHRoZSB6b29taW5nIGxldmVsIHdoZW4gdGhlXG4gICAgLy8gICAgICAgICAgdXNlciB6b29tcyB3aXRoIHRoZSBtb3VzZS13aGVlbC5cbiAgICB6b29taW5nUmF0aW86IDEuNyxcbiAgICAvLyB7bnVtYmVyfSBEZWZpbmVzIGJ5IGhvdyBtdWNoIG11bHRpcGxpY2F0aW5nIHRoZSB6b29taW5nIGxldmVsIHdoZW4gdGhlXG4gICAgLy8gICAgICAgICAgdXNlciB6b29tcyBieSBkb3VibGUgY2xpY2tpbmcuXG4gICAgZG91YmxlQ2xpY2tab29taW5nUmF0aW86IDIuMixcbiAgICAvLyB7bnVtYmVyfSBUaGUgbWluaW11bSB6b29taW5nIGxldmVsLlxuICAgIHpvb21NaW46IDAuMDYyNSxcbiAgICAvLyB7bnVtYmVyfSBUaGUgbWF4aW11bSB6b29taW5nIGxldmVsLlxuICAgIHpvb21NYXg6IDIsXG4gICAgLy8ge251bWJlcn0gVGhlIGR1cmF0aW9uIG9mIGFuaW1hdGlvbnMgZm9sbG93aW5nIGEgbW91c2Ugc2Nyb2xsaW5nLlxuICAgIG1vdXNlWm9vbUR1cmF0aW9uOiAyMDAsXG4gICAgLy8ge251bWJlcn0gVGhlIGR1cmF0aW9uIG9mIGFuaW1hdGlvbnMgZm9sbG93aW5nIGEgbW91c2UgZG91YmxlIGNsaWNrLlxuICAgIGRvdWJsZUNsaWNrWm9vbUR1cmF0aW9uOiAyMDAsXG4gICAgLy8ge251bWJlcn0gVGhlIGR1cmF0aW9uIG9mIGFuaW1hdGlvbnMgZm9sbG93aW5nIGEgbW91c2UgZHJvcHBpbmcuXG4gICAgbW91c2VJbmVydGlhRHVyYXRpb246IDIwMCxcbiAgICAvLyB7bnVtYmVyfSBUaGUgaW5lcnRpYSBwb3dlciAobW91c2UgY2FwdG9yKS5cbiAgICBtb3VzZUluZXJ0aWFSYXRpbzogMyxcbiAgICAvLyB7bnVtYmVyfSBUaGUgZHVyYXRpb24gb2YgYW5pbWF0aW9ucyBmb2xsb3dpbmcgYSB0b3VjaCBkcm9wcGluZy5cbiAgICB0b3VjaEluZXJ0aWFEdXJhdGlvbjogMjAwLFxuICAgIC8vIHtudW1iZXJ9IFRoZSBpbmVydGlhIHBvd2VyICh0b3VjaCBjYXB0b3IpLlxuICAgIHRvdWNoSW5lcnRpYVJhdGlvOiAzLFxuICAgIC8vIHtudW1iZXJ9IFRoZSBtYXhpbXVtIHRpbWUgYmV0d2VlbiB0d28gY2xpY2tzIHRvIG1ha2UgaXQgYSBkb3VibGUgY2xpY2suXG4gICAgZG91YmxlQ2xpY2tUaW1lb3V0OiAzMDAsXG4gICAgLy8ge251bWJlcn0gVGhlIG1heGltdW0gdGltZSBiZXR3ZWVuIHR3byB0YXBzIHRvIG1ha2UgaXQgYSBkb3VibGUgdGFwLlxuICAgIGRvdWJsZVRhcFRpbWVvdXQ6IDMwMCxcbiAgICAvLyB7bnVtYmVyfSBUaGUgbWF4aW11bSB0aW1lIG9mIGRyYWdnaW5nIHRvIHRyaWdnZXIgaW50ZXJ0aWEuXG4gICAgZHJhZ1RpbWVvdXQ6IDIwMCxcblxuXG5cblxuICAgIC8qKlxuICAgICAqIEdMT0JBTCBTRVRUSU5HUzpcbiAgICAgKiAqKioqKioqKioqKioqKioqXG4gICAgICovXG4gICAgLy8ge2Jvb2xlYW59IERldGVybWluZXMgd2hldGhlciB0aGUgaW5zdGFuY2UgaGFzIHRvIHJlZnJlc2ggaXRzZWxmXG4gICAgLy8gICAgICAgICAgIGF1dG9tYXRpY2FsbHkgd2hlbiBhIFwicmVzaXplXCIgZXZlbnQgaXMgZGlzcGF0Y2hlZCBmcm9tIHRoZVxuICAgIC8vICAgICAgICAgICB3aW5kb3cgb2JqZWN0LlxuICAgIGF1dG9SZXNpemU6IHRydWUsXG4gICAgLy8ge2Jvb2xlYW59IERldGVybWluZXMgd2hldGhlciB0aGUgXCJyZXNjYWxlXCIgbWlkZGxld2FyZSBoYXMgdG8gYmUgY2FsbGVkXG4gICAgLy8gICAgICAgICAgIGF1dG9tYXRpY2FsbHkgZm9yIGVhY2ggY2FtZXJhIG9uIHJlZnJlc2guXG4gICAgYXV0b1Jlc2NhbGU6IHRydWUsXG4gICAgLy8ge2Jvb2xlYW59IElmIHNldCB0byBmYWxzZSwgdGhlIGNhbWVyYSBtZXRob2QgXCJnb1RvXCIgd2lsbCBiYXNpY2FsbHkgZG9cbiAgICAvLyAgICAgICAgICAgbm90aGluZy5cbiAgICBlbmFibGVDYW1lcmE6IHRydWUsXG4gICAgLy8ge2Jvb2xlYW59IElmIHNldCB0byBmYWxzZSwgdGhlIG5vZGVzIGNhbm5vdCBiZSBob3ZlcmVkLlxuICAgIGVuYWJsZUhvdmVyaW5nOiB0cnVlLFxuICAgIC8vIHtib29sZWFufSBJZiBzZXQgdG8gdHJ1ZSwgdGhlIGVkZ2VzIGNhbiBiZSBob3ZlcmVkLlxuICAgIGVuYWJsZUVkZ2VIb3ZlcmluZzogZmFsc2UsXG4gICAgLy8ge251bWJlcn0gVGhlIHNpemUgb2YgdGhlIGFyZWEgYXJvdW5kIHRoZSBlZGdlcyB0byBhY3RpdmF0ZSBob3ZlcmluZy5cbiAgICBlZGdlSG92ZXJQcmVjaXNpb246IDUsXG4gICAgLy8ge2Jvb2xlYW59IElmIHNldCB0byB0cnVlLCB0aGUgcmVzY2FsZSBtaWRkbGV3YXJlIHdpbGwgaWdub3JlIG5vZGUgc2l6ZXNcbiAgICAvLyAgICAgICAgICAgdG8gZGV0ZXJtaW5lIHRoZSBncmFwaHMgYm91bmRpbmdzLlxuICAgIHJlc2NhbGVJZ25vcmVTaXplOiBmYWxzZSxcbiAgICAvLyB7Ym9vbGVhbn0gRGV0ZXJtaW5lcyBpZiB0aGUgY29yZSBoYXMgdG8gdHJ5IHRvIGNhdGNoIGVycm9ycyBvblxuICAgIC8vICAgICAgICAgICByZW5kZXJpbmcuXG4gICAgc2tpcEVycm9yczogZmFsc2UsXG5cblxuXG5cbiAgICAvKipcbiAgICAgKiBDQU1FUkEgU0VUVElOR1M6XG4gICAgICogKioqKioqKioqKioqKioqKlxuICAgICAqL1xuICAgIC8vIHtudW1iZXJ9IFRoZSBwb3dlciBkZWdyZWVzIGFwcGxpZWQgdG8gdGhlIG5vZGVzL2VkZ2VzIHNpemUgcmVsYXRpdmVseSB0b1xuICAgIC8vICAgICAgICAgIHRoZSB6b29taW5nIGxldmVsLiBCYXNpY2FsbHk6XG4gICAgLy8gICAgICAgICAgID4gb25TY3JlZW5SID0gTWF0aC5wb3coem9vbSwgbm9kZXNQb3dSYXRpbykgKiBSXG4gICAgLy8gICAgICAgICAgID4gb25TY3JlZW5UID0gTWF0aC5wb3coem9vbSwgZWRnZXNQb3dSYXRpbykgKiBUXG4gICAgbm9kZXNQb3dSYXRpbzogMC41LFxuICAgIGVkZ2VzUG93UmF0aW86IDAuNSxcblxuXG5cblxuICAgIC8qKlxuICAgICAqIEFOSU1BVElPTlMgU0VUVElOR1M6XG4gICAgICogKioqKioqKioqKioqKioqKioqKipcbiAgICAgKi9cbiAgICAvLyB7bnVtYmVyfSBUaGUgZGVmYXVsdCBhbmltYXRpb24gdGltZS5cbiAgICBhbmltYXRpb25zVGltZTogMjAwXG4gIH07XG5cbiAgLy8gRXhwb3J0IHRoZSBwcmV2aW91c2x5IGRlc2lnbmVkIHNldHRpbmdzOlxuICBzaWdtYS5zZXR0aW5ncyA9IHNpZ21hLnV0aWxzLmV4dGVuZChzaWdtYS5zZXR0aW5ncyB8fCB7fSwgc2V0dGluZ3MpO1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVyIGNvbnN0cnVjdG9yLlxuICAgKlxuICAgKiBAcmV0dXJuIHtkaXNwYXRjaGVyfSBUaGUgbmV3IGRpc3BhdGNoZXIgaW5zdGFuY2UuXG4gICAqL1xuICB2YXIgZGlzcGF0Y2hlciA9IGZ1bmN0aW9uKCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX2hhbmRsZXJzJywge1xuICAgICAgdmFsdWU6IHt9XG4gICAgfSk7XG4gIH07XG5cblxuXG5cbiAgLyoqXG4gICAqIFdpbGwgZXhlY3V0ZSB0aGUgaGFuZGxlciBldmVyeXRpbWUgdGhhdCB0aGUgaW5kaWNhdGVkIGV2ZW50IChvciB0aGVcbiAgICogaW5kaWNhdGVkIGV2ZW50cykgd2lsbCBiZSB0cmlnZ2VyZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgIGV2ZW50cyAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IChvciB0aGUgZXZlbnRzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VwYXJhdGVkIGJ5IHNwYWNlcykuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9uKE9iamVjdCl9IGhhbmRsZXIgVGhlIGhhbmRsZXIgdG8gYmluZC5cbiAgICogQHJldHVybiB7ZGlzcGF0Y2hlcn0gICAgICAgICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBkaXNwYXRjaGVyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIGV2ZW50LFxuICAgICAgICBlQXJyYXk7XG5cbiAgICBpZiAoXG4gICAgICBhcmd1bWVudHMubGVuZ3RoID09PSAxICYmXG4gICAgICB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnb2JqZWN0J1xuICAgIClcbiAgICAgIGZvciAoZXZlbnRzIGluIGFyZ3VtZW50c1swXSlcbiAgICAgICAgdGhpcy5iaW5kKGV2ZW50cywgYXJndW1lbnRzWzBdW2V2ZW50c10pO1xuICAgIGVsc2UgaWYgKFxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICkge1xuICAgICAgZUFycmF5ID0gdHlwZW9mIGV2ZW50cyA9PT0gJ3N0cmluZycgPyBldmVudHMuc3BsaXQoJyAnKSA6IGV2ZW50cztcblxuICAgICAgZm9yIChpID0gMCwgbCA9IGVBcnJheS5sZW5ndGg7IGkgIT09IGw7IGkgKz0gMSkge1xuICAgICAgICBldmVudCA9IGVBcnJheVtpXTtcblxuICAgICAgICAvLyBDaGVjayB0aGF0IGV2ZW50IGlzIG5vdCAnJzpcbiAgICAgICAgaWYgKCFldmVudClcbiAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICBpZiAoIXRoaXMuX2hhbmRsZXJzW2V2ZW50XSlcbiAgICAgICAgICB0aGlzLl9oYW5kbGVyc1tldmVudF0gPSBbXTtcblxuICAgICAgICAvLyBVc2luZyBhbiBvYmplY3QgaW5zdGVhZCBvZiBkaXJlY3RseSB0aGUgaGFuZGxlciB3aWxsIG1ha2UgcG9zc2libGVcbiAgICAgICAgLy8gbGF0ZXIgdG8gYWRkIGZsYWdzXG4gICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50XS5wdXNoKHtcbiAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZVxuICAgICAgdGhyb3cgJ2JpbmQ6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGhhbmRsZXIgZnJvbSBhIHNwZWNpZmllZCBldmVudCAob3Igc3BlY2lmaWVkIGV2ZW50cykuXG4gICAqXG4gICAqIEBwYXJhbSAgez9zdHJpbmd9ICAgICAgICAgICBldmVudHMgIFRoZSBuYW1lIG9mIHRoZSBldmVudCAob3IgdGhlIGV2ZW50c1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0ZWQgYnkgc3BhY2VzKS4gSWYgdW5kZWZpbmVkLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVuIGFsbCBoYW5kbGVycyBhcmUgcmVtb3ZlZC5cbiAgICogQHBhcmFtICB7P2Z1bmN0aW9uKG9iamVjdCl9IGhhbmRsZXIgVGhlIGhhbmRsZXIgdG8gdW5iaW5kLiBJZiB1bmRlZmluZWQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhY2ggaGFuZGxlciBib3VuZCB0byB0aGUgZXZlbnQgb3IgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cyB3aWxsIGJlIHJlbW92ZWQuXG4gICAqIEByZXR1cm4ge2Rpc3BhdGNoZXJ9ICAgICAgICAgICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIGRpc3BhdGNoZXIucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uKGV2ZW50cywgaGFuZGxlcikge1xuICAgIHZhciBpLFxuICAgICAgICBuLFxuICAgICAgICBqLFxuICAgICAgICBtLFxuICAgICAgICBrLFxuICAgICAgICBhLFxuICAgICAgICBldmVudCxcbiAgICAgICAgZUFycmF5ID0gdHlwZW9mIGV2ZW50cyA9PT0gJ3N0cmluZycgPyBldmVudHMuc3BsaXQoJyAnKSA6IGV2ZW50cztcblxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgZm9yIChrIGluIHRoaXMuX2hhbmRsZXJzKVxuICAgICAgICBkZWxldGUgdGhpcy5faGFuZGxlcnNba107XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgZm9yIChpID0gMCwgbiA9IGVBcnJheS5sZW5ndGg7IGkgIT09IG47IGkgKz0gMSkge1xuICAgICAgICBldmVudCA9IGVBcnJheVtpXTtcbiAgICAgICAgaWYgKHRoaXMuX2hhbmRsZXJzW2V2ZW50XSkge1xuICAgICAgICAgIGEgPSBbXTtcbiAgICAgICAgICBmb3IgKGogPSAwLCBtID0gdGhpcy5faGFuZGxlcnNbZXZlbnRdLmxlbmd0aDsgaiAhPT0gbTsgaiArPSAxKVxuICAgICAgICAgICAgaWYgKHRoaXMuX2hhbmRsZXJzW2V2ZW50XVtqXS5oYW5kbGVyICE9PSBoYW5kbGVyKVxuICAgICAgICAgICAgICBhLnB1c2godGhpcy5faGFuZGxlcnNbZXZlbnRdW2pdKTtcblxuICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50XSA9IGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faGFuZGxlcnNbZXZlbnRdICYmIHRoaXMuX2hhbmRsZXJzW2V2ZW50XS5sZW5ndGggPT09IDApXG4gICAgICAgICAgZGVsZXRlIHRoaXMuX2hhbmRsZXJzW2V2ZW50XTtcbiAgICAgIH1cbiAgICB9IGVsc2VcbiAgICAgIGZvciAoaSA9IDAsIG4gPSBlQXJyYXkubGVuZ3RoOyBpICE9PSBuOyBpICs9IDEpXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9oYW5kbGVyc1tlQXJyYXlbaV1dO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGVhY2ggaGFuZGxlciBib3VuZCB0byB0aGUgZXZlbnRcbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgZXZlbnRzIFRoZSBuYW1lIG9mIHRoZSBldmVudCAob3IgdGhlIGV2ZW50cyBzZXBhcmF0ZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5IHNwYWNlcykuXG4gICAqIEBwYXJhbSAgez9vYmplY3R9ICAgIGRhdGEgICBUaGUgY29udGVudCBvZiB0aGUgZXZlbnQgKG9wdGlvbmFsKS5cbiAgICogQHJldHVybiB7ZGlzcGF0Y2hlcn0gICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIGRpc3BhdGNoZXIucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihldmVudHMsIGRhdGEpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbixcbiAgICAgICAgaixcbiAgICAgICAgbSxcbiAgICAgICAgYSxcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIGV2ZW50TmFtZSxcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIGVBcnJheSA9IHR5cGVvZiBldmVudHMgPT09ICdzdHJpbmcnID8gZXZlbnRzLnNwbGl0KCcgJykgOiBldmVudHM7XG5cbiAgICBkYXRhID0gZGF0YSA9PT0gdW5kZWZpbmVkID8ge30gOiBkYXRhO1xuXG4gICAgZm9yIChpID0gMCwgbiA9IGVBcnJheS5sZW5ndGg7IGkgIT09IG47IGkgKz0gMSkge1xuICAgICAgZXZlbnROYW1lID0gZUFycmF5W2ldO1xuXG4gICAgICBpZiAodGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXSkge1xuICAgICAgICBldmVudCA9IHNlbGYuZ2V0RXZlbnQoZXZlbnROYW1lLCBkYXRhKTtcbiAgICAgICAgYSA9IFtdO1xuXG4gICAgICAgIGZvciAoaiA9IDAsIG0gPSB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdLmxlbmd0aDsgaiAhPT0gbTsgaiArPSAxKSB7XG4gICAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXVtqXS5oYW5kbGVyKGV2ZW50KTtcbiAgICAgICAgICBpZiAoIXRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV1bal0ub25lKVxuICAgICAgICAgICAgYS5wdXNoKHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV1bal0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXSA9IGE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBldmVudCBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gIGV2ZW50cyBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXG4gICAqIEBwYXJhbSAgez9vYmplY3R9IGRhdGEgICBUaGUgY29udGVudCBvZiB0aGUgZXZlbnQgKG9wdGlvbmFsKS5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIGRpc3BhdGNoZXIucHJvdG90eXBlLmdldEV2ZW50ID0gZnVuY3Rpb24oZXZlbnQsIGRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogZXZlbnQsXG4gICAgICBkYXRhOiBkYXRhIHx8IHt9LFxuICAgICAgdGFyZ2V0OiB0aGlzXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogQSB1c2VmdWwgZnVuY3Rpb24gdG8gZGVhbCB3aXRoIGluaGVyaXRhbmNlLiBJdCB3aWxsIG1ha2UgdGhlIHRhcmdldFxuICAgKiBpbmhlcml0IHRoZSBwcm90b3R5cGUgb2YgdGhlIGNsYXNzIGRpc3BhdGNoZXIgYXMgd2VsbCBhcyBpdHMgY29uc3RydWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgVGhlIHRhcmdldC5cbiAgICovXG4gIGRpc3BhdGNoZXIuZXh0ZW5kID0gZnVuY3Rpb24odGFyZ2V0LCBhcmdzKSB7XG4gICAgdmFyIGs7XG5cbiAgICBmb3IgKGsgaW4gZGlzcGF0Y2hlci5wcm90b3R5cGUpXG4gICAgICBpZiAoZGlzcGF0Y2hlci5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoaykpXG4gICAgICAgIHRhcmdldFtrXSA9IGRpc3BhdGNoZXIucHJvdG90eXBlW2tdO1xuXG4gICAgZGlzcGF0Y2hlci5hcHBseSh0YXJnZXQsIGFyZ3MpO1xuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiBFWFBPUlQ6XG4gICAqICoqKioqKipcbiAgICovXG4gIGlmICh0eXBlb2YgdGhpcy5zaWdtYSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLnNpZ21hLmNsYXNzZXMgPSB0aGlzLnNpZ21hLmNsYXNzZXMgfHwge307XG4gICAgdGhpcy5zaWdtYS5jbGFzc2VzLmRpc3BhdGNoZXIgPSBkaXNwYXRjaGVyO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cylcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGRpc3BhdGNoZXI7XG4gICAgZXhwb3J0cy5kaXNwYXRjaGVyID0gZGlzcGF0Y2hlcjtcbiAgfSBlbHNlXG4gICAgdGhpcy5kaXNwYXRjaGVyID0gZGlzcGF0Y2hlcjtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogVGhpcyB1dGlscyBhaW1zIHRvIGZhY2lsaXRhdGUgdGhlIG1hbmlwdWxhdGlvbiBvZiBlYWNoIGluc3RhbmNlIHNldHRpbmcuXG4gICAqIFVzaW5nIGEgZnVuY3Rpb24gaW5zdGVhZCBvZiBhbiBvYmplY3QgYnJpbmdzIHR3byBtYWluIGFkdmFudGFnZXM6IEZpcnN0LFxuICAgKiBpdCB3aWxsIGJlIGVhc2llciBpbiB0aGUgZnV0dXJlIHRvIGNhdGNoIHNldHRpbmdzIHVwZGF0ZXMgdGhyb3VnaCBhXG4gICAqIGZ1bmN0aW9uIHRoYW4gYW4gb2JqZWN0LiBTZWNvbmQsIGdpdmluZyBpdCBhIGZ1bGwgb2JqZWN0IHdpbGwgXCJtZXJnZVwiIGl0XG4gICAqIHRvIHRoZSBzZXR0aW5ncyBvYmplY3QgcHJvcGVybHksIGtlZXBpbmcgdXMgdG8gaGF2ZSB0byBhbHdheXMgYWRkIGEgbG9vcC5cbiAgICpcbiAgICogQHJldHVybiB7Y29uZmlndXJhYmxlfSBUaGUgXCJzZXR0aW5nc1wiIGZ1bmN0aW9uLlxuICAgKi9cbiAgdmFyIGNvbmZpZ3VyYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICBkYXRhID0ge30sXG4gICAgICAgIGRhdGFzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtZXRob2QgdG8gdXNlIHRvIHNldCBvciBnZXQgYW55IHByb3BlcnR5IG9mIHRoaXMgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd8b2JqZWN0fSAgICBhMSBJZiBpdCBpcyBhIHN0cmluZyBhbmQgaWYgYTIgaXMgdW5kZWZpbmVkLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4gaXQgd2lsbCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eS4gSWYgaXQgaXMgYSBzdHJpbmcgYW5kIGlmIGEyIGlzXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0LCB0aGVuIGl0IHdpbGwgc2V0IGEyIGFzIHRoZSBwcm9wZXJ0eVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRpbmcgdG8gYTEsIGFuZCByZXR1cm4gdGhpcy4gSWZcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdCBpcyBhbiBvYmplY3QsIHRoZW4gZWFjaCBwYWlyIHN0cmluZyArXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0KG9yIGFueSBvdGhlciB0eXBlKSB3aWxsIGJlIHNldCBhcyBhXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkuXG4gICAgICogQHBhcmFtICB7Kj99ICAgICAgICAgICAgICAgYTIgVGhlIG5ldyBwcm9wZXJ0eSBjb3JyZXNwb25kaW5nIHRvIGExIGlmIGExXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgYSBzdHJpbmcuXG4gICAgICogQHJldHVybiB7Knxjb25maWd1cmFibGV9ICAgICAgUmV0dXJucyBpdHNlbGYgb3IgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIFBvbHltb3JwaGlzbTpcbiAgICAgKiAqKioqKioqKioqKioqXG4gICAgICogSGVyZSBhcmUgc29tZSBiYXNpYyB1c2UgZXhhbXBsZXM6XG4gICAgICpcbiAgICAgKiAgPiBzZXR0aW5ncyA9IG5ldyBjb25maWd1cmFibGUoKTtcbiAgICAgKiAgPiBzZXR0aW5ncygnbXlTZXR0aW5nJywgNDIpO1xuICAgICAqICA+IHNldHRpbmdzKCdteVNldHRpbmcnKTsgLy8gTG9nczogNDJcbiAgICAgKiAgPiBzZXR0aW5ncygnbXlTZXR0aW5nJywgMTIzKTtcbiAgICAgKiAgPiBzZXR0aW5ncygnbXlTZXR0aW5nJyk7IC8vIExvZ3M6IDEyM1xuICAgICAqICA+IHNldHRpbmdzKHtteVNldHRpbmc6IDQ1Nn0pO1xuICAgICAqICA+IHNldHRpbmdzKCdteVNldHRpbmcnKTsgLy8gTG9nczogNDU2XG4gICAgICpcbiAgICAgKiBBbHNvLCBpdCBpcyBwb3NzaWJsZSB0byB1c2UgdGhlIGZ1bmN0aW9uIGFzIGEgZmFsbGJhY2s6XG4gICAgICogID4gc2V0dGluZ3Moe215U2V0dGluZzogJ2FiYyd9LCAnbXlTZXR0aW5nJyk7ICAvLyBMb2dzOiAnYWJjJ1xuICAgICAqICA+IHNldHRpbmdzKHtoaXNTZXR0aW5nOiAnYWJjJ30sICdteVNldHRpbmcnKTsgLy8gTG9nczogNDU2XG4gICAgICovXG4gICAgdmFyIHNldHRpbmdzID0gZnVuY3Rpb24oYTEsIGEyKSB7XG4gICAgICB2YXIgbyxcbiAgICAgICAgICBpLFxuICAgICAgICAgIGwsXG4gICAgICAgICAgaztcblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGExID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoZGF0YVthMV0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICByZXR1cm4gZGF0YVthMV07XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBkYXRhcy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgaWYgKGRhdGFzW2ldW2ExXSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIGRhdGFzW2ldW2ExXTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGExID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYTIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiAoYTEgfHwge30pW2EyXSAhPT0gdW5kZWZpbmVkID8gYTFbYTJdIDogc2V0dGluZ3MoYTIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbyA9ICh0eXBlb2YgYTEgPT09ICdvYmplY3QnICYmIGEyID09PSB1bmRlZmluZWQpID8gYTEgOiB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIGExID09PSAnc3RyaW5nJylcbiAgICAgICAgICBvW2ExXSA9IGEyO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGsgPSBPYmplY3Qua2V5cyhvKSwgbCA9IGsubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIGRhdGFba1tpXV0gPSBvW2tbaV1dO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGNvbmZpZ3VyYWJsZSBmdW5jdGlvbiwgd2l0aCBuZXcgb2JqZWN0c1xuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0Kn0gIEFueSBudW1iZXIgb2Ygb2JqZWN0cyB0byBzZWFyY2ggaW4uXG4gICAgICogQHJldHVybiB7ZnVuY3Rpb259IFJldHVybnMgdGhlIGZ1bmN0aW9uLiBDaGVjayBpdHMgZG9jdW1lbnRhdGlvbiB0byBrbm93XG4gICAgICogICAgICAgICAgICAgICAgICAgIG1vcmUgYWJvdXQgaG93IGl0IHdvcmtzLlxuICAgICAqL1xuICAgIHNldHRpbmdzLmVtYmVkT2JqZWN0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSBkYXRhcy5jb25jYXQoXG4gICAgICAgIGRhdGFcbiAgICAgICkuY29uY2F0KFxuICAgICAgICBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoYXJndW1lbnRzLCAwKVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIGNvbmZpZ3VyYWJsZS5hcHBseSh7fSwgYXJncyk7XG4gICAgfTtcblxuICAgIC8vIEluaXRpYWxpemVcbiAgICBmb3IgKGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIHNldHRpbmdzKGFyZ3VtZW50c1tpXSk7XG5cbiAgICByZXR1cm4gc2V0dGluZ3M7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVYUE9SVDpcbiAgICogKioqKioqKlxuICAgKi9cbiAgaWYgKHR5cGVvZiB0aGlzLnNpZ21hICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMuc2lnbWEuY2xhc3NlcyA9IHRoaXMuc2lnbWEuY2xhc3NlcyB8fCB7fTtcbiAgICB0aGlzLnNpZ21hLmNsYXNzZXMuY29uZmlndXJhYmxlID0gY29uZmlndXJhYmxlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cylcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNvbmZpZ3VyYWJsZTtcbiAgICBleHBvcnRzLmNvbmZpZ3VyYWJsZSA9IGNvbmZpZ3VyYWJsZTtcbiAgfSBlbHNlXG4gICAgdGhpcy5jb25maWd1cmFibGUgPSBjb25maWd1cmFibGU7XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF9tZXRob2RzID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIF9pbmRleGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIF9pbml0QmluZGluZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgX21ldGhvZEJpbmRpbmdzID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIF9tZXRob2RCZWZvcmVCaW5kaW5ncyA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBfZGVmYXVsdFNldHRpbmdzID0ge1xuICAgICAgICBpbW11dGFibGU6IHRydWUsXG4gICAgICAgIGNsb25lOiB0cnVlXG4gICAgICB9LFxuICAgICAgX2RlZmF1bHRTZXR0aW5nc0Z1bmN0aW9uID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBfZGVmYXVsdFNldHRpbmdzW2tleV07XG4gICAgICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgZ3JhcGggY29uc3RydWN0b3IuIEl0IGluaXRpYWxpemVzIHRoZSBkYXRhIGFuZCB0aGUgaW5kZXhlcywgYW5kIGJpbmRzXG4gICAqIHRoZSBjdXN0b20gaW5kZXhlcyBhbmQgbWV0aG9kcyB0byBpdHMgb3duIHNjb3BlLlxuICAgKlxuICAgKiBSZWNvZ25pemVkIHBhcmFtZXRlcnM6XG4gICAqICoqKioqKioqKioqKioqKioqKioqKipcbiAgICogSGVyZSBpcyB0aGUgZXhoYXVzdGl2ZSBsaXN0IG9mIGV2ZXJ5IGFjY2VwdGVkIHBhcmFtZXRlcnMgaW4gdGhlIHNldHRpbmdzXG4gICAqIG9iamVjdDpcbiAgICpcbiAgICogICB7Ym9vbGVhbn0gY2xvbmUgICAgIEluZGljYXRlcyBpZiB0aGUgZGF0YSBoYXZlIHRvIGJlIGNsb25lZCBpbiBtZXRob2RzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICB0byBhZGQgbm9kZXMgb3IgZWRnZXMuXG4gICAqICAge2Jvb2xlYW59IGltbXV0YWJsZSBJbmRpY2F0ZXMgaWYgbm9kZXMgXCJpZFwiIHZhbHVlcyBhbmQgZWRnZXMgXCJpZFwiLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgXCJzb3VyY2VcIiBhbmQgXCJ0YXJnZXRcIiB2YWx1ZXMgbXVzdCBiZSBzZXQgYXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgIGltbXV0YWJsZS5cbiAgICpcbiAgICogQHBhcmFtICB7P2NvbmZpZ3VyYWJsZX0gc2V0dGluZ3MgRXZlbnR1YWxseSBhIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtncmFwaH0gICAgICAgICAgICAgICAgICBUaGUgbmV3IGdyYXBoIGluc3RhbmNlLlxuICAgKi9cbiAgdmFyIGdyYXBoID0gZnVuY3Rpb24oc2V0dGluZ3MpIHtcbiAgICB2YXIgayxcbiAgICAgICAgZm4sXG4gICAgICAgIGRhdGE7XG5cbiAgICAvKipcbiAgICAgKiBEQVRBOlxuICAgICAqICoqKioqXG4gICAgICogRXZlcnkgZGF0YSB0aGF0IGlzIGNhbGxhYmxlIGZyb20gZ3JhcGggbWV0aG9kcyBhcmUgc3RvcmVkIGluIHRoaXMgXCJkYXRhXCJcbiAgICAgKiBvYmplY3QuIFRoaXMgb2JqZWN0IHdpbGwgYmUgc2VydmVkIGFzIGNvbnRleHQgZm9yIGFsbCB0aGVzZSBtZXRob2RzLFxuICAgICAqIGFuZCBpdCBpcyBwb3NzaWJsZSB0byBhZGQgb3RoZXIgdHlwZSBvZiBkYXRhIGluIGl0LlxuICAgICAqL1xuICAgIGRhdGEgPSB7XG4gICAgICAvKipcbiAgICAgICAqIFNFVFRJTkdTIEZVTkNUSU9OOlxuICAgICAgICogKioqKioqKioqKioqKioqKioqXG4gICAgICAgKi9cbiAgICAgIHNldHRpbmdzOiBzZXR0aW5ncyB8fCBfZGVmYXVsdFNldHRpbmdzRnVuY3Rpb24sXG5cbiAgICAgIC8qKlxuICAgICAgICogTUFJTiBEQVRBOlxuICAgICAgICogKioqKioqKioqKlxuICAgICAgICovXG4gICAgICBub2Rlc0FycmF5OiBbXSxcbiAgICAgIGVkZ2VzQXJyYXk6IFtdLFxuXG4gICAgICAvKipcbiAgICAgICAqIEdMT0JBTCBJTkRFWEVTOlxuICAgICAgICogKioqKioqKioqKioqKioqXG4gICAgICAgKiBUaGVzZSBpbmRleGVzIGp1c3QgaW5kZXggZGF0YSBieSBpZHMuXG4gICAgICAgKi9cbiAgICAgIG5vZGVzSW5kZXg6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBlZGdlc0luZGV4OiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gICAgICAvKipcbiAgICAgICAqIExPQ0FMIElOREVYRVM6XG4gICAgICAgKiAqKioqKioqKioqKioqKlxuICAgICAgICogVGhlc2UgaW5kZXhlcyByZWZlciBmcm9tIG5vZGUgdG8gbm9kZXMuIEVhY2gga2V5IGlzIGFuIGlkLCBhbmQgZWFjaFxuICAgICAgICogdmFsdWUgaXMgdGhlIGFycmF5IG9mIHRoZSBpZHMgb2YgcmVsYXRlZCBub2Rlcy5cbiAgICAgICAqL1xuICAgICAgaW5OZWlnaGJvcnNJbmRleDogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIG91dE5laWdoYm9yc0luZGV4OiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgYWxsTmVpZ2hib3JzSW5kZXg6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgICAgIGluTmVpZ2hib3JzQ291bnQ6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBvdXROZWlnaGJvcnNDb3VudDogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIGFsbE5laWdoYm9yc0NvdW50OiBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgfTtcblxuICAgIC8vIEV4ZWN1dGUgYmluZGluZ3M6XG4gICAgZm9yIChrIGluIF9pbml0QmluZGluZ3MpXG4gICAgICBfaW5pdEJpbmRpbmdzW2tdLmNhbGwoZGF0YSk7XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBib3RoIHRoZSBzY29wZSBhbmQgdGhlIGRhdGEgb2JqZWN0czpcbiAgICBmb3IgKGsgaW4gX21ldGhvZHMpIHtcbiAgICAgIGZuID0gX19iaW5kR3JhcGhNZXRob2QoaywgZGF0YSwgX21ldGhvZHNba10pO1xuICAgICAgdGhpc1trXSA9IGZuO1xuICAgICAgZGF0YVtrXSA9IGZuO1xuICAgIH1cbiAgfTtcblxuXG5cblxuICAvKipcbiAgICogQSBjdXN0b20gdG9vbCB0byBiaW5kIG1ldGhvZHMgc3VjaCB0aGF0IGZ1bmN0aW9uIHRoYXQgYXJlIGJvdW5kIHRvIGl0IHdpbGxcbiAgICogYmUgZXhlY3V0ZWQgYW55dGltZSB0aGUgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgIG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0byBiaW5kLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgc2NvcGUgICAgICBUaGUgc2NvcGUgd2hlcmUgdGhlIG1ldGhvZCBtdXN0IGJlIGV4ZWN1dGVkLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gZm4gICAgICAgICBUaGUgbWV0aG9kIGl0c2VsZi5cbiAgICogQHJldHVybiB7ZnVuY3Rpb259ICAgICAgICAgICAgVGhlIG5ldyBtZXRob2QuXG4gICAqL1xuICBmdW5jdGlvbiBfX2JpbmRHcmFwaE1ldGhvZChtZXRob2ROYW1lLCBzY29wZSwgZm4pIHtcbiAgICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgayxcbiAgICAgICAgICByZXM7XG5cbiAgICAgIC8vIEV4ZWN1dGUgXCJiZWZvcmVcIiBib3VuZCBmdW5jdGlvbnM6XG4gICAgICBmb3IgKGsgaW4gX21ldGhvZEJlZm9yZUJpbmRpbmdzW21ldGhvZE5hbWVdKVxuICAgICAgICBfbWV0aG9kQmVmb3JlQmluZGluZ3NbbWV0aG9kTmFtZV1ba10uYXBwbHkoc2NvcGUsIGFyZ3VtZW50cyk7XG5cbiAgICAgIC8vIEFwcGx5IHRoZSBtZXRob2Q6XG4gICAgICByZXMgPSBmbi5hcHBseShzY29wZSwgYXJndW1lbnRzKTtcblxuICAgICAgLy8gRXhlY3V0ZSBib3VuZCBmdW5jdGlvbnM6XG4gICAgICBmb3IgKGsgaW4gX21ldGhvZEJpbmRpbmdzW21ldGhvZE5hbWVdKVxuICAgICAgICBfbWV0aG9kQmluZGluZ3NbbWV0aG9kTmFtZV1ba10uYXBwbHkoc2NvcGUsIGFyZ3VtZW50cyk7XG5cbiAgICAgIC8vIFJldHVybiByZXM6XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH07XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgY3VzdG9tIHRvb2wgZnVuY3Rpb24gcmVtb3ZlcyBldmVyeSBwYWlyIGtleS92YWx1ZSBmcm9tIGFuIGhhc2guIFRoZVxuICAgKiBnb2FsIGlzIHRvIGF2b2lkIGNyZWF0aW5nIGEgbmV3IG9iamVjdCB3aGlsZSBzb21lIG90aGVyIHJlZmVyZW5jZXMgYXJlXG4gICAqIHN0aWxsIGhhbmdpbmcgaW4gc29tZSBzY29wZXMuLi5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBlbXB0eS5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgVGhlIGVtcHR5IG9iamVjdC5cbiAgICovXG4gIGZ1bmN0aW9uIF9fZW1wdHlPYmplY3Qob2JqKSB7XG4gICAgdmFyIGs7XG5cbiAgICBmb3IgKGsgaW4gb2JqKVxuICAgICAgaWYgKCEoJ2hhc093blByb3BlcnR5JyBpbiBvYmopIHx8IG9iai5oYXNPd25Qcm9wZXJ0eShrKSlcbiAgICAgICAgZGVsZXRlIG9ialtrXTtcblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuXG5cblxuICAvKipcbiAgICogVGhpcyBnbG9iYWwgbWV0aG9kIGFkZHMgYSBtZXRob2QgdGhhdCB3aWxsIGJlIGJvdW5kIHRvIHRoZSBmdXR1cmx5IGNyZWF0ZWRcbiAgICogZ3JhcGggaW5zdGFuY2VzLlxuICAgKlxuICAgKiBTaW5jZSB0aGVzZSBtZXRob2RzIHdpbGwgYmUgYm91bmQgdG8gdGhlaXIgc2NvcGUgd2hlbiB0aGUgaW5zdGFuY2VzIGFyZVxuICAgKiBjcmVhdGVkLCBpdCBkb2VzIG5vdCB1c2UgdGhlIHByb3RvdHlwZS4gQmVjYXVzZSBvZiB0aGF0LCBtZXRob2RzIGhhdmUgdG9cbiAgICogYmUgYWRkZWQgYmVmb3JlIGluc3RhbmNlcyBhcmUgY3JlYXRlZCB0byBtYWtlIHRoZW0gYXZhaWxhYmxlLlxuICAgKlxuICAgKiBIZXJlIGlzIGFuIGV4YW1wbGU6XG4gICAqXG4gICAqICA+IGdyYXBoLmFkZE1ldGhvZCgnZ2V0Tm9kZXNDb3VudCcsIGZ1bmN0aW9uKCkge1xuICAgKiAgPiAgIHJldHVybiB0aGlzLm5vZGVzQXJyYXkubGVuZ3RoO1xuICAgKiAgPiB9KTtcbiAgICogID5cbiAgICogID4gdmFyIG15R3JhcGggPSBuZXcgZ3JhcGgoKTtcbiAgICogID4gY29uc29sZS5sb2cobXlHcmFwaC5nZXROb2Rlc0NvdW50KCkpOyAvLyBvdXRwdXRzIDBcbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgIG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGZuICAgICAgICAgVGhlIG1ldGhvZCBpdHNlbGYuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgICAgIFRoZSBnbG9iYWwgZ3JhcGggY29uc3RydWN0b3IuXG4gICAqL1xuICBncmFwaC5hZGRNZXRob2QgPSBmdW5jdGlvbihtZXRob2ROYW1lLCBmbikge1xuICAgIGlmIChcbiAgICAgIHR5cGVvZiBtZXRob2ROYW1lICE9PSAnc3RyaW5nJyB8fFxuICAgICAgdHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nIHx8XG4gICAgICBhcmd1bWVudHMubGVuZ3RoICE9PSAyXG4gICAgKVxuICAgICAgdGhyb3cgJ2FkZE1ldGhvZDogV3JvbmcgYXJndW1lbnRzLic7XG5cbiAgICBpZiAoX21ldGhvZHNbbWV0aG9kTmFtZV0gfHwgZ3JhcGhbbWV0aG9kTmFtZV0pXG4gICAgICB0aHJvdyAnVGhlIG1ldGhvZCBcIicgKyBtZXRob2ROYW1lICsgJ1wiIGFscmVhZHkgZXhpc3RzLic7XG5cbiAgICBfbWV0aG9kc1ttZXRob2ROYW1lXSA9IGZuO1xuICAgIF9tZXRob2RCaW5kaW5nc1ttZXRob2ROYW1lXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgX21ldGhvZEJlZm9yZUJpbmRpbmdzW21ldGhvZE5hbWVdID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGdsb2JhbCBtZXRob2QgcmV0dXJucyB0cnVlIGlmIHRoZSBtZXRob2QgaGFzIGFscmVhZHkgYmVlbiBhZGRlZCwgYW5kXG4gICAqIGZhbHNlIGVsc2UuXG4gICAqXG4gICAqIEhlcmUgYXJlIHNvbWUgZXhhbXBsZXM6XG4gICAqXG4gICAqICA+IGdyYXBoLmhhc01ldGhvZCgnYWRkTm9kZScpOyAvLyByZXR1cm5zIHRydWVcbiAgICogID4gZ3JhcGguaGFzTWV0aG9kKCdoYXNNZXRob2QnKTsgLy8gcmV0dXJucyB0cnVlXG4gICAqICA+IGdyYXBoLmhhc01ldGhvZCgndW5leGlzdGluZ01ldGhvZCcpOyAvLyByZXR1cm5zIGZhbHNlXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gIG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gICAgICAgICAgICBUaGUgcmVzdWx0LlxuICAgKi9cbiAgZ3JhcGguaGFzTWV0aG9kID0gZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgIHJldHVybiAhIShfbWV0aG9kc1ttZXRob2ROYW1lXSB8fCBncmFwaFttZXRob2ROYW1lXSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2xvYmFsIG1ldGhvZHMgYXR0YWNoZXMgYSBmdW5jdGlvbiB0byBhIG1ldGhvZC4gQW55dGltZSB0aGUgc3BlY2lmaWVkXG4gICAqIG1ldGhvZCBpcyBjYWxsZWQsIHRoZSBhdHRhY2hlZCBmdW5jdGlvbiBpcyBjYWxsZWQgcmlnaHQgYWZ0ZXIsIHdpdGggdGhlXG4gICAqIHNhbWUgYXJndW1lbnRzIGFuZCBpbiB0aGUgc2FtZSBzY29wZS4gVGhlIGF0dGFjaGVkIGZ1bmN0aW9uIGlzIGNhbGxlZFxuICAgKiByaWdodCBiZWZvcmUgaWYgdGhlIGxhc3QgYXJndW1lbnQgaXMgdHJ1ZSwgdW5sZXNzIHRoZSBtZXRob2QgaXMgdGhlIGdyYXBoXG4gICAqIGNvbnN0cnVjdG9yLlxuICAgKlxuICAgKiBUbyBhdHRhY2ggYSBmdW5jdGlvbiB0byB0aGUgZ3JhcGggY29uc3RydWN0b3IsIHVzZSAnY29uc3RydWN0b3InIGFzIHRoZVxuICAgKiBtZXRob2QgbmFtZSAoZmlyc3QgYXJndW1lbnQpLlxuICAgKlxuICAgKiBUaGUgbWFpbiBpZGVhIGlzIHRvIGhhdmUgYSBjbGVhbiB3YXkgdG8ga2VlcCBjdXN0b20gaW5kZXhlcyB1cCB0byBkYXRlLFxuICAgKiBmb3IgaW5zdGFuY2U6XG4gICAqXG4gICAqICA+IHZhciB0aW1lc0FkZE5vZGVDYWxsZWQgPSAwO1xuICAgKiAgPiBncmFwaC5hdHRhY2goJ2FkZE5vZGUnLCAndGltZXNBZGROb2RlQ2FsbGVkSW5jJywgZnVuY3Rpb24oKSB7XG4gICAqICA+ICAgdGltZXNBZGROb2RlQ2FsbGVkKys7XG4gICAqICA+IH0pO1xuICAgKiAgPlxuICAgKiAgPiB2YXIgbXlHcmFwaCA9IG5ldyBncmFwaCgpO1xuICAgKiAgPiBjb25zb2xlLmxvZyh0aW1lc0FkZE5vZGVDYWxsZWQpOyAvLyBvdXRwdXRzIDBcbiAgICogID5cbiAgICogID4gbXlHcmFwaC5hZGROb2RlKHsgaWQ6ICcxJyB9KS5hZGROb2RlKHsgaWQ6ICcyJyB9KTtcbiAgICogID4gY29uc29sZS5sb2codGltZXNBZGROb2RlQ2FsbGVkKTsgLy8gb3V0cHV0cyAyXG4gICAqXG4gICAqIFRoZSBpZGVhIGZvciBjYWxsaW5nIGEgZnVuY3Rpb24gYmVmb3JlIGlzIHRvIHByb3ZpZGUgcHJlLXByb2Nlc3NvcnMsIGZvclxuICAgKiBpbnN0YW5jZTpcbiAgICpcbiAgICogID4gdmFyIGNvbG9yUGFsZXR0ZSA9IHsgUGVyc29uOiAnI0MzQ0JFMScsIFBsYWNlOiAnIzlCREVCRCcgfTtcbiAgICogID4gZ3JhcGguYXR0YWNoKCdhZGROb2RlJywgJ2FwcGx5Tm9kZUNvbG9yUGFsZXR0ZScsIGZ1bmN0aW9uKG4pIHtcbiAgICogID4gICBuLmNvbG9yID0gY29sb3JQYWxldHRlW24uY2F0ZWdvcnldO1xuICAgKiAgPiB9LCB0cnVlKTtcbiAgICogID5cbiAgICogID4gdmFyIG15R3JhcGggPSBuZXcgZ3JhcGgoKTtcbiAgICogID4gbXlHcmFwaC5hZGROb2RlKHsgaWQ6ICduMCcsIGNhdGVnb3J5OiAnUGVyc29uJyB9KTtcbiAgICogID4gY29uc29sZS5sb2cobXlHcmFwaC5ub2RlcygnbjAnKS5jb2xvcik7IC8vIG91dHB1dHMgJyNDM0NCRTEnXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSByZWxhdGVkIG1ldGhvZCBvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNvbnN0cnVjdG9yXCIuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICBrZXkgICAgICAgIFRoZSBrZXkgdG8gaWRlbnRpZnkgdGhlIGZ1bmN0aW9uIHRvIGF0dGFjaC5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGZuICAgICAgICAgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICBiZWZvcmUgICAgIElmIHRydWUgdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCByaWdodCBiZWZvcmUuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgICAgIFRoZSBnbG9iYWwgZ3JhcGggY29uc3RydWN0b3IuXG4gICAqL1xuICBncmFwaC5hdHRhY2ggPSBmdW5jdGlvbihtZXRob2ROYW1lLCBrZXksIGZuLCBiZWZvcmUpIHtcbiAgICBpZiAoXG4gICAgICB0eXBlb2YgbWV0aG9kTmFtZSAhPT0gJ3N0cmluZycgfHxcbiAgICAgIHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnIHx8XG4gICAgICB0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicgfHxcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPCAzIHx8XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gNFxuICAgIClcbiAgICAgIHRocm93ICdhdHRhY2g6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgdmFyIGJpbmRpbmdzO1xuXG4gICAgaWYgKG1ldGhvZE5hbWUgPT09ICdjb25zdHJ1Y3RvcicpXG4gICAgICBiaW5kaW5ncyA9IF9pbml0QmluZGluZ3M7XG4gICAgZWxzZSB7XG4gICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgIGlmICghX21ldGhvZEJlZm9yZUJpbmRpbmdzW21ldGhvZE5hbWVdKVxuICAgICAgICB0aHJvdyAnVGhlIG1ldGhvZCBcIicgKyBtZXRob2ROYW1lICsgJ1wiIGRvZXMgbm90IGV4aXN0Lic7XG5cbiAgICAgICAgYmluZGluZ3MgPSBfbWV0aG9kQmVmb3JlQmluZGluZ3NbbWV0aG9kTmFtZV07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKCFfbWV0aG9kQmluZGluZ3NbbWV0aG9kTmFtZV0pXG4gICAgICAgICAgdGhyb3cgJ1RoZSBtZXRob2QgXCInICsgbWV0aG9kTmFtZSArICdcIiBkb2VzIG5vdCBleGlzdC4nO1xuXG4gICAgICAgIGJpbmRpbmdzID0gX21ldGhvZEJpbmRpbmdzW21ldGhvZE5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChiaW5kaW5nc1trZXldKVxuICAgICAgdGhyb3cgJ0EgZnVuY3Rpb24gXCInICsga2V5ICsgJ1wiIGlzIGFscmVhZHkgYXR0YWNoZWQgJyArXG4gICAgICAgICAgICAndG8gdGhlIG1ldGhvZCBcIicgKyBtZXRob2ROYW1lICsgJ1wiLic7XG5cbiAgICBiaW5kaW5nc1trZXldID0gZm47XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQWxpYXMgb2YgYXR0YWNoKG1ldGhvZE5hbWUsIGtleSwgZm4sIHRydWUpLlxuICAgKi9cbiAgZ3JhcGguYXR0YWNoQmVmb3JlID0gZnVuY3Rpb24obWV0aG9kTmFtZSwga2V5LCBmbikge1xuICAgIHJldHVybiB0aGlzLmF0dGFjaChtZXRob2ROYW1lLCBrZXksIGZuLCB0cnVlKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2RzIGlzIGp1c3QgYW4gaGVscGVyIHRvIGRlYWwgd2l0aCBjdXN0b20gaW5kZXhlcy4gSXQgdGFrZXMgYXNcbiAgICogYXJndW1lbnRzIHRoZSBuYW1lIG9mIHRoZSBpbmRleCBhbmQgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBkaWZmZXJlbnRcbiAgICogZnVuY3Rpb25zIHRvIGJpbmQgdG8gdGhlIG1ldGhvZHMuXG4gICAqXG4gICAqIEhlcmUgaXMgYSBiYXNpYyBleGFtcGxlLCB0aGF0IGNyZWF0ZXMgYW4gaW5kZXggdG8ga2VlcCB0aGUgbnVtYmVyIG9mIG5vZGVzXG4gICAqIGluIHRoZSBjdXJyZW50IGdyYXBoLiBJdCBhbHNvIGFkZHMgYSBtZXRob2QgdG8gcHJvdmlkZSBhIGdldHRlciBvbiB0aGF0XG4gICAqIG5ldyBpbmRleDpcbiAgICpcbiAgICogID4gc2lnbWEuY2xhc3Nlcy5ncmFwaC5hZGRJbmRleCgnbm9kZXNDb3VudCcsIHtcbiAgICogID4gICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oKSB7XG4gICAqICA+ICAgICB0aGlzLm5vZGVzQ291bnQgPSAwO1xuICAgKiAgPiAgIH0sXG4gICAqICA+ICAgYWRkTm9kZTogZnVuY3Rpb24oKSB7XG4gICAqICA+ICAgICB0aGlzLm5vZGVzQ291bnQrKztcbiAgICogID4gICB9LFxuICAgKiAgPiAgIGRyb3BOb2RlOiBmdW5jdGlvbigpIHtcbiAgICogID4gICAgIHRoaXMubm9kZXNDb3VudC0tO1xuICAgKiAgPiAgIH1cbiAgICogID4gfSk7XG4gICAqICA+XG4gICAqICA+IHNpZ21hLmNsYXNzZXMuZ3JhcGguYWRkTWV0aG9kKCdnZXROb2Rlc0NvdW50JywgZnVuY3Rpb24oKSB7XG4gICAqICA+ICAgcmV0dXJuIHRoaXMubm9kZXNDb3VudDtcbiAgICogID4gfSk7XG4gICAqICA+XG4gICAqICA+IHZhciBteUdyYXBoID0gbmV3IHNpZ21hLmNsYXNzZXMuZ3JhcGgoKTtcbiAgICogID4gY29uc29sZS5sb2cobXlHcmFwaC5nZXROb2Rlc0NvdW50KCkpOyAvLyBvdXRwdXRzIDBcbiAgICogID5cbiAgICogID4gbXlHcmFwaC5hZGROb2RlKHsgaWQ6ICcxJyB9KS5hZGROb2RlKHsgaWQ6ICcyJyB9KTtcbiAgICogID4gY29uc29sZS5sb2cobXlHcmFwaC5nZXROb2Rlc0NvdW50KCkpOyAvLyBvdXRwdXRzIDJcbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSBuYW1lICAgICBUaGUgbmFtZSBvZiB0aGUgaW5kZXguXG4gICAqIEBwYXJhbSAge29iamVjdH0gYmluZGluZ3MgVGhlIG9iamVjdCBjb250YWluaW5nIHRoZSBmdW5jdGlvbnMgdG8gYmluZC5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICBUaGUgZ2xvYmFsIGdyYXBoIGNvbnN0cnVjdG9yLlxuICAgKi9cbiAgZ3JhcGguYWRkSW5kZXggPSBmdW5jdGlvbihuYW1lLCBiaW5kaW5ncykge1xuICAgIGlmIChcbiAgICAgIHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fFxuICAgICAgT2JqZWN0KGJpbmRpbmdzKSAhPT0gYmluZGluZ3MgfHxcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggIT09IDJcbiAgICApXG4gICAgICB0aHJvdyAnYWRkSW5kZXg6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgaWYgKF9pbmRleGVzW25hbWVdKVxuICAgICAgdGhyb3cgJ1RoZSBpbmRleCBcIicgKyBuYW1lICsgJ1wiIGFscmVhZHkgZXhpc3RzLic7XG5cbiAgICB2YXIgaztcblxuICAgIC8vIFN0b3JlIHRoZSBiaW5kaW5nczpcbiAgICBfaW5kZXhlc1tuYW1lXSA9IGJpbmRpbmdzO1xuXG4gICAgLy8gQXR0YWNoIHRoZSBiaW5kaW5nczpcbiAgICBmb3IgKGsgaW4gYmluZGluZ3MpXG4gICAgICBpZiAodHlwZW9mIGJpbmRpbmdzW2tdICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyAnVGhlIGJpbmRpbmdzIG11c3QgYmUgZnVuY3Rpb25zLic7XG4gICAgICBlbHNlXG4gICAgICAgIGdyYXBoLmF0dGFjaChrLCBuYW1lLCBiaW5kaW5nc1trXSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG5cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgYWRkcyBhIG5vZGUgdG8gdGhlIGdyYXBoLiBUaGUgbm9kZSBtdXN0IGJlIGFuIG9iamVjdCwgd2l0aCBhXG4gICAqIHN0cmluZyB1bmRlciB0aGUga2V5IFwiaWRcIi4gRXhjZXB0IGZvciB0aGlzLCBpdCBpcyBwb3NzaWJsZSB0byBhZGQgYW55XG4gICAqIG90aGVyIGF0dHJpYnV0ZSwgdGhhdCB3aWxsIGJlIHByZXNlcnZlZCBhbGwgYWxvbmcgdGhlIG1hbmlwdWxhdGlvbnMuXG4gICAqXG4gICAqIElmIHRoZSBncmFwaCBvcHRpb24gXCJjbG9uZVwiIGhhcyBhIHRydXRoeSB2YWx1ZSwgdGhlIG5vZGUgd2lsbCBiZSBjbG9uZWRcbiAgICogd2hlbiBhZGRlZCB0byB0aGUgZ3JhcGguIEFsc28sIGlmIHRoZSBncmFwaCBvcHRpb24gXCJpbW11dGFibGVcIiBoYXMgYVxuICAgKiB0cnV0aHkgdmFsdWUsIGl0cyBpZCB3aWxsIGJlIGRlZmluZWQgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IG5vZGUgVGhlIG5vZGUgdG8gYWRkLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgVGhlIGdyYXBoIGluc3RhbmNlLlxuICAgKi9cbiAgZ3JhcGguYWRkTWV0aG9kKCdhZGROb2RlJywgZnVuY3Rpb24obm9kZSkge1xuICAgIC8vIENoZWNrIHRoYXQgdGhlIG5vZGUgaXMgYW4gb2JqZWN0IGFuZCBoYXMgYW4gaWQ6XG4gICAgaWYgKE9iamVjdChub2RlKSAhPT0gbm9kZSB8fCBhcmd1bWVudHMubGVuZ3RoICE9PSAxKVxuICAgICAgdGhyb3cgJ2FkZE5vZGU6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgaWYgKHR5cGVvZiBub2RlLmlkICE9PSAnc3RyaW5nJyAmJiB0eXBlb2Ygbm9kZS5pZCAhPT0gJ251bWJlcicpXG4gICAgICB0aHJvdyAnVGhlIG5vZGUgbXVzdCBoYXZlIGEgc3RyaW5nIG9yIG51bWJlciBpZC4nO1xuXG4gICAgaWYgKHRoaXMubm9kZXNJbmRleFtub2RlLmlkXSlcbiAgICAgIHRocm93ICdUaGUgbm9kZSBcIicgKyBub2RlLmlkICsgJ1wiIGFscmVhZHkgZXhpc3RzLic7XG5cbiAgICB2YXIgayxcbiAgICAgICAgaWQgPSBub2RlLmlkLFxuICAgICAgICB2YWxpZE5vZGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgLy8gQ2hlY2sgdGhlIFwiY2xvbmVcIiBvcHRpb246XG4gICAgaWYgKHRoaXMuc2V0dGluZ3MoJ2Nsb25lJykpIHtcbiAgICAgIGZvciAoayBpbiBub2RlKVxuICAgICAgICBpZiAoayAhPT0gJ2lkJylcbiAgICAgICAgICB2YWxpZE5vZGVba10gPSBub2RlW2tdO1xuICAgIH0gZWxzZVxuICAgICAgdmFsaWROb2RlID0gbm9kZTtcblxuICAgIC8vIENoZWNrIHRoZSBcImltbXV0YWJsZVwiIG9wdGlvbjpcbiAgICBpZiAodGhpcy5zZXR0aW5ncygnaW1tdXRhYmxlJykpXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWROb2RlLCAnaWQnLCB7XG4gICAgICAgIHZhbHVlOiBpZCxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgZWxzZVxuICAgICAgdmFsaWROb2RlLmlkID0gaWQ7XG5cbiAgICAvLyBBZGQgZW1wdHkgY29udGFpbmVycyBmb3IgZWRnZXMgaW5kZXhlczpcbiAgICB0aGlzLmluTmVpZ2hib3JzSW5kZXhbaWRdID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLm91dE5laWdoYm9yc0luZGV4W2lkXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5hbGxOZWlnaGJvcnNJbmRleFtpZF0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgdGhpcy5pbk5laWdoYm9yc0NvdW50W2lkXSA9IDA7XG4gICAgdGhpcy5vdXROZWlnaGJvcnNDb3VudFtpZF0gPSAwO1xuICAgIHRoaXMuYWxsTmVpZ2hib3JzQ291bnRbaWRdID0gMDtcblxuICAgIC8vIEFkZCB0aGUgbm9kZSB0byBpbmRleGVzOlxuICAgIHRoaXMubm9kZXNBcnJheS5wdXNoKHZhbGlkTm9kZSk7XG4gICAgdGhpcy5ub2Rlc0luZGV4W3ZhbGlkTm9kZS5pZF0gPSB2YWxpZE5vZGU7XG5cbiAgICAvLyBSZXR1cm4gdGhlIGN1cnJlbnQgaW5zdGFuY2U6XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBhZGRzIGFuIGVkZ2UgdG8gdGhlIGdyYXBoLiBUaGUgZWRnZSBtdXN0IGJlIGFuIG9iamVjdCwgd2l0aCBhXG4gICAqIHN0cmluZyB1bmRlciB0aGUga2V5IFwiaWRcIiwgYW5kIHN0cmluZ3MgdW5kZXIgdGhlIGtleXMgXCJzb3VyY2VcIiBhbmRcbiAgICogXCJ0YXJnZXRcIiB0aGF0IGRlc2lnbiBleGlzdGluZyBub2Rlcy4gRXhjZXB0IGZvciB0aGlzLCBpdCBpcyBwb3NzaWJsZSB0b1xuICAgKiBhZGQgYW55IG90aGVyIGF0dHJpYnV0ZSwgdGhhdCB3aWxsIGJlIHByZXNlcnZlZCBhbGwgYWxvbmcgdGhlXG4gICAqIG1hbmlwdWxhdGlvbnMuXG4gICAqXG4gICAqIElmIHRoZSBncmFwaCBvcHRpb24gXCJjbG9uZVwiIGhhcyBhIHRydXRoeSB2YWx1ZSwgdGhlIGVkZ2Ugd2lsbCBiZSBjbG9uZWRcbiAgICogd2hlbiBhZGRlZCB0byB0aGUgZ3JhcGguIEFsc28sIGlmIHRoZSBncmFwaCBvcHRpb24gXCJpbW11dGFibGVcIiBoYXMgYVxuICAgKiB0cnV0aHkgdmFsdWUsIGl0cyBpZCwgc291cmNlIGFuZCB0YXJnZXQgd2lsbCBiZSBkZWZpbmVkIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSBlZGdlIFRoZSBlZGdlIHRvIGFkZC5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgIFRoZSBncmFwaCBpbnN0YW5jZS5cbiAgICovXG4gIGdyYXBoLmFkZE1ldGhvZCgnYWRkRWRnZScsIGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAvLyBDaGVjayB0aGF0IHRoZSBlZGdlIGlzIGFuIG9iamVjdCBhbmQgaGFzIGFuIGlkOlxuICAgIGlmIChPYmplY3QoZWRnZSkgIT09IGVkZ2UgfHwgYXJndW1lbnRzLmxlbmd0aCAhPT0gMSlcbiAgICAgIHRocm93ICdhZGRFZGdlOiBXcm9uZyBhcmd1bWVudHMuJztcblxuICAgIGlmICh0eXBlb2YgZWRnZS5pZCAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGVkZ2UuaWQgIT09ICdudW1iZXInKVxuICAgICAgdGhyb3cgJ1RoZSBlZGdlIG11c3QgaGF2ZSBhIHN0cmluZyBvciBudW1iZXIgaWQuJztcblxuICAgIGlmICgodHlwZW9mIGVkZ2Uuc291cmNlICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgZWRnZS5zb3VyY2UgIT09ICdudW1iZXInKSB8fFxuICAgICAgICAhdGhpcy5ub2Rlc0luZGV4W2VkZ2Uuc291cmNlXSlcbiAgICAgIHRocm93ICdUaGUgZWRnZSBzb3VyY2UgbXVzdCBoYXZlIGFuIGV4aXN0aW5nIG5vZGUgaWQuJztcblxuICAgIGlmICgodHlwZW9mIGVkZ2UudGFyZ2V0ICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgZWRnZS50YXJnZXQgIT09ICdudW1iZXInKSB8fFxuICAgICAgICAhdGhpcy5ub2Rlc0luZGV4W2VkZ2UudGFyZ2V0XSlcbiAgICAgIHRocm93ICdUaGUgZWRnZSB0YXJnZXQgbXVzdCBoYXZlIGFuIGV4aXN0aW5nIG5vZGUgaWQuJztcblxuICAgIGlmICh0aGlzLmVkZ2VzSW5kZXhbZWRnZS5pZF0pXG4gICAgICB0aHJvdyAnVGhlIGVkZ2UgXCInICsgZWRnZS5pZCArICdcIiBhbHJlYWR5IGV4aXN0cy4nO1xuXG4gICAgdmFyIGssXG4gICAgICAgIHZhbGlkRWRnZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAvLyBDaGVjayB0aGUgXCJjbG9uZVwiIG9wdGlvbjpcbiAgICBpZiAodGhpcy5zZXR0aW5ncygnY2xvbmUnKSkge1xuICAgICAgZm9yIChrIGluIGVkZ2UpXG4gICAgICAgIGlmIChrICE9PSAnaWQnICYmIGsgIT09ICdzb3VyY2UnICYmIGsgIT09ICd0YXJnZXQnKVxuICAgICAgICAgIHZhbGlkRWRnZVtrXSA9IGVkZ2Vba107XG4gICAgfSBlbHNlXG4gICAgICB2YWxpZEVkZ2UgPSBlZGdlO1xuXG4gICAgLy8gQ2hlY2sgdGhlIFwiaW1tdXRhYmxlXCIgb3B0aW9uOlxuICAgIGlmICh0aGlzLnNldHRpbmdzKCdpbW11dGFibGUnKSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkRWRnZSwgJ2lkJywge1xuICAgICAgICB2YWx1ZTogZWRnZS5pZCxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZEVkZ2UsICdzb3VyY2UnLCB7XG4gICAgICAgIHZhbHVlOiBlZGdlLnNvdXJjZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZEVkZ2UsICd0YXJnZXQnLCB7XG4gICAgICAgIHZhbHVlOiBlZGdlLnRhcmdldCxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkRWRnZS5pZCA9IGVkZ2UuaWQ7XG4gICAgICB2YWxpZEVkZ2Uuc291cmNlID0gZWRnZS5zb3VyY2U7XG4gICAgICB2YWxpZEVkZ2UudGFyZ2V0ID0gZWRnZS50YXJnZXQ7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSBlZGdlIHRvIGluZGV4ZXM6XG4gICAgdGhpcy5lZGdlc0FycmF5LnB1c2godmFsaWRFZGdlKTtcbiAgICB0aGlzLmVkZ2VzSW5kZXhbdmFsaWRFZGdlLmlkXSA9IHZhbGlkRWRnZTtcblxuICAgIGlmICghdGhpcy5pbk5laWdoYm9yc0luZGV4W3ZhbGlkRWRnZS50YXJnZXRdW3ZhbGlkRWRnZS5zb3VyY2VdKVxuICAgICAgdGhpcy5pbk5laWdoYm9yc0luZGV4W3ZhbGlkRWRnZS50YXJnZXRdW3ZhbGlkRWRnZS5zb3VyY2VdID1cbiAgICAgICAgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmluTmVpZ2hib3JzSW5kZXhbdmFsaWRFZGdlLnRhcmdldF1bdmFsaWRFZGdlLnNvdXJjZV1bdmFsaWRFZGdlLmlkXSA9XG4gICAgICB2YWxpZEVkZ2U7XG5cbiAgICBpZiAoIXRoaXMub3V0TmVpZ2hib3JzSW5kZXhbdmFsaWRFZGdlLnNvdXJjZV1bdmFsaWRFZGdlLnRhcmdldF0pXG4gICAgICB0aGlzLm91dE5laWdoYm9yc0luZGV4W3ZhbGlkRWRnZS5zb3VyY2VdW3ZhbGlkRWRnZS50YXJnZXRdID1cbiAgICAgICAgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLm91dE5laWdoYm9yc0luZGV4W3ZhbGlkRWRnZS5zb3VyY2VdW3ZhbGlkRWRnZS50YXJnZXRdW3ZhbGlkRWRnZS5pZF0gPVxuICAgICAgdmFsaWRFZGdlO1xuXG4gICAgaWYgKCF0aGlzLmFsbE5laWdoYm9yc0luZGV4W3ZhbGlkRWRnZS5zb3VyY2VdW3ZhbGlkRWRnZS50YXJnZXRdKVxuICAgICAgdGhpcy5hbGxOZWlnaGJvcnNJbmRleFt2YWxpZEVkZ2Uuc291cmNlXVt2YWxpZEVkZ2UudGFyZ2V0XSA9XG4gICAgICAgIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5hbGxOZWlnaGJvcnNJbmRleFt2YWxpZEVkZ2Uuc291cmNlXVt2YWxpZEVkZ2UudGFyZ2V0XVt2YWxpZEVkZ2UuaWRdID1cbiAgICAgIHZhbGlkRWRnZTtcblxuICAgIGlmICh2YWxpZEVkZ2UudGFyZ2V0ICE9PSB2YWxpZEVkZ2Uuc291cmNlKSB7XG4gICAgICBpZiAoIXRoaXMuYWxsTmVpZ2hib3JzSW5kZXhbdmFsaWRFZGdlLnRhcmdldF1bdmFsaWRFZGdlLnNvdXJjZV0pXG4gICAgICAgIHRoaXMuYWxsTmVpZ2hib3JzSW5kZXhbdmFsaWRFZGdlLnRhcmdldF1bdmFsaWRFZGdlLnNvdXJjZV0gPVxuICAgICAgICAgIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLmFsbE5laWdoYm9yc0luZGV4W3ZhbGlkRWRnZS50YXJnZXRdW3ZhbGlkRWRnZS5zb3VyY2VdW3ZhbGlkRWRnZS5pZF0gPVxuICAgICAgICB2YWxpZEVkZ2U7XG4gICAgfVxuXG4gICAgLy8gS2VlcCBjb3VudHMgdXAgdG8gZGF0ZTpcbiAgICB0aGlzLmluTmVpZ2hib3JzQ291bnRbdmFsaWRFZGdlLnRhcmdldF0rKztcbiAgICB0aGlzLm91dE5laWdoYm9yc0NvdW50W3ZhbGlkRWRnZS5zb3VyY2VdKys7XG4gICAgdGhpcy5hbGxOZWlnaGJvcnNDb3VudFt2YWxpZEVkZ2UudGFyZ2V0XSsrO1xuICAgIHRoaXMuYWxsTmVpZ2hib3JzQ291bnRbdmFsaWRFZGdlLnNvdXJjZV0rKztcblxuICAgIHJldHVybiB0aGlzO1xuICB9KTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgZHJvcHMgYSBub2RlIGZyb20gdGhlIGdyYXBoLiBJdCBhbHNvIHJlbW92ZXMgZWFjaCBlZGdlIHRoYXQgaXNcbiAgICogYm91bmQgdG8gaXQsIHRocm91Z2ggdGhlIGRyb3BFZGdlIG1ldGhvZC4gQW4gZXJyb3IgaXMgdGhyb3duIGlmIHRoZSBub2RlXG4gICAqIGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlkIFRoZSBub2RlIGlkLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgIFRoZSBncmFwaCBpbnN0YW5jZS5cbiAgICovXG4gIGdyYXBoLmFkZE1ldGhvZCgnZHJvcE5vZGUnLCBmdW5jdGlvbihpZCkge1xuICAgIC8vIENoZWNrIHRoYXQgdGhlIGFyZ3VtZW50cyBhcmUgdmFsaWQ6XG4gICAgaWYgKCh0eXBlb2YgaWQgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBpZCAhPT0gJ251bWJlcicpIHx8XG4gICAgICAgIGFyZ3VtZW50cy5sZW5ndGggIT09IDEpXG4gICAgICB0aHJvdyAnZHJvcE5vZGU6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgaWYgKCF0aGlzLm5vZGVzSW5kZXhbaWRdKVxuICAgICAgdGhyb3cgJ1RoZSBub2RlIFwiJyArIGlkICsgJ1wiIGRvZXMgbm90IGV4aXN0Lic7XG5cbiAgICB2YXIgaSwgaywgbDtcblxuICAgIC8vIFJlbW92ZSB0aGUgbm9kZSBmcm9tIGluZGV4ZXM6XG4gICAgZGVsZXRlIHRoaXMubm9kZXNJbmRleFtpZF07XG4gICAgZm9yIChpID0gMCwgbCA9IHRoaXMubm9kZXNBcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICBpZiAodGhpcy5ub2Rlc0FycmF5W2ldLmlkID09PSBpZCkge1xuICAgICAgICB0aGlzLm5vZGVzQXJyYXkuc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIC8vIFJlbW92ZSByZWxhdGVkIGVkZ2VzOlxuICAgIGZvciAoaSA9IHRoaXMuZWRnZXNBcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgIGlmICh0aGlzLmVkZ2VzQXJyYXlbaV0uc291cmNlID09PSBpZCB8fCB0aGlzLmVkZ2VzQXJyYXlbaV0udGFyZ2V0ID09PSBpZClcbiAgICAgICAgdGhpcy5kcm9wRWRnZSh0aGlzLmVkZ2VzQXJyYXlbaV0uaWQpO1xuXG4gICAgLy8gUmVtb3ZlIHJlbGF0ZWQgZWRnZSBpbmRleGVzOlxuICAgIGRlbGV0ZSB0aGlzLmluTmVpZ2hib3JzSW5kZXhbaWRdO1xuICAgIGRlbGV0ZSB0aGlzLm91dE5laWdoYm9yc0luZGV4W2lkXTtcbiAgICBkZWxldGUgdGhpcy5hbGxOZWlnaGJvcnNJbmRleFtpZF07XG5cbiAgICBkZWxldGUgdGhpcy5pbk5laWdoYm9yc0NvdW50W2lkXTtcbiAgICBkZWxldGUgdGhpcy5vdXROZWlnaGJvcnNDb3VudFtpZF07XG4gICAgZGVsZXRlIHRoaXMuYWxsTmVpZ2hib3JzQ291bnRbaWRdO1xuXG4gICAgZm9yIChrIGluIHRoaXMubm9kZXNJbmRleCkge1xuICAgICAgZGVsZXRlIHRoaXMuaW5OZWlnaGJvcnNJbmRleFtrXVtpZF07XG4gICAgICBkZWxldGUgdGhpcy5vdXROZWlnaGJvcnNJbmRleFtrXVtpZF07XG4gICAgICBkZWxldGUgdGhpcy5hbGxOZWlnaGJvcnNJbmRleFtrXVtpZF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBkcm9wcyBhbiBlZGdlIGZyb20gdGhlIGdyYXBoLiBBbiBlcnJvciBpcyB0aHJvd24gaWYgdGhlIGVkZ2VcbiAgICogZG9lcyBub3QgZXhpc3QuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gaWQgVGhlIGVkZ2UgaWQuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgVGhlIGdyYXBoIGluc3RhbmNlLlxuICAgKi9cbiAgZ3JhcGguYWRkTWV0aG9kKCdkcm9wRWRnZScsIGZ1bmN0aW9uKGlkKSB7XG4gICAgLy8gQ2hlY2sgdGhhdCB0aGUgYXJndW1lbnRzIGFyZSB2YWxpZDpcbiAgICBpZiAoKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGlkICE9PSAnbnVtYmVyJykgfHxcbiAgICAgICAgYXJndW1lbnRzLmxlbmd0aCAhPT0gMSlcbiAgICAgIHRocm93ICdkcm9wRWRnZTogV3JvbmcgYXJndW1lbnRzLic7XG5cbiAgICBpZiAoIXRoaXMuZWRnZXNJbmRleFtpZF0pXG4gICAgICB0aHJvdyAnVGhlIGVkZ2UgXCInICsgaWQgKyAnXCIgZG9lcyBub3QgZXhpc3QuJztcblxuICAgIHZhciBpLCBsLCBlZGdlO1xuXG4gICAgLy8gUmVtb3ZlIHRoZSBlZGdlIGZyb20gaW5kZXhlczpcbiAgICBlZGdlID0gdGhpcy5lZGdlc0luZGV4W2lkXTtcbiAgICBkZWxldGUgdGhpcy5lZGdlc0luZGV4W2lkXTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5lZGdlc0FycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIGlmICh0aGlzLmVkZ2VzQXJyYXlbaV0uaWQgPT09IGlkKSB7XG4gICAgICAgIHRoaXMuZWRnZXNBcnJheS5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgZGVsZXRlIHRoaXMuaW5OZWlnaGJvcnNJbmRleFtlZGdlLnRhcmdldF1bZWRnZS5zb3VyY2VdW2VkZ2UuaWRdO1xuICAgIGlmICghT2JqZWN0LmtleXModGhpcy5pbk5laWdoYm9yc0luZGV4W2VkZ2UudGFyZ2V0XVtlZGdlLnNvdXJjZV0pLmxlbmd0aClcbiAgICAgIGRlbGV0ZSB0aGlzLmluTmVpZ2hib3JzSW5kZXhbZWRnZS50YXJnZXRdW2VkZ2Uuc291cmNlXTtcblxuICAgIGRlbGV0ZSB0aGlzLm91dE5laWdoYm9yc0luZGV4W2VkZ2Uuc291cmNlXVtlZGdlLnRhcmdldF1bZWRnZS5pZF07XG4gICAgaWYgKCFPYmplY3Qua2V5cyh0aGlzLm91dE5laWdoYm9yc0luZGV4W2VkZ2Uuc291cmNlXVtlZGdlLnRhcmdldF0pLmxlbmd0aClcbiAgICAgIGRlbGV0ZSB0aGlzLm91dE5laWdoYm9yc0luZGV4W2VkZ2Uuc291cmNlXVtlZGdlLnRhcmdldF07XG5cbiAgICBkZWxldGUgdGhpcy5hbGxOZWlnaGJvcnNJbmRleFtlZGdlLnNvdXJjZV1bZWRnZS50YXJnZXRdW2VkZ2UuaWRdO1xuICAgIGlmICghT2JqZWN0LmtleXModGhpcy5hbGxOZWlnaGJvcnNJbmRleFtlZGdlLnNvdXJjZV1bZWRnZS50YXJnZXRdKS5sZW5ndGgpXG4gICAgICBkZWxldGUgdGhpcy5hbGxOZWlnaGJvcnNJbmRleFtlZGdlLnNvdXJjZV1bZWRnZS50YXJnZXRdO1xuXG4gICAgaWYgKGVkZ2UudGFyZ2V0ICE9PSBlZGdlLnNvdXJjZSkge1xuICAgICAgZGVsZXRlIHRoaXMuYWxsTmVpZ2hib3JzSW5kZXhbZWRnZS50YXJnZXRdW2VkZ2Uuc291cmNlXVtlZGdlLmlkXTtcbiAgICAgIGlmICghT2JqZWN0LmtleXModGhpcy5hbGxOZWlnaGJvcnNJbmRleFtlZGdlLnRhcmdldF1bZWRnZS5zb3VyY2VdKS5sZW5ndGgpXG4gICAgICAgIGRlbGV0ZSB0aGlzLmFsbE5laWdoYm9yc0luZGV4W2VkZ2UudGFyZ2V0XVtlZGdlLnNvdXJjZV07XG4gICAgfVxuXG4gICAgdGhpcy5pbk5laWdoYm9yc0NvdW50W2VkZ2UudGFyZ2V0XS0tO1xuICAgIHRoaXMub3V0TmVpZ2hib3JzQ291bnRbZWRnZS5zb3VyY2VdLS07XG4gICAgdGhpcy5hbGxOZWlnaGJvcnNDb3VudFtlZGdlLnNvdXJjZV0tLTtcbiAgICB0aGlzLmFsbE5laWdoYm9yc0NvdW50W2VkZ2UudGFyZ2V0XS0tO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBkZXN0cm95cyB0aGUgY3VycmVudCBpbnN0YW5jZS4gSXQgYmFzaWNhbGx5IGVtcHRpZXMgZWFjaCBpbmRleFxuICAgKiBhbmQgbWV0aG9kcyBhdHRhY2hlZCB0byB0aGUgZ3JhcGguXG4gICAqL1xuICBncmFwaC5hZGRNZXRob2QoJ2tpbGwnLCBmdW5jdGlvbigpIHtcbiAgICAvLyBEZWxldGUgYXJyYXlzOlxuICAgIHRoaXMubm9kZXNBcnJheS5sZW5ndGggPSAwO1xuICAgIHRoaXMuZWRnZXNBcnJheS5sZW5ndGggPSAwO1xuICAgIGRlbGV0ZSB0aGlzLm5vZGVzQXJyYXk7XG4gICAgZGVsZXRlIHRoaXMuZWRnZXNBcnJheTtcblxuICAgIC8vIERlbGV0ZSBpbmRleGVzOlxuICAgIGRlbGV0ZSB0aGlzLm5vZGVzSW5kZXg7XG4gICAgZGVsZXRlIHRoaXMuZWRnZXNJbmRleDtcbiAgICBkZWxldGUgdGhpcy5pbk5laWdoYm9yc0luZGV4O1xuICAgIGRlbGV0ZSB0aGlzLm91dE5laWdoYm9yc0luZGV4O1xuICAgIGRlbGV0ZSB0aGlzLmFsbE5laWdoYm9yc0luZGV4O1xuICAgIGRlbGV0ZSB0aGlzLmluTmVpZ2hib3JzQ291bnQ7XG4gICAgZGVsZXRlIHRoaXMub3V0TmVpZ2hib3JzQ291bnQ7XG4gICAgZGVsZXRlIHRoaXMuYWxsTmVpZ2hib3JzQ291bnQ7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBlbXB0aWVzIHRoZSBub2RlcyBhbmQgZWRnZXMgYXJyYXlzLCBhcyB3ZWxsIGFzIHRoZSBkaWZmZXJlbnRcbiAgICogaW5kZXhlcy5cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgZ3JhcGggaW5zdGFuY2UuXG4gICAqL1xuICBncmFwaC5hZGRNZXRob2QoJ2NsZWFyJywgZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5ub2Rlc0FycmF5Lmxlbmd0aCA9IDA7XG4gICAgdGhpcy5lZGdlc0FycmF5Lmxlbmd0aCA9IDA7XG5cbiAgICAvLyBEdWUgdG8gR0MgaXNzdWVzLCBJIHByZWZlciBub3QgdG8gY3JlYXRlIG5ldyBvYmplY3QuIFRoZXNlIG9iamVjdHMgYXJlXG4gICAgLy8gb25seSBhdmFpbGFibGUgZnJvbSB0aGUgbWV0aG9kcyBhbmQgYXR0YWNoZWQgZnVuY3Rpb25zLCBidXQgc3RpbGwsIGl0IGlzXG4gICAgLy8gYmV0dGVyIHRvIHByZXZlbnQgZ2hvc3QgcmVmZXJlbmNlcyB0byB1bnJlbGV2YW50IGRhdGEuLi5cbiAgICBfX2VtcHR5T2JqZWN0KHRoaXMubm9kZXNJbmRleCk7XG4gICAgX19lbXB0eU9iamVjdCh0aGlzLmVkZ2VzSW5kZXgpO1xuICAgIF9fZW1wdHlPYmplY3QodGhpcy5ub2Rlc0luZGV4KTtcbiAgICBfX2VtcHR5T2JqZWN0KHRoaXMuaW5OZWlnaGJvcnNJbmRleCk7XG4gICAgX19lbXB0eU9iamVjdCh0aGlzLm91dE5laWdoYm9yc0luZGV4KTtcbiAgICBfX2VtcHR5T2JqZWN0KHRoaXMuYWxsTmVpZ2hib3JzSW5kZXgpO1xuICAgIF9fZW1wdHlPYmplY3QodGhpcy5pbk5laWdoYm9yc0NvdW50KTtcbiAgICBfX2VtcHR5T2JqZWN0KHRoaXMub3V0TmVpZ2hib3JzQ291bnQpO1xuICAgIF9fZW1wdHlPYmplY3QodGhpcy5hbGxOZWlnaGJvcnNDb3VudCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJlYWRzIGFuIG9iamVjdCBhbmQgYWRkcyB0aGUgbm9kZXMgYW5kIGVkZ2VzLCB0aHJvdWdoIHRoZVxuICAgKiBwcm9wZXIgbWV0aG9kcyBcImFkZE5vZGVcIiBhbmQgXCJhZGRFZGdlXCIuXG4gICAqXG4gICAqIEhlcmUgaXMgYW4gZXhhbXBsZTpcbiAgICpcbiAgICogID4gdmFyIG15R3JhcGggPSBuZXcgZ3JhcGgoKTtcbiAgICogID4gbXlHcmFwaC5yZWFkKHtcbiAgICogID4gICBub2RlczogW1xuICAgKiAgPiAgICAgeyBpZDogJ24wJyB9LFxuICAgKiAgPiAgICAgeyBpZDogJ24xJyB9XG4gICAqICA+ICAgXSxcbiAgICogID4gICBlZGdlczogW1xuICAgKiAgPiAgICAge1xuICAgKiAgPiAgICAgICBpZDogJ2UwJyxcbiAgICogID4gICAgICAgc291cmNlOiAnbjAnLFxuICAgKiAgPiAgICAgICB0YXJnZXQ6ICduMSdcbiAgICogID4gICAgIH1cbiAgICogID4gICBdXG4gICAqICA+IH0pO1xuICAgKiAgPlxuICAgKiAgPiBjb25zb2xlLmxvZyhcbiAgICogID4gICBteUdyYXBoLm5vZGVzKCkubGVuZ3RoLFxuICAgKiAgPiAgIG15R3JhcGguZWRnZXMoKS5sZW5ndGhcbiAgICogID4gKTsgLy8gb3V0cHV0cyAyIDFcbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSBnIFRoZSBncmFwaCBvYmplY3QuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICBUaGUgZ3JhcGggaW5zdGFuY2UuXG4gICAqL1xuICBncmFwaC5hZGRNZXRob2QoJ3JlYWQnLCBmdW5jdGlvbihnKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGEsXG4gICAgICAgIGw7XG5cbiAgICBhID0gZy5ub2RlcyB8fCBbXTtcbiAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICB0aGlzLmFkZE5vZGUoYVtpXSk7XG5cbiAgICBhID0gZy5lZGdlcyB8fCBbXTtcbiAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICB0aGlzLmFkZEVkZ2UoYVtpXSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kcyByZXR1cm5zIG9uZSBvciBzZXZlcmFsIG5vZGVzLCBkZXBlbmRpbmcgb24gaG93IGl0IGlzIGNhbGxlZC5cbiAgICpcbiAgICogVG8gZ2V0IHRoZSBhcnJheSBvZiBub2RlcywgY2FsbCBcIm5vZGVzXCIgd2l0aG91dCBhcmd1bWVudC4gVG8gZ2V0IGFcbiAgICogc3BlY2lmaWMgbm9kZSwgY2FsbCBpdCB3aXRoIHRoZSBpZCBvZiB0aGUgbm9kZS4gVGhlIGdldCBtdWx0aXBsZSBub2RlLFxuICAgKiBjYWxsIGl0IHdpdGggYW4gYXJyYXkgb2YgaWRzLCBhbmQgaXQgd2lsbCByZXR1cm4gdGhlIGFycmF5IG9mIG5vZGVzLCBpblxuICAgKiB0aGUgc2FtZSBvcmRlci5cbiAgICpcbiAgICogQHBhcmFtICB7PyhzdHJpbmd8YXJyYXkpfSB2IEV2ZW50dWFsbHkgb25lIGlkLCBhbiBhcnJheSBvZiBpZHMuXG4gICAqIEByZXR1cm4ge29iamVjdHxhcnJheX0gICAgICBUaGUgcmVsYXRlZCBub2RlIG9yIGFycmF5IG9mIG5vZGVzLlxuICAgKi9cbiAgZ3JhcGguYWRkTWV0aG9kKCdub2RlcycsIGZ1bmN0aW9uKHYpIHtcbiAgICAvLyBDbG9uZSB0aGUgYXJyYXkgb2Ygbm9kZXMgYW5kIHJldHVybiBpdDpcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICByZXR1cm4gdGhpcy5ub2Rlc0FycmF5LnNsaWNlKDApO1xuXG4gICAgLy8gUmV0dXJuIHRoZSByZWxhdGVkIG5vZGU6XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgKHR5cGVvZiB2ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdiA9PT0gJ251bWJlcicpKVxuICAgICAgcmV0dXJuIHRoaXMubm9kZXNJbmRleFt2XTtcblxuICAgIC8vIFJldHVybiBhbiBhcnJheSBvZiB0aGUgcmVsYXRlZCBub2RlOlxuICAgIGlmIChcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiZcbiAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgICkge1xuICAgICAgdmFyIGksXG4gICAgICAgICAgbCxcbiAgICAgICAgICBhID0gW107XG5cbiAgICAgIGZvciAoaSA9IDAsIGwgPSB2Lmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgaWYgKHR5cGVvZiB2W2ldID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdltpXSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgYS5wdXNoKHRoaXMubm9kZXNJbmRleFt2W2ldXSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aHJvdyAnbm9kZXM6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICB0aHJvdyAnbm9kZXM6IFdyb25nIGFyZ3VtZW50cy4nO1xuICB9KTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2RzIHJldHVybnMgdGhlIGRlZ3JlZSBvZiBvbmUgb3Igc2V2ZXJhbCBub2RlcywgZGVwZW5kaW5nIG9uIGhvd1xuICAgKiBpdCBpcyBjYWxsZWQuIEl0IGlzIGFsc28gcG9zc2libGUgdG8gZ2V0IGluY29taW5nIG9yIG91dGNvbWluZyBkZWdyZWVzXG4gICAqIGluc3RlYWQgYnkgc3BlY2lmeWluZyAnaW4nIG9yICdvdXQnIGFzIGEgc2Vjb25kIGFyZ3VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd8YXJyYXl9IHYgICAgIE9uZSBpZCwgYW4gYXJyYXkgb2YgaWRzLlxuICAgKiBAcGFyYW0gIHs/c3RyaW5nfSAgICAgIHdoaWNoIFdoaWNoIGRlZ3JlZSBpcyByZXF1aXJlZC4gVmFsdWVzIGFyZSAnaW4nLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvdXQnLCBhbmQgYnkgZGVmYXVsdCB0aGUgbm9ybWFsIGRlZ3JlZS5cbiAgICogQHJldHVybiB7bnVtYmVyfGFycmF5fSAgICAgICBUaGUgcmVsYXRlZCBkZWdyZWUgb3IgYXJyYXkgb2YgZGVncmVlcy5cbiAgICovXG4gIGdyYXBoLmFkZE1ldGhvZCgnZGVncmVlJywgZnVuY3Rpb24odiwgd2hpY2gpIHtcbiAgICAvLyBDaGVjayB3aGljaCBkZWdyZWUgaXMgcmVxdWlyZWQ6XG4gICAgd2hpY2ggPSB7XG4gICAgICAnaW4nOiB0aGlzLmluTmVpZ2hib3JzQ291bnQsXG4gICAgICAnb3V0JzogdGhpcy5vdXROZWlnaGJvcnNDb3VudFxuICAgIH1bd2hpY2ggfHwgJyddIHx8IHRoaXMuYWxsTmVpZ2hib3JzQ291bnQ7XG5cbiAgICAvLyBSZXR1cm4gdGhlIHJlbGF0ZWQgbm9kZTpcbiAgICBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2ID09PSAnbnVtYmVyJylcbiAgICAgIHJldHVybiB3aGljaFt2XTtcblxuICAgIC8vIFJldHVybiBhbiBhcnJheSBvZiB0aGUgcmVsYXRlZCBub2RlOlxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIHZhciBpLFxuICAgICAgICAgIGwsXG4gICAgICAgICAgYSA9IFtdO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsID0gdi5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIGlmICh0eXBlb2YgdltpXSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZbaV0gPT09ICdudW1iZXInKVxuICAgICAgICAgIGEucHVzaCh3aGljaFt2W2ldXSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aHJvdyAnZGVncmVlOiBXcm9uZyBhcmd1bWVudHMuJztcblxuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgdGhyb3cgJ2RlZ3JlZTogV3JvbmcgYXJndW1lbnRzLic7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZHMgcmV0dXJucyBvbmUgb3Igc2V2ZXJhbCBlZGdlcywgZGVwZW5kaW5nIG9uIGhvdyBpdCBpcyBjYWxsZWQuXG4gICAqXG4gICAqIFRvIGdldCB0aGUgYXJyYXkgb2YgZWRnZXMsIGNhbGwgXCJlZGdlc1wiIHdpdGhvdXQgYXJndW1lbnQuIFRvIGdldCBhXG4gICAqIHNwZWNpZmljIGVkZ2UsIGNhbGwgaXQgd2l0aCB0aGUgaWQgb2YgdGhlIGVkZ2UuIFRoZSBnZXQgbXVsdGlwbGUgZWRnZSxcbiAgICogY2FsbCBpdCB3aXRoIGFuIGFycmF5IG9mIGlkcywgYW5kIGl0IHdpbGwgcmV0dXJuIHRoZSBhcnJheSBvZiBlZGdlcywgaW5cbiAgICogdGhlIHNhbWUgb3JkZXIuXG4gICAqXG4gICAqIEBwYXJhbSAgez8oc3RyaW5nfGFycmF5KX0gdiBFdmVudHVhbGx5IG9uZSBpZCwgYW4gYXJyYXkgb2YgaWRzLlxuICAgKiBAcmV0dXJuIHtvYmplY3R8YXJyYXl9ICAgICAgVGhlIHJlbGF0ZWQgZWRnZSBvciBhcnJheSBvZiBlZGdlcy5cbiAgICovXG4gIGdyYXBoLmFkZE1ldGhvZCgnZWRnZXMnLCBmdW5jdGlvbih2KSB7XG4gICAgLy8gQ2xvbmUgdGhlIGFycmF5IG9mIGVkZ2VzIGFuZCByZXR1cm4gaXQ6XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgcmV0dXJuIHRoaXMuZWRnZXNBcnJheS5zbGljZSgwKTtcblxuICAgIC8vIFJldHVybiB0aGUgcmVsYXRlZCBlZGdlOlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICh0eXBlb2YgdiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHYgPT09ICdudW1iZXInKSlcbiAgICAgIHJldHVybiB0aGlzLmVkZ2VzSW5kZXhbdl07XG5cbiAgICAvLyBSZXR1cm4gYW4gYXJyYXkgb2YgdGhlIHJlbGF0ZWQgZWRnZTpcbiAgICBpZiAoXG4gICAgICBhcmd1bWVudHMubGVuZ3RoID09PSAxICYmXG4gICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgICApIHtcbiAgICAgIHZhciBpLFxuICAgICAgICAgIGwsXG4gICAgICAgICAgYSA9IFtdO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsID0gdi5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIGlmICh0eXBlb2YgdltpXSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZbaV0gPT09ICdudW1iZXInKVxuICAgICAgICAgIGEucHVzaCh0aGlzLmVkZ2VzSW5kZXhbdltpXV0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhyb3cgJ2VkZ2VzOiBXcm9uZyBhcmd1bWVudHMuJztcblxuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgdGhyb3cgJ2VkZ2VzOiBXcm9uZyBhcmd1bWVudHMuJztcbiAgfSk7XG5cblxuICAvKipcbiAgICogRVhQT1JUOlxuICAgKiAqKioqKioqXG4gICAqL1xuICBpZiAodHlwZW9mIHNpZ21hICE9PSAndW5kZWZpbmVkJykge1xuICAgIHNpZ21hLmNsYXNzZXMgPSBzaWdtYS5jbGFzc2VzIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgc2lnbWEuY2xhc3Nlcy5ncmFwaCA9IGdyYXBoO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cylcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGdyYXBoO1xuICAgIGV4cG9ydHMuZ3JhcGggPSBncmFwaDtcbiAgfSBlbHNlXG4gICAgdGhpcy5ncmFwaCA9IGdyYXBoO1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2xhc3NlcycpO1xuXG4gIC8qKlxuICAgKiBUaGUgY2FtZXJhIGNvbnN0cnVjdG9yLiBJdCBqdXN0IGluaXRpYWxpemVzIGl0cyBhdHRyaWJ1dGVzIGFuZCBtZXRob2RzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgIGlkICAgICAgIFRoZSBpZC5cbiAgICogQHBhcmFtICB7c2lnbWEuY2xhc3Nlcy5ncmFwaH0gIGdyYXBoICAgIFRoZSBncmFwaC5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSBzZXR0aW5ncyBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSAgez9vYmplY3R9ICAgICAgb3B0aW9ucyAgRXZlbnR1YWxseSBzb21lIG92ZXJyaWRpbmcgb3B0aW9ucy5cbiAgICogQHJldHVybiB7Y2FtZXJhfSAgICAgICAgICAgICAgICBSZXR1cm5zIHRoZSBmcmVzaCBuZXcgY2FtZXJhIGluc3RhbmNlLlxuICAgKi9cbiAgc2lnbWEuY2xhc3Nlcy5jYW1lcmEgPSBmdW5jdGlvbihpZCwgZ3JhcGgsIHNldHRpbmdzLCBvcHRpb25zKSB7XG4gICAgc2lnbWEuY2xhc3Nlcy5kaXNwYXRjaGVyLmV4dGVuZCh0aGlzKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZ3JhcGgnLCB7XG4gICAgICB2YWx1ZTogZ3JhcGhcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2lkJywge1xuICAgICAgdmFsdWU6IGlkXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdyZWFkUHJlZml4Jywge1xuICAgICAgdmFsdWU6ICdyZWFkX2NhbScgKyBpZCArICc6J1xuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncHJlZml4Jywge1xuICAgICAgdmFsdWU6ICdjYW0nICsgaWQgKyAnOidcbiAgICB9KTtcblxuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgICB0aGlzLnJhdGlvID0gMTtcbiAgICB0aGlzLmFuZ2xlID0gMDtcbiAgICB0aGlzLmlzQW5pbWF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnNldHRpbmdzID0gKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJiBvcHRpb25zKSA/XG4gICAgICBzZXR0aW5ncy5lbWJlZE9iamVjdChvcHRpb25zKSA6XG4gICAgICBzZXR0aW5ncztcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgY2FtZXJhIHBvc2l0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGNvb3JkaW5hdGVzIFRoZSBuZXcgY29vcmRpbmF0ZXMgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtjYW1lcmF9ICAgICAgICAgICAgIFJldHVybnMgdGhlIGNhbWVyYS5cbiAgICovXG4gIHNpZ21hLmNsYXNzZXMuY2FtZXJhLnByb3RvdHlwZS5nb1RvID0gZnVuY3Rpb24oY29vcmRpbmF0ZXMpIHtcbiAgICBpZiAoIXRoaXMuc2V0dGluZ3MoJ2VuYWJsZUNhbWVyYScpKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgYyA9IGNvb3JkaW5hdGVzIHx8IHt9LFxuICAgICAgICBrZXlzID0gWyd4JywgJ3knLCAncmF0aW8nLCAnYW5nbGUnXTtcblxuICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIGlmIChjW2tleXNbaV1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjW2tleXNbaV1dID09PSAnbnVtYmVyJyAmJiAhaXNOYU4oY1trZXlzW2ldXSkpXG4gICAgICAgICAgdGhpc1trZXlzW2ldXSA9IGNba2V5c1tpXV07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aHJvdyAnVmFsdWUgZm9yIFwiJyArIGtleXNbaV0gKyAnXCIgaXMgbm90IGEgbnVtYmVyLic7XG4gICAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ2Nvb3JkaW5hdGVzVXBkYXRlZCcpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCB0YWtlcyBhIGdyYXBoIGFuZCBjb21wdXRlcyBmb3IgZWFjaCBub2RlIGFuZCBlZGdlcyBpdHNcbiAgICogY29vcmRpbmF0ZXMgcmVsYXRpdmVseSB0byB0aGUgY2VudGVyIG9mIHRoZSBjYW1lcmEuIEJhc2ljYWxseSwgaXQgd2lsbFxuICAgKiBjb21wdXRlIHRoZSBjb29yZGluYXRlcyB0aGF0IHdpbGwgYmUgdXNlZCBieSB0aGUgZ3JhcGhpYyByZW5kZXJlcnMuXG4gICAqXG4gICAqIFNpbmNlIGl0IHNob3VsZCBiZSBwb3NzaWJsZSB0byB1c2UgZGlmZmVyZW50IGNhbWVyYXMgYW5kIGRpZmZlcmVudFxuICAgKiByZW5kZXJlcnMsIGl0IGlzIHBvc3NpYmxlIHRvIHNwZWNpZnkgYSBwcmVmaXggdG8gcHV0IGJlZm9yZSB0aGUgbmV3XG4gICAqIGNvb3JkaW5hdGVzICh0byBnZXQgc29tZXRoaW5nIGxpa2UgXCJub2RlLmNhbWVyYTFfeFwiKVxuICAgKlxuICAgKiBAcGFyYW0gIHs/c3RyaW5nfSByZWFkICAgIFRoZSBwcmVmaXggb2YgdGhlIGNvb3JkaW5hdGVzIHRvIHJlYWQuXG4gICAqIEBwYXJhbSAgez9zdHJpbmd9IHdyaXRlICAgVGhlIHByZWZpeCBvZiB0aGUgY29vcmRpbmF0ZXMgdG8gd3JpdGUuXG4gICAqIEBwYXJhbSAgez9vYmplY3R9IG9wdGlvbnMgRXZlbnR1YWxseSBhbiBvYmplY3Qgb2Ygb3B0aW9ucy4gVGhvc2UgY2FuIGJlOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gQSByZXN0cmljdGVkIG5vZGVzIGFycmF5LlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gQSByZXN0cmljdGVkIGVkZ2VzIGFycmF5LlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gQSB3aWR0aC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAtIEEgaGVpZ2h0LlxuICAgKiBAcmV0dXJuIHtjYW1lcmF9ICAgICAgICBSZXR1cm5zIHRoZSBjYW1lcmEuXG4gICAqL1xuICBzaWdtYS5jbGFzc2VzLmNhbWVyYS5wcm90b3R5cGUuYXBwbHlWaWV3ID0gZnVuY3Rpb24ocmVhZCwgd3JpdGUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB3cml0ZSA9IHdyaXRlICE9PSB1bmRlZmluZWQgPyB3cml0ZSA6IHRoaXMucHJlZml4O1xuICAgIHJlYWQgPSByZWFkICE9PSB1bmRlZmluZWQgPyByZWFkIDogdGhpcy5yZWFkUHJlZml4O1xuXG4gICAgdmFyIG5vZGVzID0gb3B0aW9ucy5ub2RlcyB8fCB0aGlzLmdyYXBoLm5vZGVzKCksXG4gICAgICAgIGVkZ2VzID0gb3B0aW9ucy5lZGdlcyB8fCB0aGlzLmdyYXBoLmVkZ2VzKCk7XG5cbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgcmVsQ29zID0gTWF0aC5jb3ModGhpcy5hbmdsZSkgLyB0aGlzLnJhdGlvLFxuICAgICAgICByZWxTaW4gPSBNYXRoLnNpbih0aGlzLmFuZ2xlKSAvIHRoaXMucmF0aW8sXG4gICAgICAgIG5vZGVSYXRpbyA9IE1hdGgucG93KHRoaXMucmF0aW8sIHRoaXMuc2V0dGluZ3MoJ25vZGVzUG93UmF0aW8nKSksXG4gICAgICAgIGVkZ2VSYXRpbyA9IE1hdGgucG93KHRoaXMucmF0aW8sIHRoaXMuc2V0dGluZ3MoJ2VkZ2VzUG93UmF0aW8nKSksXG4gICAgICAgIHhPZmZzZXQgPSAob3B0aW9ucy53aWR0aCB8fCAwKSAvIDIgLSB0aGlzLnggKiByZWxDb3MgLSB0aGlzLnkgKiByZWxTaW4sXG4gICAgICAgIHlPZmZzZXQgPSAob3B0aW9ucy5oZWlnaHQgfHwgMCkgLyAyIC0gdGhpcy55ICogcmVsQ29zICsgdGhpcy54ICogcmVsU2luO1xuXG4gICAgZm9yIChpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgbm9kZVt3cml0ZSArICd4J10gPVxuICAgICAgICAobm9kZVtyZWFkICsgJ3gnXSB8fCAwKSAqIHJlbENvcyArXG4gICAgICAgIChub2RlW3JlYWQgKyAneSddIHx8IDApICogcmVsU2luICtcbiAgICAgICAgeE9mZnNldDtcbiAgICAgIG5vZGVbd3JpdGUgKyAneSddID1cbiAgICAgICAgKG5vZGVbcmVhZCArICd5J10gfHwgMCkgKiByZWxDb3MgLVxuICAgICAgICAobm9kZVtyZWFkICsgJ3gnXSB8fCAwKSAqIHJlbFNpbiArXG4gICAgICAgIHlPZmZzZXQ7XG4gICAgICBub2RlW3dyaXRlICsgJ3NpemUnXSA9XG4gICAgICAgIChub2RlW3JlYWQgKyAnc2l6ZSddIHx8IDApIC9cbiAgICAgICAgbm9kZVJhdGlvO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGwgPSBlZGdlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGVkZ2VzW2ldW3dyaXRlICsgJ3NpemUnXSA9XG4gICAgICAgIChlZGdlc1tpXVtyZWFkICsgJ3NpemUnXSB8fCAwKSAvXG4gICAgICAgIGVkZ2VSYXRpbztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBjb252ZXJ0cyB0aGUgY29vcmRpbmF0ZXMgb2YgYSBwb2ludCBmcm9tIHRoZSBmcmFtZSBvZiB0aGVcbiAgICogY2FtZXJhIHRvIHRoZSBmcmFtZSBvZiB0aGUgZ3JhcGguXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0geCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCBpbiB0aGUgZnJhbWUgb2YgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICBjYW1lcmEuXG4gICAqIEBwYXJhbSAge251bWJlcn0geSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCBpbiB0aGUgZnJhbWUgb2YgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICBjYW1lcmEuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICBUaGUgcG9pbnQgY29vcmRpbmF0ZXMgaW4gdGhlIGZyYW1lIG9mIHRoZSBncmFwaC5cbiAgICovXG4gIHNpZ21hLmNsYXNzZXMuY2FtZXJhLnByb3RvdHlwZS5ncmFwaFBvc2l0aW9uID0gZnVuY3Rpb24oeCwgeSwgdmVjdG9yKSB7XG4gICAgdmFyIFggPSAwLFxuICAgICAgICBZID0gMCxcbiAgICAgICAgY29zID0gTWF0aC5jb3ModGhpcy5hbmdsZSksXG4gICAgICAgIHNpbiA9IE1hdGguc2luKHRoaXMuYW5nbGUpO1xuXG4gICAgLy8gUmV2ZXJ0IHRoZSBvcmlnaW4gZGlmZmVyZW50aWFsIHZlY3RvcjpcbiAgICBpZiAoIXZlY3Rvcikge1xuICAgICAgWCA9IC0gKHRoaXMueCAqIGNvcyArIHRoaXMueSAqIHNpbikgLyB0aGlzLnJhdGlvO1xuICAgICAgWSA9IC0gKHRoaXMueSAqIGNvcyAtIHRoaXMueCAqIHNpbikgLyB0aGlzLnJhdGlvO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB4OiAoeCAqIGNvcyArIHkgKiBzaW4pIC8gdGhpcy5yYXRpbyArIFgsXG4gICAgICB5OiAoeSAqIGNvcyAtIHggKiBzaW4pIC8gdGhpcy5yYXRpbyArIFlcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGNvbnZlcnRzIHRoZSBjb29yZGluYXRlcyBvZiBhIHBvaW50IGZyb20gdGhlIGZyYW1lIG9mIHRoZVxuICAgKiBncmFwaCB0byB0aGUgZnJhbWUgb2YgdGhlIGNhbWVyYS5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IGluIHRoZSBmcmFtZSBvZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgIGdyYXBoLlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgaW4gdGhlIGZyYW1lIG9mIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgZ3JhcGguXG4gICAqIEByZXR1cm4ge29iamVjdH0gICBUaGUgcG9pbnQgY29vcmRpbmF0ZXMgaW4gdGhlIGZyYW1lIG9mIHRoZSBjYW1lcmEuXG4gICAqL1xuICBzaWdtYS5jbGFzc2VzLmNhbWVyYS5wcm90b3R5cGUuY2FtZXJhUG9zaXRpb24gPSBmdW5jdGlvbih4LCB5LCB2ZWN0b3IpIHtcbiAgICB2YXIgWCA9IDAsXG4gICAgICAgIFkgPSAwLFxuICAgICAgICBjb3MgPSBNYXRoLmNvcyh0aGlzLmFuZ2xlKSxcbiAgICAgICAgc2luID0gTWF0aC5zaW4odGhpcy5hbmdsZSk7XG5cbiAgICAvLyBSZXZlcnQgdGhlIG9yaWdpbiBkaWZmZXJlbnRpYWwgdmVjdG9yOlxuICAgIGlmICghdmVjdG9yKSB7XG4gICAgICBYID0gLSAodGhpcy54ICogY29zICsgdGhpcy55ICogc2luKSAvIHRoaXMucmF0aW87XG4gICAgICBZID0gLSAodGhpcy55ICogY29zIC0gdGhpcy54ICogc2luKSAvIHRoaXMucmF0aW87XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6ICgoeCAtIFgpICogY29zIC0gKHkgLSBZKSAqIHNpbikgKiB0aGlzLnJhdGlvLFxuICAgICAgeTogKCh5IC0gWSkgKiBjb3MgKyAoeCAtIFgpICogc2luKSAqIHRoaXMucmF0aW9cbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggb2YgdGhlIGNhbWVyYS4gVGhpcyBpc1xuICAgKiBlc3BlY2lhbGx5IHVzZWZ1bCB0byBhcHBseSB0aGUgY2FtZXJhIHZpZXcgZGlyZWN0bHkgaW4gc2hhZGVycywgaW4gY2FzZSBvZlxuICAgKiBXZWJHTCByZW5kZXJpbmcuXG4gICAqXG4gICAqIEByZXR1cm4ge2FycmF5fSBUaGUgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuICAgKi9cbiAgc2lnbWEuY2xhc3Nlcy5jYW1lcmEucHJvdG90eXBlLmdldE1hdHJpeCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2FsZSA9IHNpZ21hLnV0aWxzLm1hdHJpY2VzLnNjYWxlKDEgLyB0aGlzLnJhdGlvKSxcbiAgICAgICAgcm90YXRpb24gPSBzaWdtYS51dGlscy5tYXRyaWNlcy5yb3RhdGlvbih0aGlzLmFuZ2xlKSxcbiAgICAgICAgdHJhbnNsYXRpb24gPSBzaWdtYS51dGlscy5tYXRyaWNlcy50cmFuc2xhdGlvbigtdGhpcy54LCAtdGhpcy55KSxcbiAgICAgICAgbWF0cml4ID0gc2lnbWEudXRpbHMubWF0cmljZXMubXVsdGlwbHkoXG4gICAgICAgICAgdHJhbnNsYXRpb24sXG4gICAgICAgICAgc2lnbWEudXRpbHMubWF0cmljZXMubXVsdGlwbHkoXG4gICAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICAgIHNjYWxlXG4gICAgICAgICAgKVxuICAgICAgICApO1xuXG4gICAgcmV0dXJuIG1hdHJpeDtcbiAgfTtcblxuICAvKipcbiAgICogVGFraW5nIGEgd2lkdGggYW5kIGEgaGVpZ2h0IGFzIHBhcmFtZXRlcnMsIHRoaXMgbWV0aG9kIHJldHVybnMgdGhlXG4gICAqIGNvb3JkaW5hdGVzIG9mIHRoZSByZWN0YW5nbGUgcmVwcmVzZW50aW5nIHRoZSBjYW1lcmEgb24gc2NyZWVuLCBpbiB0aGVcbiAgICogZ3JhcGgncyByZWZlcmVudGllbC5cbiAgICpcbiAgICogVG8ga2VlcCBkaXNwbGF5aW5nIGxhYmVscyBvZiBub2RlcyBnb2luZyBvdXQgb2YgdGhlIHNjcmVlbiwgdGhlIG1ldGhvZFxuICAgKiBrZWVwcyBhIG1hcmdpbiBhcm91bmQgdGhlIHNjcmVlbiBpbiB0aGUgcmV0dXJuZWQgcmVjdGFuZ2xlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHdpZHRoICBUaGUgd2lkdGggb2YgdGhlIHNjcmVlbi5cbiAgICogQHBhcmFtICB7bnVtYmVyfSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgc2NyZWVuLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICBUaGUgcmVjdGFuZ2xlIGFzIHgxLCB5MSwgeDIgYW5kIHkyLCByZXByZXNlbnRpbmdcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgdHdvIG9wcG9zaXRlIHBvaW50cy5cbiAgICovXG4gIHNpZ21hLmNsYXNzZXMuY2FtZXJhLnByb3RvdHlwZS5nZXRSZWN0YW5nbGUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIHdpZHRoVmVjdCA9IHRoaXMuY2FtZXJhUG9zaXRpb24od2lkdGgsIDAsIHRydWUpLFxuICAgICAgICBoZWlnaHRWZWN0ID0gdGhpcy5jYW1lcmFQb3NpdGlvbigwLCBoZWlnaHQsIHRydWUpLFxuICAgICAgICBjZW50ZXJWZWN0ID0gdGhpcy5jYW1lcmFQb3NpdGlvbih3aWR0aCAvIDIsIGhlaWdodCAvIDIsIHRydWUpLFxuICAgICAgICBtYXJnaW5YID0gdGhpcy5jYW1lcmFQb3NpdGlvbih3aWR0aCAvIDQsIDAsIHRydWUpLngsXG4gICAgICAgIG1hcmdpblkgPSB0aGlzLmNhbWVyYVBvc2l0aW9uKDAsIGhlaWdodCAvIDQsIHRydWUpLnk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDE6IHRoaXMueCAtIGNlbnRlclZlY3QueCAtIG1hcmdpblgsXG4gICAgICB5MTogdGhpcy55IC0gY2VudGVyVmVjdC55IC0gbWFyZ2luWSxcbiAgICAgIHgyOiB0aGlzLnggLSBjZW50ZXJWZWN0LnggKyBtYXJnaW5YICsgd2lkdGhWZWN0LngsXG4gICAgICB5MjogdGhpcy55IC0gY2VudGVyVmVjdC55IC0gbWFyZ2luWSArIHdpZHRoVmVjdC55LFxuICAgICAgaGVpZ2h0OiBNYXRoLnNxcnQoXG4gICAgICAgIE1hdGgucG93KGhlaWdodFZlY3QueCwgMikgK1xuICAgICAgICBNYXRoLnBvdyhoZWlnaHRWZWN0LnkgKyAyICogbWFyZ2luWSwgMilcbiAgICAgIClcbiAgICB9O1xuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBTaWdtYSBRdWFkdHJlZSBNb2R1bGVcbiAgICogPT09PT09PT09PT09PT09PT09PT09XG4gICAqXG4gICAqIEF1dGhvcjogR3VpbGxhdW1lIFBsaXF1ZSAoWW9tZ3VpdGhlcmVhbClcbiAgICogVmVyc2lvbjogMC4yXG4gICAqL1xuXG5cblxuICAvKipcbiAgICogUXVhZCBHZW9tZXRyaWMgT3BlcmF0aW9uc1xuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqXG4gICAqIEEgdXNlZnVsIGJhdGNoIG9mIGdlb21ldHJpYyBvcGVyYXRpb25zIHVzZWQgYnkgdGhlIHF1YWR0cmVlLlxuICAgKi9cblxuICB2YXIgX2dlb20gPSB7XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGEgZ3JhcGggbm9kZSB3aXRoIHgsIHkgYW5kIHNpemUgaW50byBhblxuICAgICAqIGF4aXMtYWxpZ25lZCBzcXVhcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgZ3JhcGggbm9kZSB3aXRoIGF0IGxlYXN0IGEgcG9pbnQgKHgsIHkpIGFuZCBhIHNpemUuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBBIHNxdWFyZTogdHdvIHBvaW50cyAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICAgKi9cbiAgICBwb2ludFRvU3F1YXJlOiBmdW5jdGlvbihuKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogbi54IC0gbi5zaXplLFxuICAgICAgICB5MTogbi55IC0gbi5zaXplLFxuICAgICAgICB4Mjogbi54ICsgbi5zaXplLFxuICAgICAgICB5Mjogbi55IC0gbi5zaXplLFxuICAgICAgICBoZWlnaHQ6IG4uc2l6ZSAqIDJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIGEgcmVjdGFuZ2xlIGlzIGF4aXMtYWxpZ25lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gIEEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHBvaW50c1xuICAgICAqICAgICAgICAgICAgICAgICAgICh4MSwgeTEpIGFuZCAoeDIsIHkyKS5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSByZWN0YW5nbGUgaXMgYXhpcy1hbGlnbmVkLlxuICAgICAqL1xuICAgIGlzQXhpc0FsaWduZWQ6IGZ1bmN0aW9uKHIpIHtcbiAgICAgIHJldHVybiByLngxID09PSByLngyIHx8IHIueTEgPT09IHIueTI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdG9wIHBvaW50cyBvZiBhbiBheGlzLWFsaWduZWQgcmVjdGFuZ2xlLiBUaGlzIGlzIHVzZWZ1bCBpblxuICAgICAqIGNhc2VzIHdoZW4gdGhlIHJlY3RhbmdsZSBoYXMgYmVlbiByb3RhdGVkIChsZWZ0LCByaWdodCBvciBib3R0b20gdXApIGFuZFxuICAgICAqIGxhdGVyIG9wZXJhdGlvbnMgbmVlZCB0byBrbm93IHRoZSB0b3AgcG9pbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBBbiBheGlzLWFsaWduZWQgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHBvaW50c1xuICAgICAqICAgICAgICAgICAgICAgICAgKHgxLCB5MSksICh4MiwgeTIpIGFuZCBoZWlnaHQuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBBIHJlY3RhbmdsZTogdHdvIHBvaW50cyAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICAgKi9cbiAgICBheGlzQWxpZ25lZFRvcFBvaW50czogZnVuY3Rpb24ocikge1xuXG4gICAgICAvLyBCYXNpY1xuICAgICAgaWYgKHIueTEgPT09IHIueTIgJiYgci54MSA8IHIueDIpXG4gICAgICAgIHJldHVybiByO1xuXG4gICAgICAvLyBSb3RhdGVkIHRvIHJpZ2h0XG4gICAgICBpZiAoci54MSA9PT0gci54MiAmJiByLnkyID4gci55MSlcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4MTogci54MSAtIHIuaGVpZ2h0LCB5MTogci55MSxcbiAgICAgICAgICB4Mjogci54MSwgeTI6IHIueTEsXG4gICAgICAgICAgaGVpZ2h0OiByLmhlaWdodFxuICAgICAgICB9O1xuXG4gICAgICAvLyBSb3RhdGVkIHRvIGxlZnRcbiAgICAgIGlmIChyLngxID09PSByLngyICYmIHIueTIgPCByLnkxKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHgxOiByLngxLCB5MTogci55MixcbiAgICAgICAgICB4Mjogci54MiArIHIuaGVpZ2h0LCB5Mjogci55MixcbiAgICAgICAgICBoZWlnaHQ6IHIuaGVpZ2h0XG4gICAgICAgIH07XG5cbiAgICAgIC8vIEJvdHRvbSdzIHVwXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogci54MiwgeTE6IHIueTEgLSByLmhlaWdodCxcbiAgICAgICAgeDI6IHIueDEsIHkyOiByLnkxIC0gci5oZWlnaHQsXG4gICAgICAgIGhlaWdodDogci5oZWlnaHRcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBjb29yZGluYXRlcyBvZiBhIHJlY3RhbmdsZSdzIGxvd2VyIGxlZnQgY29ybmVyIGZyb20gaXRzIHRvcCBwb2ludHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHBvaW50cyAoeDEsIHkxKSBhbmQgKHgyLCB5MikuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBDb29yZGluYXRlcyBvZiB0aGUgY29ybmVyICh4LCB5KS5cbiAgICAgKi9cbiAgICBsb3dlckxlZnRDb29yOiBmdW5jdGlvbihyKSB7XG4gICAgICB2YXIgd2lkdGggPSAoXG4gICAgICAgIE1hdGguc3FydChcbiAgICAgICAgICBNYXRoLnBvdyhyLngyIC0gci54MSwgMikgK1xuICAgICAgICAgIE1hdGgucG93KHIueTIgLSByLnkxLCAyKVxuICAgICAgICApXG4gICAgICApO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiByLngxIC0gKHIueTIgLSByLnkxKSAqIHIuaGVpZ2h0IC8gd2lkdGgsXG4gICAgICAgIHk6IHIueTEgKyAoci54MiAtIHIueDEpICogci5oZWlnaHQgLyB3aWR0aFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGNvb3JkaW5hdGVzIG9mIGEgcmVjdGFuZ2xlJ3MgbG93ZXIgcmlnaHQgY29ybmVyIGZyb20gaXRzIHRvcCBwb2ludHNcbiAgICAgKiBhbmQgaXRzIGxvd2VyIGxlZnQgY29ybmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBBIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IHR3byBwb2ludHMgKHgxLCB5MSkgYW5kICh4MiwgeTIpLlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQSBjb3JuZXIncyBjb29yZGluYXRlcyAoeCwgeSkuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBDb29yZGluYXRlcyBvZiB0aGUgY29ybmVyICh4LCB5KS5cbiAgICAgKi9cbiAgICBsb3dlclJpZ2h0Q29vcjogZnVuY3Rpb24ociwgbGxjKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBsbGMueCAtIHIueDEgKyByLngyLFxuICAgICAgICB5OiBsbGMueSAtIHIueTEgKyByLnkyXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNvb3JkaW5hdGVzIG9mIGFsbCB0aGUgY29ybmVycyBvZiBhIHJlY3RhbmdsZSBmcm9tIGl0cyB0b3AgcG9pbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHBvaW50cyAoeDEsIHkxKSBhbmQgKHgyLCB5MikuXG4gICAgICogQHJldHVybiB7YXJyYXl9ICBBbiBhcnJheSBvZiB0aGUgZm91ciBjb3JuZXJzJyBjb29yZGluYXRlcyAoeCwgeSkuXG4gICAgICovXG4gICAgcmVjdGFuZ2xlQ29ybmVyczogZnVuY3Rpb24ocikge1xuICAgICAgdmFyIGxsYyA9IHRoaXMubG93ZXJMZWZ0Q29vcihyKSxcbiAgICAgICAgICBscmMgPSB0aGlzLmxvd2VyUmlnaHRDb29yKHIsIGxsYyk7XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHt4OiByLngxLCB5OiByLnkxfSxcbiAgICAgICAge3g6IHIueDIsIHk6IHIueTJ9LFxuICAgICAgICB7eDogbGxjLngsIHk6IGxsYy55fSxcbiAgICAgICAge3g6IGxyYy54LCB5OiBscmMueX1cbiAgICAgIF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNwbGl0IGEgc3F1YXJlIGRlZmluZWQgYnkgaXRzIGJvdW5kYXJpZXMgaW50byBmb3VyLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBCb3VuZGFyaWVzIG9mIHRoZSBzcXVhcmUgKHgsIHksIHdpZHRoLCBoZWlnaHQpLlxuICAgICAqIEByZXR1cm4ge2FycmF5fSAgQW4gYXJyYXkgY29udGFpbmluZyB0aGUgZm91ciBuZXcgc3F1YXJlcywgdGhlbXNlbHZlc1xuICAgICAqICAgICAgICAgICAgICAgICAgZGVmaW5lZCBieSBhbiBhcnJheSBvZiB0aGVpciBmb3VyIGNvcm5lcnMgKHgsIHkpLlxuICAgICAqL1xuICAgIHNwbGl0U3F1YXJlOiBmdW5jdGlvbihiKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBbXG4gICAgICAgICAge3g6IGIueCwgeTogYi55fSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueX0sXG4gICAgICAgICAge3g6IGIueCwgeTogYi55ICsgYi5oZWlnaHQgLyAyfSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn1cbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55fSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCwgeTogYi55fSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGgsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn1cbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIHt4OiBiLngsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9LFxuICAgICAgICAgIHt4OiBiLngsIHk6IGIueSArIGIuaGVpZ2h0fSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueSArIGIuaGVpZ2h0fVxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoLCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55ICsgYi5oZWlnaHR9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoLCB5OiBiLnkgKyBiLmhlaWdodH1cbiAgICAgICAgXVxuICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0aGUgZm91ciBheGlzIGJldHdlZW4gY29ybmVycyBvZiByZWN0YW5nbGUgQSBhbmQgY29ybmVycyBvZlxuICAgICAqIHJlY3RhbmdsZSBCLiBUaGlzIGlzIG5lZWRlZCBsYXRlciB0byBjaGVjayBhbiBldmVudHVhbCBjb2xsaXNpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHthcnJheX0gQW4gYXJyYXkgb2YgcmVjdGFuZ2xlIEEncyBmb3VyIGNvcm5lcnMgKHgsIHkpLlxuICAgICAqIEBwYXJhbSAge2FycmF5fSBBbiBhcnJheSBvZiByZWN0YW5nbGUgQidzIGZvdXIgY29ybmVycyAoeCwgeSkuXG4gICAgICogQHJldHVybiB7YXJyYXl9IEFuIGFycmF5IG9mIGZvdXIgYXhpcyBkZWZpbmVkIGJ5IHRoZWlyIGNvb3JkaW5hdGVzICh4LHkpLlxuICAgICAqL1xuICAgIGF4aXM6IGZ1bmN0aW9uKGMxLCBjMikge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAge3g6IGMxWzFdLnggLSBjMVswXS54LCB5OiBjMVsxXS55IC0gYzFbMF0ueX0sXG4gICAgICAgIHt4OiBjMVsxXS54IC0gYzFbM10ueCwgeTogYzFbMV0ueSAtIGMxWzNdLnl9LFxuICAgICAgICB7eDogYzJbMF0ueCAtIGMyWzJdLngsIHk6IGMyWzBdLnkgLSBjMlsyXS55fSxcbiAgICAgICAge3g6IGMyWzBdLnggLSBjMlsxXS54LCB5OiBjMlswXS55IC0gYzJbMV0ueX1cbiAgICAgIF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb2plY3QgYSByZWN0YW5nbGUncyBjb3JuZXIgb24gYW4gYXhpcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQ29vcmRpbmF0ZXMgb2YgYSBjb3JuZXIgKHgsIHkpLlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQ29vcmRpbmF0ZXMgb2YgYW4gYXhpcyAoeCwgeSkuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcHJvamVjdGlvbiBkZWZpbmVkIGJ5IGNvb3JkaW5hdGVzICh4LCB5KS5cbiAgICAgKi9cbiAgICBwcm9qZWN0aW9uOiBmdW5jdGlvbihjLCBhKSB7XG4gICAgICB2YXIgbCA9IChcbiAgICAgICAgKGMueCAqIGEueCArIGMueSAqIGEueSkgL1xuICAgICAgICAoTWF0aC5wb3coYS54LCAyKSArIE1hdGgucG93KGEueSwgMikpXG4gICAgICApO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBsICogYS54LFxuICAgICAgICB5OiBsICogYS55XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHR3byByZWN0YW5nbGVzIGNvbGxpZGUgb24gb25lIHBhcnRpY3VsYXIgYXhpcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICBBbiBheGlzJyBjb29yZGluYXRlcyAoeCwgeSkuXG4gICAgICogQHBhcmFtICB7YXJyYXl9ICAgIFJlY3RhbmdsZSBBJ3MgY29ybmVycy5cbiAgICAgKiBAcGFyYW0gIHthcnJheX0gICAgUmVjdGFuZ2xlIEIncyBjb3JuZXJzLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59ICBUcnVlIGlmIHRoZSByZWN0YW5nbGVzIGNvbGxpZGUgb24gdGhlIGF4aXMuXG4gICAgICovXG4gICAgYXhpc0NvbGxpc2lvbjogZnVuY3Rpb24oYSwgYzEsIGMyKSB7XG4gICAgICB2YXIgc2MxID0gW10sXG4gICAgICAgICAgc2MyID0gW107XG5cbiAgICAgIGZvciAodmFyIGNpID0gMDsgY2kgPCA0OyBjaSsrKSB7XG4gICAgICAgIHZhciBwMSA9IHRoaXMucHJvamVjdGlvbihjMVtjaV0sIGEpLFxuICAgICAgICAgICAgcDIgPSB0aGlzLnByb2plY3Rpb24oYzJbY2ldLCBhKTtcblxuICAgICAgICBzYzEucHVzaChwMS54ICogYS54ICsgcDEueSAqIGEueSk7XG4gICAgICAgIHNjMi5wdXNoKHAyLnggKiBhLnggKyBwMi55ICogYS55KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1heGMxID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgc2MxKSxcbiAgICAgICAgICBtYXhjMiA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHNjMiksXG4gICAgICAgICAgbWluYzEgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBzYzEpLFxuICAgICAgICAgIG1pbmMyID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgc2MyKTtcblxuICAgICAgcmV0dXJuIChtaW5jMiA8PSBtYXhjMSAmJiBtYXhjMiA+PSBtaW5jMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdHdvIHJlY3RhbmdsZXMgY29sbGlkZSBvbiBlYWNoIG9uZSBvZiB0aGVpciBmb3VyIGF4aXMuIElmXG4gICAgICogYWxsIGF4aXMgY29sbGlkZSwgdGhlbiB0aGUgdHdvIHJlY3RhbmdsZXMgZG8gY29sbGlkZSBvbiB0aGUgcGxhbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHthcnJheX0gICAgUmVjdGFuZ2xlIEEncyBjb3JuZXJzLlxuICAgICAqIEBwYXJhbSAge2FycmF5fSAgICBSZWN0YW5nbGUgQidzIGNvcm5lcnMuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gIFRydWUgaWYgdGhlIHJlY3RhbmdsZXMgY29sbGlkZS5cbiAgICAgKi9cbiAgICBjb2xsaXNpb246IGZ1bmN0aW9uKGMxLCBjMikge1xuICAgICAgdmFyIGF4aXMgPSB0aGlzLmF4aXMoYzEsIGMyKSxcbiAgICAgICAgICBjb2wgPSB0cnVlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKylcbiAgICAgICAgY29sID0gY29sICYmIHRoaXMuYXhpc0NvbGxpc2lvbihheGlzW2ldLCBjMSwgYzIpO1xuXG4gICAgICByZXR1cm4gY29sO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBRdWFkIEZ1bmN0aW9uc1xuICAgKiAtLS0tLS0tLS0tLS1cbiAgICpcbiAgICogVGhlIFF1YWR0cmVlIGZ1bmN0aW9ucyB0aGVtc2VsdmVzLlxuICAgKiBGb3IgZWFjaCBvZiB0aG9zZSBmdW5jdGlvbnMsIHdlIGNvbnNpZGVyIHRoYXQgaW4gYSBzcGxpdHRlZCBxdWFkLCB0aGVcbiAgICogaW5kZXggb2YgZWFjaCBub2RlIGlzIHRoZSBmb2xsb3dpbmc6XG4gICAqIDA6IHRvcCBsZWZ0XG4gICAqIDE6IHRvcCByaWdodFxuICAgKiAyOiBib3R0b20gbGVmdFxuICAgKiAzOiBib3R0b20gcmlnaHRcbiAgICpcbiAgICogTW9yZW92ZXIsIHRoZSBoZXJlYWZ0ZXIgcXVhZCdzIHBoaWxvc29waHkgaXMgdG8gY29uc2lkZXIgdGhhdCBpZiBhbiBlbGVtZW50XG4gICAqIGNvbGxpZGVzIHdpdGggbW9yZSB0aGFuIG9uZSBub2RlcywgdGhpcyBlbGVtZW50IGJlbG9uZ3MgdG8gZWFjaCBvZiB0aGVcbiAgICogbm9kZXMgaXQgY29sbGlkZXMgd2l0aCB3aGVyZSBvdGhlciB3b3VsZCBsZXQgaXQgbGllIG9uIGEgaGlnaGVyIG5vZGUuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGluZGV4IG9mIHRoZSBub2RlIGNvbnRhaW5pbmcgdGhlIHBvaW50IGluIHRoZSBxdWFkXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHBvaW50ICAgICAgQSBwb2ludCBkZWZpbmVkIGJ5IGNvb3JkaW5hdGVzICh4LCB5KS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgcXVhZEJvdW5kcyBCb3VuZGFyaWVzIG9mIHRoZSBxdWFkICh4LCB5LCB3aWR0aCwgaGVpZ3RoKS5cbiAgICogQHJldHVybiB7aW50ZWdlcn0gICAgICAgICAgICBUaGUgaW5kZXggb2YgdGhlIG5vZGUgY29udGFpbmluZyB0aGUgcG9pbnQuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZEluZGV4KHBvaW50LCBxdWFkQm91bmRzKSB7XG4gICAgdmFyIHhtcCA9IHF1YWRCb3VuZHMueCArIHF1YWRCb3VuZHMud2lkdGggLyAyLFxuICAgICAgICB5bXAgPSBxdWFkQm91bmRzLnkgKyBxdWFkQm91bmRzLmhlaWdodCAvIDIsXG4gICAgICAgIHRvcCA9IChwb2ludC55IDwgeW1wKSxcbiAgICAgICAgbGVmdCA9IChwb2ludC54IDwgeG1wKTtcblxuICAgIGlmICh0b3ApIHtcbiAgICAgIGlmIChsZWZ0KVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKGxlZnQpXG4gICAgICAgIHJldHVybiAyO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gMztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgbGlzdCBvZiBpbmRleGVzIG9mIG5vZGVzIGNvbnRhaW5pbmcgYW4gYXhpcy1hbGlnbmVkIHJlY3RhbmdsZVxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICByZWN0YW5nbGUgICBBIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IHR3byBwb2ludHMgKHgxLCB5MSksXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh4MiwgeTIpIGFuZCBoZWlnaHQuXG4gICAqIEBwYXJhbSAge2FycmF5fSAgIHF1YWRDb3JuZXJzIEFuIGFycmF5IG9mIHRoZSBxdWFkIG5vZGVzJyBjb3JuZXJzLlxuICAgKiBAcmV0dXJuIHthcnJheX0gICAgICAgICAgICAgICBBbiBhcnJheSBvZiBpbmRleGVzIGNvbnRhaW5pbmcgb25lIHRvXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdXIgaW50ZWdlcnMuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZEluZGV4ZXMocmVjdGFuZ2xlLCBxdWFkQ29ybmVycykge1xuICAgIHZhciBpbmRleGVzID0gW107XG5cbiAgICAvLyBJdGVyYXRpbmcgdGhyb3VnaCBxdWFkc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKVxuICAgICAgaWYgKChyZWN0YW5nbGUueDIgPj0gcXVhZENvcm5lcnNbaV1bMF0ueCkgJiZcbiAgICAgICAgICAocmVjdGFuZ2xlLngxIDw9IHF1YWRDb3JuZXJzW2ldWzFdLngpICYmXG4gICAgICAgICAgKHJlY3RhbmdsZS55MSArIHJlY3RhbmdsZS5oZWlnaHQgPj0gcXVhZENvcm5lcnNbaV1bMF0ueSkgJiZcbiAgICAgICAgICAocmVjdGFuZ2xlLnkxIDw9IHF1YWRDb3JuZXJzW2ldWzJdLnkpKVxuICAgICAgICBpbmRleGVzLnB1c2goaSk7XG5cbiAgICByZXR1cm4gaW5kZXhlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBsaXN0IG9mIGluZGV4ZXMgb2Ygbm9kZXMgY29udGFpbmluZyBhIG5vbi1heGlzLWFsaWduZWQgcmVjdGFuZ2xlXG4gICAqXG4gICAqIEBwYXJhbSAge2FycmF5fSAgY29ybmVycyAgICAgIEFuIGFycmF5IGNvbnRhaW5pbmcgZWFjaCBjb3JuZXIgb2YgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IGl0cyBjb29yZGluYXRlcyAoeCwgeSkuXG4gICAqIEBwYXJhbSAge2FycmF5fSAgcXVhZENvcm5lcnMgIEFuIGFycmF5IG9mIHRoZSBxdWFkIG5vZGVzJyBjb3JuZXJzLlxuICAgKiBAcmV0dXJuIHthcnJheX0gICAgICAgICAgICAgICBBbiBhcnJheSBvZiBpbmRleGVzIGNvbnRhaW5pbmcgb25lIHRvXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdXIgaW50ZWdlcnMuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZENvbGxpc2lvbihjb3JuZXJzLCBxdWFkQ29ybmVycykge1xuICAgIHZhciBpbmRleGVzID0gW107XG5cbiAgICAvLyBJdGVyYXRpbmcgdGhyb3VnaCBxdWFkc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKVxuICAgICAgaWYgKF9nZW9tLmNvbGxpc2lvbihjb3JuZXJzLCBxdWFkQ29ybmVyc1tpXSkpXG4gICAgICAgIGluZGV4ZXMucHVzaChpKTtcblxuICAgIHJldHVybiBpbmRleGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YmRpdmlkZSBhIHF1YWQgYnkgY3JlYXRpbmcgYSBub2RlIGF0IGEgcHJlY2lzZSBpbmRleC4gVGhlIGZ1bmN0aW9uIGRvZXNcbiAgICogbm90IGdlbmVyYXRlIGFsbCBmb3VyIG5vZGVzIG5vdCB0byBwb3RlbnRpYWxseSBjcmVhdGUgdW51c2VkIG5vZGVzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtpbnRlZ2VyfSAgaW5kZXggVGhlIGluZGV4IG9mIHRoZSBub2RlIHRvIGNyZWF0ZS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgIHF1YWQgIFRoZSBxdWFkIG9iamVjdCB0byBzdWJkaXZpZGUuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICBBIG5ldyBxdWFkIHJlcHJlc2VudGluZyB0aGUgbm9kZSBjcmVhdGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gX3F1YWRTdWJkaXZpZGUoaW5kZXgsIHF1YWQpIHtcbiAgICB2YXIgbmV4dCA9IHF1YWQubGV2ZWwgKyAxLFxuICAgICAgICBzdWJ3ID0gTWF0aC5yb3VuZChxdWFkLmJvdW5kcy53aWR0aCAvIDIpLFxuICAgICAgICBzdWJoID0gTWF0aC5yb3VuZChxdWFkLmJvdW5kcy5oZWlnaHQgLyAyKSxcbiAgICAgICAgcXggPSBNYXRoLnJvdW5kKHF1YWQuYm91bmRzLngpLFxuICAgICAgICBxeSA9IE1hdGgucm91bmQocXVhZC5ib3VuZHMueSksXG4gICAgICAgIHgsXG4gICAgICAgIHk7XG5cbiAgICBzd2l0Y2ggKGluZGV4KSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHggPSBxeDtcbiAgICAgICAgeSA9IHF5O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgeCA9IHF4ICsgc3VidztcbiAgICAgICAgeSA9IHF5O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgeCA9IHF4O1xuICAgICAgICB5ID0gcXkgKyBzdWJoO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgeCA9IHF4ICsgc3VidztcbiAgICAgICAgeSA9IHF5ICsgc3ViaDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9xdWFkVHJlZShcbiAgICAgIHt4OiB4LCB5OiB5LCB3aWR0aDogc3VidywgaGVpZ2h0OiBzdWJofSxcbiAgICAgIG5leHQsXG4gICAgICBxdWFkLm1heEVsZW1lbnRzLFxuICAgICAgcXVhZC5tYXhMZXZlbFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgaW5zZXJ0IGFuIGVsZW1lbnQgaW50byB0aGUgcXVhZHRyZWUuIE9ubHkgcG9pbnRzXG4gICAqIHdpdGggc2l6ZSwgaS5lLiBheGlzLWFsaWduZWQgc3F1YXJlcywgbWF5IGJlIGluc2VydGVkIHdpdGggdGhpc1xuICAgKiBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gIGVsICAgICAgICAgVGhlIGVsZW1lbnQgdG8gaW5zZXJ0IGluIHRoZSBxdWFkdHJlZS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgc2l6ZWRQb2ludCBBIHNpemVkIHBvaW50IGRlZmluZWQgYnkgdHdvIHRvcCBwb2ludHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgcXVhZCAgICAgICBUaGUgcXVhZCBpbiB3aGljaCB0byBpbnNlcnQgdGhlIGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge3VuZGVmaW5lZH0gICAgICAgICAgVGhlIGZ1bmN0aW9uIGRvZXMgbm90IHJldHVybiBhbnl0aGluZy5cbiAgICovXG4gIGZ1bmN0aW9uIF9xdWFkSW5zZXJ0KGVsLCBzaXplZFBvaW50LCBxdWFkKSB7XG4gICAgaWYgKHF1YWQubGV2ZWwgPCBxdWFkLm1heExldmVsKSB7XG5cbiAgICAgIC8vIFNlYXJjaGluZyBhcHByb3ByaWF0ZSBxdWFkc1xuICAgICAgdmFyIGluZGV4ZXMgPSBfcXVhZEluZGV4ZXMoc2l6ZWRQb2ludCwgcXVhZC5jb3JuZXJzKTtcblxuICAgICAgLy8gSXRlcmF0aW5nXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGluZGV4ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cbiAgICAgICAgLy8gU3ViZGl2aWRpbmcgaWYgbmVjZXNzYXJ5XG4gICAgICAgIGlmIChxdWFkLm5vZGVzW2luZGV4ZXNbaV1dID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgcXVhZC5ub2Rlc1tpbmRleGVzW2ldXSA9IF9xdWFkU3ViZGl2aWRlKGluZGV4ZXNbaV0sIHF1YWQpO1xuXG4gICAgICAgIC8vIFJlY3Vyc2lvblxuICAgICAgICBfcXVhZEluc2VydChlbCwgc2l6ZWRQb2ludCwgcXVhZC5ub2Rlc1tpbmRleGVzW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuXG4gICAgICAvLyBQdXNoaW5nIHRoZSBlbGVtZW50IGluIGEgbGVhZiBub2RlXG4gICAgICBxdWFkLmVsZW1lbnRzLnB1c2goZWwpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSByZXRyaWV2ZSBldmVyeSBlbGVtZW50cyBoZWxkIGJ5IHRoZSBub2RlIGNvbnRhaW5pbmcgdGhlXG4gICAqIHNlYXJjaGVkIHBvaW50LlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBwb2ludCBUaGUgc2VhcmNoZWQgcG9pbnQgKHgsIHkpLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBxdWFkICBUaGUgc2VhcmNoZWQgcXVhZC5cbiAgICogQHJldHVybiB7YXJyYXl9ICAgICAgICAgQW4gYXJyYXkgb2YgZWxlbWVudHMgY29udGFpbmVkIGluIHRoZSByZWxldmFudFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLlxuICAgKi9cbiAgZnVuY3Rpb24gX3F1YWRSZXRyaWV2ZVBvaW50KHBvaW50LCBxdWFkKSB7XG4gICAgaWYgKHF1YWQubGV2ZWwgPCBxdWFkLm1heExldmVsKSB7XG4gICAgICB2YXIgaW5kZXggPSBfcXVhZEluZGV4KHBvaW50LCBxdWFkLmJvdW5kcyk7XG5cbiAgICAgIC8vIElmIG5vZGUgZG9lcyBub3QgZXhpc3Qgd2UgcmV0dXJuIGFuIGVtcHR5IGxpc3RcbiAgICAgIGlmIChxdWFkLm5vZGVzW2luZGV4XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBfcXVhZFJldHJpZXZlUG9pbnQocG9pbnQsIHF1YWQubm9kZXNbaW5kZXhdKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHF1YWQuZWxlbWVudHM7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IHJldHJpZXZlIGV2ZXJ5IGVsZW1lbnRzIGNvbnRhaW5lZCB3aXRoaW4gYW4gcmVjdGFuZ3VsYXIgYXJlYVxuICAgKiB0aGF0IG1heSBvciBtYXkgbm90IGJlIGF4aXMtYWxpZ25lZC5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fGFycmF5fSByZWN0RGF0YSAgICAgICBUaGUgc2VhcmNoZWQgYXJlYSBkZWZpbmVkIGVpdGhlciBieVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuIGFycmF5IG9mIGZvdXIgY29ybmVycyAoeCwgeSkgaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgY2FzZSBvZiBhIG5vbi1heGlzLWFsaWduZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWN0YW5nbGUgb3IgYW4gb2JqZWN0IHdpdGggdHdvIHRvcFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cyAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICBxdWFkICAgICAgICAgICBUaGUgc2VhcmNoZWQgcXVhZC5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259ICAgICBjb2xsaXNpb25GdW5jICBUaGUgY29sbGlzaW9uIGZ1bmN0aW9uIHVzZWQgdG8gc2VhcmNoXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIG5vZGUgaW5kZXhlcy5cbiAgICogQHBhcmFtICB7YXJyYXk/fSAgICAgICBlbHMgICAgICAgICAgICBUaGUgcmV0cmlldmVkIGVsZW1lbnRzLlxuICAgKiBAcmV0dXJuIHthcnJheX0gICAgICAgICAgICAgICAgICAgICAgIEFuIGFycmF5IG9mIGVsZW1lbnRzIGNvbnRhaW5lZCBpbiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmVhLlxuICAgKi9cbiAgZnVuY3Rpb24gX3F1YWRSZXRyaWV2ZUFyZWEocmVjdERhdGEsIHF1YWQsIGNvbGxpc2lvbkZ1bmMsIGVscykge1xuICAgIGVscyA9IGVscyB8fCB7fTtcblxuICAgIGlmIChxdWFkLmxldmVsIDwgcXVhZC5tYXhMZXZlbCkge1xuICAgICAgdmFyIGluZGV4ZXMgPSBjb2xsaXNpb25GdW5jKHJlY3REYXRhLCBxdWFkLmNvcm5lcnMpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGluZGV4ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICBpZiAocXVhZC5ub2Rlc1tpbmRleGVzW2ldXSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIF9xdWFkUmV0cmlldmVBcmVhKFxuICAgICAgICAgICAgcmVjdERhdGEsXG4gICAgICAgICAgICBxdWFkLm5vZGVzW2luZGV4ZXNbaV1dLFxuICAgICAgICAgICAgY29sbGlzaW9uRnVuYyxcbiAgICAgICAgICAgIGVsc1xuICAgICAgICAgICk7XG4gICAgfSBlbHNlXG4gICAgICBmb3IgKHZhciBqID0gMCwgbSA9IHF1YWQuZWxlbWVudHMubGVuZ3RoOyBqIDwgbTsgaisrKVxuICAgICAgICBpZiAoZWxzW3F1YWQuZWxlbWVudHNbal0uaWRdID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgZWxzW3F1YWQuZWxlbWVudHNbal0uaWRdID0gcXVhZC5lbGVtZW50c1tqXTtcblxuICAgIHJldHVybiBlbHM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgcXVhZHRyZWUgb2JqZWN0IGl0c2VsZi5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgIGJvdW5kcyAgICAgICBUaGUgYm91bmRhcmllcyBvZiB0aGUgcXVhZCBkZWZpbmVkIGJ5IGFuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luICh4LCB5KSwgd2lkdGggYW5kIGhlaWd0aC5cbiAgICogQHBhcmFtICB7aW50ZWdlcn0gIGxldmVsICAgICAgICBUaGUgbGV2ZWwgb2YgdGhlIHF1YWQgaW4gdGhlIHRyZWUuXG4gICAqIEBwYXJhbSAge2ludGVnZXJ9ICBtYXhFbGVtZW50cyAgVGhlIG1heCBudW1iZXIgb2YgZWxlbWVudCBpbiBhIGxlYWYgbm9kZS5cbiAgICogQHBhcmFtICB7aW50ZWdlcn0gIG1heExldmVsICAgICBUaGUgbWF4IHJlY3Vyc2lvbiBsZXZlbCBvZiB0aGUgdHJlZS5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICAgICAgICBUaGUgcXVhZHRyZWUgb2JqZWN0LlxuICAgKi9cbiAgZnVuY3Rpb24gX3F1YWRUcmVlKGJvdW5kcywgbGV2ZWwsIG1heEVsZW1lbnRzLCBtYXhMZXZlbCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZXZlbDogbGV2ZWwgfHwgMCxcbiAgICAgIGJvdW5kczogYm91bmRzLFxuICAgICAgY29ybmVyczogX2dlb20uc3BsaXRTcXVhcmUoYm91bmRzKSxcbiAgICAgIG1heEVsZW1lbnRzOiBtYXhFbGVtZW50cyB8fCAyMCxcbiAgICAgIG1heExldmVsOiBtYXhMZXZlbCB8fCA0LFxuICAgICAgZWxlbWVudHM6IFtdLFxuICAgICAgbm9kZXM6IFtdXG4gICAgfTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFNpZ21hIFF1YWQgQ29uc3RydWN0b3JcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKlxuICAgKiBUaGUgcXVhZCBBUEkgYXMgZXhwb3NlZCB0byBzaWdtYS5cbiAgICovXG5cbiAgLyoqXG4gICAqIFRoZSBxdWFkIGNvcmUgdGhhdCB3aWxsIGJlY29tZSB0aGUgc2lnbWEgaW50ZXJmYWNlIHdpdGggdGhlIHF1YWR0cmVlLlxuICAgKlxuICAgKiBwcm9wZXJ0eSB7b2JqZWN0fSBfdHJlZSAgUHJvcGVydHkgaG9sZGluZyB0aGUgcXVhZHRyZWUgb2JqZWN0LlxuICAgKiBwcm9wZXJ0eSB7b2JqZWN0fSBfZ2VvbSAgRXhwb3NpdGlvbiBvZiB0aGUgX2dlb20gbmFtZXNwYWNlIGZvciB0ZXN0aW5nLlxuICAgKiBwcm9wZXJ0eSB7b2JqZWN0fSBfY2FjaGUgQ2FjaGUgZm9yIHRoZSBhcmVhIG1ldGhvZC5cbiAgICovXG4gIHZhciBxdWFkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZ2VvbSA9IF9nZW9tO1xuICAgIHRoaXMuX3RyZWUgPSBudWxsO1xuICAgIHRoaXMuX2NhY2hlID0ge1xuICAgICAgcXVlcnk6IGZhbHNlLFxuICAgICAgcmVzdWx0OiBmYWxzZVxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEluZGV4IGEgZ3JhcGggYnkgaW5zZXJ0aW5nIGl0cyBub2RlcyBpbnRvIHRoZSBxdWFkdHJlZS5cbiAgICpcbiAgICogQHBhcmFtICB7YXJyYXl9ICBub2RlcyAgIEFuIGFycmF5IG9mIG5vZGVzIHRvIGluZGV4LlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IHBhcmFtcyAgQW4gb2JqZWN0IG9mIHBhcmFtZXRlcnMgd2l0aCBhdCBsZWFzdCB0aGUgcXVhZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRzLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgVGhlIHF1YWR0cmVlIG9iamVjdC5cbiAgICpcbiAgICogUGFyYW1ldGVyczpcbiAgICogLS0tLS0tLS0tLVxuICAgKiBib3VuZHM6ICAgICAge29iamVjdH0gICBib3VuZGFyaWVzIG9mIHRoZSBxdWFkIGRlZmluZWQgYnkgaXRzIG9yaWdpbiAoeCwgeSlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggYW5kIGhlaWd0aC5cbiAgICogcHJlZml4OiAgICAgIHtzdHJpbmc/fSAgYSBwcmVmaXggZm9yIG5vZGUgZ2VvbWV0cmljIGF0dHJpYnV0ZXMuXG4gICAqIG1heEVsZW1lbnRzOiB7aW50ZWdlcj99IHRoZSBtYXggbnVtYmVyIG9mIGVsZW1lbnRzIGluIGEgbGVhZiBub2RlLlxuICAgKiBtYXhMZXZlbDogICAge2ludGVnZXI/fSB0aGUgbWF4IHJlY3Vyc2lvbiBsZXZlbCBvZiB0aGUgdHJlZS5cbiAgICovXG4gIHF1YWQucHJvdG90eXBlLmluZGV4ID0gZnVuY3Rpb24obm9kZXMsIHBhcmFtcykge1xuXG4gICAgLy8gRW5mb3JjaW5nIHByZXNlbmNlIG9mIGJvdW5kYXJpZXNcbiAgICBpZiAoIXBhcmFtcy5ib3VuZHMpXG4gICAgICB0aHJvdyAnc2lnbWEuY2xhc3Nlcy5xdWFkLmluZGV4OiBib3VuZHMgaW5mb3JtYXRpb24gbm90IGdpdmVuLic7XG5cbiAgICAvLyBQcmVmaXhcbiAgICB2YXIgcHJlZml4ID0gcGFyYW1zLnByZWZpeCB8fCAnJztcblxuICAgIC8vIEJ1aWxkaW5nIHRoZSB0cmVlXG4gICAgdGhpcy5fdHJlZSA9IF9xdWFkVHJlZShcbiAgICAgIHBhcmFtcy5ib3VuZHMsXG4gICAgICAwLFxuICAgICAgcGFyYW1zLm1heEVsZW1lbnRzLFxuICAgICAgcGFyYW1zLm1heExldmVsXG4gICAgKTtcblxuICAgIC8vIEluc2VydGluZyBncmFwaCBub2RlcyBpbnRvIHRoZSB0cmVlXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblxuICAgICAgLy8gSW5zZXJ0aW5nIG5vZGVcbiAgICAgIF9xdWFkSW5zZXJ0KFxuICAgICAgICBub2Rlc1tpXSxcbiAgICAgICAgX2dlb20ucG9pbnRUb1NxdWFyZSh7XG4gICAgICAgICAgeDogbm9kZXNbaV1bcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICB5OiBub2Rlc1tpXVtwcmVmaXggKyAneSddLFxuICAgICAgICAgIHNpemU6IG5vZGVzW2ldW3ByZWZpeCArICdzaXplJ11cbiAgICAgICAgfSksXG4gICAgICAgIHRoaXMuX3RyZWVcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgY2FjaGU6XG4gICAgdGhpcy5fY2FjaGUgPSB7XG4gICAgICBxdWVyeTogZmFsc2UsXG4gICAgICByZXN1bHQ6IGZhbHNlXG4gICAgfTtcblxuICAgIC8vIHJlbW92ZT9cbiAgICByZXR1cm4gdGhpcy5fdHJlZTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmUgZXZlcnkgZ3JhcGggbm9kZXMgaGVsZCBieSB0aGUgcXVhZHRyZWUgbm9kZSBjb250YWluaW5nIHRoZVxuICAgKiBzZWFyY2hlZCBwb2ludC5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4IG9mIHRoZSBwb2ludC5cbiAgICogQHBhcmFtICB7bnVtYmVyfSB5IG9mIHRoZSBwb2ludC5cbiAgICogQHJldHVybiB7YXJyYXl9ICBBbiBhcnJheSBvZiBub2RlcyByZXRyaWV2ZWQuXG4gICAqL1xuICBxdWFkLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJlZSA/XG4gICAgICBfcXVhZFJldHJpZXZlUG9pbnQoe3g6IHgsIHk6IHl9LCB0aGlzLl90cmVlKSB8fCBbXSA6XG4gICAgICBbXTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmUgZXZlcnkgZ3JhcGggbm9kZXMgd2l0aGluIGEgcmVjdGFuZ3VsYXIgYXJlYS4gVGhlIG1ldGhvZHMga2VlcCB0aGVcbiAgICogbGFzdCBhcmVhIHF1ZXJpZWQgaW4gY2FjaGUgZm9yIG9wdGltaXphdGlvbiByZWFzb24gYW5kIHdpbGwgYWN0IGRpZmZlcmVudGx5XG4gICAqIGZvciB0aGUgc2FtZSByZWFzb24gaWYgdGhlIGFyZWEgaXMgYXhpcy1hbGlnbmVkIG9yIG5vdC5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSBBIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IHR3byB0b3AgcG9pbnRzICh4MSwgeTEpLCAoeDIsIHkyKVxuICAgKiAgICAgICAgICAgICAgICAgIGFuZCBoZWlnaHQuXG4gICAqIEByZXR1cm4ge2FycmF5fSAgQW4gYXJyYXkgb2Ygbm9kZXMgcmV0cmlldmVkLlxuICAgKi9cbiAgcXVhZC5wcm90b3R5cGUuYXJlYSA9IGZ1bmN0aW9uKHJlY3QpIHtcbiAgICB2YXIgc2VyaWFsaXplZCA9IEpTT04uc3RyaW5naWZ5KHJlY3QpLFxuICAgICAgICBjb2xsaXNpb25GdW5jLFxuICAgICAgICByZWN0RGF0YTtcblxuICAgIC8vIFJldHVybmluZyBjYWNoZT9cbiAgICBpZiAodGhpcy5fY2FjaGUucXVlcnkgPT09IHNlcmlhbGl6ZWQpXG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGUucmVzdWx0O1xuXG4gICAgLy8gQXhpcyBhbGlnbmVkID9cbiAgICBpZiAoX2dlb20uaXNBeGlzQWxpZ25lZChyZWN0KSkge1xuICAgICAgY29sbGlzaW9uRnVuYyA9IF9xdWFkSW5kZXhlcztcbiAgICAgIHJlY3REYXRhID0gX2dlb20uYXhpc0FsaWduZWRUb3BQb2ludHMocmVjdCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29sbGlzaW9uRnVuYyA9IF9xdWFkQ29sbGlzaW9uO1xuICAgICAgcmVjdERhdGEgPSBfZ2VvbS5yZWN0YW5nbGVDb3JuZXJzKHJlY3QpO1xuICAgIH1cblxuICAgIC8vIFJldHJpZXZpbmcgbm9kZXNcbiAgICB2YXIgbm9kZXMgPSB0aGlzLl90cmVlID9cbiAgICAgIF9xdWFkUmV0cmlldmVBcmVhKFxuICAgICAgICByZWN0RGF0YSxcbiAgICAgICAgdGhpcy5fdHJlZSxcbiAgICAgICAgY29sbGlzaW9uRnVuY1xuICAgICAgKSA6XG4gICAgICBbXTtcblxuICAgIC8vIE9iamVjdCB0byBhcnJheVxuICAgIHZhciBub2Rlc0FycmF5ID0gW107XG4gICAgZm9yICh2YXIgaSBpbiBub2RlcylcbiAgICAgIG5vZGVzQXJyYXkucHVzaChub2Rlc1tpXSk7XG5cbiAgICAvLyBDYWNoaW5nXG4gICAgdGhpcy5fY2FjaGUucXVlcnkgPSBzZXJpYWxpemVkO1xuICAgIHRoaXMuX2NhY2hlLnJlc3VsdCA9IG5vZGVzQXJyYXk7XG5cbiAgICByZXR1cm4gbm9kZXNBcnJheTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBFWFBPUlQ6XG4gICAqICoqKioqKipcbiAgICovXG4gIGlmICh0eXBlb2YgdGhpcy5zaWdtYSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLnNpZ21hLmNsYXNzZXMgPSB0aGlzLnNpZ21hLmNsYXNzZXMgfHwge307XG4gICAgdGhpcy5zaWdtYS5jbGFzc2VzLnF1YWQgPSBxdWFkO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cylcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHF1YWQ7XG4gICAgZXhwb3J0cy5xdWFkID0gcXVhZDtcbiAgfSBlbHNlXG4gICAgdGhpcy5xdWFkID0gcXVhZDtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogU2lnbWEgUXVhZHRyZWUgTW9kdWxlIGZvciBlZGdlc1xuICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAqXG4gICAqIEF1dGhvcjogU8OpYmFzdGllbiBIZXltYW5uLFxuICAgKiAgIGZyb20gdGhlIHF1YWQgb2YgR3VpbGxhdW1lIFBsaXF1ZSAoWW9tZ3VpdGhlcmVhbClcbiAgICogVmVyc2lvbjogMC4yXG4gICAqL1xuXG5cblxuICAvKipcbiAgICogUXVhZCBHZW9tZXRyaWMgT3BlcmF0aW9uc1xuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqXG4gICAqIEEgdXNlZnVsIGJhdGNoIG9mIGdlb21ldHJpYyBvcGVyYXRpb25zIHVzZWQgYnkgdGhlIHF1YWR0cmVlLlxuICAgKi9cblxuICB2YXIgX2dlb20gPSB7XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGEgZ3JhcGggbm9kZSB3aXRoIHgsIHkgYW5kIHNpemUgaW50byBhblxuICAgICAqIGF4aXMtYWxpZ25lZCBzcXVhcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgZ3JhcGggbm9kZSB3aXRoIGF0IGxlYXN0IGEgcG9pbnQgKHgsIHkpIGFuZCBhIHNpemUuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBBIHNxdWFyZTogdHdvIHBvaW50cyAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICAgKi9cbiAgICBwb2ludFRvU3F1YXJlOiBmdW5jdGlvbihuKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogbi54IC0gbi5zaXplLFxuICAgICAgICB5MTogbi55IC0gbi5zaXplLFxuICAgICAgICB4Mjogbi54ICsgbi5zaXplLFxuICAgICAgICB5Mjogbi55IC0gbi5zaXplLFxuICAgICAgICBoZWlnaHQ6IG4uc2l6ZSAqIDJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYSBncmFwaCBlZGdlIHdpdGggeDEsIHkxLCB4MiwgeTIgYW5kIHNpemUgaW50byBhblxuICAgICAqIGF4aXMtYWxpZ25lZCBzcXVhcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgZ3JhcGggZWRnZSB3aXRoIGF0IGxlYXN0IHR3byBwb2ludHNcbiAgICAgKiAgICAgICAgICAgICAgICAgICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgYSBzaXplLlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gQSBzcXVhcmU6IHR3byBwb2ludHMgKHgxLCB5MSksICh4MiwgeTIpIGFuZCBoZWlnaHQuXG4gICAgICovXG4gICAgbGluZVRvU3F1YXJlOiBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoZS55MSA8IGUueTIpIHtcbiAgICAgICAgLy8gKGUueDEsIGUueTEpIG9uIHRvcFxuICAgICAgICBpZiAoZS54MSA8IGUueDIpIHtcbiAgICAgICAgICAvLyAoZS54MSwgZS55MSkgb24gbGVmdFxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4MTogZS54MSAtIGUuc2l6ZSxcbiAgICAgICAgICAgIHkxOiBlLnkxIC0gZS5zaXplLFxuICAgICAgICAgICAgeDI6IGUueDIgKyBlLnNpemUsXG4gICAgICAgICAgICB5MjogZS55MSAtIGUuc2l6ZSxcbiAgICAgICAgICAgIGhlaWdodDogZS55MiAtIGUueTEgKyBlLnNpemUgKiAyXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyAoZS54MSwgZS55MSkgb24gcmlnaHRcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4MTogZS54MiAtIGUuc2l6ZSxcbiAgICAgICAgICB5MTogZS55MSAtIGUuc2l6ZSxcbiAgICAgICAgICB4MjogZS54MSArIGUuc2l6ZSxcbiAgICAgICAgICB5MjogZS55MSAtIGUuc2l6ZSxcbiAgICAgICAgICBoZWlnaHQ6IGUueTIgLSBlLnkxICsgZS5zaXplICogMlxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyAoZS54MiwgZS55Mikgb24gdG9wXG4gICAgICBpZiAoZS54MSA8IGUueDIpIHtcbiAgICAgICAgLy8gKGUueDEsIGUueTEpIG9uIGxlZnRcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4MTogZS54MSAtIGUuc2l6ZSxcbiAgICAgICAgICB5MTogZS55MiAtIGUuc2l6ZSxcbiAgICAgICAgICB4MjogZS54MiArIGUuc2l6ZSxcbiAgICAgICAgICB5MjogZS55MiAtIGUuc2l6ZSxcbiAgICAgICAgICBoZWlnaHQ6IGUueTEgLSBlLnkyICsgZS5zaXplICogMlxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgLy8gKGUueDIsIGUueTIpIG9uIHJpZ2h0XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogZS54MiAtIGUuc2l6ZSxcbiAgICAgICAgeTE6IGUueTIgLSBlLnNpemUsXG4gICAgICAgIHgyOiBlLngxICsgZS5zaXplLFxuICAgICAgICB5MjogZS55MiAtIGUuc2l6ZSxcbiAgICAgICAgaGVpZ2h0OiBlLnkxIC0gZS55MiArIGUuc2l6ZSAqIDJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYSBncmFwaCBlZGdlIG9mIHR5cGUgJ2N1cnZlJyB3aXRoIHgxLCB5MSwgeDIsIHkyLFxuICAgICAqIGNvbnRyb2wgcG9pbnQgYW5kIHNpemUgaW50byBhbiBheGlzLWFsaWduZWQgc3F1YXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBlICBBIGdyYXBoIGVkZ2Ugd2l0aCBhdCBsZWFzdCB0d28gcG9pbnRzXG4gICAgICogICAgICAgICAgICAgICAgICAgICAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGEgc2l6ZS5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IGNwIEEgY29udHJvbCBwb2ludCAoeCx5KS5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgIEEgc3F1YXJlOiB0d28gcG9pbnRzICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxuICAgICAqL1xuICAgIHF1YWRyYXRpY0N1cnZlVG9TcXVhcmU6IGZ1bmN0aW9uKGUsIGNwKSB7XG4gICAgICB2YXIgcHQgPSBzaWdtYS51dGlscy5nZXRQb2ludE9uUXVhZHJhdGljQ3VydmUoXG4gICAgICAgIDAuNSxcbiAgICAgICAgZS54MSxcbiAgICAgICAgZS55MSxcbiAgICAgICAgZS54MixcbiAgICAgICAgZS55MixcbiAgICAgICAgY3AueCxcbiAgICAgICAgY3AueVxuICAgICAgKTtcblxuICAgICAgLy8gQm91bmRpbmcgYm94IG9mIHRoZSB0d28gcG9pbnRzIGFuZCB0aGUgcG9pbnQgYXQgdGhlIG1pZGRsZSBvZiB0aGVcbiAgICAgIC8vIGN1cnZlOlxuICAgICAgdmFyIG1pblggPSBNYXRoLm1pbihlLngxLCBlLngyLCBwdC54KSxcbiAgICAgICAgICBtYXhYID0gTWF0aC5tYXgoZS54MSwgZS54MiwgcHQueCksXG4gICAgICAgICAgbWluWSA9IE1hdGgubWluKGUueTEsIGUueTIsIHB0LnkpLFxuICAgICAgICAgIG1heFkgPSBNYXRoLm1heChlLnkxLCBlLnkyLCBwdC55KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IG1pblggLSBlLnNpemUsXG4gICAgICAgIHkxOiBtaW5ZIC0gZS5zaXplLFxuICAgICAgICB4MjogbWF4WCArIGUuc2l6ZSxcbiAgICAgICAgeTI6IG1pblkgLSBlLnNpemUsXG4gICAgICAgIGhlaWdodDogbWF4WSAtIG1pblkgKyBlLnNpemUgKiAyXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGEgZ3JhcGggc2VsZiBsb29wIGludG8gYW4gYXhpcy1hbGlnbmVkIHNxdWFyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gbiBBIGdyYXBoIG5vZGUgd2l0aCBhIHBvaW50ICh4LCB5KSBhbmQgYSBzaXplLlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gICBBIHNxdWFyZTogdHdvIHBvaW50cyAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICAgKi9cbiAgICBzZWxmTG9vcFRvU3F1YXJlOiBmdW5jdGlvbihuKSB7XG4gICAgICAvLyBGaXR0aW5nIHRvIHRoZSBjdXJ2ZSBpcyB0b28gY29zdGx5LCB3ZSBjb21wdXRlIGEgbGFyZ2VyIGJvdW5kaW5nIGJveFxuICAgICAgLy8gdXNpbmcgdGhlIGNvbnRyb2wgcG9pbnRzOlxuICAgICAgdmFyIGNwID0gc2lnbWEudXRpbHMuZ2V0U2VsZkxvb3BDb250cm9sUG9pbnRzKG4ueCwgbi55LCBuLnNpemUpO1xuXG4gICAgICAvLyBCb3VuZGluZyBib3ggb2YgdGhlIHBvaW50IGFuZCB0aGUgdHdvIGNvbnRyb2wgcG9pbnRzOlxuICAgICAgdmFyIG1pblggPSBNYXRoLm1pbihuLngsIGNwLngxLCBjcC54MiksXG4gICAgICAgICAgbWF4WCA9IE1hdGgubWF4KG4ueCwgY3AueDEsIGNwLngyKSxcbiAgICAgICAgICBtaW5ZID0gTWF0aC5taW4obi55LCBjcC55MSwgY3AueTIpLFxuICAgICAgICAgIG1heFkgPSBNYXRoLm1heChuLnksIGNwLnkxLCBjcC55Mik7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiBtaW5YIC0gbi5zaXplLFxuICAgICAgICB5MTogbWluWSAtIG4uc2l6ZSxcbiAgICAgICAgeDI6IG1heFggKyBuLnNpemUsXG4gICAgICAgIHkyOiBtaW5ZIC0gbi5zaXplLFxuICAgICAgICBoZWlnaHQ6IG1heFkgLSBtaW5ZICsgbi5zaXplICogMlxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgYSByZWN0YW5nbGUgaXMgYXhpcy1hbGlnbmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgQSByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gcG9pbnRzXG4gICAgICogICAgICAgICAgICAgICAgICAgKHgxLCB5MSkgYW5kICh4MiwgeTIpLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHJlY3RhbmdsZSBpcyBheGlzLWFsaWduZWQuXG4gICAgICovXG4gICAgaXNBeGlzQWxpZ25lZDogZnVuY3Rpb24ocikge1xuICAgICAgcmV0dXJuIHIueDEgPT09IHIueDIgfHwgci55MSA9PT0gci55MjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0b3AgcG9pbnRzIG9mIGFuIGF4aXMtYWxpZ25lZCByZWN0YW5nbGUuIFRoaXMgaXMgdXNlZnVsIGluXG4gICAgICogY2FzZXMgd2hlbiB0aGUgcmVjdGFuZ2xlIGhhcyBiZWVuIHJvdGF0ZWQgKGxlZnQsIHJpZ2h0IG9yIGJvdHRvbSB1cCkgYW5kXG4gICAgICogbGF0ZXIgb3BlcmF0aW9ucyBuZWVkIHRvIGtub3cgdGhlIHRvcCBwb2ludHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEFuIGF4aXMtYWxpZ25lZCByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gcG9pbnRzXG4gICAgICogICAgICAgICAgICAgICAgICAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IEEgcmVjdGFuZ2xlOiB0d28gcG9pbnRzICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxuICAgICAqL1xuICAgIGF4aXNBbGlnbmVkVG9wUG9pbnRzOiBmdW5jdGlvbihyKSB7XG5cbiAgICAgIC8vIEJhc2ljXG4gICAgICBpZiAoci55MSA9PT0gci55MiAmJiByLngxIDwgci54MilcbiAgICAgICAgcmV0dXJuIHI7XG5cbiAgICAgIC8vIFJvdGF0ZWQgdG8gcmlnaHRcbiAgICAgIGlmIChyLngxID09PSByLngyICYmIHIueTIgPiByLnkxKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHgxOiByLngxIC0gci5oZWlnaHQsIHkxOiByLnkxLFxuICAgICAgICAgIHgyOiByLngxLCB5Mjogci55MSxcbiAgICAgICAgICBoZWlnaHQ6IHIuaGVpZ2h0XG4gICAgICAgIH07XG5cbiAgICAgIC8vIFJvdGF0ZWQgdG8gbGVmdFxuICAgICAgaWYgKHIueDEgPT09IHIueDIgJiYgci55MiA8IHIueTEpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDE6IHIueDEsIHkxOiByLnkyLFxuICAgICAgICAgIHgyOiByLngyICsgci5oZWlnaHQsIHkyOiByLnkyLFxuICAgICAgICAgIGhlaWdodDogci5oZWlnaHRcbiAgICAgICAgfTtcblxuICAgICAgLy8gQm90dG9tJ3MgdXBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiByLngyLCB5MTogci55MSAtIHIuaGVpZ2h0LFxuICAgICAgICB4Mjogci54MSwgeTI6IHIueTEgLSByLmhlaWdodCxcbiAgICAgICAgaGVpZ2h0OiByLmhlaWdodFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGNvb3JkaW5hdGVzIG9mIGEgcmVjdGFuZ2xlJ3MgbG93ZXIgbGVmdCBjb3JuZXIgZnJvbSBpdHMgdG9wIHBvaW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQSByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gcG9pbnRzICh4MSwgeTEpIGFuZCAoeDIsIHkyKS5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IENvb3JkaW5hdGVzIG9mIHRoZSBjb3JuZXIgKHgsIHkpLlxuICAgICAqL1xuICAgIGxvd2VyTGVmdENvb3I6IGZ1bmN0aW9uKHIpIHtcbiAgICAgIHZhciB3aWR0aCA9IChcbiAgICAgICAgTWF0aC5zcXJ0KFxuICAgICAgICAgIE1hdGgucG93KHIueDIgLSByLngxLCAyKSArXG4gICAgICAgICAgTWF0aC5wb3coci55MiAtIHIueTEsIDIpXG4gICAgICAgIClcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHIueDEgLSAoci55MiAtIHIueTEpICogci5oZWlnaHQgLyB3aWR0aCxcbiAgICAgICAgeTogci55MSArIChyLngyIC0gci54MSkgKiByLmhlaWdodCAvIHdpZHRoXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgY29vcmRpbmF0ZXMgb2YgYSByZWN0YW5nbGUncyBsb3dlciByaWdodCBjb3JuZXIgZnJvbSBpdHMgdG9wIHBvaW50c1xuICAgICAqIGFuZCBpdHMgbG93ZXIgbGVmdCBjb3JuZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHBvaW50cyAoeDEsIHkxKSBhbmQgKHgyLCB5MikuXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBBIGNvcm5lcidzIGNvb3JkaW5hdGVzICh4LCB5KS5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IENvb3JkaW5hdGVzIG9mIHRoZSBjb3JuZXIgKHgsIHkpLlxuICAgICAqL1xuICAgIGxvd2VyUmlnaHRDb29yOiBmdW5jdGlvbihyLCBsbGMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGxsYy54IC0gci54MSArIHIueDIsXG4gICAgICAgIHk6IGxsYy55IC0gci55MSArIHIueTJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY29vcmRpbmF0ZXMgb2YgYWxsIHRoZSBjb3JuZXJzIG9mIGEgcmVjdGFuZ2xlIGZyb20gaXRzIHRvcCBwb2ludC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQSByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gcG9pbnRzICh4MSwgeTEpIGFuZCAoeDIsIHkyKS5cbiAgICAgKiBAcmV0dXJuIHthcnJheX0gIEFuIGFycmF5IG9mIHRoZSBmb3VyIGNvcm5lcnMnIGNvb3JkaW5hdGVzICh4LCB5KS5cbiAgICAgKi9cbiAgICByZWN0YW5nbGVDb3JuZXJzOiBmdW5jdGlvbihyKSB7XG4gICAgICB2YXIgbGxjID0gdGhpcy5sb3dlckxlZnRDb29yKHIpLFxuICAgICAgICAgIGxyYyA9IHRoaXMubG93ZXJSaWdodENvb3IociwgbGxjKTtcblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAge3g6IHIueDEsIHk6IHIueTF9LFxuICAgICAgICB7eDogci54MiwgeTogci55Mn0sXG4gICAgICAgIHt4OiBsbGMueCwgeTogbGxjLnl9LFxuICAgICAgICB7eDogbHJjLngsIHk6IGxyYy55fVxuICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3BsaXQgYSBzcXVhcmUgZGVmaW5lZCBieSBpdHMgYm91bmRhcmllcyBpbnRvIGZvdXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEJvdW5kYXJpZXMgb2YgdGhlIHNxdWFyZSAoeCwgeSwgd2lkdGgsIGhlaWdodCkuXG4gICAgICogQHJldHVybiB7YXJyYXl9ICBBbiBhcnJheSBjb250YWluaW5nIHRoZSBmb3VyIG5ldyBzcXVhcmVzLCB0aGVtc2VsdmVzXG4gICAgICogICAgICAgICAgICAgICAgICBkZWZpbmVkIGJ5IGFuIGFycmF5IG9mIHRoZWlyIGZvdXIgY29ybmVycyAoeCwgeSkuXG4gICAgICovXG4gICAgc3BsaXRTcXVhcmU6IGZ1bmN0aW9uKGIpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIFtcbiAgICAgICAgICB7eDogYi54LCB5OiBiLnl9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55fSxcbiAgICAgICAgICB7eDogYi54LCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55ICsgYi5oZWlnaHQgLyAyfVxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnl9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoLCB5OiBiLnl9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55ICsgYi5oZWlnaHQgLyAyfSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCwgeTogYi55ICsgYi5oZWlnaHQgLyAyfVxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAge3g6IGIueCwgeTogYi55ICsgYi5oZWlnaHQgLyAyfSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn0sXG4gICAgICAgICAge3g6IGIueCwgeTogYi55ICsgYi5oZWlnaHR9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55ICsgYi5oZWlnaHR9XG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGgsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnkgKyBiLmhlaWdodH0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGgsIHk6IGIueSArIGIuaGVpZ2h0fVxuICAgICAgICBdXG4gICAgICBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBmb3VyIGF4aXMgYmV0d2VlbiBjb3JuZXJzIG9mIHJlY3RhbmdsZSBBIGFuZCBjb3JuZXJzIG9mXG4gICAgICogcmVjdGFuZ2xlIEIuIFRoaXMgaXMgbmVlZGVkIGxhdGVyIHRvIGNoZWNrIGFuIGV2ZW50dWFsIGNvbGxpc2lvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge2FycmF5fSBBbiBhcnJheSBvZiByZWN0YW5nbGUgQSdzIGZvdXIgY29ybmVycyAoeCwgeSkuXG4gICAgICogQHBhcmFtICB7YXJyYXl9IEFuIGFycmF5IG9mIHJlY3RhbmdsZSBCJ3MgZm91ciBjb3JuZXJzICh4LCB5KS5cbiAgICAgKiBAcmV0dXJuIHthcnJheX0gQW4gYXJyYXkgb2YgZm91ciBheGlzIGRlZmluZWQgYnkgdGhlaXIgY29vcmRpbmF0ZXMgKHgseSkuXG4gICAgICovXG4gICAgYXhpczogZnVuY3Rpb24oYzEsIGMyKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7eDogYzFbMV0ueCAtIGMxWzBdLngsIHk6IGMxWzFdLnkgLSBjMVswXS55fSxcbiAgICAgICAge3g6IGMxWzFdLnggLSBjMVszXS54LCB5OiBjMVsxXS55IC0gYzFbM10ueX0sXG4gICAgICAgIHt4OiBjMlswXS54IC0gYzJbMl0ueCwgeTogYzJbMF0ueSAtIGMyWzJdLnl9LFxuICAgICAgICB7eDogYzJbMF0ueCAtIGMyWzFdLngsIHk6IGMyWzBdLnkgLSBjMlsxXS55fVxuICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvamVjdCBhIHJlY3RhbmdsZSdzIGNvcm5lciBvbiBhbiBheGlzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBDb29yZGluYXRlcyBvZiBhIGNvcm5lciAoeCwgeSkuXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBDb29yZGluYXRlcyBvZiBhbiBheGlzICh4LCB5KS5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBwcm9qZWN0aW9uIGRlZmluZWQgYnkgY29vcmRpbmF0ZXMgKHgsIHkpLlxuICAgICAqL1xuICAgIHByb2plY3Rpb246IGZ1bmN0aW9uKGMsIGEpIHtcbiAgICAgIHZhciBsID0gKFxuICAgICAgICAoYy54ICogYS54ICsgYy55ICogYS55KSAvXG4gICAgICAgIChNYXRoLnBvdyhhLngsIDIpICsgTWF0aC5wb3coYS55LCAyKSlcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGwgKiBhLngsXG4gICAgICAgIHk6IGwgKiBhLnlcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdHdvIHJlY3RhbmdsZXMgY29sbGlkZSBvbiBvbmUgcGFydGljdWxhciBheGlzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgIEFuIGF4aXMnIGNvb3JkaW5hdGVzICh4LCB5KS5cbiAgICAgKiBAcGFyYW0gIHthcnJheX0gICAgUmVjdGFuZ2xlIEEncyBjb3JuZXJzLlxuICAgICAqIEBwYXJhbSAge2FycmF5fSAgICBSZWN0YW5nbGUgQidzIGNvcm5lcnMuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gIFRydWUgaWYgdGhlIHJlY3RhbmdsZXMgY29sbGlkZSBvbiB0aGUgYXhpcy5cbiAgICAgKi9cbiAgICBheGlzQ29sbGlzaW9uOiBmdW5jdGlvbihhLCBjMSwgYzIpIHtcbiAgICAgIHZhciBzYzEgPSBbXSxcbiAgICAgICAgICBzYzIgPSBbXTtcblxuICAgICAgZm9yICh2YXIgY2kgPSAwOyBjaSA8IDQ7IGNpKyspIHtcbiAgICAgICAgdmFyIHAxID0gdGhpcy5wcm9qZWN0aW9uKGMxW2NpXSwgYSksXG4gICAgICAgICAgICBwMiA9IHRoaXMucHJvamVjdGlvbihjMltjaV0sIGEpO1xuXG4gICAgICAgIHNjMS5wdXNoKHAxLnggKiBhLnggKyBwMS55ICogYS55KTtcbiAgICAgICAgc2MyLnB1c2gocDIueCAqIGEueCArIHAyLnkgKiBhLnkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF4YzEgPSBNYXRoLm1heC5hcHBseShNYXRoLCBzYzEpLFxuICAgICAgICAgIG1heGMyID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgc2MyKSxcbiAgICAgICAgICBtaW5jMSA9IE1hdGgubWluLmFwcGx5KE1hdGgsIHNjMSksXG4gICAgICAgICAgbWluYzIgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBzYzIpO1xuXG4gICAgICByZXR1cm4gKG1pbmMyIDw9IG1heGMxICYmIG1heGMyID49IG1pbmMxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0d28gcmVjdGFuZ2xlcyBjb2xsaWRlIG9uIGVhY2ggb25lIG9mIHRoZWlyIGZvdXIgYXhpcy4gSWZcbiAgICAgKiBhbGwgYXhpcyBjb2xsaWRlLCB0aGVuIHRoZSB0d28gcmVjdGFuZ2xlcyBkbyBjb2xsaWRlIG9uIHRoZSBwbGFuZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge2FycmF5fSAgICBSZWN0YW5nbGUgQSdzIGNvcm5lcnMuXG4gICAgICogQHBhcmFtICB7YXJyYXl9ICAgIFJlY3RhbmdsZSBCJ3MgY29ybmVycy5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSAgVHJ1ZSBpZiB0aGUgcmVjdGFuZ2xlcyBjb2xsaWRlLlxuICAgICAqL1xuICAgIGNvbGxpc2lvbjogZnVuY3Rpb24oYzEsIGMyKSB7XG4gICAgICB2YXIgYXhpcyA9IHRoaXMuYXhpcyhjMSwgYzIpLFxuICAgICAgICAgIGNvbCA9IHRydWU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKVxuICAgICAgICBjb2wgPSBjb2wgJiYgdGhpcy5heGlzQ29sbGlzaW9uKGF4aXNbaV0sIGMxLCBjMik7XG5cbiAgICAgIHJldHVybiBjb2w7XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG4gICAqIFF1YWQgRnVuY3Rpb25zXG4gICAqIC0tLS0tLS0tLS0tLVxuICAgKlxuICAgKiBUaGUgUXVhZHRyZWUgZnVuY3Rpb25zIHRoZW1zZWx2ZXMuXG4gICAqIEZvciBlYWNoIG9mIHRob3NlIGZ1bmN0aW9ucywgd2UgY29uc2lkZXIgdGhhdCBpbiBhIHNwbGl0dGVkIHF1YWQsIHRoZVxuICAgKiBpbmRleCBvZiBlYWNoIG5vZGUgaXMgdGhlIGZvbGxvd2luZzpcbiAgICogMDogdG9wIGxlZnRcbiAgICogMTogdG9wIHJpZ2h0XG4gICAqIDI6IGJvdHRvbSBsZWZ0XG4gICAqIDM6IGJvdHRvbSByaWdodFxuICAgKlxuICAgKiBNb3Jlb3ZlciwgdGhlIGhlcmVhZnRlciBxdWFkJ3MgcGhpbG9zb3BoeSBpcyB0byBjb25zaWRlciB0aGF0IGlmIGFuIGVsZW1lbnRcbiAgICogY29sbGlkZXMgd2l0aCBtb3JlIHRoYW4gb25lIG5vZGVzLCB0aGlzIGVsZW1lbnQgYmVsb25ncyB0byBlYWNoIG9mIHRoZVxuICAgKiBub2RlcyBpdCBjb2xsaWRlcyB3aXRoIHdoZXJlIG90aGVyIHdvdWxkIGxldCBpdCBsaWUgb24gYSBoaWdoZXIgbm9kZS5cbiAgICovXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaW5kZXggb2YgdGhlIG5vZGUgY29udGFpbmluZyB0aGUgcG9pbnQgaW4gdGhlIHF1YWRcbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgcG9pbnQgICAgICBBIHBvaW50IGRlZmluZWQgYnkgY29vcmRpbmF0ZXMgKHgsIHkpLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBxdWFkQm91bmRzIEJvdW5kYXJpZXMgb2YgdGhlIHF1YWQgKHgsIHksIHdpZHRoLCBoZWlndGgpLlxuICAgKiBAcmV0dXJuIHtpbnRlZ2VyfSAgICAgICAgICAgIFRoZSBpbmRleCBvZiB0aGUgbm9kZSBjb250YWluaW5nIHRoZSBwb2ludC5cbiAgICovXG4gIGZ1bmN0aW9uIF9xdWFkSW5kZXgocG9pbnQsIHF1YWRCb3VuZHMpIHtcbiAgICB2YXIgeG1wID0gcXVhZEJvdW5kcy54ICsgcXVhZEJvdW5kcy53aWR0aCAvIDIsXG4gICAgICAgIHltcCA9IHF1YWRCb3VuZHMueSArIHF1YWRCb3VuZHMuaGVpZ2h0IC8gMixcbiAgICAgICAgdG9wID0gKHBvaW50LnkgPCB5bXApLFxuICAgICAgICBsZWZ0ID0gKHBvaW50LnggPCB4bXApO1xuXG4gICAgaWYgKHRvcCkge1xuICAgICAgaWYgKGxlZnQpXG4gICAgICAgIHJldHVybiAwO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAobGVmdClcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiAzO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBsaXN0IG9mIGluZGV4ZXMgb2Ygbm9kZXMgY29udGFpbmluZyBhbiBheGlzLWFsaWduZWQgcmVjdGFuZ2xlXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHJlY3RhbmdsZSAgIEEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHBvaW50cyAoeDEsIHkxKSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICogQHBhcmFtICB7YXJyYXl9ICAgcXVhZENvcm5lcnMgQW4gYXJyYXkgb2YgdGhlIHF1YWQgbm9kZXMnIGNvcm5lcnMuXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgICAgICAgIEFuIGFycmF5IG9mIGluZGV4ZXMgY29udGFpbmluZyBvbmUgdG9cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91ciBpbnRlZ2Vycy5cbiAgICovXG4gIGZ1bmN0aW9uIF9xdWFkSW5kZXhlcyhyZWN0YW5nbGUsIHF1YWRDb3JuZXJzKSB7XG4gICAgdmFyIGluZGV4ZXMgPSBbXTtcblxuICAgIC8vIEl0ZXJhdGluZyB0aHJvdWdoIHF1YWRzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspXG4gICAgICBpZiAoKHJlY3RhbmdsZS54MiA+PSBxdWFkQ29ybmVyc1tpXVswXS54KSAmJlxuICAgICAgICAgIChyZWN0YW5nbGUueDEgPD0gcXVhZENvcm5lcnNbaV1bMV0ueCkgJiZcbiAgICAgICAgICAocmVjdGFuZ2xlLnkxICsgcmVjdGFuZ2xlLmhlaWdodCA+PSBxdWFkQ29ybmVyc1tpXVswXS55KSAmJlxuICAgICAgICAgIChyZWN0YW5nbGUueTEgPD0gcXVhZENvcm5lcnNbaV1bMl0ueSkpXG4gICAgICAgIGluZGV4ZXMucHVzaChpKTtcblxuICAgIHJldHVybiBpbmRleGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGxpc3Qgb2YgaW5kZXhlcyBvZiBub2RlcyBjb250YWluaW5nIGEgbm9uLWF4aXMtYWxpZ25lZCByZWN0YW5nbGVcbiAgICpcbiAgICogQHBhcmFtICB7YXJyYXl9ICBjb3JuZXJzICAgICAgQW4gYXJyYXkgY29udGFpbmluZyBlYWNoIGNvcm5lciBvZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdGFuZ2xlIGRlZmluZWQgYnkgaXRzIGNvb3JkaW5hdGVzICh4LCB5KS5cbiAgICogQHBhcmFtICB7YXJyYXl9ICBxdWFkQ29ybmVycyAgQW4gYXJyYXkgb2YgdGhlIHF1YWQgbm9kZXMnIGNvcm5lcnMuXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgICAgICAgIEFuIGFycmF5IG9mIGluZGV4ZXMgY29udGFpbmluZyBvbmUgdG9cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91ciBpbnRlZ2Vycy5cbiAgICovXG4gIGZ1bmN0aW9uIF9xdWFkQ29sbGlzaW9uKGNvcm5lcnMsIHF1YWRDb3JuZXJzKSB7XG4gICAgdmFyIGluZGV4ZXMgPSBbXTtcblxuICAgIC8vIEl0ZXJhdGluZyB0aHJvdWdoIHF1YWRzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspXG4gICAgICBpZiAoX2dlb20uY29sbGlzaW9uKGNvcm5lcnMsIHF1YWRDb3JuZXJzW2ldKSlcbiAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xuXG4gICAgcmV0dXJuIGluZGV4ZXM7XG4gIH1cblxuICAvKipcbiAgICogU3ViZGl2aWRlIGEgcXVhZCBieSBjcmVhdGluZyBhIG5vZGUgYXQgYSBwcmVjaXNlIGluZGV4LiBUaGUgZnVuY3Rpb24gZG9lc1xuICAgKiBub3QgZ2VuZXJhdGUgYWxsIGZvdXIgbm9kZXMgbm90IHRvIHBvdGVudGlhbGx5IGNyZWF0ZSB1bnVzZWQgbm9kZXMuXG4gICAqXG4gICAqIEBwYXJhbSAge2ludGVnZXJ9ICBpbmRleCBUaGUgaW5kZXggb2YgdGhlIG5vZGUgdG8gY3JlYXRlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgcXVhZCAgVGhlIHF1YWQgb2JqZWN0IHRvIHN1YmRpdmlkZS5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgIEEgbmV3IHF1YWQgcmVwcmVzZW50aW5nIHRoZSBub2RlIGNyZWF0ZWQuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZFN1YmRpdmlkZShpbmRleCwgcXVhZCkge1xuICAgIHZhciBuZXh0ID0gcXVhZC5sZXZlbCArIDEsXG4gICAgICAgIHN1YncgPSBNYXRoLnJvdW5kKHF1YWQuYm91bmRzLndpZHRoIC8gMiksXG4gICAgICAgIHN1YmggPSBNYXRoLnJvdW5kKHF1YWQuYm91bmRzLmhlaWdodCAvIDIpLFxuICAgICAgICBxeCA9IE1hdGgucm91bmQocXVhZC5ib3VuZHMueCksXG4gICAgICAgIHF5ID0gTWF0aC5yb3VuZChxdWFkLmJvdW5kcy55KSxcbiAgICAgICAgeCxcbiAgICAgICAgeTtcblxuICAgIHN3aXRjaCAoaW5kZXgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgeCA9IHF4O1xuICAgICAgICB5ID0gcXk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICB4ID0gcXggKyBzdWJ3O1xuICAgICAgICB5ID0gcXk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICB4ID0gcXg7XG4gICAgICAgIHkgPSBxeSArIHN1Ymg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICB4ID0gcXggKyBzdWJ3O1xuICAgICAgICB5ID0gcXkgKyBzdWJoO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gX3F1YWRUcmVlKFxuICAgICAge3g6IHgsIHk6IHksIHdpZHRoOiBzdWJ3LCBoZWlnaHQ6IHN1Ymh9LFxuICAgICAgbmV4dCxcbiAgICAgIHF1YWQubWF4RWxlbWVudHMsXG4gICAgICBxdWFkLm1heExldmVsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSBpbnNlcnQgYW4gZWxlbWVudCBpbnRvIHRoZSBxdWFkdHJlZS4gT25seSBwb2ludHNcbiAgICogd2l0aCBzaXplLCBpLmUuIGF4aXMtYWxpZ25lZCBzcXVhcmVzLCBtYXkgYmUgaW5zZXJ0ZWQgd2l0aCB0aGlzXG4gICAqIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgZWwgICAgICAgICBUaGUgZWxlbWVudCB0byBpbnNlcnQgaW4gdGhlIHF1YWR0cmVlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBzaXplZFBvaW50IEEgc2l6ZWQgcG9pbnQgZGVmaW5lZCBieSB0d28gdG9wIHBvaW50c1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBxdWFkICAgICAgIFRoZSBxdWFkIGluIHdoaWNoIHRvIGluc2VydCB0aGUgZWxlbWVudC5cbiAgICogQHJldHVybiB7dW5kZWZpbmVkfSAgICAgICAgICBUaGUgZnVuY3Rpb24gZG9lcyBub3QgcmV0dXJuIGFueXRoaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gX3F1YWRJbnNlcnQoZWwsIHNpemVkUG9pbnQsIHF1YWQpIHtcbiAgICBpZiAocXVhZC5sZXZlbCA8IHF1YWQubWF4TGV2ZWwpIHtcblxuICAgICAgLy8gU2VhcmNoaW5nIGFwcHJvcHJpYXRlIHF1YWRzXG4gICAgICB2YXIgaW5kZXhlcyA9IF9xdWFkSW5kZXhlcyhzaXplZFBvaW50LCBxdWFkLmNvcm5lcnMpO1xuXG4gICAgICAvLyBJdGVyYXRpbmdcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaW5kZXhlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblxuICAgICAgICAvLyBTdWJkaXZpZGluZyBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKHF1YWQubm9kZXNbaW5kZXhlc1tpXV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICBxdWFkLm5vZGVzW2luZGV4ZXNbaV1dID0gX3F1YWRTdWJkaXZpZGUoaW5kZXhlc1tpXSwgcXVhZCk7XG5cbiAgICAgICAgLy8gUmVjdXJzaW9uXG4gICAgICAgIF9xdWFkSW5zZXJ0KGVsLCBzaXplZFBvaW50LCBxdWFkLm5vZGVzW2luZGV4ZXNbaV1dKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG5cbiAgICAgIC8vIFB1c2hpbmcgdGhlIGVsZW1lbnQgaW4gYSBsZWFmIG5vZGVcbiAgICAgIHF1YWQuZWxlbWVudHMucHVzaChlbCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IHJldHJpZXZlIGV2ZXJ5IGVsZW1lbnRzIGhlbGQgYnkgdGhlIG5vZGUgY29udGFpbmluZyB0aGVcbiAgICogc2VhcmNoZWQgcG9pbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHBvaW50IFRoZSBzZWFyY2hlZCBwb2ludCAoeCwgeSkuXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHF1YWQgIFRoZSBzZWFyY2hlZCBxdWFkLlxuICAgKiBAcmV0dXJuIHthcnJheX0gICAgICAgICBBbiBhcnJheSBvZiBlbGVtZW50cyBjb250YWluZWQgaW4gdGhlIHJlbGV2YW50XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZFJldHJpZXZlUG9pbnQocG9pbnQsIHF1YWQpIHtcbiAgICBpZiAocXVhZC5sZXZlbCA8IHF1YWQubWF4TGV2ZWwpIHtcbiAgICAgIHZhciBpbmRleCA9IF9xdWFkSW5kZXgocG9pbnQsIHF1YWQuYm91bmRzKTtcblxuICAgICAgLy8gSWYgbm9kZSBkb2VzIG5vdCBleGlzdCB3ZSByZXR1cm4gYW4gZW1wdHkgbGlzdFxuICAgICAgaWYgKHF1YWQubm9kZXNbaW5kZXhdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIF9xdWFkUmV0cmlldmVQb2ludChwb2ludCwgcXVhZC5ub2Rlc1tpbmRleF0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gcXVhZC5lbGVtZW50cztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgcmV0cmlldmUgZXZlcnkgZWxlbWVudHMgY29udGFpbmVkIHdpdGhpbiBhbiByZWN0YW5ndWxhciBhcmVhXG4gICAqIHRoYXQgbWF5IG9yIG1heSBub3QgYmUgYXhpcy1hbGlnbmVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R8YXJyYXl9IHJlY3REYXRhICAgICAgIFRoZSBzZWFyY2hlZCBhcmVhIGRlZmluZWQgZWl0aGVyIGJ5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW4gYXJyYXkgb2YgZm91ciBjb3JuZXJzICh4LCB5KSBpblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBjYXNlIG9mIGEgbm9uLWF4aXMtYWxpZ25lZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RhbmdsZSBvciBhbiBvYmplY3Qgd2l0aCB0d28gdG9wXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgIHF1YWQgICAgICAgICAgIFRoZSBzZWFyY2hlZCBxdWFkLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gICAgIGNvbGxpc2lvbkZ1bmMgIFRoZSBjb2xsaXNpb24gZnVuY3Rpb24gdXNlZCB0byBzZWFyY2hcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3Igbm9kZSBpbmRleGVzLlxuICAgKiBAcGFyYW0gIHthcnJheT99ICAgICAgIGVscyAgICAgICAgICAgIFRoZSByZXRyaWV2ZWQgZWxlbWVudHMuXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgICAgICAgICAgICAgICAgQW4gYXJyYXkgb2YgZWxlbWVudHMgY29udGFpbmVkIGluIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZWEuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZFJldHJpZXZlQXJlYShyZWN0RGF0YSwgcXVhZCwgY29sbGlzaW9uRnVuYywgZWxzKSB7XG4gICAgZWxzID0gZWxzIHx8IHt9O1xuXG4gICAgaWYgKHF1YWQubGV2ZWwgPCBxdWFkLm1heExldmVsKSB7XG4gICAgICB2YXIgaW5kZXhlcyA9IGNvbGxpc2lvbkZ1bmMocmVjdERhdGEsIHF1YWQuY29ybmVycyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaW5kZXhlcy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIGlmIChxdWFkLm5vZGVzW2luZGV4ZXNbaV1dICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgX3F1YWRSZXRyaWV2ZUFyZWEoXG4gICAgICAgICAgICByZWN0RGF0YSxcbiAgICAgICAgICAgIHF1YWQubm9kZXNbaW5kZXhlc1tpXV0sXG4gICAgICAgICAgICBjb2xsaXNpb25GdW5jLFxuICAgICAgICAgICAgZWxzXG4gICAgICAgICAgKTtcbiAgICB9IGVsc2VcbiAgICAgIGZvciAodmFyIGogPSAwLCBtID0gcXVhZC5lbGVtZW50cy5sZW5ndGg7IGogPCBtOyBqKyspXG4gICAgICAgIGlmIChlbHNbcXVhZC5lbGVtZW50c1tqXS5pZF0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICBlbHNbcXVhZC5lbGVtZW50c1tqXS5pZF0gPSBxdWFkLmVsZW1lbnRzW2pdO1xuXG4gICAgcmV0dXJuIGVscztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBxdWFkdHJlZSBvYmplY3QgaXRzZWxmLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgYm91bmRzICAgICAgIFRoZSBib3VuZGFyaWVzIG9mIHRoZSBxdWFkIGRlZmluZWQgYnkgYW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW4gKHgsIHkpLCB3aWR0aCBhbmQgaGVpZ3RoLlxuICAgKiBAcGFyYW0gIHtpbnRlZ2VyfSAgbGV2ZWwgICAgICAgIFRoZSBsZXZlbCBvZiB0aGUgcXVhZCBpbiB0aGUgdHJlZS5cbiAgICogQHBhcmFtICB7aW50ZWdlcn0gIG1heEVsZW1lbnRzICBUaGUgbWF4IG51bWJlciBvZiBlbGVtZW50IGluIGEgbGVhZiBub2RlLlxuICAgKiBAcGFyYW0gIHtpbnRlZ2VyfSAgbWF4TGV2ZWwgICAgIFRoZSBtYXggcmVjdXJzaW9uIGxldmVsIG9mIHRoZSB0cmVlLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgICAgICAgIFRoZSBxdWFkdHJlZSBvYmplY3QuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZFRyZWUoYm91bmRzLCBsZXZlbCwgbWF4RWxlbWVudHMsIG1heExldmVsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxldmVsOiBsZXZlbCB8fCAwLFxuICAgICAgYm91bmRzOiBib3VuZHMsXG4gICAgICBjb3JuZXJzOiBfZ2VvbS5zcGxpdFNxdWFyZShib3VuZHMpLFxuICAgICAgbWF4RWxlbWVudHM6IG1heEVsZW1lbnRzIHx8IDQwLFxuICAgICAgbWF4TGV2ZWw6IG1heExldmVsIHx8IDgsXG4gICAgICBlbGVtZW50czogW10sXG4gICAgICBub2RlczogW11cbiAgICB9O1xuICB9XG5cblxuICAvKipcbiAgICogU2lnbWEgUXVhZCBDb25zdHJ1Y3RvclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqXG4gICAqIFRoZSBlZGdlcXVhZCBBUEkgYXMgZXhwb3NlZCB0byBzaWdtYS5cbiAgICovXG5cbiAgLyoqXG4gICAqIFRoZSBlZGdlcXVhZCBjb3JlIHRoYXQgd2lsbCBiZWNvbWUgdGhlIHNpZ21hIGludGVyZmFjZSB3aXRoIHRoZSBxdWFkdHJlZS5cbiAgICpcbiAgICogcHJvcGVydHkge29iamVjdH0gX3RyZWUgICAgIFByb3BlcnR5IGhvbGRpbmcgdGhlIHF1YWR0cmVlIG9iamVjdC5cbiAgICogcHJvcGVydHkge29iamVjdH0gX2dlb20gICAgIEV4cG9zaXRpb24gb2YgdGhlIF9nZW9tIG5hbWVzcGFjZSBmb3IgdGVzdGluZy5cbiAgICogcHJvcGVydHkge29iamVjdH0gX2NhY2hlICAgIENhY2hlIGZvciB0aGUgYXJlYSBtZXRob2QuXG4gICAqIHByb3BlcnR5IHtib29sZWFufSBfZW5hYmxlZCBDYW4gaW5kZXggYW5kIHJldHJlaXZlIGVsZW1lbnRzLlxuICAgKi9cbiAgdmFyIGVkZ2VxdWFkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZ2VvbSA9IF9nZW9tO1xuICAgIHRoaXMuX3RyZWUgPSBudWxsO1xuICAgIHRoaXMuX2NhY2hlID0ge1xuICAgICAgcXVlcnk6IGZhbHNlLFxuICAgICAgcmVzdWx0OiBmYWxzZVxuICAgIH07XG4gICAgdGhpcy5fZW5hYmxlZCA9IHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluZGV4IGEgZ3JhcGggYnkgaW5zZXJ0aW5nIGl0cyBlZGdlcyBpbnRvIHRoZSBxdWFkdHJlZS5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSBncmFwaCAgIEEgZ3JhcGggaW5zdGFuY2UuXG4gICAqIEBwYXJhbSAge29iamVjdH0gcGFyYW1zICBBbiBvYmplY3Qgb2YgcGFyYW1ldGVycyB3aXRoIGF0IGxlYXN0IHRoZSBxdWFkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZHMuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICBUaGUgcXVhZHRyZWUgb2JqZWN0LlxuICAgKlxuICAgKiBQYXJhbWV0ZXJzOlxuICAgKiAtLS0tLS0tLS0tXG4gICAqIGJvdW5kczogICAgICB7b2JqZWN0fSAgIGJvdW5kYXJpZXMgb2YgdGhlIHF1YWQgZGVmaW5lZCBieSBpdHMgb3JpZ2luICh4LCB5KVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCBhbmQgaGVpZ3RoLlxuICAgKiBwcmVmaXg6ICAgICAge3N0cmluZz99ICBhIHByZWZpeCBmb3IgZWRnZSBnZW9tZXRyaWMgYXR0cmlidXRlcy5cbiAgICogbWF4RWxlbWVudHM6IHtpbnRlZ2VyP30gdGhlIG1heCBudW1iZXIgb2YgZWxlbWVudHMgaW4gYSBsZWFmIG5vZGUuXG4gICAqIG1heExldmVsOiAgICB7aW50ZWdlcj99IHRoZSBtYXggcmVjdXJzaW9uIGxldmVsIG9mIHRoZSB0cmVlLlxuICAgKi9cbiAgZWRnZXF1YWQucHJvdG90eXBlLmluZGV4ID0gZnVuY3Rpb24oZ3JhcGgsIHBhcmFtcykge1xuICAgIGlmICghdGhpcy5fZW5hYmxlZClcbiAgICAgIHJldHVybiB0aGlzLl90cmVlO1xuXG4gICAgLy8gRW5mb3JjaW5nIHByZXNlbmNlIG9mIGJvdW5kYXJpZXNcbiAgICBpZiAoIXBhcmFtcy5ib3VuZHMpXG4gICAgICB0aHJvdyAnc2lnbWEuY2xhc3Nlcy5lZGdlcXVhZC5pbmRleDogYm91bmRzIGluZm9ybWF0aW9uIG5vdCBnaXZlbi4nO1xuXG4gICAgLy8gUHJlZml4XG4gICAgdmFyIHByZWZpeCA9IHBhcmFtcy5wcmVmaXggfHwgJycsXG4gICAgICAgIGNwLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgbixcbiAgICAgICAgZTtcblxuICAgIC8vIEJ1aWxkaW5nIHRoZSB0cmVlXG4gICAgdGhpcy5fdHJlZSA9IF9xdWFkVHJlZShcbiAgICAgIHBhcmFtcy5ib3VuZHMsXG4gICAgICAwLFxuICAgICAgcGFyYW1zLm1heEVsZW1lbnRzLFxuICAgICAgcGFyYW1zLm1heExldmVsXG4gICAgKTtcblxuICAgIHZhciBlZGdlcyA9IGdyYXBoLmVkZ2VzKCk7XG5cbiAgICAvLyBJbnNlcnRpbmcgZ3JhcGggZWRnZXMgaW50byB0aGUgdHJlZVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gZWRnZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBzb3VyY2UgPSBncmFwaC5ub2RlcyhlZGdlc1tpXS5zb3VyY2UpO1xuICAgICAgdGFyZ2V0ID0gZ3JhcGgubm9kZXMoZWRnZXNbaV0udGFyZ2V0KTtcbiAgICAgIGUgPSB7XG4gICAgICAgIHgxOiBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgeTE6IHNvdXJjZVtwcmVmaXggKyAneSddLFxuICAgICAgICB4MjogdGFyZ2V0W3ByZWZpeCArICd4J10sXG4gICAgICAgIHkyOiB0YXJnZXRbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgc2l6ZTogZWRnZXNbaV1bcHJlZml4ICsgJ3NpemUnXSB8fCAwXG4gICAgICB9O1xuXG4gICAgICAvLyBJbnNlcnRpbmcgZWRnZVxuICAgICAgaWYgKGVkZ2VzW2ldLnR5cGUgPT09ICdjdXJ2ZScgfHwgZWRnZXNbaV0udHlwZSA9PT0gJ2N1cnZlZEFycm93Jykge1xuICAgICAgICBpZiAoc291cmNlLmlkID09PSB0YXJnZXQuaWQpIHtcbiAgICAgICAgICBuID0ge1xuICAgICAgICAgICAgeDogc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICAgICAgICB5OiBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICAgIHNpemU6IHNvdXJjZVtwcmVmaXggKyAnc2l6ZSddIHx8IDBcbiAgICAgICAgICB9O1xuICAgICAgICAgIF9xdWFkSW5zZXJ0KFxuICAgICAgICAgICAgZWRnZXNbaV0sXG4gICAgICAgICAgICBfZ2VvbS5zZWxmTG9vcFRvU3F1YXJlKG4pLFxuICAgICAgICAgICAgdGhpcy5fdHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY3AgPSBzaWdtYS51dGlscy5nZXRRdWFkcmF0aWNDb250cm9sUG9pbnQoZS54MSwgZS55MSwgZS54MiwgZS55Mik7XG4gICAgICAgICAgX3F1YWRJbnNlcnQoXG4gICAgICAgICAgICBlZGdlc1tpXSxcbiAgICAgICAgICAgIF9nZW9tLnF1YWRyYXRpY0N1cnZlVG9TcXVhcmUoZSwgY3ApLFxuICAgICAgICAgICAgdGhpcy5fdHJlZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBfcXVhZEluc2VydChcbiAgICAgICAgICBlZGdlc1tpXSxcbiAgICAgICAgICBfZ2VvbS5saW5lVG9TcXVhcmUoZSksXG4gICAgICAgICAgdGhpcy5fdHJlZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgY2FjaGU6XG4gICAgdGhpcy5fY2FjaGUgPSB7XG4gICAgICBxdWVyeTogZmFsc2UsXG4gICAgICByZXN1bHQ6IGZhbHNlXG4gICAgfTtcblxuICAgIC8vIHJlbW92ZT9cbiAgICByZXR1cm4gdGhpcy5fdHJlZTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmUgZXZlcnkgZ3JhcGggZWRnZXMgaGVsZCBieSB0aGUgcXVhZHRyZWUgbm9kZSBjb250YWluaW5nIHRoZVxuICAgKiBzZWFyY2hlZCBwb2ludC5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4IG9mIHRoZSBwb2ludC5cbiAgICogQHBhcmFtICB7bnVtYmVyfSB5IG9mIHRoZSBwb2ludC5cbiAgICogQHJldHVybiB7YXJyYXl9ICBBbiBhcnJheSBvZiBlZGdlcyByZXRyaWV2ZWQuXG4gICAqL1xuICBlZGdlcXVhZC5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgaWYgKCF0aGlzLl9lbmFibGVkKVxuICAgICAgcmV0dXJuIFtdO1xuXG4gICAgcmV0dXJuIHRoaXMuX3RyZWUgP1xuICAgICAgX3F1YWRSZXRyaWV2ZVBvaW50KHt4OiB4LCB5OiB5fSwgdGhpcy5fdHJlZSkgfHwgW10gOlxuICAgICAgW107XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIGV2ZXJ5IGdyYXBoIGVkZ2VzIHdpdGhpbiBhIHJlY3Rhbmd1bGFyIGFyZWEuIFRoZSBtZXRob2RzIGtlZXAgdGhlXG4gICAqIGxhc3QgYXJlYSBxdWVyaWVkIGluIGNhY2hlIGZvciBvcHRpbWl6YXRpb24gcmVhc29uIGFuZCB3aWxsIGFjdCBkaWZmZXJlbnRseVxuICAgKiBmb3IgdGhlIHNhbWUgcmVhc29uIGlmIHRoZSBhcmVhIGlzIGF4aXMtYWxpZ25lZCBvciBub3QuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gQSByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gdG9wIHBvaW50cyAoeDEsIHkxKSwgKHgyLCB5MilcbiAgICogICAgICAgICAgICAgICAgICBhbmQgaGVpZ2h0LlxuICAgKiBAcmV0dXJuIHthcnJheX0gIEFuIGFycmF5IG9mIGVkZ2VzIHJldHJpZXZlZC5cbiAgICovXG4gIGVkZ2VxdWFkLnByb3RvdHlwZS5hcmVhID0gZnVuY3Rpb24ocmVjdCkge1xuICAgIGlmICghdGhpcy5fZW5hYmxlZClcbiAgICAgIHJldHVybiBbXTtcblxuICAgIHZhciBzZXJpYWxpemVkID0gSlNPTi5zdHJpbmdpZnkocmVjdCksXG4gICAgICAgIGNvbGxpc2lvbkZ1bmMsXG4gICAgICAgIHJlY3REYXRhO1xuXG4gICAgLy8gUmV0dXJuaW5nIGNhY2hlP1xuICAgIGlmICh0aGlzLl9jYWNoZS5xdWVyeSA9PT0gc2VyaWFsaXplZClcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZS5yZXN1bHQ7XG5cbiAgICAvLyBBeGlzIGFsaWduZWQgP1xuICAgIGlmIChfZ2VvbS5pc0F4aXNBbGlnbmVkKHJlY3QpKSB7XG4gICAgICBjb2xsaXNpb25GdW5jID0gX3F1YWRJbmRleGVzO1xuICAgICAgcmVjdERhdGEgPSBfZ2VvbS5heGlzQWxpZ25lZFRvcFBvaW50cyhyZWN0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb2xsaXNpb25GdW5jID0gX3F1YWRDb2xsaXNpb247XG4gICAgICByZWN0RGF0YSA9IF9nZW9tLnJlY3RhbmdsZUNvcm5lcnMocmVjdCk7XG4gICAgfVxuXG4gICAgLy8gUmV0cmlldmluZyBlZGdlc1xuICAgIHZhciBlZGdlcyA9IHRoaXMuX3RyZWUgP1xuICAgICAgX3F1YWRSZXRyaWV2ZUFyZWEoXG4gICAgICAgIHJlY3REYXRhLFxuICAgICAgICB0aGlzLl90cmVlLFxuICAgICAgICBjb2xsaXNpb25GdW5jXG4gICAgICApIDpcbiAgICAgIFtdO1xuXG4gICAgLy8gT2JqZWN0IHRvIGFycmF5XG4gICAgdmFyIGVkZ2VzQXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpIGluIGVkZ2VzKVxuICAgICAgZWRnZXNBcnJheS5wdXNoKGVkZ2VzW2ldKTtcblxuICAgIC8vIENhY2hpbmdcbiAgICB0aGlzLl9jYWNoZS5xdWVyeSA9IHNlcmlhbGl6ZWQ7XG4gICAgdGhpcy5fY2FjaGUucmVzdWx0ID0gZWRnZXNBcnJheTtcblxuICAgIHJldHVybiBlZGdlc0FycmF5O1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEVYUE9SVDpcbiAgICogKioqKioqKlxuICAgKi9cbiAgaWYgKHR5cGVvZiB0aGlzLnNpZ21hICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMuc2lnbWEuY2xhc3NlcyA9IHRoaXMuc2lnbWEuY2xhc3NlcyB8fCB7fTtcbiAgICB0aGlzLnNpZ21hLmNsYXNzZXMuZWRnZXF1YWQgPSBlZGdlcXVhZDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpXG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBlZGdlcXVhZDtcbiAgICBleHBvcnRzLmVkZ2VxdWFkID0gZWRnZXF1YWQ7XG4gIH0gZWxzZVxuICAgIHRoaXMuZWRnZXF1YWQgPSBlZGdlcXVhZDtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhcHRvcnMnKTtcblxuICAvKipcbiAgICogVGhlIHVzZXIgaW5wdXRzIGRlZmF1bHQgY2FwdG9yLiBJdCBkZWFscyB3aXRoIG1vdXNlIGV2ZW50cywga2V5Ym9hcmRzXG4gICAqIGV2ZW50cyBhbmQgdG91Y2ggZXZlbnRzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSAgIHRhcmdldCAgIFRoZSBET00gZWxlbWVudCB3aGVyZSB0aGUgbGlzdGVuZXJzIHdpbGwgYmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZC5cbiAgICogQHBhcmFtICB7Y2FtZXJhfSAgICAgICBjYW1lcmEgICBUaGUgY2FtZXJhIHJlbGF0ZWQgdG8gdGhlIHRhcmdldC5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSBzZXR0aW5ncyBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge3NpZ21hLmNhcHRvcn0gICAgICAgICAgVGhlIGZyZXNoIG5ldyBjYXB0b3IgaW5zdGFuY2UuXG4gICAqL1xuICBzaWdtYS5jYXB0b3JzLm1vdXNlID0gZnVuY3Rpb24odGFyZ2V0LCBjYW1lcmEsIHNldHRpbmdzKSB7XG4gICAgdmFyIF9zZWxmID0gdGhpcyxcbiAgICAgICAgX3RhcmdldCA9IHRhcmdldCxcbiAgICAgICAgX2NhbWVyYSA9IGNhbWVyYSxcbiAgICAgICAgX3NldHRpbmdzID0gc2V0dGluZ3MsXG5cbiAgICAgICAgLy8gQ0FNRVJBIE1BTkFHRU1FTlQ6XG4gICAgICAgIC8vICoqKioqKioqKioqKioqKioqKlxuICAgICAgICAvLyBUaGUgY2FtZXJhIHBvc2l0aW9uIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nOlxuICAgICAgICBfc3RhcnRDYW1lcmFYLFxuICAgICAgICBfc3RhcnRDYW1lcmFZLFxuICAgICAgICBfc3RhcnRDYW1lcmFBbmdsZSxcblxuICAgICAgICAvLyBUaGUgbGF0ZXN0IHN0YWdlIHBvc2l0aW9uOlxuICAgICAgICBfbGFzdENhbWVyYVgsXG4gICAgICAgIF9sYXN0Q2FtZXJhWSxcbiAgICAgICAgX2xhc3RDYW1lcmFBbmdsZSxcbiAgICAgICAgX2xhc3RDYW1lcmFSYXRpbyxcblxuICAgICAgICAvLyBNT1VTRSBNQU5BR0VNRU5UOlxuICAgICAgICAvLyAqKioqKioqKioqKioqKioqKlxuICAgICAgICAvLyBUaGUgbW91c2UgcG9zaXRpb24gd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmc6XG4gICAgICAgIF9zdGFydE1vdXNlWCxcbiAgICAgICAgX3N0YXJ0TW91c2VZLFxuXG4gICAgICAgIF9pc01vdXNlRG93bixcbiAgICAgICAgX2lzTW92aW5nLFxuICAgICAgICBfaGFzRHJhZ2dlZCxcbiAgICAgICAgX2Rvd25TdGFydFRpbWUsXG4gICAgICAgIF9tb3ZpbmdUaW1lb3V0SWQ7XG5cbiAgICBzaWdtYS5jbGFzc2VzLmRpc3BhdGNoZXIuZXh0ZW5kKHRoaXMpO1xuXG4gICAgc2lnbWEudXRpbHMuZG91YmxlQ2xpY2soX3RhcmdldCwgJ2NsaWNrJywgX2RvdWJsZUNsaWNrSGFuZGxlcik7XG4gICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIF93aGVlbEhhbmRsZXIsIGZhbHNlKTtcbiAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCBfd2hlZWxIYW5kbGVyLCBmYWxzZSk7XG4gICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBfbW92ZUhhbmRsZXIsIGZhbHNlKTtcbiAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIF9kb3duSGFuZGxlciwgZmFsc2UpO1xuICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfY2xpY2tIYW5kbGVyLCBmYWxzZSk7XG4gICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIF9vdXRIYW5kbGVyLCBmYWxzZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIF91cEhhbmRsZXIsIGZhbHNlKTtcblxuXG5cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHVuYmluZHMgZXZlcnkgaGFuZGxlcnMgdGhhdCBtYWtlcyB0aGUgY2FwdG9yIHdvcmsuXG4gICAgICovXG4gICAgdGhpcy5raWxsID0gZnVuY3Rpb24oKSB7XG4gICAgICBzaWdtYS51dGlscy51bmJpbmREb3VibGVDbGljayhfdGFyZ2V0LCAnY2xpY2snKTtcbiAgICAgIF90YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCBfd2hlZWxIYW5kbGVyKTtcbiAgICAgIF90YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIF93aGVlbEhhbmRsZXIpO1xuICAgICAgX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBfbW92ZUhhbmRsZXIpO1xuICAgICAgX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBfZG93bkhhbmRsZXIpO1xuICAgICAgX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIF9jbGlja0hhbmRsZXIpO1xuICAgICAgX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIF9vdXRIYW5kbGVyKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBfdXBIYW5kbGVyKTtcbiAgICB9O1xuXG5cblxuXG4gICAgLy8gTU9VU0UgRVZFTlRTOlxuICAgIC8vICoqKioqKioqKioqKipcblxuICAgIC8qKlxuICAgICAqIFRoZSBoYW5kbGVyIGxpc3RlbmluZyB0byB0aGUgJ21vdmUnIG1vdXNlIGV2ZW50LiBJdCB3aWxsIGVmZmVjdGl2ZWx5XG4gICAgICogZHJhZyB0aGUgZ3JhcGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlIEEgbW91c2UgZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gX21vdmVIYW5kbGVyKGUpIHtcbiAgICAgIHZhciB4LFxuICAgICAgICAgIHksXG4gICAgICAgICAgcG9zO1xuXG4gICAgICAvLyBEaXNwYXRjaCBldmVudDpcbiAgICAgIGlmIChfc2V0dGluZ3MoJ21vdXNlRW5hYmxlZCcpKSB7XG4gICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ21vdXNlbW92ZScsXG4gICAgICAgICAgc2lnbWEudXRpbHMubW91c2VDb29yZHMoZSkpO1xuXG4gICAgICAgIGlmIChfaXNNb3VzZURvd24pIHtcbiAgICAgICAgICBfaXNNb3ZpbmcgPSB0cnVlO1xuICAgICAgICAgIF9oYXNEcmFnZ2VkID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChfbW92aW5nVGltZW91dElkKVxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF9tb3ZpbmdUaW1lb3V0SWQpO1xuXG4gICAgICAgICAgX21vdmluZ1RpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBfaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9LCBfc2V0dGluZ3MoJ2RyYWdUaW1lb3V0JykpO1xuXG4gICAgICAgICAgc2lnbWEubWlzYy5hbmltYXRpb24ua2lsbEFsbChfY2FtZXJhKTtcblxuICAgICAgICAgIF9jYW1lcmEuaXNNb3ZpbmcgPSB0cnVlO1xuICAgICAgICAgIHBvcyA9IF9jYW1lcmEuY2FtZXJhUG9zaXRpb24oXG4gICAgICAgICAgICBzaWdtYS51dGlscy5nZXRYKGUpIC0gX3N0YXJ0TW91c2VYLFxuICAgICAgICAgICAgc2lnbWEudXRpbHMuZ2V0WShlKSAtIF9zdGFydE1vdXNlWSxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgeCA9IF9zdGFydENhbWVyYVggLSBwb3MueDtcbiAgICAgICAgICB5ID0gX3N0YXJ0Q2FtZXJhWSAtIHBvcy55O1xuXG4gICAgICAgICAgaWYgKHggIT09IF9jYW1lcmEueCB8fCB5ICE9PSBfY2FtZXJhLnkpIHtcbiAgICAgICAgICAgIF9sYXN0Q2FtZXJhWCA9IF9jYW1lcmEueDtcbiAgICAgICAgICAgIF9sYXN0Q2FtZXJhWSA9IF9jYW1lcmEueTtcblxuICAgICAgICAgICAgX2NhbWVyYS5nb1RvKHtcbiAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgeTogeVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlICd1cCcgbW91c2UgZXZlbnQuIEl0IHdpbGwgc3RvcCBkcmFnZ2luZyB0aGVcbiAgICAgKiBncmFwaC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSBtb3VzZSBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfdXBIYW5kbGVyKGUpIHtcbiAgICAgIGlmIChfc2V0dGluZ3MoJ21vdXNlRW5hYmxlZCcpICYmIF9pc01vdXNlRG93bikge1xuICAgICAgICBfaXNNb3VzZURvd24gPSBmYWxzZTtcbiAgICAgICAgaWYgKF9tb3ZpbmdUaW1lb3V0SWQpXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KF9tb3ZpbmdUaW1lb3V0SWQpO1xuXG4gICAgICAgIF9jYW1lcmEuaXNNb3ZpbmcgPSBmYWxzZTtcblxuICAgICAgICB2YXIgeCA9IHNpZ21hLnV0aWxzLmdldFgoZSksXG4gICAgICAgICAgICB5ID0gc2lnbWEudXRpbHMuZ2V0WShlKTtcblxuICAgICAgICBpZiAoX2lzTW92aW5nKSB7XG4gICAgICAgICAgc2lnbWEubWlzYy5hbmltYXRpb24ua2lsbEFsbChfY2FtZXJhKTtcbiAgICAgICAgICBzaWdtYS5taXNjLmFuaW1hdGlvbi5jYW1lcmEoXG4gICAgICAgICAgICBfY2FtZXJhLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB4OiBfY2FtZXJhLnggK1xuICAgICAgICAgICAgICAgIF9zZXR0aW5ncygnbW91c2VJbmVydGlhUmF0aW8nKSAqIChfY2FtZXJhLnggLSBfbGFzdENhbWVyYVgpLFxuICAgICAgICAgICAgICB5OiBfY2FtZXJhLnkgK1xuICAgICAgICAgICAgICAgIF9zZXR0aW5ncygnbW91c2VJbmVydGlhUmF0aW8nKSAqIChfY2FtZXJhLnkgLSBfbGFzdENhbWVyYVkpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBlYXNpbmc6ICdxdWFkcmF0aWNPdXQnLFxuICAgICAgICAgICAgICBkdXJhdGlvbjogX3NldHRpbmdzKCdtb3VzZUluZXJ0aWFEdXJhdGlvbicpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBfc3RhcnRNb3VzZVggIT09IHggfHxcbiAgICAgICAgICBfc3RhcnRNb3VzZVkgIT09IHlcbiAgICAgICAgKVxuICAgICAgICAgIF9jYW1lcmEuZ29Ubyh7XG4gICAgICAgICAgICB4OiBfY2FtZXJhLngsXG4gICAgICAgICAgICB5OiBfY2FtZXJhLnlcbiAgICAgICAgICB9KTtcblxuICAgICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdtb3VzZXVwJyxcbiAgICAgICAgICBzaWdtYS51dGlscy5tb3VzZUNvb3JkcyhlKSk7XG5cbiAgICAgICAgLy8gVXBkYXRlIF9pc01vdmluZyBmbGFnOlxuICAgICAgICBfaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlICdkb3duJyBtb3VzZSBldmVudC4gSXQgd2lsbCBzdGFydCBvYnNlcnZpbmdcbiAgICAgKiB0aGUgbW91c2UgcG9zaXRpb24gZm9yIGRyYWdnaW5nIHRoZSBncmFwaC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSBtb3VzZSBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfZG93bkhhbmRsZXIoZSkge1xuICAgICAgaWYgKF9zZXR0aW5ncygnbW91c2VFbmFibGVkJykpIHtcbiAgICAgICAgX3N0YXJ0Q2FtZXJhWCA9IF9jYW1lcmEueDtcbiAgICAgICAgX3N0YXJ0Q2FtZXJhWSA9IF9jYW1lcmEueTtcblxuICAgICAgICBfbGFzdENhbWVyYVggPSBfY2FtZXJhLng7XG4gICAgICAgIF9sYXN0Q2FtZXJhWSA9IF9jYW1lcmEueTtcblxuICAgICAgICBfc3RhcnRNb3VzZVggPSBzaWdtYS51dGlscy5nZXRYKGUpO1xuICAgICAgICBfc3RhcnRNb3VzZVkgPSBzaWdtYS51dGlscy5nZXRZKGUpO1xuXG4gICAgICAgIF9oYXNEcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgIF9kb3duU3RhcnRUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuICAgICAgICBzd2l0Y2ggKGUud2hpY2gpIHtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAvLyBNaWRkbGUgbW91c2UgYnV0dG9uIHByZXNzZWRcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAvLyBSaWdodCBtb3VzZSBidXR0b24gcHJlc3NlZFxuICAgICAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgncmlnaHRjbGljaycsXG4gICAgICAgICAgICAgIHNpZ21hLnV0aWxzLm1vdXNlQ29vcmRzKGUsIF9zdGFydE1vdXNlWCwgX3N0YXJ0TW91c2VZKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvLyBjYXNlIDE6XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIExlZnQgbW91c2UgYnV0dG9uIHByZXNzZWRcbiAgICAgICAgICAgIF9pc01vdXNlRG93biA9IHRydWU7XG5cbiAgICAgICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ21vdXNlZG93bicsXG4gICAgICAgICAgICAgIHNpZ21hLnV0aWxzLm1vdXNlQ29vcmRzKGUsIF9zdGFydE1vdXNlWCwgX3N0YXJ0TW91c2VZKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlICdvdXQnIG1vdXNlIGV2ZW50LiBJdCB3aWxsIGp1c3QgcmVkaXNwYXRjaFxuICAgICAqIHRoZSBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSBtb3VzZSBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfb3V0SGFuZGxlcihlKSB7XG4gICAgICBpZiAoX3NldHRpbmdzKCdtb3VzZUVuYWJsZWQnKSlcbiAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnbW91c2VvdXQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlICdjbGljaycgbW91c2UgZXZlbnQuIEl0IHdpbGwgcmVkaXNwYXRjaCB0aGVcbiAgICAgKiBjbGljayBldmVudCwgYnV0IHdpdGggbm9ybWFsaXplZCBYIGFuZCBZIGNvb3JkaW5hdGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtldmVudH0gZSBBIG1vdXNlIGV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9jbGlja0hhbmRsZXIoZSkge1xuICAgICAgaWYgKF9zZXR0aW5ncygnbW91c2VFbmFibGVkJykpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gc2lnbWEudXRpbHMubW91c2VDb29yZHMoZSk7XG4gICAgICAgIGV2ZW50LmlzRHJhZ2dpbmcgPVxuICAgICAgICAgICgoKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIF9kb3duU3RhcnRUaW1lKSA+IDEwMCkgJiYgX2hhc0RyYWdnZWQ7XG4gICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ2NsaWNrJywgZXZlbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdClcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZWxzZVxuICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG5cbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGhhbmRsZXIgbGlzdGVuaW5nIHRvIHRoZSBkb3VibGUgY2xpY2sgY3VzdG9tIGV2ZW50LiBJdCB3aWxsXG4gICAgICogYmFzaWNhbGx5IHpvb20gaW50byB0aGUgZ3JhcGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlIEEgbW91c2UgZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2RvdWJsZUNsaWNrSGFuZGxlcihlKSB7XG4gICAgICB2YXIgcG9zLFxuICAgICAgICAgIHJhdGlvLFxuICAgICAgICAgIGFuaW1hdGlvbjtcblxuICAgICAgaWYgKF9zZXR0aW5ncygnbW91c2VFbmFibGVkJykpIHtcbiAgICAgICAgcmF0aW8gPSAxIC8gX3NldHRpbmdzKCdkb3VibGVDbGlja1pvb21pbmdSYXRpbycpO1xuXG4gICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ2RvdWJsZWNsaWNrJyxcbiAgICAgICAgICAgIHNpZ21hLnV0aWxzLm1vdXNlQ29vcmRzKGUsIF9zdGFydE1vdXNlWCwgX3N0YXJ0TW91c2VZKSk7XG5cbiAgICAgICAgaWYgKF9zZXR0aW5ncygnZG91YmxlQ2xpY2tFbmFibGVkJykpIHtcbiAgICAgICAgICBwb3MgPSBfY2FtZXJhLmNhbWVyYVBvc2l0aW9uKFxuICAgICAgICAgICAgc2lnbWEudXRpbHMuZ2V0WChlKSAtIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS54LFxuICAgICAgICAgICAgc2lnbWEudXRpbHMuZ2V0WShlKSAtIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS55LFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBhbmltYXRpb24gPSB7XG4gICAgICAgICAgICBkdXJhdGlvbjogX3NldHRpbmdzKCdkb3VibGVDbGlja1pvb21EdXJhdGlvbicpXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHNpZ21hLnV0aWxzLnpvb21UbyhfY2FtZXJhLCBwb3MueCwgcG9zLnksIHJhdGlvLCBhbmltYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlICd3aGVlbCcgbW91c2UgZXZlbnQuIEl0IHdpbGwgYmFzaWNhbGx5IHpvb21cbiAgICAgKiBpbiBvciBub3QgaW50byB0aGUgZ3JhcGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlIEEgbW91c2UgZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gX3doZWVsSGFuZGxlcihlKSB7XG4gICAgICB2YXIgcG9zLFxuICAgICAgICAgIHJhdGlvLFxuICAgICAgICAgIGFuaW1hdGlvbixcbiAgICAgICAgICB3aGVlbERlbHRhID0gc2lnbWEudXRpbHMuZ2V0RGVsdGEoZSk7XG5cbiAgICAgIGlmIChfc2V0dGluZ3MoJ21vdXNlRW5hYmxlZCcpICYmIF9zZXR0aW5ncygnbW91c2VXaGVlbEVuYWJsZWQnKSAmJiB3aGVlbERlbHRhICE9PSAwKSB7XG4gICAgICAgIHJhdGlvID0gd2hlZWxEZWx0YSA+IDAgP1xuICAgICAgICAgIDEgLyBfc2V0dGluZ3MoJ3pvb21pbmdSYXRpbycpIDpcbiAgICAgICAgICBfc2V0dGluZ3MoJ3pvb21pbmdSYXRpbycpO1xuXG4gICAgICAgIHBvcyA9IF9jYW1lcmEuY2FtZXJhUG9zaXRpb24oXG4gICAgICAgICAgc2lnbWEudXRpbHMuZ2V0WChlKSAtIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS54LFxuICAgICAgICAgIHNpZ21hLnV0aWxzLmdldFkoZSkgLSBzaWdtYS51dGlscy5nZXRDZW50ZXIoZSkueSxcbiAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG5cbiAgICAgICAgYW5pbWF0aW9uID0ge1xuICAgICAgICAgIGR1cmF0aW9uOiBfc2V0dGluZ3MoJ21vdXNlWm9vbUR1cmF0aW9uJylcbiAgICAgICAgfTtcblxuICAgICAgICBzaWdtYS51dGlscy56b29tVG8oX2NhbWVyYSwgcG9zLngsIHBvcy55LCByYXRpbywgYW5pbWF0aW9uKTtcblxuICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdClcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG5cbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhcHRvcnMnKTtcblxuICAvKipcbiAgICogVGhlIHVzZXIgaW5wdXRzIGRlZmF1bHQgY2FwdG9yLiBJdCBkZWFscyB3aXRoIG1vdXNlIGV2ZW50cywga2V5Ym9hcmRzXG4gICAqIGV2ZW50cyBhbmQgdG91Y2ggZXZlbnRzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSAgIHRhcmdldCAgIFRoZSBET00gZWxlbWVudCB3aGVyZSB0aGUgbGlzdGVuZXJzIHdpbGwgYmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZC5cbiAgICogQHBhcmFtICB7Y2FtZXJhfSAgICAgICBjYW1lcmEgICBUaGUgY2FtZXJhIHJlbGF0ZWQgdG8gdGhlIHRhcmdldC5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSBzZXR0aW5ncyBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge3NpZ21hLmNhcHRvcn0gICAgICAgICAgVGhlIGZyZXNoIG5ldyBjYXB0b3IgaW5zdGFuY2UuXG4gICAqL1xuICBzaWdtYS5jYXB0b3JzLnRvdWNoID0gZnVuY3Rpb24odGFyZ2V0LCBjYW1lcmEsIHNldHRpbmdzKSB7XG4gICAgdmFyIF9zZWxmID0gdGhpcyxcbiAgICAgICAgX3RhcmdldCA9IHRhcmdldCxcbiAgICAgICAgX2NhbWVyYSA9IGNhbWVyYSxcbiAgICAgICAgX3NldHRpbmdzID0gc2V0dGluZ3MsXG5cbiAgICAgICAgLy8gQ0FNRVJBIE1BTkFHRU1FTlQ6XG4gICAgICAgIC8vICoqKioqKioqKioqKioqKioqKlxuICAgICAgICAvLyBUaGUgY2FtZXJhIHBvc2l0aW9uIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nOlxuICAgICAgICBfc3RhcnRDYW1lcmFYLFxuICAgICAgICBfc3RhcnRDYW1lcmFZLFxuICAgICAgICBfc3RhcnRDYW1lcmFBbmdsZSxcbiAgICAgICAgX3N0YXJ0Q2FtZXJhUmF0aW8sXG5cbiAgICAgICAgLy8gVGhlIGxhdGVzdCBzdGFnZSBwb3NpdGlvbjpcbiAgICAgICAgX2xhc3RDYW1lcmFYLFxuICAgICAgICBfbGFzdENhbWVyYVksXG4gICAgICAgIF9sYXN0Q2FtZXJhQW5nbGUsXG4gICAgICAgIF9sYXN0Q2FtZXJhUmF0aW8sXG5cbiAgICAgICAgLy8gVE9VQ0ggTUFOQUdFTUVOVDpcbiAgICAgICAgLy8gKioqKioqKioqKioqKioqKipcbiAgICAgICAgLy8gVG91Y2hlcyB0aGF0IGFyZSBkb3duOlxuICAgICAgICBfZG93blRvdWNoZXMgPSBbXSxcblxuICAgICAgICBfc3RhcnRUb3VjaFgwLFxuICAgICAgICBfc3RhcnRUb3VjaFkwLFxuICAgICAgICBfc3RhcnRUb3VjaFgxLFxuICAgICAgICBfc3RhcnRUb3VjaFkxLFxuICAgICAgICBfc3RhcnRUb3VjaEFuZ2xlLFxuICAgICAgICBfc3RhcnRUb3VjaERpc3RhbmNlLFxuXG4gICAgICAgIF90b3VjaE1vZGUsXG5cbiAgICAgICAgX2lzTW92aW5nLFxuICAgICAgICBfZG91YmxlVGFwLFxuICAgICAgICBfbW92aW5nVGltZW91dElkO1xuXG4gICAgc2lnbWEuY2xhc3Nlcy5kaXNwYXRjaGVyLmV4dGVuZCh0aGlzKTtcblxuICAgIHNpZ21hLnV0aWxzLmRvdWJsZUNsaWNrKF90YXJnZXQsICd0b3VjaHN0YXJ0JywgX2RvdWJsZVRhcEhhbmRsZXIpO1xuICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIF9oYW5kbGVTdGFydCwgZmFsc2UpO1xuICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBfaGFuZGxlTGVhdmUsIGZhbHNlKTtcbiAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgX2hhbmRsZUxlYXZlLCBmYWxzZSk7XG4gICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGxlYXZlJywgX2hhbmRsZUxlYXZlLCBmYWxzZSk7XG4gICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBfaGFuZGxlTW92ZSwgZmFsc2UpO1xuXG4gICAgZnVuY3Rpb24gcG9zaXRpb24oZSkge1xuICAgICAgdmFyIG9mZnNldCA9IHNpZ21hLnV0aWxzLmdldE9mZnNldChfdGFyZ2V0KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogZS5wYWdlWCAtIG9mZnNldC5sZWZ0LFxuICAgICAgICB5OiBlLnBhZ2VZIC0gb2Zmc2V0LnRvcFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCB1bmJpbmRzIGV2ZXJ5IGhhbmRsZXJzIHRoYXQgbWFrZXMgdGhlIGNhcHRvciB3b3JrLlxuICAgICAqL1xuICAgIHRoaXMua2lsbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgc2lnbWEudXRpbHMudW5iaW5kRG91YmxlQ2xpY2soX3RhcmdldCwgJ3RvdWNoc3RhcnQnKTtcbiAgICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIF9oYW5kbGVTdGFydCk7XG4gICAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgX2hhbmRsZUxlYXZlKTtcbiAgICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCBfaGFuZGxlTGVhdmUpO1xuICAgICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGxlYXZlJywgX2hhbmRsZUxlYXZlKTtcbiAgICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgX2hhbmRsZU1vdmUpO1xuICAgIH07XG5cbiAgICAvLyBUT1VDSCBFVkVOVFM6XG4gICAgLy8gKioqKioqKioqKioqKlxuICAgIC8qKlxuICAgICAqIFRoZSBoYW5kbGVyIGxpc3RlbmluZyB0byB0aGUgJ3RvdWNoc3RhcnQnIGV2ZW50LiBJdCB3aWxsIHNldCB0aGUgdG91Y2hcbiAgICAgKiBtb2RlIChcIl90b3VjaE1vZGVcIikgYW5kIHN0YXJ0IG9ic2VydmluZyB0aGUgdXNlciB0b3VjaCBtb3Zlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSB0b3VjaCBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfaGFuZGxlU3RhcnQoZSkge1xuICAgICAgaWYgKF9zZXR0aW5ncygndG91Y2hFbmFibGVkJykpIHtcbiAgICAgICAgdmFyIHgwLFxuICAgICAgICAgICAgeDEsXG4gICAgICAgICAgICB5MCxcbiAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgcG9zMCxcbiAgICAgICAgICAgIHBvczE7XG5cbiAgICAgICAgX2Rvd25Ub3VjaGVzID0gZS50b3VjaGVzO1xuXG4gICAgICAgIHN3aXRjaCAoX2Rvd25Ub3VjaGVzLmxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIF9jYW1lcmEuaXNNb3ZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgX3RvdWNoTW9kZSA9IDE7XG5cbiAgICAgICAgICAgIF9zdGFydENhbWVyYVggPSBfY2FtZXJhLng7XG4gICAgICAgICAgICBfc3RhcnRDYW1lcmFZID0gX2NhbWVyYS55O1xuXG4gICAgICAgICAgICBfbGFzdENhbWVyYVggPSBfY2FtZXJhLng7XG4gICAgICAgICAgICBfbGFzdENhbWVyYVkgPSBfY2FtZXJhLnk7XG5cbiAgICAgICAgICAgIHBvczAgPSBwb3NpdGlvbihfZG93blRvdWNoZXNbMF0pO1xuICAgICAgICAgICAgX3N0YXJ0VG91Y2hYMCA9IHBvczAueDtcbiAgICAgICAgICAgIF9zdGFydFRvdWNoWTAgPSBwb3MwLnk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIF9jYW1lcmEuaXNNb3ZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgX3RvdWNoTW9kZSA9IDI7XG5cbiAgICAgICAgICAgIHBvczAgPSBwb3NpdGlvbihfZG93blRvdWNoZXNbMF0pO1xuICAgICAgICAgICAgcG9zMSA9IHBvc2l0aW9uKF9kb3duVG91Y2hlc1sxXSk7XG4gICAgICAgICAgICB4MCA9IHBvczAueDtcbiAgICAgICAgICAgIHkwID0gcG9zMC55O1xuICAgICAgICAgICAgeDEgPSBwb3MxLng7XG4gICAgICAgICAgICB5MSA9IHBvczEueTtcblxuICAgICAgICAgICAgX2xhc3RDYW1lcmFYID0gX2NhbWVyYS54O1xuICAgICAgICAgICAgX2xhc3RDYW1lcmFZID0gX2NhbWVyYS55O1xuXG4gICAgICAgICAgICBfc3RhcnRDYW1lcmFBbmdsZSA9IF9jYW1lcmEuYW5nbGU7XG4gICAgICAgICAgICBfc3RhcnRDYW1lcmFSYXRpbyA9IF9jYW1lcmEucmF0aW87XG5cbiAgICAgICAgICAgIF9zdGFydENhbWVyYVggPSBfY2FtZXJhLng7XG4gICAgICAgICAgICBfc3RhcnRDYW1lcmFZID0gX2NhbWVyYS55O1xuXG4gICAgICAgICAgICBfc3RhcnRUb3VjaFgwID0geDA7XG4gICAgICAgICAgICBfc3RhcnRUb3VjaFkwID0geTA7XG4gICAgICAgICAgICBfc3RhcnRUb3VjaFgxID0geDE7XG4gICAgICAgICAgICBfc3RhcnRUb3VjaFkxID0geTE7XG5cbiAgICAgICAgICAgIF9zdGFydFRvdWNoQW5nbGUgPSBNYXRoLmF0YW4yKFxuICAgICAgICAgICAgICBfc3RhcnRUb3VjaFkxIC0gX3N0YXJ0VG91Y2hZMCxcbiAgICAgICAgICAgICAgX3N0YXJ0VG91Y2hYMSAtIF9zdGFydFRvdWNoWDBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBfc3RhcnRUb3VjaERpc3RhbmNlID0gTWF0aC5zcXJ0KFxuICAgICAgICAgICAgICAoX3N0YXJ0VG91Y2hZMSAtIF9zdGFydFRvdWNoWTApICpcbiAgICAgICAgICAgICAgICAoX3N0YXJ0VG91Y2hZMSAtIF9zdGFydFRvdWNoWTApICtcbiAgICAgICAgICAgICAgKF9zdGFydFRvdWNoWDEgLSBfc3RhcnRUb3VjaFgwKSAqXG4gICAgICAgICAgICAgICAgKF9zdGFydFRvdWNoWDEgLSBfc3RhcnRUb3VjaFgwKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGhhbmRsZXIgbGlzdGVuaW5nIHRvIHRoZSAndG91Y2hlbmQnLCAndG91Y2hjYW5jZWwnIGFuZCAndG91Y2hsZWF2ZSdcbiAgICAgKiBldmVudC4gSXQgd2lsbCB1cGRhdGUgdGhlIHRvdWNoIG1vZGUgaWYgdGhlcmUgYXJlIHN0aWxsIGF0IGxlYXN0IG9uZVxuICAgICAqIGZpbmdlciwgYW5kIHN0b3AgZHJhZ2dpbmcgZWxzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSB0b3VjaCBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfaGFuZGxlTGVhdmUoZSkge1xuICAgICAgaWYgKF9zZXR0aW5ncygndG91Y2hFbmFibGVkJykpIHtcbiAgICAgICAgX2Rvd25Ub3VjaGVzID0gZS50b3VjaGVzO1xuICAgICAgICB2YXIgaW5lcnRpYVJhdGlvID0gX3NldHRpbmdzKCd0b3VjaEluZXJ0aWFSYXRpbycpO1xuXG4gICAgICAgIGlmIChfbW92aW5nVGltZW91dElkKSB7XG4gICAgICAgICAgX2lzTW92aW5nID0gZmFsc2U7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KF9tb3ZpbmdUaW1lb3V0SWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChfdG91Y2hNb2RlKSB7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgX2hhbmRsZVN0YXJ0KGUpO1xuXG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgX2NhbWVyYS5pc01vdmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnc3RvcERyYWcnKTtcblxuICAgICAgICAgICAgaWYgKF9pc01vdmluZykge1xuICAgICAgICAgICAgICBfZG91YmxlVGFwID0gZmFsc2U7XG4gICAgICAgICAgICAgIHNpZ21hLm1pc2MuYW5pbWF0aW9uLmNhbWVyYShcbiAgICAgICAgICAgICAgICBfY2FtZXJhLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHg6IF9jYW1lcmEueCArXG4gICAgICAgICAgICAgICAgICAgIGluZXJ0aWFSYXRpbyAqIChfY2FtZXJhLnggLSBfbGFzdENhbWVyYVgpLFxuICAgICAgICAgICAgICAgICAgeTogX2NhbWVyYS55ICtcbiAgICAgICAgICAgICAgICAgICAgaW5lcnRpYVJhdGlvICogKF9jYW1lcmEueSAtIF9sYXN0Q2FtZXJhWSlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGVhc2luZzogJ3F1YWRyYXRpY091dCcsXG4gICAgICAgICAgICAgICAgICBkdXJhdGlvbjogX3NldHRpbmdzKCd0b3VjaEluZXJ0aWFEdXJhdGlvbicpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIF90b3VjaE1vZGUgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlICd0b3VjaG1vdmUnIGV2ZW50LiBJdCB3aWxsIGVmZmVjdGl2ZWx5IGRyYWdcbiAgICAgKiB0aGUgZ3JhcGgsIGFuZCBldmVudHVhbGx5IHpvb21zIGFuZCB0dXJuIGl0IGlmIHRoZSB1c2VyIGlzIHVzaW5nIHR3b1xuICAgICAqIGZpbmdlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlIEEgdG91Y2ggZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2hhbmRsZU1vdmUoZSkge1xuICAgICAgaWYgKCFfZG91YmxlVGFwICYmIF9zZXR0aW5ncygndG91Y2hFbmFibGVkJykpIHtcbiAgICAgICAgdmFyIHgwLFxuICAgICAgICAgICAgeDEsXG4gICAgICAgICAgICB5MCxcbiAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgY29zLFxuICAgICAgICAgICAgc2luLFxuICAgICAgICAgICAgZW5kLFxuICAgICAgICAgICAgcG9zMCxcbiAgICAgICAgICAgIHBvczEsXG4gICAgICAgICAgICBkaWZmLFxuICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICBkQW5nbGUsXG4gICAgICAgICAgICBkUmF0aW8sXG4gICAgICAgICAgICBuZXdTdGFnZVgsXG4gICAgICAgICAgICBuZXdTdGFnZVksXG4gICAgICAgICAgICBuZXdTdGFnZVJhdGlvLFxuICAgICAgICAgICAgbmV3U3RhZ2VBbmdsZTtcblxuICAgICAgICBfZG93blRvdWNoZXMgPSBlLnRvdWNoZXM7XG4gICAgICAgIF9pc01vdmluZyA9IHRydWU7XG5cbiAgICAgICAgaWYgKF9tb3ZpbmdUaW1lb3V0SWQpXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KF9tb3ZpbmdUaW1lb3V0SWQpO1xuXG4gICAgICAgIF9tb3ZpbmdUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIF9pc01vdmluZyA9IGZhbHNlO1xuICAgICAgICB9LCBfc2V0dGluZ3MoJ2RyYWdUaW1lb3V0JykpO1xuXG4gICAgICAgIHN3aXRjaCAoX3RvdWNoTW9kZSkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHBvczAgPSBwb3NpdGlvbihfZG93blRvdWNoZXNbMF0pO1xuICAgICAgICAgICAgeDAgPSBwb3MwLng7XG4gICAgICAgICAgICB5MCA9IHBvczAueTtcblxuICAgICAgICAgICAgZGlmZiA9IF9jYW1lcmEuY2FtZXJhUG9zaXRpb24oXG4gICAgICAgICAgICAgIHgwIC0gX3N0YXJ0VG91Y2hYMCxcbiAgICAgICAgICAgICAgeTAgLSBfc3RhcnRUb3VjaFkwLFxuICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBuZXdTdGFnZVggPSBfc3RhcnRDYW1lcmFYIC0gZGlmZi54O1xuICAgICAgICAgICAgbmV3U3RhZ2VZID0gX3N0YXJ0Q2FtZXJhWSAtIGRpZmYueTtcblxuICAgICAgICAgICAgaWYgKG5ld1N0YWdlWCAhPT0gX2NhbWVyYS54IHx8IG5ld1N0YWdlWSAhPT0gX2NhbWVyYS55KSB7XG4gICAgICAgICAgICAgIF9sYXN0Q2FtZXJhWCA9IF9jYW1lcmEueDtcbiAgICAgICAgICAgICAgX2xhc3RDYW1lcmFZID0gX2NhbWVyYS55O1xuXG4gICAgICAgICAgICAgIF9jYW1lcmEuZ29Ubyh7XG4gICAgICAgICAgICAgICAgeDogbmV3U3RhZ2VYLFxuICAgICAgICAgICAgICAgIHk6IG5ld1N0YWdlWVxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdtb3VzZW1vdmUnLFxuICAgICAgICAgICAgICAgIHNpZ21hLnV0aWxzLm1vdXNlQ29vcmRzKGUsIHBvczAueCwgcG9zMC55KSk7XG5cbiAgICAgICAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnZHJhZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcG9zMCA9IHBvc2l0aW9uKF9kb3duVG91Y2hlc1swXSk7XG4gICAgICAgICAgICBwb3MxID0gcG9zaXRpb24oX2Rvd25Ub3VjaGVzWzFdKTtcbiAgICAgICAgICAgIHgwID0gcG9zMC54O1xuICAgICAgICAgICAgeTAgPSBwb3MwLnk7XG4gICAgICAgICAgICB4MSA9IHBvczEueDtcbiAgICAgICAgICAgIHkxID0gcG9zMS55O1xuXG4gICAgICAgICAgICBzdGFydCA9IF9jYW1lcmEuY2FtZXJhUG9zaXRpb24oXG4gICAgICAgICAgICAgIChfc3RhcnRUb3VjaFgwICsgX3N0YXJ0VG91Y2hYMSkgLyAyIC1cbiAgICAgICAgICAgICAgICBzaWdtYS51dGlscy5nZXRDZW50ZXIoZSkueCxcbiAgICAgICAgICAgICAgKF9zdGFydFRvdWNoWTAgKyBfc3RhcnRUb3VjaFkxKSAvIDIgLVxuICAgICAgICAgICAgICAgIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS55LFxuICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZW5kID0gX2NhbWVyYS5jYW1lcmFQb3NpdGlvbihcbiAgICAgICAgICAgICAgKHgwICsgeDEpIC8gMiAtIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS54LFxuICAgICAgICAgICAgICAoeTAgKyB5MSkgLyAyIC0gc2lnbWEudXRpbHMuZ2V0Q2VudGVyKGUpLnksXG4gICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGRBbmdsZSA9IE1hdGguYXRhbjIoeTEgLSB5MCwgeDEgLSB4MCkgLSBfc3RhcnRUb3VjaEFuZ2xlO1xuICAgICAgICAgICAgZFJhdGlvID0gTWF0aC5zcXJ0KFxuICAgICAgICAgICAgICAoeTEgLSB5MCkgKiAoeTEgLSB5MCkgKyAoeDEgLSB4MCkgKiAoeDEgLSB4MClcbiAgICAgICAgICAgICkgLyBfc3RhcnRUb3VjaERpc3RhbmNlO1xuXG4gICAgICAgICAgICAvLyBUcmFuc2xhdGlvbjpcbiAgICAgICAgICAgIHgwID0gc3RhcnQueDtcbiAgICAgICAgICAgIHkwID0gc3RhcnQueTtcblxuICAgICAgICAgICAgLy8gSG9tb3RoZXRpYyB0cmFuc2Zvcm1hdGlvbjpcbiAgICAgICAgICAgIG5ld1N0YWdlUmF0aW8gPSBfc3RhcnRDYW1lcmFSYXRpbyAvIGRSYXRpbztcbiAgICAgICAgICAgIHgwID0geDAgKiBkUmF0aW87XG4gICAgICAgICAgICB5MCA9IHkwICogZFJhdGlvO1xuXG4gICAgICAgICAgICAvLyBSb3RhdGlvbjpcbiAgICAgICAgICAgIG5ld1N0YWdlQW5nbGUgPSBfc3RhcnRDYW1lcmFBbmdsZSAtIGRBbmdsZTtcbiAgICAgICAgICAgIGNvcyA9IE1hdGguY29zKC1kQW5nbGUpO1xuICAgICAgICAgICAgc2luID0gTWF0aC5zaW4oLWRBbmdsZSk7XG4gICAgICAgICAgICB4MSA9IHgwICogY29zICsgeTAgKiBzaW47XG4gICAgICAgICAgICB5MSA9IHkwICogY29zIC0geDAgKiBzaW47XG4gICAgICAgICAgICB4MCA9IHgxO1xuICAgICAgICAgICAgeTAgPSB5MTtcblxuICAgICAgICAgICAgLy8gRmluYWxpemU6XG4gICAgICAgICAgICBuZXdTdGFnZVggPSB4MCAtIGVuZC54ICsgX3N0YXJ0Q2FtZXJhWDtcbiAgICAgICAgICAgIG5ld1N0YWdlWSA9IHkwIC0gZW5kLnkgKyBfc3RhcnRDYW1lcmFZO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIG5ld1N0YWdlUmF0aW8gIT09IF9jYW1lcmEucmF0aW8gfHxcbiAgICAgICAgICAgICAgbmV3U3RhZ2VBbmdsZSAhPT0gX2NhbWVyYS5hbmdsZSB8fFxuICAgICAgICAgICAgICBuZXdTdGFnZVggIT09IF9jYW1lcmEueCB8fFxuICAgICAgICAgICAgICBuZXdTdGFnZVkgIT09IF9jYW1lcmEueVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIF9sYXN0Q2FtZXJhWCA9IF9jYW1lcmEueDtcbiAgICAgICAgICAgICAgX2xhc3RDYW1lcmFZID0gX2NhbWVyYS55O1xuICAgICAgICAgICAgICBfbGFzdENhbWVyYUFuZ2xlID0gX2NhbWVyYS5hbmdsZTtcbiAgICAgICAgICAgICAgX2xhc3RDYW1lcmFSYXRpbyA9IF9jYW1lcmEucmF0aW87XG5cbiAgICAgICAgICAgICAgX2NhbWVyYS5nb1RvKHtcbiAgICAgICAgICAgICAgICB4OiBuZXdTdGFnZVgsXG4gICAgICAgICAgICAgICAgeTogbmV3U3RhZ2VZLFxuICAgICAgICAgICAgICAgIGFuZ2xlOiBuZXdTdGFnZUFuZ2xlLFxuICAgICAgICAgICAgICAgIHJhdGlvOiBuZXdTdGFnZVJhdGlvXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ2RyYWcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlIGRvdWJsZSB0YXAgY3VzdG9tIGV2ZW50LiBJdCB3aWxsXG4gICAgICogYmFzaWNhbGx5IHpvb20gaW50byB0aGUgZ3JhcGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlIEEgdG91Y2ggZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2RvdWJsZVRhcEhhbmRsZXIoZSkge1xuICAgICAgdmFyIHBvcyxcbiAgICAgICAgICByYXRpbyxcbiAgICAgICAgICBhbmltYXRpb247XG5cbiAgICAgIGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA9PT0gMSAmJiBfc2V0dGluZ3MoJ3RvdWNoRW5hYmxlZCcpKSB7XG4gICAgICAgIF9kb3VibGVUYXAgPSB0cnVlO1xuXG4gICAgICAgIHJhdGlvID0gMSAvIF9zZXR0aW5ncygnZG91YmxlQ2xpY2tab29taW5nUmF0aW8nKTtcblxuICAgICAgICBwb3MgPSBwb3NpdGlvbihlLnRvdWNoZXNbMF0pO1xuICAgICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdkb3VibGVjbGljaycsXG4gICAgICAgICAgc2lnbWEudXRpbHMubW91c2VDb29yZHMoZSwgcG9zLngsIHBvcy55KSk7XG5cbiAgICAgICAgaWYgKF9zZXR0aW5ncygnZG91YmxlQ2xpY2tFbmFibGVkJykpIHtcbiAgICAgICAgICBwb3MgPSBfY2FtZXJhLmNhbWVyYVBvc2l0aW9uKFxuICAgICAgICAgICAgcG9zLnggLSBzaWdtYS51dGlscy5nZXRDZW50ZXIoZSkueCxcbiAgICAgICAgICAgIHBvcy55IC0gc2lnbWEudXRpbHMuZ2V0Q2VudGVyKGUpLnksXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGFuaW1hdGlvbiA9IHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiBfc2V0dGluZ3MoJ2RvdWJsZUNsaWNrWm9vbUR1cmF0aW9uJyksXG4gICAgICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgX2RvdWJsZVRhcCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBzaWdtYS51dGlscy56b29tVG8oX2NhbWVyYSwgcG9zLngsIHBvcy55LCByYXRpbywgYW5pbWF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KVxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcblxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIGlmICh0eXBlb2YgY29ucmFkID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnY29ucmFkIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5yZW5kZXJlcnMnKTtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyB0aGUgY29uc3RydWN0b3Igb2YgdGhlIGNhbnZhcyBzaWdtYSdzIHJlbmRlcmVyLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzaWdtYS5jbGFzc2VzLmdyYXBofSAgICAgICAgICAgIGdyYXBoICAgIFRoZSBncmFwaCB0byByZW5kZXIuXG4gICAqIEBwYXJhbSAge3NpZ21hLmNsYXNzZXMuY2FtZXJhfSAgICAgICAgICAgY2FtZXJhICAgVGhlIGNhbWVyYS5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgc2V0dGluZ3MgVGhlIHNpZ21hIGluc3RhbmNlIHNldHRpbmdzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICBvYmplY3QgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEByZXR1cm4ge3NpZ21hLnJlbmRlcmVycy5jYW52YXN9ICAgICAgICAgIFRoZSByZW5kZXJlciBpbnN0YW5jZS5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy5jYW52YXMgPSBmdW5jdGlvbihncmFwaCwgY2FtZXJhLCBzZXR0aW5ncywgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpXG4gICAgICB0aHJvdyAnc2lnbWEucmVuZGVyZXJzLmNhbnZhczogV3JvbmcgYXJndW1lbnRzLic7XG5cbiAgICBpZiAoIShvcHRpb25zLmNvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSlcbiAgICAgIHRocm93ICdDb250YWluZXIgbm90IGZvdW5kLic7XG5cbiAgICB2YXIgayxcbiAgICAgICAgaSxcbiAgICAgICAgbCxcbiAgICAgICAgYSxcbiAgICAgICAgZm4sXG4gICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgc2lnbWEuY2xhc3Nlcy5kaXNwYXRjaGVyLmV4dGVuZCh0aGlzKTtcblxuICAgIC8vIEluaXRpYWxpemUgbWFpbiBhdHRyaWJ1dGVzOlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY29ucmFkSWQnLCB7XG4gICAgICB2YWx1ZTogc2lnbWEudXRpbHMuaWQoKVxuICAgIH0pO1xuICAgIHRoaXMuZ3JhcGggPSBncmFwaDtcbiAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcbiAgICB0aGlzLmNvbnRleHRzID0ge307XG4gICAgdGhpcy5kb21FbGVtZW50cyA9IHt9O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5jb250YWluZXIgPSB0aGlzLm9wdGlvbnMuY29udGFpbmVyO1xuICAgIHRoaXMuc2V0dGluZ3MgPSAoXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLnNldHRpbmdzID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBvcHRpb25zLnNldHRpbmdzXG4gICAgICApID9cbiAgICAgICAgc2V0dGluZ3MuZW1iZWRPYmplY3RzKG9wdGlvbnMuc2V0dGluZ3MpIDpcbiAgICAgICAgc2V0dGluZ3M7XG5cbiAgICAvLyBOb2RlIGluZGV4ZXM6XG4gICAgdGhpcy5ub2Rlc09uU2NyZWVuID0gW107XG4gICAgdGhpcy5lZGdlc09uU2NyZWVuID0gW107XG5cbiAgICAvLyBDb25yYWQgcmVsYXRlZCBhdHRyaWJ1dGVzOlxuICAgIHRoaXMuam9icyA9IHt9O1xuXG4gICAgLy8gRmluZCB0aGUgcHJlZml4OlxuICAgIHRoaXMub3B0aW9ucy5wcmVmaXggPSAncmVuZGVyZXInICsgdGhpcy5jb25yYWRJZCArICc6JztcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIERPTSBlbGVtZW50czpcbiAgICBpZiAoXG4gICAgICAhdGhpcy5zZXR0aW5ncygnYmF0Y2hFZGdlc0RyYXdpbmcnKVxuICAgICkge1xuICAgICAgdGhpcy5pbml0RE9NKCdjYW52YXMnLCAnc2NlbmUnKTtcbiAgICAgIHRoaXMuY29udGV4dHMuZWRnZXMgPSB0aGlzLmNvbnRleHRzLnNjZW5lO1xuICAgICAgdGhpcy5jb250ZXh0cy5ub2RlcyA9IHRoaXMuY29udGV4dHMuc2NlbmU7XG4gICAgICB0aGlzLmNvbnRleHRzLmxhYmVscyA9IHRoaXMuY29udGV4dHMuc2NlbmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaW5pdERPTSgnY2FudmFzJywgJ2VkZ2VzJyk7XG4gICAgICB0aGlzLmluaXRET00oJ2NhbnZhcycsICdzY2VuZScpO1xuICAgICAgdGhpcy5jb250ZXh0cy5ub2RlcyA9IHRoaXMuY29udGV4dHMuc2NlbmU7XG4gICAgICB0aGlzLmNvbnRleHRzLmxhYmVscyA9IHRoaXMuY29udGV4dHMuc2NlbmU7XG4gICAgfVxuXG4gICAgdGhpcy5pbml0RE9NKCdjYW52YXMnLCAnbW91c2UnKTtcbiAgICB0aGlzLmNvbnRleHRzLmhvdmVyID0gdGhpcy5jb250ZXh0cy5tb3VzZTtcblxuICAgIC8vIEluaXRpYWxpemUgY2FwdG9yczpcbiAgICB0aGlzLmNhcHRvcnMgPSBbXTtcbiAgICBhID0gdGhpcy5vcHRpb25zLmNhcHRvcnMgfHwgW3NpZ21hLmNhcHRvcnMubW91c2UsIHNpZ21hLmNhcHRvcnMudG91Y2hdO1xuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZm4gPSB0eXBlb2YgYVtpXSA9PT0gJ2Z1bmN0aW9uJyA/IGFbaV0gOiBzaWdtYS5jYXB0b3JzW2FbaV1dO1xuICAgICAgdGhpcy5jYXB0b3JzLnB1c2goXG4gICAgICAgIG5ldyBmbihcbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLm1vdXNlLFxuICAgICAgICAgIHRoaXMuY2FtZXJhLFxuICAgICAgICAgIHRoaXMuc2V0dGluZ3NcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBEZWFsIHdpdGggc2lnbWEgZXZlbnRzOlxuICAgIHNpZ21hLm1pc2MuYmluZEV2ZW50cy5jYWxsKHRoaXMsIHRoaXMub3B0aW9ucy5wcmVmaXgpO1xuICAgIHNpZ21hLm1pc2MuZHJhd0hvdmVycy5jYWxsKHRoaXMsIHRoaXMub3B0aW9ucy5wcmVmaXgpO1xuXG4gICAgdGhpcy5yZXNpemUoZmFsc2UpO1xuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCByZW5kZXJzIHRoZSBncmFwaCBvbiB0aGUgY2FudmFzZXMuXG4gICAqXG4gICAqIEBwYXJhbSAgez9vYmplY3R9ICAgICAgICAgICAgICAgIG9wdGlvbnMgRXZlbnR1YWxseSBhbiBvYmplY3Qgb2Ygb3B0aW9ucy5cbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLmNhbnZhc30gICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMuY2FudmFzLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgYSxcbiAgICAgICAgaSxcbiAgICAgICAgayxcbiAgICAgICAgbCxcbiAgICAgICAgbyxcbiAgICAgICAgaWQsXG4gICAgICAgIGVuZCxcbiAgICAgICAgam9iLFxuICAgICAgICBzdGFydCxcbiAgICAgICAgZWRnZXMsXG4gICAgICAgIHJlbmRlcmVycyxcbiAgICAgICAgcmVuZGVyZXJUeXBlLFxuICAgICAgICBiYXRjaFNpemUsXG4gICAgICAgIHRlbXBHQ08sXG4gICAgICAgIGluZGV4ID0ge30sXG4gICAgICAgIGdyYXBoID0gdGhpcy5ncmFwaCxcbiAgICAgICAgbm9kZXMgPSB0aGlzLmdyYXBoLm5vZGVzLFxuICAgICAgICBwcmVmaXggPSB0aGlzLm9wdGlvbnMucHJlZml4IHx8ICcnLFxuICAgICAgICBkcmF3RWRnZXMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3RWRnZXMnKSxcbiAgICAgICAgZHJhd05vZGVzID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZHJhd05vZGVzJyksXG4gICAgICAgIGRyYXdMYWJlbHMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3TGFiZWxzJyksXG4gICAgICAgIGRyYXdFZGdlTGFiZWxzID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZHJhd0VkZ2VMYWJlbHMnKSxcbiAgICAgICAgZW1iZWRTZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3MuZW1iZWRPYmplY3RzKG9wdGlvbnMsIHtcbiAgICAgICAgICBwcmVmaXg6IHRoaXMub3B0aW9ucy5wcmVmaXhcbiAgICAgICAgfSk7XG5cbiAgICAvLyBDYWxsIHRoZSByZXNpemUgZnVuY3Rpb246XG4gICAgdGhpcy5yZXNpemUoZmFsc2UpO1xuXG4gICAgLy8gQ2hlY2sgdGhlICdoaWRlRWRnZXNPbk1vdmUnIHNldHRpbmc6XG4gICAgaWYgKHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2hpZGVFZGdlc09uTW92ZScpKVxuICAgICAgaWYgKHRoaXMuY2FtZXJhLmlzQW5pbWF0ZWQgfHwgdGhpcy5jYW1lcmEuaXNNb3ZpbmcpXG4gICAgICAgIGRyYXdFZGdlcyA9IGZhbHNlO1xuXG4gICAgLy8gQXBwbHkgdGhlIGNhbWVyYSdzIHZpZXc6XG4gICAgdGhpcy5jYW1lcmEuYXBwbHlWaWV3KFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgdGhpcy5vcHRpb25zLnByZWZpeCxcbiAgICAgIHtcbiAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gQ2xlYXIgY2FudmFzZXM6XG4gICAgdGhpcy5jbGVhcigpO1xuXG4gICAgLy8gS2lsbCBydW5uaW5nIGpvYnM6XG4gICAgZm9yIChrIGluIHRoaXMuam9icylcbiAgICAgIGlmIChjb25yYWQuaGFzSm9iKGspKVxuICAgICAgICBjb25yYWQua2lsbEpvYihrKTtcblxuICAgIC8vIEZpbmQgd2hpY2ggbm9kZXMgYXJlIG9uIHNjcmVlbjpcbiAgICB0aGlzLmVkZ2VzT25TY3JlZW4gPSBbXTtcbiAgICB0aGlzLm5vZGVzT25TY3JlZW4gPSB0aGlzLmNhbWVyYS5xdWFkdHJlZS5hcmVhKFxuICAgICAgdGhpcy5jYW1lcmEuZ2V0UmVjdGFuZ2xlKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KVxuICAgICk7XG5cbiAgICBmb3IgKGEgPSB0aGlzLm5vZGVzT25TY3JlZW4sIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICBpbmRleFthW2ldLmlkXSA9IGFbaV07XG5cbiAgICAvLyBEcmF3IGVkZ2VzOlxuICAgIC8vIC0gSWYgc2V0dGluZ3MoJ2JhdGNoRWRnZXNEcmF3aW5nJykgaXMgdHJ1ZSwgdGhlIGVkZ2VzIGFyZSBkaXNwbGF5ZWQgcGVyXG4gICAgLy8gICBiYXRjaGVzLiBJZiBub3QsIHRoZXkgYXJlIGRyYXduIGluIG9uZSBmcmFtZS5cbiAgICBpZiAoZHJhd0VkZ2VzKSB7XG4gICAgICAvLyBGaXJzdCwgbGV0J3MgaWRlbnRpZnkgd2hpY2ggZWRnZXMgdG8gZHJhdy4gVG8gZG8gdGhpcywgd2UganVzdCBrZWVwXG4gICAgICAvLyBldmVyeSBlZGdlcyB0aGF0IGhhdmUgYXQgbGVhc3Qgb25lIGV4dHJlbWl0eSBkaXNwbGF5ZWQgYWNjb3JkaW5nIHRvXG4gICAgICAvLyB0aGUgcXVhZHRyZWUgYW5kIHRoZSBcImhpZGRlblwiIGF0dHJpYnV0ZS4gV2UgYWxzbyBkbyBub3Qga2VlcCBoaWRkZW5cbiAgICAgIC8vIGVkZ2VzLlxuICAgICAgZm9yIChhID0gZ3JhcGguZWRnZXMoKSwgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBvID0gYVtpXTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChpbmRleFtvLnNvdXJjZV0gfHwgaW5kZXhbby50YXJnZXRdKSAmJlxuICAgICAgICAgICghby5oaWRkZW4gJiYgIW5vZGVzKG8uc291cmNlKS5oaWRkZW4gJiYgIW5vZGVzKG8udGFyZ2V0KS5oaWRkZW4pXG4gICAgICAgIClcbiAgICAgICAgICB0aGlzLmVkZ2VzT25TY3JlZW4ucHVzaChvKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIFwiYmF0Y2hFZGdlc0RyYXdpbmdcIiBzZXR0aW5ncyBpcyB0cnVlLCBlZGdlcyBhcmUgYmF0Y2hlZDpcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdiYXRjaEVkZ2VzRHJhd2luZycpKSB7XG4gICAgICAgIGlkID0gJ2VkZ2VzXycgKyB0aGlzLmNvbnJhZElkO1xuICAgICAgICBiYXRjaFNpemUgPSBlbWJlZFNldHRpbmdzKCdjYW52YXNFZGdlc0JhdGNoU2l6ZScpO1xuXG4gICAgICAgIGVkZ2VzID0gdGhpcy5lZGdlc09uU2NyZWVuO1xuICAgICAgICBsID0gZWRnZXMubGVuZ3RoO1xuXG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgZW5kID0gTWF0aC5taW4oZWRnZXMubGVuZ3RoLCBzdGFydCArIGJhdGNoU2l6ZSk7XG5cbiAgICAgICAgam9iID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGVtcEdDTyA9IHRoaXMuY29udGV4dHMuZWRnZXMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uO1xuICAgICAgICAgIHRoaXMuY29udGV4dHMuZWRnZXMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW92ZXInO1xuXG4gICAgICAgICAgcmVuZGVyZXJzID0gc2lnbWEuY2FudmFzLmVkZ2VzO1xuICAgICAgICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIG8gPSBlZGdlc1tpXTtcbiAgICAgICAgICAgIChyZW5kZXJlcnNbXG4gICAgICAgICAgICAgIG8udHlwZSB8fCB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkZWZhdWx0RWRnZVR5cGUnKVxuICAgICAgICAgICAgXSB8fCByZW5kZXJlcnMuZGVmKShcbiAgICAgICAgICAgICAgbyxcbiAgICAgICAgICAgICAgZ3JhcGgubm9kZXMoby5zb3VyY2UpLFxuICAgICAgICAgICAgICBncmFwaC5ub2RlcyhvLnRhcmdldCksXG4gICAgICAgICAgICAgIHRoaXMuY29udGV4dHMuZWRnZXMsXG4gICAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRHJhdyBlZGdlIGxhYmVsczpcbiAgICAgICAgICBpZiAoZHJhd0VkZ2VMYWJlbHMpIHtcbiAgICAgICAgICAgIHJlbmRlcmVycyA9IHNpZ21hLmNhbnZhcy5lZGdlcy5sYWJlbHM7XG4gICAgICAgICAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICAgIG8gPSBlZGdlc1tpXTtcbiAgICAgICAgICAgICAgaWYgKCFvLmhpZGRlbilcbiAgICAgICAgICAgICAgICAocmVuZGVyZXJzW1xuICAgICAgICAgICAgICAgICAgby50eXBlIHx8IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RlZmF1bHRFZGdlVHlwZScpXG4gICAgICAgICAgICAgICAgXSB8fCByZW5kZXJlcnMuZGVmKShcbiAgICAgICAgICAgICAgICAgIG8sXG4gICAgICAgICAgICAgICAgICBncmFwaC5ub2RlcyhvLnNvdXJjZSksXG4gICAgICAgICAgICAgICAgICBncmFwaC5ub2RlcyhvLnRhcmdldCksXG4gICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHRzLmxhYmVscyxcbiAgICAgICAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uOlxuICAgICAgICAgIHRoaXMuY29udGV4dHMuZWRnZXMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gdGVtcEdDTztcblxuICAgICAgICAgIC8vIENhdGNoIGpvYidzIGVuZDpcbiAgICAgICAgICBpZiAoZW5kID09PSBlZGdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmpvYnNbaWRdO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0YXJ0ID0gZW5kICsgMTtcbiAgICAgICAgICBlbmQgPSBNYXRoLm1pbihlZGdlcy5sZW5ndGgsIHN0YXJ0ICsgYmF0Y2hTaXplKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmpvYnNbaWRdID0gam9iO1xuICAgICAgICBjb25yYWQuYWRkSm9iKGlkLCBqb2IuYmluZCh0aGlzKSk7XG5cbiAgICAgIC8vIElmIG5vdCwgdGhleSBhcmUgZHJhd24gaW4gb25lIGZyYW1lOlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVuZGVyZXJzID0gc2lnbWEuY2FudmFzLmVkZ2VzO1xuICAgICAgICBmb3IgKGEgPSB0aGlzLmVkZ2VzT25TY3JlZW4sIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBvID0gYVtpXTtcbiAgICAgICAgICAocmVuZGVyZXJzW1xuICAgICAgICAgICAgby50eXBlIHx8IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RlZmF1bHRFZGdlVHlwZScpXG4gICAgICAgICAgXSB8fCByZW5kZXJlcnMuZGVmKShcbiAgICAgICAgICAgIG8sXG4gICAgICAgICAgICBncmFwaC5ub2RlcyhvLnNvdXJjZSksXG4gICAgICAgICAgICBncmFwaC5ub2RlcyhvLnRhcmdldCksXG4gICAgICAgICAgICB0aGlzLmNvbnRleHRzLmVkZ2VzLFxuICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEcmF3IGVkZ2UgbGFiZWxzOlxuICAgICAgICAvLyAtIE5vIGJhdGNoaW5nXG4gICAgICAgIGlmIChkcmF3RWRnZUxhYmVscykge1xuICAgICAgICAgIHJlbmRlcmVycyA9IHNpZ21hLmNhbnZhcy5lZGdlcy5sYWJlbHM7XG4gICAgICAgICAgZm9yIChhID0gdGhpcy5lZGdlc09uU2NyZWVuLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgICAgaWYgKCFhW2ldLmhpZGRlbilcbiAgICAgICAgICAgICAgKHJlbmRlcmVyc1tcbiAgICAgICAgICAgICAgICBhW2ldLnR5cGUgfHwgdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZGVmYXVsdEVkZ2VUeXBlJylcbiAgICAgICAgICAgICAgXSB8fCByZW5kZXJlcnMuZGVmKShcbiAgICAgICAgICAgICAgICBhW2ldLFxuICAgICAgICAgICAgICAgIGdyYXBoLm5vZGVzKGFbaV0uc291cmNlKSxcbiAgICAgICAgICAgICAgICBncmFwaC5ub2RlcyhhW2ldLnRhcmdldCksXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0cy5sYWJlbHMsXG4gICAgICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRHJhdyBub2RlczpcbiAgICAvLyAtIE5vIGJhdGNoaW5nXG4gICAgaWYgKGRyYXdOb2Rlcykge1xuICAgICAgcmVuZGVyZXJzID0gc2lnbWEuY2FudmFzLm5vZGVzO1xuICAgICAgZm9yIChhID0gdGhpcy5ub2Rlc09uU2NyZWVuLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICBpZiAoIWFbaV0uaGlkZGVuKVxuICAgICAgICAgIChyZW5kZXJlcnNbXG4gICAgICAgICAgICBhW2ldLnR5cGUgfHwgdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZGVmYXVsdE5vZGVUeXBlJylcbiAgICAgICAgICBdIHx8IHJlbmRlcmVycy5kZWYpKFxuICAgICAgICAgICAgYVtpXSxcbiAgICAgICAgICAgIHRoaXMuY29udGV4dHMubm9kZXMsXG4gICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBEcmF3IGxhYmVsczpcbiAgICAvLyAtIE5vIGJhdGNoaW5nXG4gICAgaWYgKGRyYXdMYWJlbHMpIHtcbiAgICAgIHJlbmRlcmVycyA9IHNpZ21hLmNhbnZhcy5sYWJlbHM7XG4gICAgICBmb3IgKGEgPSB0aGlzLm5vZGVzT25TY3JlZW4sIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIGlmICghYVtpXS5oaWRkZW4pXG4gICAgICAgICAgKHJlbmRlcmVyc1tcbiAgICAgICAgICAgIGFbaV0udHlwZSB8fCB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkZWZhdWx0Tm9kZVR5cGUnKVxuICAgICAgICAgIF0gfHwgcmVuZGVyZXJzLmRlZikoXG4gICAgICAgICAgICBhW2ldLFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0cy5sYWJlbHMsXG4gICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ3JlbmRlcicpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBET00gZWxlbWVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUsIHN3aXRjaGVzIGl0c1xuICAgKiBwb3NpdGlvbiB0byBcImFic29sdXRlXCIsIHJlZmVyZW5jZXMgaXQgdG8gdGhlIGRvbUVsZW1lbnRzIGF0dHJpYnV0ZSwgYW5kXG4gICAqIGZpbmFsbHkgYXBwZW5kcyBpdCB0byB0aGUgY29udGFpbmVyLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRhZyBUaGUgbGFiZWwgdGFnLlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlkICBUaGUgaWQgb2YgdGhlIGVsZW1lbnQgKHRvIHN0b3JlIGl0IGluIFwiZG9tRWxlbWVudHNcIikuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMuY2FudmFzLnByb3RvdHlwZS5pbml0RE9NID0gZnVuY3Rpb24odGFnLCBpZCkge1xuICAgIHZhciBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG5cbiAgICBkb20uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3NpZ21hLScgKyBpZCk7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnRzW2lkXSA9IGRvbTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChkb20pO1xuXG4gICAgaWYgKHRhZy50b0xvd2VyQ2FzZSgpID09PSAnY2FudmFzJylcbiAgICAgIHRoaXMuY29udGV4dHNbaWRdID0gZG9tLmdldENvbnRleHQoJzJkJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJlc2l6ZXMgZWFjaCBET00gZWxlbWVudHMgaW4gdGhlIGNvbnRhaW5lciBhbmQgc3RvcmVzIHRoZSBuZXdcbiAgICogZGltZW5zaW9ucy4gVGhlbiwgaXQgcmVuZGVycyB0aGUgZ3JhcGguXG4gICAqXG4gICAqIEBwYXJhbSAgez9udW1iZXJ9ICAgICAgICAgICAgICAgIHdpZHRoICBUaGUgbmV3IHdpZHRoIG9mIHRoZSBjb250YWluZXIuXG4gICAqIEBwYXJhbSAgez9udW1iZXJ9ICAgICAgICAgICAgICAgIGhlaWdodCBUaGUgbmV3IGhlaWdodCBvZiB0aGUgY29udGFpbmVyLlxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMuY2FudmFzfSAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLmNhbnZhcy5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24odywgaCkge1xuICAgIHZhciBrLFxuICAgICAgICBvbGRXaWR0aCA9IHRoaXMud2lkdGgsXG4gICAgICAgIG9sZEhlaWdodCA9IHRoaXMuaGVpZ2h0LFxuICAgICAgICBwaXhlbFJhdGlvID0gc2lnbWEudXRpbHMuZ2V0UGl4ZWxSYXRpbygpO1xuXG4gICAgaWYgKHcgIT09IHVuZGVmaW5lZCAmJiBoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMud2lkdGggPSB3O1xuICAgICAgdGhpcy5oZWlnaHQgPSBoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodDtcblxuICAgICAgdyA9IHRoaXMud2lkdGg7XG4gICAgICBoID0gdGhpcy5oZWlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKG9sZFdpZHRoICE9PSB0aGlzLndpZHRoIHx8IG9sZEhlaWdodCAhPT0gdGhpcy5oZWlnaHQpIHtcbiAgICAgIGZvciAoayBpbiB0aGlzLmRvbUVsZW1lbnRzKSB7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudHNba10uc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcbiAgICAgICAgdGhpcy5kb21FbGVtZW50c1trXS5zdHlsZS5oZWlnaHQgPSBoICsgJ3B4JztcblxuICAgICAgICBpZiAodGhpcy5kb21FbGVtZW50c1trXS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdjYW52YXMnKSB7XG4gICAgICAgICAgdGhpcy5kb21FbGVtZW50c1trXS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgKHcgKiBwaXhlbFJhdGlvKSArICdweCcpO1xuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHNba10uc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAoaCAqIHBpeGVsUmF0aW8pICsgJ3B4Jyk7XG5cbiAgICAgICAgICBpZiAocGl4ZWxSYXRpbyAhPT0gMSlcbiAgICAgICAgICAgIHRoaXMuY29udGV4dHNba10uc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY2xlYXJzIGVhY2ggY2FudmFzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMuY2FudmFzfSBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMuY2FudmFzLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGsgaW4gdGhpcy5jb250ZXh0cykge1xuICAgICAgdGhpcy5jb250ZXh0c1trXS5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBraWxscyBjb250ZXh0cyBhbmQgb3RoZXIgYXR0cmlidXRlcy5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy5jYW52YXMucHJvdG90eXBlLmtpbGwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgayxcbiAgICAgICAgY2FwdG9yO1xuXG4gICAgLy8gS2lsbCBjYXB0b3JzOlxuICAgIHdoaWxlICgoY2FwdG9yID0gdGhpcy5jYXB0b3JzLnBvcCgpKSlcbiAgICAgIGNhcHRvci5raWxsKCk7XG4gICAgZGVsZXRlIHRoaXMuY2FwdG9ycztcblxuICAgIC8vIEtpbGwgY29udGV4dHM6XG4gICAgZm9yIChrIGluIHRoaXMuZG9tRWxlbWVudHMpIHtcbiAgICAgIHRoaXMuZG9tRWxlbWVudHNba10ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbUVsZW1lbnRzW2tdKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmRvbUVsZW1lbnRzW2tdO1xuICAgICAgZGVsZXRlIHRoaXMuY29udGV4dHNba107XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLmRvbUVsZW1lbnRzO1xuICAgIGRlbGV0ZSB0aGlzLmNvbnRleHRzO1xuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiBUaGUgbGFiZWxzLCBub2RlcyBhbmQgZWRnZXMgcmVuZGVyZXJzIGFyZSBzdG9yZWQgaW4gdGhlIHRocmVlIGZvbGxvd2luZ1xuICAgKiBvYmplY3RzLiBXaGVuIGFuIGVsZW1lbnQgaXMgZHJhd24sIGl0cyB0eXBlIHdpbGwgYmUgY2hlY2tlZCBhbmQgaWYgYVxuICAgKiByZW5kZXJlciB3aXRoIHRoZSBzYW1lIG5hbWUgZXhpc3RzLCBpdCB3aWxsIGJlIHVzZWQuIElmIG5vdCBmb3VuZCwgdGhlXG4gICAqIGRlZmF1bHQgcmVuZGVyZXIgd2lsbCBiZSB1c2VkIGluc3RlYWQuXG4gICAqXG4gICAqIFRoZXkgYXJlIHN0b3JlZCBpbiBkaWZmZXJlbnQgZmlsZXMsIGluIHRoZSBcIi4vY2FudmFzXCIgZm9sZGVyLlxuICAgKi9cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMubm9kZXMnKTtcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMuZWRnZXMnKTtcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMubGFiZWxzJyk7XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5yZW5kZXJlcnMnKTtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyB0aGUgY29uc3RydWN0b3Igb2YgdGhlIGNhbnZhcyBzaWdtYSdzIHJlbmRlcmVyLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzaWdtYS5jbGFzc2VzLmdyYXBofSAgICAgICAgICAgIGdyYXBoICAgIFRoZSBncmFwaCB0byByZW5kZXIuXG4gICAqIEBwYXJhbSAge3NpZ21hLmNsYXNzZXMuY2FtZXJhfSAgICAgICAgICAgY2FtZXJhICAgVGhlIGNhbWVyYS5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgc2V0dGluZ3MgVGhlIHNpZ21hIGluc3RhbmNlIHNldHRpbmdzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICBvYmplY3QgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEByZXR1cm4ge3NpZ21hLnJlbmRlcmVycy5jYW52YXN9ICAgICAgICAgIFRoZSByZW5kZXJlciBpbnN0YW5jZS5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy53ZWJnbCA9IGZ1bmN0aW9uKGdyYXBoLCBjYW1lcmEsIHNldHRpbmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JylcbiAgICAgIHRocm93ICdzaWdtYS5yZW5kZXJlcnMud2ViZ2w6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgaWYgKCEob3B0aW9ucy5jb250YWluZXIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpXG4gICAgICB0aHJvdyAnQ29udGFpbmVyIG5vdCBmb3VuZC4nO1xuXG4gICAgdmFyIGssXG4gICAgICAgIGksXG4gICAgICAgIGwsXG4gICAgICAgIGEsXG4gICAgICAgIGZuLFxuICAgICAgICBfc2VsZiA9IHRoaXM7XG5cbiAgICBzaWdtYS5jbGFzc2VzLmRpc3BhdGNoZXIuZXh0ZW5kKHRoaXMpO1xuXG4gICAgLy8gQ29ucmFkIHJlbGF0ZWQgYXR0cmlidXRlczpcbiAgICB0aGlzLmpvYnMgPSB7fTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY29ucmFkSWQnLCB7XG4gICAgICB2YWx1ZTogc2lnbWEudXRpbHMuaWQoKVxuICAgIH0pO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBtYWluIGF0dHJpYnV0ZXM6XG4gICAgdGhpcy5ncmFwaCA9IGdyYXBoO1xuICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgIHRoaXMuY29udGV4dHMgPSB7fTtcbiAgICB0aGlzLmRvbUVsZW1lbnRzID0ge307XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMub3B0aW9ucy5jb250YWluZXI7XG4gICAgdGhpcy5zZXR0aW5ncyA9IChcbiAgICAgICAgdHlwZW9mIG9wdGlvbnMuc2V0dGluZ3MgPT09ICdvYmplY3QnICYmXG4gICAgICAgIG9wdGlvbnMuc2V0dGluZ3NcbiAgICAgICkgP1xuICAgICAgICBzZXR0aW5ncy5lbWJlZE9iamVjdHMob3B0aW9ucy5zZXR0aW5ncykgOlxuICAgICAgICBzZXR0aW5ncztcblxuICAgIC8vIEZpbmQgdGhlIHByZWZpeDpcbiAgICB0aGlzLm9wdGlvbnMucHJlZml4ID0gdGhpcy5jYW1lcmEucmVhZFByZWZpeDtcblxuICAgIC8vIEluaXRpYWxpemUgcHJvZ3JhbXMgaGFzaFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbm9kZVByb2dyYW1zJywge1xuICAgICAgdmFsdWU6IHt9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdlZGdlUHJvZ3JhbXMnLCB7XG4gICAgICB2YWx1ZToge31cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ25vZGVGbG9hdEFycmF5cycsIHtcbiAgICAgIHZhbHVlOiB7fVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZWRnZUZsb2F0QXJyYXlzJywge1xuICAgICAgdmFsdWU6IHt9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdlZGdlSW5kaWNlc0FycmF5cycsIHtcbiAgICAgIHZhbHVlOiB7fVxuICAgIH0pO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgRE9NIGVsZW1lbnRzOlxuICAgIGlmICh0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdiYXRjaEVkZ2VzRHJhd2luZycpKSB7XG4gICAgICB0aGlzLmluaXRET00oJ2NhbnZhcycsICdlZGdlcycsIHRydWUpO1xuICAgICAgdGhpcy5pbml0RE9NKCdjYW52YXMnLCAnbm9kZXMnLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbml0RE9NKCdjYW52YXMnLCAnc2NlbmUnLCB0cnVlKTtcbiAgICAgIHRoaXMuY29udGV4dHMubm9kZXMgPSB0aGlzLmNvbnRleHRzLnNjZW5lO1xuICAgICAgdGhpcy5jb250ZXh0cy5lZGdlcyA9IHRoaXMuY29udGV4dHMuc2NlbmU7XG4gICAgfVxuXG4gICAgdGhpcy5pbml0RE9NKCdjYW52YXMnLCAnbGFiZWxzJyk7XG4gICAgdGhpcy5pbml0RE9NKCdjYW52YXMnLCAnbW91c2UnKTtcbiAgICB0aGlzLmNvbnRleHRzLmhvdmVyID0gdGhpcy5jb250ZXh0cy5tb3VzZTtcblxuICAgIC8vIEluaXRpYWxpemUgY2FwdG9yczpcbiAgICB0aGlzLmNhcHRvcnMgPSBbXTtcbiAgICBhID0gdGhpcy5vcHRpb25zLmNhcHRvcnMgfHwgW3NpZ21hLmNhcHRvcnMubW91c2UsIHNpZ21hLmNhcHRvcnMudG91Y2hdO1xuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZm4gPSB0eXBlb2YgYVtpXSA9PT0gJ2Z1bmN0aW9uJyA/IGFbaV0gOiBzaWdtYS5jYXB0b3JzW2FbaV1dO1xuICAgICAgdGhpcy5jYXB0b3JzLnB1c2goXG4gICAgICAgIG5ldyBmbihcbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLm1vdXNlLFxuICAgICAgICAgIHRoaXMuY2FtZXJhLFxuICAgICAgICAgIHRoaXMuc2V0dGluZ3NcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBEZWFsIHdpdGggc2lnbWEgZXZlbnRzOlxuICAgIHNpZ21hLm1pc2MuYmluZEV2ZW50cy5jYWxsKHRoaXMsIHRoaXMuY2FtZXJhLnByZWZpeCk7XG4gICAgc2lnbWEubWlzYy5kcmF3SG92ZXJzLmNhbGwodGhpcywgdGhpcy5jYW1lcmEucHJlZml4KTtcblxuICAgIHRoaXMucmVzaXplKCk7XG4gIH07XG5cblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgZ2VuZXJhdGUgdGhlIG5vZGVzIGFuZCBlZGdlcyBmbG9hdCBhcnJheXMuIFRoaXMgc3RlcCBpc1xuICAgKiBzZXBhcmF0ZWQgZnJvbSB0aGUgXCJyZW5kZXJcIiBtZXRob2QsIGJlY2F1c2UgdG8ga2VlcCBXZWJHTCBlZmZpY2llbnQsIHNpbmNlXG4gICAqIGFsbCB0aGUgY2FtZXJhIGFuZCBtaWRkbGV3YXJlcyBhcmUgbW9kZWxpc2VkIGFzIG1hdHJpY2VzIGFuZCB0aGV5IGRvIG5vdFxuICAgKiByZXF1aXJlIHRoZSBmbG9hdCBhcnJheXMgdG8gYmUgcmVnZW5lcmF0ZWQuXG4gICAqXG4gICAqIEJhc2ljYWxseSwgd2hlbiB0aGUgdXNlciBtb3ZlcyB0aGUgY2FtZXJhIG9yIGFwcGxpZXMgc29tZSBzcGVjaWZpYyBsaW5lYXJcbiAgICogdHJhbnNmb3JtYXRpb25zLCB0aGlzIHByb2Nlc3Mgc3RlcCB3aWxsIGJlIHNraXBwZWQsIGFuZCB0aGUgXCJyZW5kZXJcIlxuICAgKiBtZXRob2Qgd2lsbCBlZmZpY2llbnRseSByZWZyZXNoIHRoZSByZW5kZXJpbmcuXG4gICAqXG4gICAqIEFuZCB3aGVuIHRoZSB1c2VyIG1vZGlmaWVzIHRoZSBncmFwaCBjb2xvcnMgb3IgcG9zaXRpb25zIChhcHBseWluZyBhIG5ld1xuICAgKiBsYXlvdXQgb3IgZmlsdGVyaW5nIHRoZSBjb2xvcnMsIGZvciBpbnN0YW5jZSksIHRoaXMgXCJwcm9jZXNzXCIgc3RlcCB3aWxsIGJlXG4gICAqIHJlcXVpcmVkIHRvIHJlZ2VuZXJhdGUgdGhlIGZsb2F0IGFycmF5cy5cbiAgICpcbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLndlYmdsfSBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMud2ViZ2wucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYSxcbiAgICAgICAgaSxcbiAgICAgICAgbCxcbiAgICAgICAgayxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcmVuZGVyZXIsXG4gICAgICAgIGdyYXBoID0gdGhpcy5ncmFwaCxcbiAgICAgICAgb3B0aW9ucyA9IHNpZ21hLnV0aWxzLmV4dGVuZChvcHRpb25zLCB0aGlzLm9wdGlvbnMpLFxuICAgICAgICBkZWZhdWx0RWRnZVR5cGUgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkZWZhdWx0RWRnZVR5cGUnKSxcbiAgICAgICAgZGVmYXVsdE5vZGVUeXBlID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZGVmYXVsdE5vZGVUeXBlJyk7XG5cbiAgICAvLyBFbXB0eSBmbG9hdCBhcnJheXM6XG4gICAgZm9yIChrIGluIHRoaXMubm9kZUZsb2F0QXJyYXlzKVxuICAgICAgZGVsZXRlIHRoaXMubm9kZUZsb2F0QXJyYXlzW2tdO1xuXG4gICAgZm9yIChrIGluIHRoaXMuZWRnZUZsb2F0QXJyYXlzKVxuICAgICAgZGVsZXRlIHRoaXMuZWRnZUZsb2F0QXJyYXlzW2tdO1xuXG4gICAgZm9yIChrIGluIHRoaXMuZWRnZUluZGljZXNBcnJheXMpXG4gICAgICBkZWxldGUgdGhpcy5lZGdlSW5kaWNlc0FycmF5c1trXTtcblxuICAgIC8vIFNvcnQgZWRnZXMgYW5kIG5vZGVzIHBlciB0eXBlczpcbiAgICBmb3IgKGEgPSBncmFwaC5lZGdlcygpLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0eXBlID0gYVtpXS50eXBlIHx8IGRlZmF1bHRFZGdlVHlwZTtcbiAgICAgIGsgPSAodHlwZSAmJiBzaWdtYS53ZWJnbC5lZGdlc1t0eXBlXSkgPyB0eXBlIDogJ2RlZic7XG5cbiAgICAgIGlmICghdGhpcy5lZGdlRmxvYXRBcnJheXNba10pXG4gICAgICAgIHRoaXMuZWRnZUZsb2F0QXJyYXlzW2tdID0ge1xuICAgICAgICAgIGVkZ2VzOiBbXVxuICAgICAgICB9O1xuXG4gICAgICB0aGlzLmVkZ2VGbG9hdEFycmF5c1trXS5lZGdlcy5wdXNoKGFbaV0pO1xuICAgIH1cblxuICAgIGZvciAoYSA9IGdyYXBoLm5vZGVzKCksIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHR5cGUgPSBhW2ldLnR5cGUgfHwgZGVmYXVsdE5vZGVUeXBlO1xuICAgICAgayA9ICh0eXBlICYmIHNpZ21hLndlYmdsLm5vZGVzW3R5cGVdKSA/IHR5cGUgOiAnZGVmJztcblxuICAgICAgaWYgKCF0aGlzLm5vZGVGbG9hdEFycmF5c1trXSlcbiAgICAgICAgdGhpcy5ub2RlRmxvYXRBcnJheXNba10gPSB7XG4gICAgICAgICAgbm9kZXM6IFtdXG4gICAgICAgIH07XG5cbiAgICAgIHRoaXMubm9kZUZsb2F0QXJyYXlzW2tdLm5vZGVzLnB1c2goYVtpXSk7XG4gICAgfVxuXG4gICAgLy8gUHVzaCBlZGdlczpcbiAgICBmb3IgKGsgaW4gdGhpcy5lZGdlRmxvYXRBcnJheXMpIHtcbiAgICAgIHJlbmRlcmVyID0gc2lnbWEud2ViZ2wuZWRnZXNba107XG4gICAgICBhID0gdGhpcy5lZGdlRmxvYXRBcnJheXNba10uZWRnZXM7XG5cbiAgICAgIC8vIENyZWF0aW5nIHRoZSBuZWNlc3NhcnkgYXJyYXlzXG4gICAgICB0aGlzLmVkZ2VGbG9hdEFycmF5c1trXS5hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoXG4gICAgICAgIGEubGVuZ3RoICogcmVuZGVyZXIuUE9JTlRTICogcmVuZGVyZXIuQVRUUklCVVRFU1xuICAgICAgKTtcblxuICAgICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cbiAgICAgICAgLy8gSnVzdCBjaGVjayB0aGF0IHRoZSBlZGdlIGFuZCBib3RoIGl0cyBleHRyZW1pdGllcyBhcmUgdmlzaWJsZTpcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFhW2ldLmhpZGRlbiAmJlxuICAgICAgICAgICFncmFwaC5ub2RlcyhhW2ldLnNvdXJjZSkuaGlkZGVuICYmXG4gICAgICAgICAgIWdyYXBoLm5vZGVzKGFbaV0udGFyZ2V0KS5oaWRkZW5cbiAgICAgICAgKVxuICAgICAgICAgIHJlbmRlcmVyLmFkZEVkZ2UoXG4gICAgICAgICAgICBhW2ldLFxuICAgICAgICAgICAgZ3JhcGgubm9kZXMoYVtpXS5zb3VyY2UpLFxuICAgICAgICAgICAgZ3JhcGgubm9kZXMoYVtpXS50YXJnZXQpLFxuICAgICAgICAgICAgdGhpcy5lZGdlRmxvYXRBcnJheXNba10uYXJyYXksXG4gICAgICAgICAgICBpICogcmVuZGVyZXIuUE9JTlRTICogcmVuZGVyZXIuQVRUUklCVVRFUyxcbiAgICAgICAgICAgIG9wdGlvbnMucHJlZml4LFxuICAgICAgICAgICAgdGhpcy5zZXR0aW5nc1xuICAgICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgcmVuZGVyZXIuY29tcHV0ZUluZGljZXMgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRoaXMuZWRnZUluZGljZXNBcnJheXNba10gPSByZW5kZXJlci5jb21wdXRlSW5kaWNlcyhcbiAgICAgICAgICB0aGlzLmVkZ2VGbG9hdEFycmF5c1trXS5hcnJheVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIFB1c2ggbm9kZXM6XG4gICAgZm9yIChrIGluIHRoaXMubm9kZUZsb2F0QXJyYXlzKSB7XG4gICAgICByZW5kZXJlciA9IHNpZ21hLndlYmdsLm5vZGVzW2tdO1xuICAgICAgYSA9IHRoaXMubm9kZUZsb2F0QXJyYXlzW2tdLm5vZGVzO1xuXG4gICAgICAvLyBDcmVhdGluZyB0aGUgbmVjZXNzYXJ5IGFycmF5c1xuICAgICAgdGhpcy5ub2RlRmxvYXRBcnJheXNba10uYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KFxuICAgICAgICBhLmxlbmd0aCAqIHJlbmRlcmVyLlBPSU5UUyAqIHJlbmRlcmVyLkFUVFJJQlVURVNcbiAgICAgICk7XG5cbiAgICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoIXRoaXMubm9kZUZsb2F0QXJyYXlzW2tdLmFycmF5KVxuICAgICAgICAgIHRoaXMubm9kZUZsb2F0QXJyYXlzW2tdLmFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShcbiAgICAgICAgICAgIGEubGVuZ3RoICogcmVuZGVyZXIuUE9JTlRTICogcmVuZGVyZXIuQVRUUklCVVRFU1xuICAgICAgICAgICk7XG5cbiAgICAgICAgLy8gSnVzdCBjaGVjayB0aGF0IHRoZSBlZGdlIGFuZCBib3RoIGl0cyBleHRyZW1pdGllcyBhcmUgdmlzaWJsZTpcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFhW2ldLmhpZGRlblxuICAgICAgICApXG4gICAgICAgICAgcmVuZGVyZXIuYWRkTm9kZShcbiAgICAgICAgICAgIGFbaV0sXG4gICAgICAgICAgICB0aGlzLm5vZGVGbG9hdEFycmF5c1trXS5hcnJheSxcbiAgICAgICAgICAgIGkgKiByZW5kZXJlci5QT0lOVFMgKiByZW5kZXJlci5BVFRSSUJVVEVTLFxuICAgICAgICAgICAgb3B0aW9ucy5wcmVmaXgsXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG5cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgcmVuZGVycyB0aGUgZ3JhcGguIEl0IGJhc2ljYWxseSBjYWxscyBlYWNoIHByb2dyYW0gKGFuZFxuICAgKiBnZW5lcmF0ZSB0aGVtIGlmIHRoZXkgZG8gbm90IGV4aXN0IHlldCkgdG8gcmVuZGVyIG5vZGVzIGFuZCBlZGdlcywgYmF0Y2hlZFxuICAgKiBwZXIgcmVuZGVyZXIuXG4gICAqXG4gICAqIEFzIGluIHRoZSBjYW52YXMgcmVuZGVyZXIsIGl0IGlzIHBvc3NpYmxlIHRvIGRpc3BsYXkgZWRnZXMsIG5vZGVzIGFuZCAvIG9yXG4gICAqIGxhYmVscyBpbiBiYXRjaGVzLCB0byBtYWtlIHRoZSB3aG9sZSB0aGluZyB3YXkgbW9yZSBzY2FsYWJsZS5cbiAgICpcbiAgICogQHBhcmFtICB7P29iamVjdH0gICAgICAgICAgICAgICBwYXJhbXMgRXZlbnR1YWxseSBhbiBvYmplY3Qgb2Ygb3B0aW9ucy5cbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLndlYmdsfSAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLndlYmdsLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICB2YXIgYSxcbiAgICAgICAgaSxcbiAgICAgICAgbCxcbiAgICAgICAgayxcbiAgICAgICAgbyxcbiAgICAgICAgcHJvZ3JhbSxcbiAgICAgICAgcmVuZGVyZXIsXG4gICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICBncmFwaCA9IHRoaXMuZ3JhcGgsXG4gICAgICAgIG5vZGVzR2wgPSB0aGlzLmNvbnRleHRzLm5vZGVzLFxuICAgICAgICBlZGdlc0dsID0gdGhpcy5jb250ZXh0cy5lZGdlcyxcbiAgICAgICAgbWF0cml4ID0gdGhpcy5jYW1lcmEuZ2V0TWF0cml4KCksXG4gICAgICAgIG9wdGlvbnMgPSBzaWdtYS51dGlscy5leHRlbmQocGFyYW1zLCB0aGlzLm9wdGlvbnMpLFxuICAgICAgICBkcmF3TGFiZWxzID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZHJhd0xhYmVscycpLFxuICAgICAgICBkcmF3RWRnZXMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3RWRnZXMnKSxcbiAgICAgICAgZHJhd05vZGVzID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZHJhd05vZGVzJyk7XG5cbiAgICAvLyBDYWxsIHRoZSByZXNpemUgZnVuY3Rpb246XG4gICAgdGhpcy5yZXNpemUoZmFsc2UpO1xuXG4gICAgLy8gQ2hlY2sgdGhlICdoaWRlRWRnZXNPbk1vdmUnIHNldHRpbmc6XG4gICAgaWYgKHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2hpZGVFZGdlc09uTW92ZScpKVxuICAgICAgaWYgKHRoaXMuY2FtZXJhLmlzQW5pbWF0ZWQgfHwgdGhpcy5jYW1lcmEuaXNNb3ZpbmcpXG4gICAgICAgIGRyYXdFZGdlcyA9IGZhbHNlO1xuXG4gICAgLy8gQ2xlYXIgY2FudmFzZXM6XG4gICAgdGhpcy5jbGVhcigpO1xuXG4gICAgLy8gVHJhbnNsYXRlIG1hdHJpeCB0byBbd2lkdGgvMiwgaGVpZ2h0LzJdOlxuICAgIG1hdHJpeCA9IHNpZ21hLnV0aWxzLm1hdHJpY2VzLm11bHRpcGx5KFxuICAgICAgbWF0cml4LFxuICAgICAgc2lnbWEudXRpbHMubWF0cmljZXMudHJhbnNsYXRpb24odGhpcy53aWR0aCAvIDIsIHRoaXMuaGVpZ2h0IC8gMilcbiAgICApO1xuXG4gICAgLy8gS2lsbCBydW5uaW5nIGpvYnM6XG4gICAgZm9yIChrIGluIHRoaXMuam9icylcbiAgICAgIGlmIChjb25yYWQuaGFzSm9iKGspKVxuICAgICAgICBjb25yYWQua2lsbEpvYihrKTtcblxuICAgIGlmIChkcmF3RWRnZXMpIHtcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdiYXRjaEVkZ2VzRHJhd2luZycpKVxuICAgICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGEsXG4gICAgICAgICAgICAgIGssXG4gICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICBqb2IsXG4gICAgICAgICAgICAgIGFycixcbiAgICAgICAgICAgICAgZW5kLFxuICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgICAgaW5kaWNlcyxcbiAgICAgICAgICAgICAgcmVuZGVyZXIsXG4gICAgICAgICAgICAgIGJhdGNoU2l6ZSxcbiAgICAgICAgICAgICAgY3VycmVudFByb2dyYW07XG5cbiAgICAgICAgICBpZCA9ICdlZGdlc18nICsgdGhpcy5jb25yYWRJZDtcbiAgICAgICAgICBiYXRjaFNpemUgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICd3ZWJnbEVkZ2VzQmF0Y2hTaXplJyk7XG4gICAgICAgICAgYSA9IE9iamVjdC5rZXlzKHRoaXMuZWRnZUZsb2F0QXJyYXlzKTtcblxuICAgICAgICAgIGlmICghYS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgcmVuZGVyZXIgPSBzaWdtYS53ZWJnbC5lZGdlc1thW2ldXTtcbiAgICAgICAgICBhcnIgPSB0aGlzLmVkZ2VGbG9hdEFycmF5c1thW2ldXS5hcnJheTtcbiAgICAgICAgICBpbmRpY2VzID0gdGhpcy5lZGdlSW5kaWNlc0FycmF5c1thW2ldXTtcbiAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgICAgZW5kID0gTWF0aC5taW4oXG4gICAgICAgICAgICBzdGFydCArIGJhdGNoU2l6ZSAqIHJlbmRlcmVyLlBPSU5UUyxcbiAgICAgICAgICAgIGFyci5sZW5ndGggLyByZW5kZXJlci5BVFRSSUJVVEVTXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGpvYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgcHJvZ3JhbTpcbiAgICAgICAgICAgIGlmICghdGhpcy5lZGdlUHJvZ3JhbXNbYVtpXV0pXG4gICAgICAgICAgICAgIHRoaXMuZWRnZVByb2dyYW1zW2FbaV1dID0gcmVuZGVyZXIuaW5pdFByb2dyYW0oZWRnZXNHbCk7XG5cbiAgICAgICAgICAgIGlmIChzdGFydCA8IGVuZCkge1xuICAgICAgICAgICAgICBlZGdlc0dsLnVzZVByb2dyYW0odGhpcy5lZGdlUHJvZ3JhbXNbYVtpXV0pO1xuICAgICAgICAgICAgICByZW5kZXJlci5yZW5kZXIoXG4gICAgICAgICAgICAgICAgZWRnZXNHbCxcbiAgICAgICAgICAgICAgICB0aGlzLmVkZ2VQcm9ncmFtc1thW2ldXSxcbiAgICAgICAgICAgICAgICBhcnIsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgc2V0dGluZ3M6IHRoaXMuc2V0dGluZ3MsXG4gICAgICAgICAgICAgICAgICBtYXRyaXg6IG1hdHJpeCxcbiAgICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgIHJhdGlvOiB0aGlzLmNhbWVyYS5yYXRpbyxcbiAgICAgICAgICAgICAgICAgIHNjYWxpbmdSYXRpbzogdGhpcy5zZXR0aW5ncyhcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgJ3dlYmdsT3ZlcnNhbXBsaW5nUmF0aW8nXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgY291bnQ6IGVuZCAtIHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgaW5kaWNlc0RhdGE6IGluZGljZXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhdGNoIGpvYidzIGVuZDpcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgZW5kID49IGFyci5sZW5ndGggLyByZW5kZXJlci5BVFRSSUJVVEVTICYmXG4gICAgICAgICAgICAgIGkgPT09IGEubGVuZ3RoIC0gMVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmpvYnNbaWRdO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbmQgPj0gYXJyLmxlbmd0aCAvIHJlbmRlcmVyLkFUVFJJQlVURVMpIHtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICBhcnIgPSB0aGlzLmVkZ2VGbG9hdEFycmF5c1thW2ldXS5hcnJheTtcbiAgICAgICAgICAgICAgcmVuZGVyZXIgPSBzaWdtYS53ZWJnbC5lZGdlc1thW2ldXTtcbiAgICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICAgICAgICBlbmQgPSBNYXRoLm1pbihcbiAgICAgICAgICAgICAgICBzdGFydCArIGJhdGNoU2l6ZSAqIHJlbmRlcmVyLlBPSU5UUyxcbiAgICAgICAgICAgICAgICBhcnIubGVuZ3RoIC8gcmVuZGVyZXIuQVRUUklCVVRFU1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKFxuICAgICAgICAgICAgICAgIHN0YXJ0ICsgYmF0Y2hTaXplICogcmVuZGVyZXIuUE9JTlRTLFxuICAgICAgICAgICAgICAgIGFyci5sZW5ndGggLyByZW5kZXJlci5BVFRSSUJVVEVTXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB0aGlzLmpvYnNbaWRdID0gam9iO1xuICAgICAgICAgIGNvbnJhZC5hZGRKb2IoaWQsIGpvYi5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGsgaW4gdGhpcy5lZGdlRmxvYXRBcnJheXMpIHtcbiAgICAgICAgICByZW5kZXJlciA9IHNpZ21hLndlYmdsLmVkZ2VzW2tdO1xuXG4gICAgICAgICAgLy8gQ2hlY2sgcHJvZ3JhbTpcbiAgICAgICAgICBpZiAoIXRoaXMuZWRnZVByb2dyYW1zW2tdKVxuICAgICAgICAgICAgdGhpcy5lZGdlUHJvZ3JhbXNba10gPSByZW5kZXJlci5pbml0UHJvZ3JhbShlZGdlc0dsKTtcblxuICAgICAgICAgIC8vIFJlbmRlclxuICAgICAgICAgIGlmICh0aGlzLmVkZ2VGbG9hdEFycmF5c1trXSkge1xuICAgICAgICAgICAgZWRnZXNHbC51c2VQcm9ncmFtKHRoaXMuZWRnZVByb2dyYW1zW2tdKTtcbiAgICAgICAgICAgIHJlbmRlcmVyLnJlbmRlcihcbiAgICAgICAgICAgICAgZWRnZXNHbCxcbiAgICAgICAgICAgICAgdGhpcy5lZGdlUHJvZ3JhbXNba10sXG4gICAgICAgICAgICAgIHRoaXMuZWRnZUZsb2F0QXJyYXlzW2tdLmFycmF5LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3M6IHRoaXMuc2V0dGluZ3MsXG4gICAgICAgICAgICAgICAgbWF0cml4OiBtYXRyaXgsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgICAgICByYXRpbzogdGhpcy5jYW1lcmEucmF0aW8sXG4gICAgICAgICAgICAgICAgc2NhbGluZ1JhdGlvOiB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICd3ZWJnbE92ZXJzYW1wbGluZ1JhdGlvJyksXG4gICAgICAgICAgICAgICAgaW5kaWNlc0RhdGE6IHRoaXMuZWRnZUluZGljZXNBcnJheXNba11cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZHJhd05vZGVzKSB7XG4gICAgICAvLyBFbmFibGUgYmxlbmRpbmc6XG4gICAgICBub2Rlc0dsLmJsZW5kRnVuYyhub2Rlc0dsLlNSQ19BTFBIQSwgbm9kZXNHbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcbiAgICAgIG5vZGVzR2wuZW5hYmxlKG5vZGVzR2wuQkxFTkQpO1xuXG4gICAgICBmb3IgKGsgaW4gdGhpcy5ub2RlRmxvYXRBcnJheXMpIHtcbiAgICAgICAgcmVuZGVyZXIgPSBzaWdtYS53ZWJnbC5ub2Rlc1trXTtcblxuICAgICAgICAvLyBDaGVjayBwcm9ncmFtOlxuICAgICAgICBpZiAoIXRoaXMubm9kZVByb2dyYW1zW2tdKVxuICAgICAgICAgIHRoaXMubm9kZVByb2dyYW1zW2tdID0gcmVuZGVyZXIuaW5pdFByb2dyYW0obm9kZXNHbCk7XG5cbiAgICAgICAgLy8gUmVuZGVyXG4gICAgICAgIGlmICh0aGlzLm5vZGVGbG9hdEFycmF5c1trXSkge1xuICAgICAgICAgIG5vZGVzR2wudXNlUHJvZ3JhbSh0aGlzLm5vZGVQcm9ncmFtc1trXSk7XG4gICAgICAgICAgcmVuZGVyZXIucmVuZGVyKFxuICAgICAgICAgICAgbm9kZXNHbCxcbiAgICAgICAgICAgIHRoaXMubm9kZVByb2dyYW1zW2tdLFxuICAgICAgICAgICAgdGhpcy5ub2RlRmxvYXRBcnJheXNba10uYXJyYXksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHNldHRpbmdzOiB0aGlzLnNldHRpbmdzLFxuICAgICAgICAgICAgICBtYXRyaXg6IG1hdHJpeCxcbiAgICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICAgIHJhdGlvOiB0aGlzLmNhbWVyYS5yYXRpbyxcbiAgICAgICAgICAgICAgc2NhbGluZ1JhdGlvOiB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICd3ZWJnbE92ZXJzYW1wbGluZ1JhdGlvJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRyYXdMYWJlbHMpIHtcbiAgICAgIGEgPSB0aGlzLmNhbWVyYS5xdWFkdHJlZS5hcmVhKFxuICAgICAgICB0aGlzLmNhbWVyYS5nZXRSZWN0YW5nbGUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpXG4gICAgICApO1xuXG4gICAgICAvLyBBcHBseSBjYW1lcmEgdmlldyB0byB0aGVzZSBub2RlczpcbiAgICAgIHRoaXMuY2FtZXJhLmFwcGx5VmlldyhcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHtcbiAgICAgICAgICBub2RlczogYSxcbiAgICAgICAgICBlZGdlczogW10sXG4gICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICBvID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBzZWxmLnNldHRpbmdzKHtcbiAgICAgICAgICBwcmVmaXg6IHNlbGYuY2FtZXJhLnByZWZpeFxuICAgICAgICB9LCBrZXkpO1xuICAgICAgfTtcblxuICAgICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICBpZiAoIWFbaV0uaGlkZGVuKVxuICAgICAgICAgIChcbiAgICAgICAgICAgIHNpZ21hLmNhbnZhcy5sYWJlbHNbXG4gICAgICAgICAgICAgIGFbaV0udHlwZSB8fFxuICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkZWZhdWx0Tm9kZVR5cGUnKVxuICAgICAgICAgICAgXSB8fCBzaWdtYS5jYW52YXMubGFiZWxzLmRlZlxuICAgICAgICAgICkoYVtpXSwgdGhpcy5jb250ZXh0cy5sYWJlbHMsIG8pO1xuICAgIH1cblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgncmVuZGVyJyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG5cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY3JlYXRlcyBhIERPTSBlbGVtZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSwgc3dpdGNoZXMgaXRzXG4gICAqIHBvc2l0aW9uIHRvIFwiYWJzb2x1dGVcIiwgcmVmZXJlbmNlcyBpdCB0byB0aGUgZG9tRWxlbWVudHMgYXR0cmlidXRlLCBhbmRcbiAgICogZmluYWxseSBhcHBlbmRzIGl0IHRvIHRoZSBjb250YWluZXIuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICB0YWcgICBUaGUgbGFiZWwgdGFnLlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgaWQgICAgVGhlIGlkIG9mIHRoZSBlbGVtZW50ICh0byBzdG9yZSBpdCBpblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkb21FbGVtZW50c1wiKS5cbiAgICogQHBhcmFtICB7P2Jvb2xlYW59IHdlYmdsIFdpbGwgaW5pdCB0aGUgV2ViR0wgY29udGV4dCBpZiB0cnVlLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLndlYmdsLnByb3RvdHlwZS5pbml0RE9NID0gZnVuY3Rpb24odGFnLCBpZCwgd2ViZ2wpIHtcbiAgICB2YXIgZ2wsXG4gICAgICAgIGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKSxcbiAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICBkb20uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3NpZ21hLScgKyBpZCk7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnRzW2lkXSA9IGRvbTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChkb20pO1xuXG4gICAgaWYgKHRhZy50b0xvd2VyQ2FzZSgpID09PSAnY2FudmFzJykge1xuICAgICAgdGhpcy5jb250ZXh0c1tpZF0gPSBkb20uZ2V0Q29udGV4dCh3ZWJnbCA/ICdleHBlcmltZW50YWwtd2ViZ2wnIDogJzJkJywge1xuICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBZGRpbmcgd2ViZ2wgY29udGV4dCBsb3NzIGxpc3RlbmVyc1xuICAgICAgaWYgKHdlYmdsKSB7XG4gICAgICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRsb3N0JywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSwgZmFsc2UpO1xuXG4gICAgICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBzZWxmLnJlbmRlcigpO1xuICAgICAgICB9LCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCByZXNpemVzIGVhY2ggRE9NIGVsZW1lbnRzIGluIHRoZSBjb250YWluZXIgYW5kIHN0b3JlcyB0aGUgbmV3XG4gICAqIGRpbWVuc2lvbnMuIFRoZW4sIGl0IHJlbmRlcnMgdGhlIGdyYXBoLlxuICAgKlxuICAgKiBAcGFyYW0gIHs/bnVtYmVyfSAgICAgICAgICAgICAgIHdpZHRoICBUaGUgbmV3IHdpZHRoIG9mIHRoZSBjb250YWluZXIuXG4gICAqIEBwYXJhbSAgez9udW1iZXJ9ICAgICAgICAgICAgICAgaGVpZ2h0IFRoZSBuZXcgaGVpZ2h0IG9mIHRoZSBjb250YWluZXIuXG4gICAqIEByZXR1cm4ge3NpZ21hLnJlbmRlcmVycy53ZWJnbH0gICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy53ZWJnbC5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24odywgaCkge1xuICAgIHZhciBrLFxuICAgICAgICBvbGRXaWR0aCA9IHRoaXMud2lkdGgsXG4gICAgICAgIG9sZEhlaWdodCA9IHRoaXMuaGVpZ2h0LFxuICAgICAgICBwaXhlbFJhdGlvID0gc2lnbWEudXRpbHMuZ2V0UGl4ZWxSYXRpbygpO1xuXG4gICAgaWYgKHcgIT09IHVuZGVmaW5lZCAmJiBoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMud2lkdGggPSB3O1xuICAgICAgdGhpcy5oZWlnaHQgPSBoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodDtcblxuICAgICAgdyA9IHRoaXMud2lkdGg7XG4gICAgICBoID0gdGhpcy5oZWlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKG9sZFdpZHRoICE9PSB0aGlzLndpZHRoIHx8IG9sZEhlaWdodCAhPT0gdGhpcy5oZWlnaHQpIHtcbiAgICAgIGZvciAoayBpbiB0aGlzLmRvbUVsZW1lbnRzKSB7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudHNba10uc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcbiAgICAgICAgdGhpcy5kb21FbGVtZW50c1trXS5zdHlsZS5oZWlnaHQgPSBoICsgJ3B4JztcblxuICAgICAgICBpZiAodGhpcy5kb21FbGVtZW50c1trXS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdjYW52YXMnKSB7XG4gICAgICAgICAgLy8gSWYgc2ltcGxlIDJEIGNhbnZhczpcbiAgICAgICAgICBpZiAodGhpcy5jb250ZXh0c1trXSAmJiB0aGlzLmNvbnRleHRzW2tdLnNjYWxlKSB7XG4gICAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzW2tdLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAodyAqIHBpeGVsUmF0aW8pICsgJ3B4Jyk7XG4gICAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzW2tdLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgKGggKiBwaXhlbFJhdGlvKSArICdweCcpO1xuXG4gICAgICAgICAgICBpZiAocGl4ZWxSYXRpbyAhPT0gMSlcbiAgICAgICAgICAgICAgdGhpcy5jb250ZXh0c1trXS5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kb21FbGVtZW50c1trXS5zZXRBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICd3aWR0aCcsXG4gICAgICAgICAgICAgICh3ICogdGhpcy5zZXR0aW5ncygnd2ViZ2xPdmVyc2FtcGxpbmdSYXRpbycpKSArICdweCdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzW2tdLnNldEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgJ2hlaWdodCcsXG4gICAgICAgICAgICAgIChoICogdGhpcy5zZXR0aW5ncygnd2ViZ2xPdmVyc2FtcGxpbmdSYXRpbycpKSArICdweCdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2NhbGU6XG4gICAgZm9yIChrIGluIHRoaXMuY29udGV4dHMpXG4gICAgICBpZiAodGhpcy5jb250ZXh0c1trXSAmJiB0aGlzLmNvbnRleHRzW2tdLnZpZXdwb3J0KVxuICAgICAgICB0aGlzLmNvbnRleHRzW2tdLnZpZXdwb3J0KFxuICAgICAgICAgIDAsXG4gICAgICAgICAgMCxcbiAgICAgICAgICB0aGlzLndpZHRoICogdGhpcy5zZXR0aW5ncygnd2ViZ2xPdmVyc2FtcGxpbmdSYXRpbycpLFxuICAgICAgICAgIHRoaXMuaGVpZ2h0ICogdGhpcy5zZXR0aW5ncygnd2ViZ2xPdmVyc2FtcGxpbmdSYXRpbycpXG4gICAgICAgICk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY2xlYXJzIGVhY2ggY2FudmFzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMud2ViZ2x9IFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy53ZWJnbC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNvbnRleHRzLmxhYmVscy5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIHRoaXMuY29udGV4dHMubm9kZXMuY2xlYXIodGhpcy5jb250ZXh0cy5ub2Rlcy5DT0xPUl9CVUZGRVJfQklUKTtcbiAgICB0aGlzLmNvbnRleHRzLmVkZ2VzLmNsZWFyKHRoaXMuY29udGV4dHMuZWRnZXMuQ09MT1JfQlVGRkVSX0JJVCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2Qga2lsbHMgY29udGV4dHMgYW5kIG90aGVyIGF0dHJpYnV0ZXMuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMud2ViZ2wucHJvdG90eXBlLmtpbGwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgayxcbiAgICAgICAgY2FwdG9yO1xuXG4gICAgLy8gS2lsbCBjYXB0b3JzOlxuICAgIHdoaWxlICgoY2FwdG9yID0gdGhpcy5jYXB0b3JzLnBvcCgpKSlcbiAgICAgIGNhcHRvci5raWxsKCk7XG4gICAgZGVsZXRlIHRoaXMuY2FwdG9ycztcblxuICAgIC8vIEtpbGwgY29udGV4dHM6XG4gICAgZm9yIChrIGluIHRoaXMuZG9tRWxlbWVudHMpIHtcbiAgICAgIHRoaXMuZG9tRWxlbWVudHNba10ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbUVsZW1lbnRzW2tdKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmRvbUVsZW1lbnRzW2tdO1xuICAgICAgZGVsZXRlIHRoaXMuY29udGV4dHNba107XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLmRvbUVsZW1lbnRzO1xuICAgIGRlbGV0ZSB0aGlzLmNvbnRleHRzO1xuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IFwic2lnbWEud2ViZ2wubm9kZXNcIiBjb250YWlucyB0aGUgZGlmZmVyZW50IFdlYkdMIG5vZGVcbiAgICogcmVuZGVyZXJzLiBUaGUgZGVmYXVsdCBvbmUgZHJhdyBub2RlcyBhcyBkaXNjcy4gSGVyZSBhcmUgdGhlIGF0dHJpYnV0ZXNcbiAgICogYW55IG5vZGUgcmVuZGVyZXIgbXVzdCBoYXZlOlxuICAgKlxuICAgKiB7bnVtYmVyfSAgIFBPSU5UUyAgICAgIFRoZSBudW1iZXIgb2YgcG9pbnRzIHJlcXVpcmVkIHRvIGRyYXcgYSBub2RlLlxuICAgKiB7bnVtYmVyfSAgIEFUVFJJQlVURVMgIFRoZSBudW1iZXIgb2YgYXR0cmlidXRlcyBuZWVkZWQgdG8gZHJhdyBvbmUgcG9pbnQuXG4gICAqIHtmdW5jdGlvbn0gYWRkTm9kZSAgICAgQSBmdW5jdGlvbiB0aGF0IGFkZHMgYSBub2RlIHRvIHRoZSBkYXRhIHN0YWNrIHRoYXRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGJlIGdpdmVuIHRvIHRoZSBidWZmZXIuIEhlcmUgaXMgdGhlIGFyZ3VtZW50czpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtvYmplY3R9ICAgICAgIG5vZGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtudW1iZXJ9ICAgICAgIGluZGV4ICAgVGhlIG5vZGUgaW5kZXggaW4gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzIGFycmF5LlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge0Zsb2F0MzJBcnJheX0gZGF0YSAgICBUaGUgc3RhY2suXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7b2JqZWN0fSAgICAgICBvcHRpb25zIFNvbWUgb3B0aW9ucy5cbiAgICoge2Z1bmN0aW9ufSByZW5kZXIgICAgICBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGVmZmVjdGl2ZWx5IHJlbmRlciB0aGUgbm9kZXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICBpbnRvIHRoZSBidWZmZXIuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge1dlYkdMUHJvZ3JhbX0gICAgICAgICAgcHJvZ3JhbVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge0Zsb2F0MzJBcnJheX0gZGF0YSAgICBUaGUgc3RhY2sgdG8gZ2l2ZSB0byB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge29iamVjdH0gICAgICAgcGFyYW1zICBBbiBvYmplY3QgY29udGFpbmluZyBzb21lXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMsIGxpa2Ugd2lkdGgsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCwgdGhlIGNhbWVyYSByYXRpby5cbiAgICoge2Z1bmN0aW9ufSBpbml0UHJvZ3JhbSBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGluaXRpYXRlIHRoZSBwcm9ncmFtLCB3aXRoXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHJlbGV2YW50IHNoYWRlcnMgYW5kIHBhcmFtZXRlcnMuIEl0IG11c3QgcmV0dXJuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG5ld2x5IGNyZWF0ZWQgcHJvZ3JhbS5cbiAgICpcbiAgICogQ2hlY2sgc2lnbWEud2ViZ2wubm9kZXMuZGVmIG9yIHNpZ21hLndlYmdsLm5vZGVzLmZhc3QgdG8gc2VlIGhvdyBpdFxuICAgKiB3b3JrcyBtb3JlIHByZWNpc2VseS5cbiAgICovXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEud2ViZ2wubm9kZXMnKTtcblxuXG5cblxuICAvKipcbiAgICogVGhlIG9iamVjdCBcInNpZ21hLndlYmdsLmVkZ2VzXCIgY29udGFpbnMgdGhlIGRpZmZlcmVudCBXZWJHTCBlZGdlXG4gICAqIHJlbmRlcmVycy4gVGhlIGRlZmF1bHQgb25lIGRyYXcgZWRnZXMgYXMgZGlyZWN0IGxpbmVzLiBIZXJlIGFyZSB0aGVcbiAgICogYXR0cmlidXRlcyBhbnkgZWRnZSByZW5kZXJlciBtdXN0IGhhdmU6XG4gICAqXG4gICAqIHtudW1iZXJ9ICAgUE9JTlRTICAgICAgVGhlIG51bWJlciBvZiBwb2ludHMgcmVxdWlyZWQgdG8gZHJhdyBhbiBlZGdlLlxuICAgKiB7bnVtYmVyfSAgIEFUVFJJQlVURVMgIFRoZSBudW1iZXIgb2YgYXR0cmlidXRlcyBuZWVkZWQgdG8gZHJhdyBvbmUgcG9pbnQuXG4gICAqIHtmdW5jdGlvbn0gYWRkRWRnZSAgICAgQSBmdW5jdGlvbiB0aGF0IGFkZHMgYW4gZWRnZSB0byB0aGUgZGF0YSBzdGFjayB0aGF0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBiZSBnaXZlbiB0byB0aGUgYnVmZmVyLiBIZXJlIGlzIHRoZSBhcmd1bWVudHM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7b2JqZWN0fSAgICAgICBlZGdlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7b2JqZWN0fSAgICAgICBzb3VyY2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtvYmplY3R9ICAgICAgIHRhcmdldFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge0Zsb2F0MzJBcnJheX0gZGF0YSAgICBUaGUgc3RhY2suXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7b2JqZWN0fSAgICAgICBvcHRpb25zIFNvbWUgb3B0aW9ucy5cbiAgICoge2Z1bmN0aW9ufSByZW5kZXIgICAgICBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGVmZmVjdGl2ZWx5IHJlbmRlciB0aGUgZWRnZXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICBpbnRvIHRoZSBidWZmZXIuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge1dlYkdMUHJvZ3JhbX0gICAgICAgICAgcHJvZ3JhbVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge0Zsb2F0MzJBcnJheX0gZGF0YSAgICBUaGUgc3RhY2sgdG8gZ2l2ZSB0byB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge29iamVjdH0gICAgICAgcGFyYW1zICBBbiBvYmplY3QgY29udGFpbmluZyBzb21lXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMsIGxpa2Ugd2lkdGgsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCwgdGhlIGNhbWVyYSByYXRpby5cbiAgICoge2Z1bmN0aW9ufSBpbml0UHJvZ3JhbSBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGluaXRpYXRlIHRoZSBwcm9ncmFtLCB3aXRoXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHJlbGV2YW50IHNoYWRlcnMgYW5kIHBhcmFtZXRlcnMuIEl0IG11c3QgcmV0dXJuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG5ld2x5IGNyZWF0ZWQgcHJvZ3JhbS5cbiAgICpcbiAgICogQ2hlY2sgc2lnbWEud2ViZ2wuZWRnZXMuZGVmIG9yIHNpZ21hLndlYmdsLmVkZ2VzLmZhc3QgdG8gc2VlIGhvdyBpdFxuICAgKiB3b3JrcyBtb3JlIHByZWNpc2VseS5cbiAgICovXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEud2ViZ2wuZWRnZXMnKTtcblxuXG5cblxuICAvKipcbiAgICogVGhlIG9iamVjdCBcInNpZ21hLmNhbnZhcy5sYWJlbHNcIiBjb250YWlucyB0aGUgZGlmZmVyZW50XG4gICAqIGxhYmVsIHJlbmRlcmVycyBmb3IgdGhlIFdlYkdMIHJlbmRlcmVyLiBTaW5jZSBkaXNwbGF5aW5nIHRleHRzIGluIFdlYkdMIGlzXG4gICAqIGRlZmluaXRlbHkgcGFpbmZ1bCBhbmQgc2luY2UgdGhlcmUgYSB3YXkgbGVzcyBsYWJlbHMgdG8gZGlzcGxheSB0aGFuIG5vZGVzXG4gICAqIG9yIGVkZ2VzLCB0aGUgZGVmYXVsdCByZW5kZXJlciBzaW1wbHkgcmVuZGVycyB0aGVtIGluIGEgY2FudmFzLlxuICAgKlxuICAgKiBBIGxhYmVscyByZW5kZXJlciBpcyBhIHNpbXBsZSBmdW5jdGlvbiwgdGFraW5nIGFzIGFyZ3VtZW50cyB0aGUgcmVsYXRlZFxuICAgKiBub2RlLCB0aGUgcmVuZGVyZXIgYW5kIGEgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqL1xuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5sYWJlbHMnKTtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICBpZiAodHlwZW9mIGNvbnJhZCA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ2NvbnJhZCBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEucmVuZGVyZXJzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgdGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBzdmcgc2lnbWEncyByZW5kZXJlci5cbiAgICpcbiAgICogQHBhcmFtICB7c2lnbWEuY2xhc3Nlcy5ncmFwaH0gICAgICAgICAgICBncmFwaCAgICBUaGUgZ3JhcGggdG8gcmVuZGVyLlxuICAgKiBAcGFyYW0gIHtzaWdtYS5jbGFzc2VzLmNhbWVyYX0gICAgICAgICAgIGNhbWVyYSAgIFRoZSBjYW1lcmEuXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgIHNldHRpbmdzIFRoZSBzaWdtYSBpbnN0YW5jZSBzZXR0aW5nc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbi5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgb2JqZWN0ICAgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMuc3ZnfSAgICAgICAgICAgICBUaGUgcmVuZGVyZXIgaW5zdGFuY2UuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMuc3ZnID0gZnVuY3Rpb24oZ3JhcGgsIGNhbWVyYSwgc2V0dGluZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKVxuICAgICAgdGhyb3cgJ3NpZ21hLnJlbmRlcmVycy5zdmc6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgaWYgKCEob3B0aW9ucy5jb250YWluZXIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpXG4gICAgICB0aHJvdyAnQ29udGFpbmVyIG5vdCBmb3VuZC4nO1xuXG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIGEsXG4gICAgICAgIGZuLFxuICAgICAgICBzZWxmID0gdGhpcztcblxuICAgIHNpZ21hLmNsYXNzZXMuZGlzcGF0Y2hlci5leHRlbmQodGhpcyk7XG5cbiAgICAvLyBJbml0aWFsaXplIG1haW4gYXR0cmlidXRlczpcbiAgICB0aGlzLmdyYXBoID0gZ3JhcGg7XG4gICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XG4gICAgdGhpcy5kb21FbGVtZW50cyA9IHtcbiAgICAgIGdyYXBoOiBudWxsLFxuICAgICAgZ3JvdXBzOiB7fSxcbiAgICAgIG5vZGVzOiB7fSxcbiAgICAgIGVkZ2VzOiB7fSxcbiAgICAgIGxhYmVsczoge30sXG4gICAgICBob3ZlcnM6IHt9XG4gICAgfTtcbiAgICB0aGlzLm1lYXN1cmVtZW50Q2FudmFzID0gbnVsbDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5vcHRpb25zLmNvbnRhaW5lcjtcbiAgICB0aGlzLnNldHRpbmdzID0gKFxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5zZXR0aW5ncyA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgb3B0aW9ucy5zZXR0aW5nc1xuICAgICAgKSA/XG4gICAgICAgIHNldHRpbmdzLmVtYmVkT2JqZWN0cyhvcHRpb25zLnNldHRpbmdzKSA6XG4gICAgICAgIHNldHRpbmdzO1xuXG4gICAgLy8gSXMgdGhlIHJlbmRlcmVyIG1lYW50IHRvIGJlIGZyZWVzdHlsZT9cbiAgICB0aGlzLnNldHRpbmdzKCdmcmVlU3R5bGUnLCAhIXRoaXMub3B0aW9ucy5mcmVlU3R5bGUpO1xuXG4gICAgLy8gU1ZHIHhtbG5zXG4gICAgdGhpcy5zZXR0aW5ncygneG1sbnMnLCAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnKTtcblxuICAgIC8vIEluZGV4ZXM6XG4gICAgdGhpcy5ub2Rlc09uU2NyZWVuID0gW107XG4gICAgdGhpcy5lZGdlc09uU2NyZWVuID0gW107XG5cbiAgICAvLyBGaW5kIHRoZSBwcmVmaXg6XG4gICAgdGhpcy5vcHRpb25zLnByZWZpeCA9ICdyZW5kZXJlcicgKyBzaWdtYS51dGlscy5pZCgpICsgJzonO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgRE9NIGVsZW1lbnRzXG4gICAgdGhpcy5pbml0RE9NKCdzdmcnKTtcblxuICAgIC8vIEluaXRpYWxpemUgY2FwdG9yczpcbiAgICB0aGlzLmNhcHRvcnMgPSBbXTtcbiAgICBhID0gdGhpcy5vcHRpb25zLmNhcHRvcnMgfHwgW3NpZ21hLmNhcHRvcnMubW91c2UsIHNpZ21hLmNhcHRvcnMudG91Y2hdO1xuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZm4gPSB0eXBlb2YgYVtpXSA9PT0gJ2Z1bmN0aW9uJyA/IGFbaV0gOiBzaWdtYS5jYXB0b3JzW2FbaV1dO1xuICAgICAgdGhpcy5jYXB0b3JzLnB1c2goXG4gICAgICAgIG5ldyBmbihcbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLmdyYXBoLFxuICAgICAgICAgIHRoaXMuY2FtZXJhLFxuICAgICAgICAgIHRoaXMuc2V0dGluZ3NcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBCaW5kIHJlc2l6ZTpcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLnJlc2l6ZSgpO1xuICAgIH0pO1xuXG4gICAgLy8gRGVhbCB3aXRoIHNpZ21hIGV2ZW50czpcbiAgICAvLyBUT0RPOiBrZWVwIGFuIG9wdGlvbiB0byBvdmVycmlkZSB0aGUgRE9NIGV2ZW50cz9cbiAgICBzaWdtYS5taXNjLmJpbmRET01FdmVudHMuY2FsbCh0aGlzLCB0aGlzLmRvbUVsZW1lbnRzLmdyYXBoKTtcbiAgICB0aGlzLmJpbmRIb3ZlcnModGhpcy5vcHRpb25zLnByZWZpeCk7XG5cbiAgICAvLyBSZXNpemVcbiAgICB0aGlzLnJlc2l6ZShmYWxzZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJlbmRlcnMgdGhlIGdyYXBoIG9uIHRoZSBzdmcgc2NlbmUuXG4gICAqXG4gICAqIEBwYXJhbSAgez9vYmplY3R9ICAgICAgICAgICAgICAgIG9wdGlvbnMgRXZlbnR1YWxseSBhbiBvYmplY3Qgb2Ygb3B0aW9ucy5cbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLnN2Z30gICAgICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMuc3ZnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgYSxcbiAgICAgICAgaSxcbiAgICAgICAgayxcbiAgICAgICAgZSxcbiAgICAgICAgbCxcbiAgICAgICAgbyxcbiAgICAgICAgc291cmNlLFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBlZGdlcyxcbiAgICAgICAgcmVuZGVyZXJzLFxuICAgICAgICBzdWJyZW5kZXJlcnMsXG4gICAgICAgIGluZGV4ID0ge30sXG4gICAgICAgIGdyYXBoID0gdGhpcy5ncmFwaCxcbiAgICAgICAgbm9kZXMgPSB0aGlzLmdyYXBoLm5vZGVzLFxuICAgICAgICBwcmVmaXggPSB0aGlzLm9wdGlvbnMucHJlZml4IHx8ICcnLFxuICAgICAgICBkcmF3RWRnZXMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3RWRnZXMnKSxcbiAgICAgICAgZHJhd05vZGVzID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZHJhd05vZGVzJyksXG4gICAgICAgIGRyYXdMYWJlbHMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3TGFiZWxzJyksXG4gICAgICAgIGVtYmVkU2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzLmVtYmVkT2JqZWN0cyhvcHRpb25zLCB7XG4gICAgICAgICAgcHJlZml4OiB0aGlzLm9wdGlvbnMucHJlZml4LFxuICAgICAgICAgIGZvcmNlTGFiZWxzOiB0aGlzLm9wdGlvbnMuZm9yY2VMYWJlbHNcbiAgICAgICAgfSk7XG5cbiAgICAvLyBDaGVjayB0aGUgJ2hpZGVFZGdlc09uTW92ZScgc2V0dGluZzpcbiAgICBpZiAodGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnaGlkZUVkZ2VzT25Nb3ZlJykpXG4gICAgICBpZiAodGhpcy5jYW1lcmEuaXNBbmltYXRlZCB8fCB0aGlzLmNhbWVyYS5pc01vdmluZylcbiAgICAgICAgZHJhd0VkZ2VzID0gZmFsc2U7XG5cbiAgICAvLyBBcHBseSB0aGUgY2FtZXJhJ3MgdmlldzpcbiAgICB0aGlzLmNhbWVyYS5hcHBseVZpZXcoXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB0aGlzLm9wdGlvbnMucHJlZml4LFxuICAgICAge1xuICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBIaWRpbmcgZXZlcnl0aGluZ1xuICAgIC8vIFRPRE86IGZpbmQgYSBtb3JlIHNlbnNpYmxlIHdheSB0byBwZXJmb3JtIHRoaXMgb3BlcmF0aW9uXG4gICAgdGhpcy5oaWRlRE9NRWxlbWVudHModGhpcy5kb21FbGVtZW50cy5ub2Rlcyk7XG4gICAgdGhpcy5oaWRlRE9NRWxlbWVudHModGhpcy5kb21FbGVtZW50cy5lZGdlcyk7XG4gICAgdGhpcy5oaWRlRE9NRWxlbWVudHModGhpcy5kb21FbGVtZW50cy5sYWJlbHMpO1xuXG4gICAgLy8gRmluZCB3aGljaCBub2RlcyBhcmUgb24gc2NyZWVuXG4gICAgdGhpcy5lZGdlc09uU2NyZWVuID0gW107XG4gICAgdGhpcy5ub2Rlc09uU2NyZWVuID0gdGhpcy5jYW1lcmEucXVhZHRyZWUuYXJlYShcbiAgICAgIHRoaXMuY2FtZXJhLmdldFJlY3RhbmdsZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodClcbiAgICApO1xuXG4gICAgLy8gTm9kZSBpbmRleFxuICAgIGZvciAoYSA9IHRoaXMubm9kZXNPblNjcmVlbiwgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIGluZGV4W2FbaV0uaWRdID0gYVtpXTtcblxuICAgIC8vIEZpbmQgd2hpY2ggZWRnZXMgYXJlIG9uIHNjcmVlblxuICAgIGZvciAoYSA9IGdyYXBoLmVkZ2VzKCksIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIG8gPSBhW2ldO1xuICAgICAgaWYgKFxuICAgICAgICAoaW5kZXhbby5zb3VyY2VdIHx8IGluZGV4W28udGFyZ2V0XSkgJiZcbiAgICAgICAgKCFvLmhpZGRlbiAmJiAhbm9kZXMoby5zb3VyY2UpLmhpZGRlbiAmJiAhbm9kZXMoby50YXJnZXQpLmhpZGRlbilcbiAgICAgIClcbiAgICAgICAgdGhpcy5lZGdlc09uU2NyZWVuLnB1c2gobyk7XG4gICAgfVxuXG4gICAgLy8gRGlzcGxheSBub2Rlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tXG4gICAgcmVuZGVyZXJzID0gc2lnbWEuc3ZnLm5vZGVzO1xuICAgIHN1YnJlbmRlcmVycyA9IHNpZ21hLnN2Zy5sYWJlbHM7XG5cbiAgICAvLy0tIEZpcnN0IHdlIGNyZWF0ZSB0aGUgbm9kZXMgd2hpY2ggYXJlIG5vdCBhbHJlYWR5IGNyZWF0ZWRcbiAgICBpZiAoZHJhd05vZGVzKVxuICAgICAgZm9yIChhID0gdGhpcy5ub2Rlc09uU2NyZWVuLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmICghYVtpXS5oaWRkZW4gJiYgIXRoaXMuZG9tRWxlbWVudHMubm9kZXNbYVtpXS5pZF0pIHtcblxuICAgICAgICAgIC8vIE5vZGVcbiAgICAgICAgICBlID0gKHJlbmRlcmVyc1thW2ldLnR5cGVdIHx8IHJlbmRlcmVycy5kZWYpLmNyZWF0ZShcbiAgICAgICAgICAgIGFbaV0sXG4gICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMubm9kZXNbYVtpXS5pZF0gPSBlO1xuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMuZ3JvdXBzLm5vZGVzLmFwcGVuZENoaWxkKGUpO1xuXG4gICAgICAgICAgLy8gTGFiZWxcbiAgICAgICAgICBlID0gKHN1YnJlbmRlcmVyc1thW2ldLnR5cGVdIHx8IHN1YnJlbmRlcmVycy5kZWYpLmNyZWF0ZShcbiAgICAgICAgICAgIGFbaV0sXG4gICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMubGFiZWxzW2FbaV0uaWRdID0gZTtcbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLmdyb3Vwcy5sYWJlbHMuYXBwZW5kQ2hpbGQoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIC8vLS0gU2Vjb25kIHdlIHVwZGF0ZSB0aGUgbm9kZXNcbiAgICBpZiAoZHJhd05vZGVzKVxuICAgICAgZm9yIChhID0gdGhpcy5ub2Rlc09uU2NyZWVuLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cbiAgICAgICAgaWYgKGFbaV0uaGlkZGVuKVxuICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIE5vZGVcbiAgICAgICAgKHJlbmRlcmVyc1thW2ldLnR5cGVdIHx8IHJlbmRlcmVycy5kZWYpLnVwZGF0ZShcbiAgICAgICAgICBhW2ldLFxuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMubm9kZXNbYVtpXS5pZF0sXG4gICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICApO1xuXG4gICAgICAgIC8vIExhYmVsXG4gICAgICAgIChzdWJyZW5kZXJlcnNbYVtpXS50eXBlXSB8fCBzdWJyZW5kZXJlcnMuZGVmKS51cGRhdGUoXG4gICAgICAgICAgYVtpXSxcbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLmxhYmVsc1thW2ldLmlkXSxcbiAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAvLyBEaXNwbGF5IGVkZ2VzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS1cbiAgICByZW5kZXJlcnMgPSBzaWdtYS5zdmcuZWRnZXM7XG5cbiAgICAvLy0tIEZpcnN0IHdlIGNyZWF0ZSB0aGUgZWRnZXMgd2hpY2ggYXJlIG5vdCBhbHJlYWR5IGNyZWF0ZWRcbiAgICBpZiAoZHJhd0VkZ2VzKVxuICAgICAgZm9yIChhID0gdGhpcy5lZGdlc09uU2NyZWVuLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmICghdGhpcy5kb21FbGVtZW50cy5lZGdlc1thW2ldLmlkXSkge1xuICAgICAgICAgIHNvdXJjZSA9IG5vZGVzKGFbaV0uc291cmNlKTtcbiAgICAgICAgICB0YXJnZXQgPSBub2RlcyhhW2ldLnRhcmdldCk7XG5cbiAgICAgICAgICBlID0gKHJlbmRlcmVyc1thW2ldLnR5cGVdIHx8IHJlbmRlcmVycy5kZWYpLmNyZWF0ZShcbiAgICAgICAgICAgIGFbaV0sXG4gICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMuZWRnZXNbYVtpXS5pZF0gPSBlO1xuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMuZ3JvdXBzLmVkZ2VzLmFwcGVuZENoaWxkKGUpO1xuICAgICAgICB9XG4gICAgICAgfVxuXG4gICAgLy8tLSBTZWNvbmQgd2UgdXBkYXRlIHRoZSBlZGdlc1xuICAgIGlmIChkcmF3RWRnZXMpXG4gICAgICBmb3IgKGEgPSB0aGlzLmVkZ2VzT25TY3JlZW4sIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgc291cmNlID0gbm9kZXMoYVtpXS5zb3VyY2UpO1xuICAgICAgICB0YXJnZXQgPSBub2RlcyhhW2ldLnRhcmdldCk7XG5cbiAgICAgICAgKHJlbmRlcmVyc1thW2ldLnR5cGVdIHx8IHJlbmRlcmVycy5kZWYpLnVwZGF0ZShcbiAgICAgICAgICBhW2ldLFxuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMuZWRnZXNbYVtpXS5pZF0sXG4gICAgICAgICAgc291cmNlLFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICk7XG4gICAgICAgfVxuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdyZW5kZXInKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGEgRE9NIGVsZW1lbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlLCBzd2l0Y2hlcyBpdHNcbiAgICogcG9zaXRpb24gdG8gXCJhYnNvbHV0ZVwiLCByZWZlcmVuY2VzIGl0IHRvIHRoZSBkb21FbGVtZW50cyBhdHRyaWJ1dGUsIGFuZFxuICAgKiBmaW5hbGx5IGFwcGVuZHMgaXQgdG8gdGhlIGNvbnRhaW5lci5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSB0YWcgVGhlIGxhYmVsIHRhZy5cbiAgICogQHBhcmFtICB7c3RyaW5nfSBpZCAgVGhlIGlkIG9mIHRoZSBlbGVtZW50ICh0byBzdG9yZSBpdCBpbiBcImRvbUVsZW1lbnRzXCIpLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLnN2Zy5wcm90b3R5cGUuaW5pdERPTSA9IGZ1bmN0aW9uKHRhZykge1xuICAgIHZhciBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlModGhpcy5zZXR0aW5ncygneG1sbnMnKSwgdGFnKSxcbiAgICAgICAgYyA9IHRoaXMuc2V0dGluZ3MoJ2NsYXNzUHJlZml4JyksXG4gICAgICAgIGcsXG4gICAgICAgIGwsXG4gICAgICAgIGk7XG5cbiAgICBkb20uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgYyArICctc3ZnJyk7XG5cbiAgICAvLyBTZXR0aW5nIFNWRyBuYW1lc3BhY2VcbiAgICBkb20uc2V0QXR0cmlidXRlKCd4bWxucycsIHRoaXMuc2V0dGluZ3MoJ3htbG5zJykpO1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ3htbG5zOnhsaW5rJywgJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnKTtcbiAgICBkb20uc2V0QXR0cmlidXRlKCd2ZXJzaW9uJywgJzEuMScpO1xuXG4gICAgLy8gQ3JlYXRpbmcgdGhlIG1lYXN1cmVtZW50IGNhbnZhc1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBjYW52YXMuc2V0QXR0cmlidXRlKCdjbGFzcycsIGMgKyAnLW1lYXN1cmVtZW50LWNhbnZhcycpO1xuXG4gICAgLy8gQXBwZW5kaW5nIGVsZW1lbnRzXG4gICAgdGhpcy5kb21FbGVtZW50cy5ncmFwaCA9IHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGRvbSk7XG5cbiAgICAvLyBDcmVhdGluZyBncm91cHNcbiAgICB2YXIgZ3JvdXBzID0gWydlZGdlcycsICdub2RlcycsICdsYWJlbHMnLCAnaG92ZXJzJ107XG4gICAgZm9yIChpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlModGhpcy5zZXR0aW5ncygneG1sbnMnKSwgJ2cnKTtcblxuICAgICAgZy5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnaWQnLCBjICsgJy1ncm91cC0nICsgZ3JvdXBzW2ldKTtcbiAgICAgIGcuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2NsYXNzJywgYyArICctZ3JvdXAnKTtcblxuICAgICAgdGhpcy5kb21FbGVtZW50cy5ncm91cHNbZ3JvdXBzW2ldXSA9XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudHMuZ3JhcGguYXBwZW5kQ2hpbGQoZyk7XG4gICAgfVxuXG4gICAgLy8gQXBwZW5kaW5nIG1lYXN1cmVtZW50IGNhbnZhc1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgdGhpcy5tZWFzdXJlbWVudENhbnZhcyA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBoaWRlcyBhIGJhdGNoIG9mIFNWRyBET00gZWxlbWVudHMuXG4gICAqXG4gICAqIEBwYXJhbSAge2FycmF5fSAgICAgICAgICAgICAgICAgIGVsZW1lbnRzICBBbiBhcnJheSBvZiBlbGVtZW50cyB0byBoaWRlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICByZW5kZXJlciAgVGhlIHJlbmRlcmVyIHRvIHVzZS5cbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLnN2Z30gICAgICAgICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy5zdmcucHJvdG90eXBlLmhpZGVET01FbGVtZW50cyA9IGZ1bmN0aW9uKGVsZW1lbnRzKSB7XG4gICAgdmFyIG8sXG4gICAgICAgIGk7XG5cbiAgICBmb3IgKGkgaW4gZWxlbWVudHMpIHtcbiAgICAgIG8gPSBlbGVtZW50c1tpXTtcbiAgICAgIHNpZ21hLnN2Zy51dGlscy5oaWRlKG8pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBiaW5kcyB0aGUgaG92ZXIgZXZlbnRzIHRvIHRoZSByZW5kZXJlci5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSBwcmVmaXggVGhlIHJlbmRlcmVyIHByZWZpeC5cbiAgICovXG4gIC8vIFRPRE86IGFkZCBvcHRpb24gYWJvdXQgd2hldGhlciB0byBkaXNwbGF5IGhvdmVycyBvciBub3RcbiAgc2lnbWEucmVuZGVyZXJzLnN2Zy5wcm90b3R5cGUuYmluZEhvdmVycyA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHZhciByZW5kZXJlcnMgPSBzaWdtYS5zdmcuaG92ZXJzLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgaG92ZXJlZE5vZGU7XG5cbiAgICBmdW5jdGlvbiBvdmVyTm9kZShlKSB7XG4gICAgICB2YXIgbm9kZSA9IGUuZGF0YS5ub2RlLFxuICAgICAgICAgIGVtYmVkU2V0dGluZ3MgPSBzZWxmLnNldHRpbmdzLmVtYmVkT2JqZWN0cyh7XG4gICAgICAgICAgICBwcmVmaXg6IHByZWZpeFxuICAgICAgICAgIH0pO1xuXG4gICAgICBpZiAoIWVtYmVkU2V0dGluZ3MoJ2VuYWJsZUhvdmVyaW5nJykpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgdmFyIGhvdmVyID0gKHJlbmRlcmVyc1tub2RlLnR5cGVdIHx8IHJlbmRlcmVycy5kZWYpLmNyZWF0ZShcbiAgICAgICAgbm9kZSxcbiAgICAgICAgc2VsZi5kb21FbGVtZW50cy5ub2Rlc1tub2RlLmlkXSxcbiAgICAgICAgc2VsZi5tZWFzdXJlbWVudENhbnZhcyxcbiAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgKTtcblxuICAgICAgc2VsZi5kb21FbGVtZW50cy5ob3ZlcnNbbm9kZS5pZF0gPSBob3ZlcjtcblxuICAgICAgLy8gSW5zZXJ0aW5nIHRoZSBob3ZlciBpbiB0aGUgZG9tXG4gICAgICBzZWxmLmRvbUVsZW1lbnRzLmdyb3Vwcy5ob3ZlcnMuYXBwZW5kQ2hpbGQoaG92ZXIpO1xuICAgICAgaG92ZXJlZE5vZGUgPSBub2RlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG91dE5vZGUoZSkge1xuICAgICAgdmFyIG5vZGUgPSBlLmRhdGEubm9kZSxcbiAgICAgICAgICBlbWJlZFNldHRpbmdzID0gc2VsZi5zZXR0aW5ncy5lbWJlZE9iamVjdHMoe1xuICAgICAgICAgICAgcHJlZml4OiBwcmVmaXhcbiAgICAgICAgICB9KTtcblxuICAgICAgaWYgKCFlbWJlZFNldHRpbmdzKCdlbmFibGVIb3ZlcmluZycpKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIC8vIERlbGV0aW5nIGVsZW1lbnRcbiAgICAgIHNlbGYuZG9tRWxlbWVudHMuZ3JvdXBzLmhvdmVycy5yZW1vdmVDaGlsZChcbiAgICAgICAgc2VsZi5kb21FbGVtZW50cy5ob3ZlcnNbbm9kZS5pZF1cbiAgICAgICk7XG4gICAgICBob3ZlcmVkTm9kZSA9IG51bGw7XG4gICAgICBkZWxldGUgc2VsZi5kb21FbGVtZW50cy5ob3ZlcnNbbm9kZS5pZF07XG5cbiAgICAgIC8vIFJlaW5zdGF0ZVxuICAgICAgc2VsZi5kb21FbGVtZW50cy5ncm91cHMubm9kZXMuYXBwZW5kQ2hpbGQoXG4gICAgICAgIHNlbGYuZG9tRWxlbWVudHMubm9kZXNbbm9kZS5pZF1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gT1BUSU1JWkU6IHBlcmZvcm0gYSByZWFsIHVwZGF0ZSByYXRoZXIgdGhhbiBhIGRlbGV0aW9uXG4gICAgZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgaWYgKCFob3ZlcmVkTm9kZSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICB2YXIgZW1iZWRTZXR0aW5ncyA9IHNlbGYuc2V0dGluZ3MuZW1iZWRPYmplY3RzKHtcbiAgICAgICAgICAgIHByZWZpeDogcHJlZml4XG4gICAgICAgICAgfSk7XG5cbiAgICAgIC8vIERlbGV0aW5nIGVsZW1lbnQgYmVmb3JlIHVwZGF0ZVxuICAgICAgc2VsZi5kb21FbGVtZW50cy5ncm91cHMuaG92ZXJzLnJlbW92ZUNoaWxkKFxuICAgICAgICBzZWxmLmRvbUVsZW1lbnRzLmhvdmVyc1tob3ZlcmVkTm9kZS5pZF1cbiAgICAgICk7XG4gICAgICBkZWxldGUgc2VsZi5kb21FbGVtZW50cy5ob3ZlcnNbaG92ZXJlZE5vZGUuaWRdO1xuXG4gICAgICB2YXIgaG92ZXIgPSAocmVuZGVyZXJzW2hvdmVyZWROb2RlLnR5cGVdIHx8IHJlbmRlcmVycy5kZWYpLmNyZWF0ZShcbiAgICAgICAgaG92ZXJlZE5vZGUsXG4gICAgICAgIHNlbGYuZG9tRWxlbWVudHMubm9kZXNbaG92ZXJlZE5vZGUuaWRdLFxuICAgICAgICBzZWxmLm1lYXN1cmVtZW50Q2FudmFzLFxuICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICApO1xuXG4gICAgICBzZWxmLmRvbUVsZW1lbnRzLmhvdmVyc1tob3ZlcmVkTm9kZS5pZF0gPSBob3ZlcjtcblxuICAgICAgLy8gSW5zZXJ0aW5nIHRoZSBob3ZlciBpbiB0aGUgZG9tXG4gICAgICBzZWxmLmRvbUVsZW1lbnRzLmdyb3Vwcy5ob3ZlcnMuYXBwZW5kQ2hpbGQoaG92ZXIpO1xuICAgIH1cblxuICAgIC8vIEJpbmRpbmcgZXZlbnRzXG4gICAgdGhpcy5iaW5kKCdvdmVyTm9kZScsIG92ZXJOb2RlKTtcbiAgICB0aGlzLmJpbmQoJ291dE5vZGUnLCBvdXROb2RlKTtcblxuICAgIC8vIFVwZGF0ZSBvbiByZW5kZXJcbiAgICB0aGlzLmJpbmQoJ3JlbmRlcicsIHVwZGF0ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJlc2l6ZXMgZWFjaCBET00gZWxlbWVudHMgaW4gdGhlIGNvbnRhaW5lciBhbmQgc3RvcmVzIHRoZSBuZXdcbiAgICogZGltZW5zaW9ucy4gVGhlbiwgaXQgcmVuZGVycyB0aGUgZ3JhcGguXG4gICAqXG4gICAqIEBwYXJhbSAgez9udW1iZXJ9ICAgICAgICAgICAgICAgIHdpZHRoICBUaGUgbmV3IHdpZHRoIG9mIHRoZSBjb250YWluZXIuXG4gICAqIEBwYXJhbSAgez9udW1iZXJ9ICAgICAgICAgICAgICAgIGhlaWdodCBUaGUgbmV3IGhlaWdodCBvZiB0aGUgY29udGFpbmVyLlxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMuc3ZnfSAgICAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLnN2Zy5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24odywgaCkge1xuICAgIHZhciBvbGRXaWR0aCA9IHRoaXMud2lkdGgsXG4gICAgICAgIG9sZEhlaWdodCA9IHRoaXMuaGVpZ2h0LFxuICAgICAgICBwaXhlbFJhdGlvID0gMTtcblxuICAgIGlmICh3ICE9PSB1bmRlZmluZWQgJiYgaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLndpZHRoID0gdztcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgIHcgPSB0aGlzLndpZHRoO1xuICAgICAgaCA9IHRoaXMuaGVpZ2h0O1xuICAgIH1cblxuICAgIGlmIChvbGRXaWR0aCAhPT0gdGhpcy53aWR0aCB8fCBvbGRIZWlnaHQgIT09IHRoaXMuaGVpZ2h0KSB7XG4gICAgICB0aGlzLmRvbUVsZW1lbnRzLmdyYXBoLnN0eWxlLndpZHRoID0gdyArICdweCc7XG4gICAgICB0aGlzLmRvbUVsZW1lbnRzLmdyYXBoLnN0eWxlLmhlaWdodCA9IGggKyAncHgnO1xuXG4gICAgICBpZiAodGhpcy5kb21FbGVtZW50cy5ncmFwaC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzdmcnKSB7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudHMuZ3JhcGguc2V0QXR0cmlidXRlKCd3aWR0aCcsICh3ICogcGl4ZWxSYXRpbykpO1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLmdyYXBoLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgKGggKiBwaXhlbFJhdGlvKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cblxuICAvKipcbiAgICogVGhlIGxhYmVscywgbm9kZXMgYW5kIGVkZ2VzIHJlbmRlcmVycyBhcmUgc3RvcmVkIGluIHRoZSB0aHJlZSBmb2xsb3dpbmdcbiAgICogb2JqZWN0cy4gV2hlbiBhbiBlbGVtZW50IGlzIGRyYXduLCBpdHMgdHlwZSB3aWxsIGJlIGNoZWNrZWQgYW5kIGlmIGFcbiAgICogcmVuZGVyZXIgd2l0aCB0aGUgc2FtZSBuYW1lIGV4aXN0cywgaXQgd2lsbCBiZSB1c2VkLiBJZiBub3QgZm91bmQsIHRoZVxuICAgKiBkZWZhdWx0IHJlbmRlcmVyIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxuICAgKlxuICAgKiBUaGV5IGFyZSBzdG9yZWQgaW4gZGlmZmVyZW50IGZpbGVzLCBpbiB0aGUgXCIuL3N2Z1wiIGZvbGRlci5cbiAgICovXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc3ZnLm5vZGVzJyk7XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc3ZnLmVkZ2VzJyk7XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc3ZnLmxhYmVscycpO1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbihnbG9iYWwpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEucmVuZGVyZXJzJyk7XG5cbiAgLy8gQ2hlY2sgaWYgV2ViR0wgaXMgZW5hYmxlZDpcbiAgdmFyIGNhbnZhcyxcbiAgICAgIHdlYmdsID0gISFnbG9iYWwuV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xuICBpZiAod2ViZ2wpIHtcbiAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB0cnkge1xuICAgICAgd2ViZ2wgPSAhIShcbiAgICAgICAgY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJykgfHxcbiAgICAgICAgY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcpXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHdlYmdsID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gQ29weSB0aGUgZ29vZCByZW5kZXJlcjpcbiAgc2lnbWEucmVuZGVyZXJzLmRlZiA9IHdlYmdsID9cbiAgICBzaWdtYS5yZW5kZXJlcnMud2ViZ2wgOlxuICAgIHNpZ21hLnJlbmRlcmVycy5jYW52YXM7XG59KSh0aGlzKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEud2ViZ2wubm9kZXMnKTtcblxuICAvKipcbiAgICogVGhpcyBub2RlIHJlbmRlcmVyIHdpbGwgZGlzcGxheSBub2RlcyBhcyBkaXNjcywgc2hhcGVkIGluIHRyaWFuZ2xlcyB3aXRoXG4gICAqIHRoZSBnbC5UUklBTkdMRVMgZGlzcGxheSBtb2RlLiBTbywgdG8gYmUgbW9yZSBwcmVjaXNlLCB0byBkcmF3IG9uZSBub2RlLFxuICAgKiBpdCB3aWxsIHN0b3JlIHRocmVlIHRpbWVzIHRoZSBjZW50ZXIgb2Ygbm9kZSwgd2l0aCB0aGUgY29sb3IgYW5kIHRoZSBzaXplLFxuICAgKiBhbmQgYW4gYW5nbGUgaW5kaWNhdGluZyB3aGljaCBcImNvcm5lclwiIG9mIHRoZSB0cmlhbmdsZSB0byBkcmF3LlxuICAgKlxuICAgKiBUaGUgZnJhZ21lbnQgc2hhZGVyIGRvZXMgbm90IGRlYWwgd2l0aCBhbnRpLWFsaWFzaW5nLCBzbyBtYWtlIHN1cmUgdGhhdFxuICAgKiB5b3UgZGVhbCB3aXRoIGl0IHNvbWV3aGVyZSBlbHNlIGluIHRoZSBjb2RlIChieSBkZWZhdWx0LCB0aGUgV2ViR0xcbiAgICogcmVuZGVyZXIgd2lsbCBvdmVyc2FtcGxlIHRoZSByZW5kZXJpbmcgdGhyb3VnaCB0aGUgd2ViZ2xPdmVyc2FtcGxpbmdSYXRpb1xuICAgKiB2YWx1ZSkuXG4gICAqL1xuICBzaWdtYS53ZWJnbC5ub2Rlcy5kZWYgPSB7XG4gICAgUE9JTlRTOiAzLFxuICAgIEFUVFJJQlVURVM6IDUsXG4gICAgYWRkTm9kZTogZnVuY3Rpb24obm9kZSwgZGF0YSwgaSwgcHJlZml4LCBzZXR0aW5ncykge1xuICAgICAgdmFyIGNvbG9yID0gc2lnbWEudXRpbHMuZmxvYXRDb2xvcihcbiAgICAgICAgbm9kZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpXG4gICAgICApO1xuXG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICd4J107XG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICd5J107XG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICdzaXplJ107XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcbiAgICAgIGRhdGFbaSsrXSA9IDA7XG5cbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3gnXTtcbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3knXTtcbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXTtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuICAgICAgZGF0YVtpKytdID0gMiAqIE1hdGguUEkgLyAzO1xuXG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICd4J107XG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICd5J107XG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICdzaXplJ107XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcbiAgICAgIGRhdGFbaSsrXSA9IDQgKiBNYXRoLlBJIC8gMztcbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24oZ2wsIHByb2dyYW0sIGRhdGEsIHBhcmFtcykge1xuICAgICAgdmFyIGJ1ZmZlcjtcblxuICAgICAgLy8gRGVmaW5lIGF0dHJpYnV0ZXM6XG4gICAgICB2YXIgcG9zaXRpb25Mb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9wb3NpdGlvbicpLFxuICAgICAgICAgIHNpemVMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9zaXplJyksXG4gICAgICAgICAgY29sb3JMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9jb2xvcicpLFxuICAgICAgICAgIGFuZ2xlTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfYW5nbGUnKSxcbiAgICAgICAgICByZXNvbHV0aW9uTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3Jlc29sdXRpb24nKSxcbiAgICAgICAgICBtYXRyaXhMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfbWF0cml4JyksXG4gICAgICAgICAgcmF0aW9Mb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfcmF0aW8nKSxcbiAgICAgICAgICBzY2FsZUxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9zY2FsZScpO1xuXG4gICAgICBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGRhdGEsIGdsLkRZTkFNSUNfRFJBVyk7XG5cbiAgICAgIGdsLnVuaWZvcm0yZihyZXNvbHV0aW9uTG9jYXRpb24sIHBhcmFtcy53aWR0aCwgcGFyYW1zLmhlaWdodCk7XG4gICAgICBnbC51bmlmb3JtMWYoXG4gICAgICAgIHJhdGlvTG9jYXRpb24sXG4gICAgICAgIDEgLyBNYXRoLnBvdyhwYXJhbXMucmF0aW8sIHBhcmFtcy5zZXR0aW5ncygnbm9kZXNQb3dSYXRpbycpKVxuICAgICAgKTtcbiAgICAgIGdsLnVuaWZvcm0xZihzY2FsZUxvY2F0aW9uLCBwYXJhbXMuc2NhbGluZ1JhdGlvKTtcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYobWF0cml4TG9jYXRpb24sIGZhbHNlLCBwYXJhbXMubWF0cml4KTtcblxuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25Mb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShzaXplTG9jYXRpb24pO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoY29sb3JMb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhbmdsZUxvY2F0aW9uKTtcblxuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICAgICAgcG9zaXRpb25Mb2NhdGlvbixcbiAgICAgICAgMixcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgICBzaXplTG9jYXRpb24sXG4gICAgICAgIDEsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICA4XG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICAgICAgY29sb3JMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDEyXG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICAgICAgYW5nbGVMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDE2XG4gICAgICApO1xuXG4gICAgICBnbC5kcmF3QXJyYXlzKFxuICAgICAgICBnbC5UUklBTkdMRVMsXG4gICAgICAgIHBhcmFtcy5zdGFydCB8fCAwLFxuICAgICAgICBwYXJhbXMuY291bnQgfHwgKGRhdGEubGVuZ3RoIC8gdGhpcy5BVFRSSUJVVEVTKVxuICAgICAgKTtcbiAgICB9LFxuICAgIGluaXRQcm9ncmFtOiBmdW5jdGlvbihnbCkge1xuICAgICAgdmFyIHZlcnRleFNoYWRlcixcbiAgICAgICAgICBmcmFnbWVudFNoYWRlcixcbiAgICAgICAgICBwcm9ncmFtO1xuXG4gICAgICB2ZXJ0ZXhTaGFkZXIgPSBzaWdtYS51dGlscy5sb2FkU2hhZGVyKFxuICAgICAgICBnbCxcbiAgICAgICAgW1xuICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uOycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX3NpemU7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfY29sb3I7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfYW5nbGU7JyxcblxuICAgICAgICAgICd1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uOycsXG4gICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdV9yYXRpbzsnLFxuICAgICAgICAgICd1bmlmb3JtIGZsb2F0IHVfc2NhbGU7JyxcbiAgICAgICAgICAndW5pZm9ybSBtYXQzIHVfbWF0cml4OycsXG5cbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXG4gICAgICAgICAgJ3ZhcnlpbmcgdmVjMiBjZW50ZXI7JyxcbiAgICAgICAgICAndmFyeWluZyBmbG9hdCByYWRpdXM7JyxcblxuICAgICAgICAgICd2b2lkIG1haW4oKSB7JyxcbiAgICAgICAgICAgIC8vIE11bHRpcGx5IHRoZSBwb2ludCBzaXplIHR3aWNlOlxuICAgICAgICAgICAgJ3JhZGl1cyA9IGFfc2l6ZSAqIHVfcmF0aW87JyxcblxuICAgICAgICAgICAgLy8gU2NhbGUgZnJvbSBbWy0xIDFdIFstMSAxXV0gdG8gdGhlIGNvbnRhaW5lcjpcbiAgICAgICAgICAgICd2ZWMyIHBvc2l0aW9uID0gKHVfbWF0cml4ICogdmVjMyhhX3Bvc2l0aW9uLCAxKSkueHk7JyxcbiAgICAgICAgICAgIC8vICdjZW50ZXIgPSAocG9zaXRpb24gLyB1X3Jlc29sdXRpb24gKiAyLjAgLSAxLjApICogdmVjMigxLCAtMSk7JyxcbiAgICAgICAgICAgICdjZW50ZXIgPSBwb3NpdGlvbiAqIHVfc2NhbGU7JyxcbiAgICAgICAgICAgICdjZW50ZXIgPSB2ZWMyKGNlbnRlci54LCB1X3NjYWxlICogdV9yZXNvbHV0aW9uLnkgLSBjZW50ZXIueSk7JyxcblxuICAgICAgICAgICAgJ3Bvc2l0aW9uID0gcG9zaXRpb24gKycsXG4gICAgICAgICAgICAgICcyLjAgKiByYWRpdXMgKiB2ZWMyKGNvcyhhX2FuZ2xlKSwgc2luKGFfYW5nbGUpKTsnLFxuICAgICAgICAgICAgJ3Bvc2l0aW9uID0gKHBvc2l0aW9uIC8gdV9yZXNvbHV0aW9uICogMi4wIC0gMS4wKSAqIHZlYzIoMSwgLTEpOycsXG5cbiAgICAgICAgICAgICdyYWRpdXMgPSByYWRpdXMgKiB1X3NjYWxlOycsXG5cbiAgICAgICAgICAgICdnbF9Qb3NpdGlvbiA9IHZlYzQocG9zaXRpb24sIDAsIDEpOycsXG5cbiAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIGNvbG9yOlxuICAgICAgICAgICAgJ2Zsb2F0IGMgPSBhX2NvbG9yOycsXG4gICAgICAgICAgICAnY29sb3IuYiA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOycsXG4gICAgICAgICAgICAnY29sb3IuZyA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOycsXG4gICAgICAgICAgICAnY29sb3IuciA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOyBjb2xvciAvPSAyNTUuMDsnLFxuICAgICAgICAgICAgJ2NvbG9yLmEgPSAxLjA7JyxcbiAgICAgICAgICAnfSdcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgICAgZ2wuVkVSVEVYX1NIQURFUlxuICAgICAgKTtcblxuICAgICAgZnJhZ21lbnRTaGFkZXIgPSBzaWdtYS51dGlscy5sb2FkU2hhZGVyKFxuICAgICAgICBnbCxcbiAgICAgICAgW1xuICAgICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxuXG4gICAgICAgICAgJ3ZhcnlpbmcgdmVjNCBjb2xvcjsnLFxuICAgICAgICAgICd2YXJ5aW5nIHZlYzIgY2VudGVyOycsXG4gICAgICAgICAgJ3ZhcnlpbmcgZmxvYXQgcmFkaXVzOycsXG5cbiAgICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAgICAgJ3ZlYzQgY29sb3IwID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApOycsXG5cbiAgICAgICAgICAgICd2ZWMyIG0gPSBnbF9GcmFnQ29vcmQueHkgLSBjZW50ZXI7JyxcbiAgICAgICAgICAgICdmbG9hdCBkaWZmID0gcmFkaXVzIC0gc3FydChtLnggKiBtLnggKyBtLnkgKiBtLnkpOycsXG5cbiAgICAgICAgICAgIC8vIEhlcmUgaXMgaG93IHdlIGRyYXcgYSBkaXNjIGluc3RlYWQgb2YgYSBzcXVhcmU6XG4gICAgICAgICAgICAnaWYgKGRpZmYgPiAwLjApJyxcbiAgICAgICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yOycsXG4gICAgICAgICAgICAnZWxzZScsXG4gICAgICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjA7JyxcbiAgICAgICAgICAnfSdcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgICAgZ2wuRlJBR01FTlRfU0hBREVSXG4gICAgICApO1xuXG4gICAgICBwcm9ncmFtID0gc2lnbWEudXRpbHMubG9hZFByb2dyYW0oZ2wsIFt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyXSk7XG5cbiAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLndlYmdsLm5vZGVzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgbm9kZSByZW5kZXJlciB3aWxsIGRpc3BsYXkgbm9kZXMgaW4gdGhlIGZhc3Rlc3Qgd2F5OiBOb2RlcyBhcmUgYmFzaWNcbiAgICogc3F1YXJlcywgZHJhd24gdGhyb3VnaCB0aGUgZ2wuUE9JTlRTIGRyYXdpbmcgbWV0aG9kLiBUaGUgc2l6ZSBvZiB0aGUgbm9kZXNcbiAgICogYXJlIHJlcHJlc2VudGVkIHdpdGggdGhlIFwiZ2xfUG9pbnRTaXplXCIgdmFsdWUgaW4gdGhlIHZlcnRleCBzaGFkZXIuXG4gICAqXG4gICAqIEl0IGlzIHRoZSBmYXN0ZXN0IG5vZGUgcmVuZGVyZXIgaGVyZSBzaW5jZSB0aGUgYnVmZmVyIGp1c3QgdGFrZXMgb25lIGxpbmVcbiAgICogdG8gZHJhdyBlYWNoIG5vZGUgKHdpdGggYXR0cmlidXRlcyBcInhcIiwgXCJ5XCIsIFwic2l6ZVwiIGFuZCBcImNvbG9yXCIpLlxuICAgKlxuICAgKiBOZXZlcnRoZWxlc3MsIHRoaXMgbWV0aG9kIGhhcyBzb21lIHByb2JsZW1zLCBlc3BlY2lhbGx5IGR1ZSB0byBzb21lIGlzc3Vlc1xuICAgKiB3aXRoIHRoZSBnbC5QT0lOVFM6XG4gICAqICAtIEZpcnN0LCBpZiB0aGUgY2VudGVyIG9mIGEgbm9kZSBpcyBvdXRzaWRlIHRoZSBzY2VuZSwgdGhlIHBvaW50IHdpbGwgbm90XG4gICAqICAgIGJlIGRyYXduLCBldmVuIGlmIGl0IHNob3VsZCBiZSBwYXJ0bHkgb24gc2NyZWVuLlxuICAgKiAgLSBJIHRyaWVkIGFwcGx5aW5nIGEgZnJhZ21lbnQgc2hhZGVyIHNpbWlsYXIgdG8gdGhlIG9uZSBpbiB0aGUgZGVmYXVsdFxuICAgKiAgICBub2RlIHJlbmRlcmVyIHRvIGRpc3BsYXkgdGhlbSBhcyBkaXNjcywgYnV0IGl0IGRpZCBub3Qgd29yayBmaW5lIG9uXG4gICAqICAgIHNvbWUgY29tcHV0ZXJzIHNldHRpbmdzLCBmaWxsaW5nIHRoZSBkaXNjcyB3aXRoIHdlaXJkIGdyYWRpZW50cyBub3RcbiAgICogICAgZGVwZW5kaW5nIG9uIHRoZSBhY3R1YWwgY29sb3IuXG4gICAqL1xuICBzaWdtYS53ZWJnbC5ub2Rlcy5mYXN0ID0ge1xuICAgIFBPSU5UUzogMSxcbiAgICBBVFRSSUJVVEVTOiA0LFxuICAgIGFkZE5vZGU6IGZ1bmN0aW9uKG5vZGUsIGRhdGEsIGksIHByZWZpeCwgc2V0dGluZ3MpIHtcbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3gnXTtcbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3knXTtcbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXTtcbiAgICAgIGRhdGFbaSsrXSA9IHNpZ21hLnV0aWxzLmZsb2F0Q29sb3IoXG4gICAgICAgIG5vZGUuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKVxuICAgICAgKTtcbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24oZ2wsIHByb2dyYW0sIGRhdGEsIHBhcmFtcykge1xuICAgICAgdmFyIGJ1ZmZlcjtcblxuICAgICAgLy8gRGVmaW5lIGF0dHJpYnV0ZXM6XG4gICAgICB2YXIgcG9zaXRpb25Mb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9wb3NpdGlvbicpLFxuICAgICAgICAgIHNpemVMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9zaXplJyksXG4gICAgICAgICAgY29sb3JMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9jb2xvcicpLFxuICAgICAgICAgIHJlc29sdXRpb25Mb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfcmVzb2x1dGlvbicpLFxuICAgICAgICAgIG1hdHJpeExvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9tYXRyaXgnKSxcbiAgICAgICAgICByYXRpb0xvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9yYXRpbycpLFxuICAgICAgICAgIHNjYWxlTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3NjYWxlJyk7XG5cbiAgICAgIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZGF0YSwgZ2wuRFlOQU1JQ19EUkFXKTtcblxuICAgICAgZ2wudW5pZm9ybTJmKHJlc29sdXRpb25Mb2NhdGlvbiwgcGFyYW1zLndpZHRoLCBwYXJhbXMuaGVpZ2h0KTtcbiAgICAgIGdsLnVuaWZvcm0xZihcbiAgICAgICAgcmF0aW9Mb2NhdGlvbixcbiAgICAgICAgMSAvIE1hdGgucG93KHBhcmFtcy5yYXRpbywgcGFyYW1zLnNldHRpbmdzKCdub2Rlc1Bvd1JhdGlvJykpXG4gICAgICApO1xuICAgICAgZ2wudW5pZm9ybTFmKHNjYWxlTG9jYXRpb24sIHBhcmFtcy5zY2FsaW5nUmF0aW8pO1xuICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihtYXRyaXhMb2NhdGlvbiwgZmFsc2UsIHBhcmFtcy5tYXRyaXgpO1xuXG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkxvY2F0aW9uKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHNpemVMb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShjb2xvckxvY2F0aW9uKTtcblxuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICAgICAgcG9zaXRpb25Mb2NhdGlvbixcbiAgICAgICAgMixcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgICBzaXplTG9jYXRpb24sXG4gICAgICAgIDEsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICA4XG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICAgICAgY29sb3JMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDEyXG4gICAgICApO1xuXG4gICAgICBnbC5kcmF3QXJyYXlzKFxuICAgICAgICBnbC5QT0lOVFMsXG4gICAgICAgIHBhcmFtcy5zdGFydCB8fCAwLFxuICAgICAgICBwYXJhbXMuY291bnQgfHwgKGRhdGEubGVuZ3RoIC8gdGhpcy5BVFRSSUJVVEVTKVxuICAgICAgKTtcbiAgICB9LFxuICAgIGluaXRQcm9ncmFtOiBmdW5jdGlvbihnbCkge1xuICAgICAgdmFyIHZlcnRleFNoYWRlcixcbiAgICAgICAgICBmcmFnbWVudFNoYWRlcixcbiAgICAgICAgICBwcm9ncmFtO1xuXG4gICAgICB2ZXJ0ZXhTaGFkZXIgPSBzaWdtYS51dGlscy5sb2FkU2hhZGVyKFxuICAgICAgICBnbCxcbiAgICAgICAgW1xuICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uOycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX3NpemU7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfY29sb3I7JyxcblxuICAgICAgICAgICd1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uOycsXG4gICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdV9yYXRpbzsnLFxuICAgICAgICAgICd1bmlmb3JtIGZsb2F0IHVfc2NhbGU7JyxcbiAgICAgICAgICAndW5pZm9ybSBtYXQzIHVfbWF0cml4OycsXG5cbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXG5cbiAgICAgICAgICAndm9pZCBtYWluKCkgeycsXG4gICAgICAgICAgICAvLyBTY2FsZSBmcm9tIFtbLTEgMV0gWy0xIDFdXSB0byB0aGUgY29udGFpbmVyOlxuICAgICAgICAgICAgJ2dsX1Bvc2l0aW9uID0gdmVjNCgnLFxuICAgICAgICAgICAgICAnKCh1X21hdHJpeCAqIHZlYzMoYV9wb3NpdGlvbiwgMSkpLnh5IC8nLFxuICAgICAgICAgICAgICAgICd1X3Jlc29sdXRpb24gKiAyLjAgLSAxLjApICogdmVjMigxLCAtMSksJyxcbiAgICAgICAgICAgICAgJzAsJyxcbiAgICAgICAgICAgICAgJzEnLFxuICAgICAgICAgICAgJyk7JyxcblxuICAgICAgICAgICAgLy8gTXVsdGlwbHkgdGhlIHBvaW50IHNpemUgdHdpY2U6XG4gICAgICAgICAgICAvLyAgLSB4IFNDQUxJTkdfUkFUSU8gdG8gY29ycmVjdCB0aGUgY2FudmFzIHNjYWxpbmdcbiAgICAgICAgICAgIC8vICAtIHggMiB0byBjb3JyZWN0IHRoZSBmb3JtdWxhZVxuICAgICAgICAgICAgJ2dsX1BvaW50U2l6ZSA9IGFfc2l6ZSAqIHVfcmF0aW8gKiB1X3NjYWxlICogMi4wOycsXG5cbiAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIGNvbG9yOlxuICAgICAgICAgICAgJ2Zsb2F0IGMgPSBhX2NvbG9yOycsXG4gICAgICAgICAgICAnY29sb3IuYiA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOycsXG4gICAgICAgICAgICAnY29sb3IuZyA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOycsXG4gICAgICAgICAgICAnY29sb3IuciA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOyBjb2xvciAvPSAyNTUuMDsnLFxuICAgICAgICAgICAgJ2NvbG9yLmEgPSAxLjA7JyxcbiAgICAgICAgICAnfSdcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgICAgZ2wuVkVSVEVYX1NIQURFUlxuICAgICAgKTtcblxuICAgICAgZnJhZ21lbnRTaGFkZXIgPSBzaWdtYS51dGlscy5sb2FkU2hhZGVyKFxuICAgICAgICBnbCxcbiAgICAgICAgW1xuICAgICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxuXG4gICAgICAgICAgJ3ZhcnlpbmcgdmVjNCBjb2xvcjsnLFxuXG4gICAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcbiAgICAgICAgICAgICdmbG9hdCBib3JkZXIgPSAwLjAxOycsXG4gICAgICAgICAgICAnZmxvYXQgcmFkaXVzID0gMC41OycsXG5cbiAgICAgICAgICAgICd2ZWM0IGNvbG9yMCA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4wKTsnLFxuICAgICAgICAgICAgJ3ZlYzIgbSA9IGdsX1BvaW50Q29vcmQgLSB2ZWMyKDAuNSwgMC41KTsnLFxuICAgICAgICAgICAgJ2Zsb2F0IGRpc3QgPSByYWRpdXMgLSBzcXJ0KG0ueCAqIG0ueCArIG0ueSAqIG0ueSk7JyxcblxuICAgICAgICAgICAgJ2Zsb2F0IHQgPSAwLjA7JyxcbiAgICAgICAgICAgICdpZiAoZGlzdCA+IGJvcmRlciknLFxuICAgICAgICAgICAgICAndCA9IDEuMDsnLFxuICAgICAgICAgICAgJ2Vsc2UgaWYgKGRpc3QgPiAwLjApJyxcbiAgICAgICAgICAgICAgJ3QgPSBkaXN0IC8gYm9yZGVyOycsXG5cbiAgICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBtaXgoY29sb3IwLCBjb2xvciwgdCk7JyxcbiAgICAgICAgICAnfSdcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgICAgZ2wuRlJBR01FTlRfU0hBREVSXG4gICAgICApO1xuXG4gICAgICBwcm9ncmFtID0gc2lnbWEudXRpbHMubG9hZFByb2dyYW0oZ2wsIFt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyXSk7XG5cbiAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLndlYmdsLmVkZ2VzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgZWRnZSByZW5kZXJlciB3aWxsIGRpc3BsYXkgZWRnZXMgYXMgbGluZXMgZ29pbmcgZnJvbSB0aGUgc291cmNlIG5vZGVcbiAgICogdG8gdGhlIHRhcmdldCBub2RlLiBUbyBkZWFsIHdpdGggZWRnZSB0aGlja25lc3NlcywgdGhlIGxpbmVzIGFyZSBtYWRlIG9mXG4gICAqIHR3byB0cmlhbmdsZXMgZm9ybWluZyByZWN0YW5nbGVzLCB3aXRoIHRoZSBnbC5UUklBTkdMRVMgZHJhd2luZyBtb2RlLlxuICAgKlxuICAgKiBJdCBpcyBleHBlbnNpdmUsIHNpbmNlIGRyYXdpbmcgYSBzaW5nbGUgZWRnZSByZXF1aXJlcyA2IHBvaW50cywgZWFjaFxuICAgKiBoYXZpbmcgNyBhdHRyaWJ1dGVzIChzb3VyY2UgcG9zaXRpb24sIHRhcmdldCBwb3NpdGlvbiwgdGhpY2tuZXNzLCBjb2xvclxuICAgKiBhbmQgYSBmbGFnIGluZGljYXRpbmcgd2hpY2ggdmVydGljZSBvZiB0aGUgcmVjdGFuZ2xlIGl0IGlzKS5cbiAgICovXG4gIHNpZ21hLndlYmdsLmVkZ2VzLmRlZiA9IHtcbiAgICBQT0lOVFM6IDYsXG4gICAgQVRUUklCVVRFUzogNyxcbiAgICBhZGRFZGdlOiBmdW5jdGlvbihlZGdlLCBzb3VyY2UsIHRhcmdldCwgZGF0YSwgaSwgcHJlZml4LCBzZXR0aW5ncykge1xuICAgICAgdmFyIHcgPSAoZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEpIC8gMixcbiAgICAgICAgICB4MSA9IHNvdXJjZVtwcmVmaXggKyAneCddLFxuICAgICAgICAgIHkxID0gc291cmNlW3ByZWZpeCArICd5J10sXG4gICAgICAgICAgeDIgPSB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICB5MiA9IHRhcmdldFtwcmVmaXggKyAneSddLFxuICAgICAgICAgIGNvbG9yID0gZWRnZS5jb2xvcjtcblxuICAgICAgaWYgKCFjb2xvcilcbiAgICAgICAgc3dpdGNoIChzZXR0aW5ncygnZWRnZUNvbG9yJykpIHtcbiAgICAgICAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgICAgICAgY29sb3IgPSBzb3VyY2UuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3RhcmdldCc6XG4gICAgICAgICAgICBjb2xvciA9IHRhcmdldC5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHRFZGdlQ29sb3InKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIC8vIE5vcm1hbGl6ZSBjb2xvcjpcbiAgICAgIGNvbG9yID0gc2lnbWEudXRpbHMuZmxvYXRDb2xvcihjb2xvcik7XG5cbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSB4MjtcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xuICAgICAgZGF0YVtpKytdID0gdztcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuXG4gICAgICBkYXRhW2krK10gPSB4MjtcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xuICAgICAgZGF0YVtpKytdID0geDE7XG4gICAgICBkYXRhW2krK10gPSB5MTtcbiAgICAgIGRhdGFbaSsrXSA9IHc7XG4gICAgICBkYXRhW2krK10gPSAxLjA7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcblxuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSB3O1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG5cbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xuICAgICAgZGF0YVtpKytdID0geTI7XG4gICAgICBkYXRhW2krK10gPSB4MTtcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xuICAgICAgZGF0YVtpKytdID0gdztcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuXG4gICAgICBkYXRhW2krK10gPSB4MTtcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IHc7XG4gICAgICBkYXRhW2krK10gPSAxLjA7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcblxuICAgICAgZGF0YVtpKytdID0geDE7XG4gICAgICBkYXRhW2krK10gPSB5MTtcbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xuICAgICAgZGF0YVtpKytdID0geTI7XG4gICAgICBkYXRhW2krK10gPSB3O1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtLCBkYXRhLCBwYXJhbXMpIHtcbiAgICAgIHZhciBidWZmZXI7XG5cbiAgICAgIC8vIERlZmluZSBhdHRyaWJ1dGVzOlxuICAgICAgdmFyIGNvbG9yTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfY29sb3InKSxcbiAgICAgICAgICBwb3NpdGlvbkxvY2F0aW9uMSA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9wb3NpdGlvbjEnKSxcbiAgICAgICAgICBwb3NpdGlvbkxvY2F0aW9uMiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9wb3NpdGlvbjInKSxcbiAgICAgICAgICB0aGlja25lc3NMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV90aGlja25lc3MnKSxcbiAgICAgICAgICBtaW51c0xvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX21pbnVzJyksXG4gICAgICAgICAgcmVzb2x1dGlvbkxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9yZXNvbHV0aW9uJyksXG4gICAgICAgICAgbWF0cml4TG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X21hdHJpeCcpLFxuICAgICAgICAgIG1hdHJpeEhhbGZQaUxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9tYXRyaXhIYWxmUGknKSxcbiAgICAgICAgICBtYXRyaXhIYWxmUGlNaW51c0xvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9tYXRyaXhIYWxmUGlNaW51cycpLFxuICAgICAgICAgIHJhdGlvTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3JhdGlvJyksXG4gICAgICAgICAgc2NhbGVMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Vfc2NhbGUnKTtcblxuICAgICAgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBkYXRhLCBnbC5TVEFUSUNfRFJBVyk7XG5cbiAgICAgIGdsLnVuaWZvcm0yZihyZXNvbHV0aW9uTG9jYXRpb24sIHBhcmFtcy53aWR0aCwgcGFyYW1zLmhlaWdodCk7XG4gICAgICBnbC51bmlmb3JtMWYoXG4gICAgICAgIHJhdGlvTG9jYXRpb24sXG4gICAgICAgIHBhcmFtcy5yYXRpbyAvIE1hdGgucG93KHBhcmFtcy5yYXRpbywgcGFyYW1zLnNldHRpbmdzKCdlZGdlc1Bvd1JhdGlvJykpXG4gICAgICApO1xuICAgICAgZ2wudW5pZm9ybTFmKHNjYWxlTG9jYXRpb24sIHBhcmFtcy5zY2FsaW5nUmF0aW8pO1xuICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihtYXRyaXhMb2NhdGlvbiwgZmFsc2UsIHBhcmFtcy5tYXRyaXgpO1xuICAgICAgZ2wudW5pZm9ybU1hdHJpeDJmdihcbiAgICAgICAgbWF0cml4SGFsZlBpTG9jYXRpb24sXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBzaWdtYS51dGlscy5tYXRyaWNlcy5yb3RhdGlvbihNYXRoLlBJIC8gMiwgdHJ1ZSlcbiAgICAgICk7XG4gICAgICBnbC51bmlmb3JtTWF0cml4MmZ2KFxuICAgICAgICBtYXRyaXhIYWxmUGlNaW51c0xvY2F0aW9uLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgc2lnbWEudXRpbHMubWF0cmljZXMucm90YXRpb24oLU1hdGguUEkgLyAyLCB0cnVlKVxuICAgICAgKTtcblxuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoY29sb3JMb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkxvY2F0aW9uMSk7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkxvY2F0aW9uMik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlja25lc3NMb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShtaW51c0xvY2F0aW9uKTtcblxuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NpdGlvbkxvY2F0aW9uMSxcbiAgICAgICAgMixcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBvc2l0aW9uTG9jYXRpb24yLFxuICAgICAgICAyLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgOFxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpY2tuZXNzTG9jYXRpb24sXG4gICAgICAgIDEsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICAxNlxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIobWludXNMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDIwXG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihjb2xvckxvY2F0aW9uLFxuICAgICAgICAxLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMjRcbiAgICAgICk7XG5cbiAgICAgIGdsLmRyYXdBcnJheXMoXG4gICAgICAgIGdsLlRSSUFOR0xFUyxcbiAgICAgICAgcGFyYW1zLnN0YXJ0IHx8IDAsXG4gICAgICAgIHBhcmFtcy5jb3VudCB8fCAoZGF0YS5sZW5ndGggLyB0aGlzLkFUVFJJQlVURVMpXG4gICAgICApO1xuICAgIH0sXG4gICAgaW5pdFByb2dyYW06IGZ1bmN0aW9uKGdsKSB7XG4gICAgICB2YXIgdmVydGV4U2hhZGVyLFxuICAgICAgICAgIGZyYWdtZW50U2hhZGVyLFxuICAgICAgICAgIHByb2dyYW07XG5cbiAgICAgIHZlcnRleFNoYWRlciA9IHNpZ21hLnV0aWxzLmxvYWRTaGFkZXIoXG4gICAgICAgIGdsLFxuICAgICAgICBbXG4gICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb24xOycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb24yOycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX3RoaWNrbmVzczsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9taW51czsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9jb2xvcjsnLFxuXG4gICAgICAgICAgJ3VuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247JyxcbiAgICAgICAgICAndW5pZm9ybSBmbG9hdCB1X3JhdGlvOycsXG4gICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdV9zY2FsZTsnLFxuICAgICAgICAgICd1bmlmb3JtIG1hdDMgdV9tYXRyaXg7JyxcbiAgICAgICAgICAndW5pZm9ybSBtYXQyIHVfbWF0cml4SGFsZlBpOycsXG4gICAgICAgICAgJ3VuaWZvcm0gbWF0MiB1X21hdHJpeEhhbGZQaU1pbnVzOycsXG5cbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXG5cbiAgICAgICAgICAndm9pZCBtYWluKCkgeycsXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBnb29kIHBvaW50OlxuICAgICAgICAgICAgJ3ZlYzIgcG9zaXRpb24gPSBhX3RoaWNrbmVzcyAqIHVfcmF0aW8gKicsXG4gICAgICAgICAgICAgICdub3JtYWxpemUoYV9wb3NpdGlvbjIgLSBhX3Bvc2l0aW9uMSk7JyxcblxuICAgICAgICAgICAgJ21hdDIgbWF0cml4ID0gYV9taW51cyAqIHVfbWF0cml4SGFsZlBpTWludXMgKycsXG4gICAgICAgICAgICAgICcoMS4wIC0gYV9taW51cykgKiB1X21hdHJpeEhhbGZQaTsnLFxuXG4gICAgICAgICAgICAncG9zaXRpb24gPSBtYXRyaXggKiBwb3NpdGlvbiArIGFfcG9zaXRpb24xOycsXG5cbiAgICAgICAgICAgIC8vIFNjYWxlIGZyb20gW1stMSAxXSBbLTEgMV1dIHRvIHRoZSBjb250YWluZXI6XG4gICAgICAgICAgICAnZ2xfUG9zaXRpb24gPSB2ZWM0KCcsXG4gICAgICAgICAgICAgICcoKHVfbWF0cml4ICogdmVjMyhwb3NpdGlvbiwgMSkpLnh5IC8nLFxuICAgICAgICAgICAgICAgICd1X3Jlc29sdXRpb24gKiAyLjAgLSAxLjApICogdmVjMigxLCAtMSksJyxcbiAgICAgICAgICAgICAgJzAsJyxcbiAgICAgICAgICAgICAgJzEnLFxuICAgICAgICAgICAgJyk7JyxcblxuICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgY29sb3I6XG4gICAgICAgICAgICAnZmxvYXQgYyA9IGFfY29sb3I7JyxcbiAgICAgICAgICAgICdjb2xvci5iID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcbiAgICAgICAgICAgICdjb2xvci5nID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcbiAgICAgICAgICAgICdjb2xvci5yID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7IGNvbG9yIC89IDI1NS4wOycsXG4gICAgICAgICAgICAnY29sb3IuYSA9IDEuMDsnLFxuICAgICAgICAgICd9J1xuICAgICAgICBdLmpvaW4oJ1xcbicpLFxuICAgICAgICBnbC5WRVJURVhfU0hBREVSXG4gICAgICApO1xuXG4gICAgICBmcmFnbWVudFNoYWRlciA9IHNpZ21hLnV0aWxzLmxvYWRTaGFkZXIoXG4gICAgICAgIGdsLFxuICAgICAgICBbXG4gICAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG5cbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXG5cbiAgICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yOycsXG4gICAgICAgICAgJ30nXG4gICAgICAgIF0uam9pbignXFxuJyksXG4gICAgICAgIGdsLkZSQUdNRU5UX1NIQURFUlxuICAgICAgKTtcblxuICAgICAgcHJvZ3JhbSA9IHNpZ21hLnV0aWxzLmxvYWRQcm9ncmFtKGdsLCBbdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcl0pO1xuXG4gICAgICByZXR1cm4gcHJvZ3JhbTtcbiAgICB9XG4gIH07XG59KSgpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS53ZWJnbC5lZGdlcycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGVkZ2UgcmVuZGVyZXIgd2lsbCBkaXNwbGF5IGVkZ2VzIGFzIGxpbmVzIHdpdGggdGhlIGdsLkxJTkVTIGRpc3BsYXlcbiAgICogbW9kZS4gU2luY2UgdGhpcyBtb2RlIGRvZXMgbm90IHN1cHBvcnQgd2VsbCB0aGlja25lc3MsIGVkZ2VzIGFyZSBhbGwgZHJhd25cbiAgICogd2l0aCB0aGUgc2FtZSB0aGlja25lc3MgKDNweCksIGluZGVwZW5kYW50bHkgb2YgdGhlIGVkZ2UgYXR0cmlidXRlcyBvciB0aGVcbiAgICogem9vbWluZyByYXRpby5cbiAgICovXG4gIHNpZ21hLndlYmdsLmVkZ2VzLmZhc3QgPSB7XG4gICAgUE9JTlRTOiAyLFxuICAgIEFUVFJJQlVURVM6IDMsXG4gICAgYWRkRWRnZTogZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIGRhdGEsIGksIHByZWZpeCwgc2V0dGluZ3MpIHtcbiAgICAgIHZhciB3ID0gKGVkZ2VbcHJlZml4ICsgJ3NpemUnXSB8fCAxKSAvIDIsXG4gICAgICAgICAgeDEgPSBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICB5MSA9IHNvdXJjZVtwcmVmaXggKyAneSddLFxuICAgICAgICAgIHgyID0gdGFyZ2V0W3ByZWZpeCArICd4J10sXG4gICAgICAgICAgeTIgPSB0YXJnZXRbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICBjb2xvciA9IGVkZ2UuY29sb3I7XG5cbiAgICAgIGlmICghY29sb3IpXG4gICAgICAgIHN3aXRjaCAoc2V0dGluZ3MoJ2VkZ2VDb2xvcicpKSB7XG4gICAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICAgIGNvbG9yID0gc291cmNlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgICAgY29sb3IgPSB0YXJnZXQuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAvLyBOb3JtYWxpemUgY29sb3I6XG4gICAgICBjb2xvciA9IHNpZ21hLnV0aWxzLmZsb2F0Q29sb3IoY29sb3IpO1xuXG4gICAgICBkYXRhW2krK10gPSB4MTtcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG5cbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xuICAgICAgZGF0YVtpKytdID0geTI7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24oZ2wsIHByb2dyYW0sIGRhdGEsIHBhcmFtcykge1xuICAgICAgdmFyIGJ1ZmZlcjtcblxuICAgICAgLy8gRGVmaW5lIGF0dHJpYnV0ZXM6XG4gICAgICB2YXIgY29sb3JMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9jb2xvcicpLFxuICAgICAgICAgIHBvc2l0aW9uTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfcG9zaXRpb24nKSxcbiAgICAgICAgICByZXNvbHV0aW9uTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3Jlc29sdXRpb24nKSxcbiAgICAgICAgICBtYXRyaXhMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfbWF0cml4Jyk7XG5cbiAgICAgIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZGF0YSwgZ2wuRFlOQU1JQ19EUkFXKTtcblxuICAgICAgZ2wudW5pZm9ybTJmKHJlc29sdXRpb25Mb2NhdGlvbiwgcGFyYW1zLndpZHRoLCBwYXJhbXMuaGVpZ2h0KTtcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYobWF0cml4TG9jYXRpb24sIGZhbHNlLCBwYXJhbXMubWF0cml4KTtcblxuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25Mb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShjb2xvckxvY2F0aW9uKTtcblxuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NpdGlvbkxvY2F0aW9uLFxuICAgICAgICAyLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMFxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoY29sb3JMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDhcbiAgICAgICk7XG5cbiAgICAgIGdsLmxpbmVXaWR0aCgzKTtcbiAgICAgIGdsLmRyYXdBcnJheXMoXG4gICAgICAgIGdsLkxJTkVTLFxuICAgICAgICBwYXJhbXMuc3RhcnQgfHwgMCxcbiAgICAgICAgcGFyYW1zLmNvdW50IHx8IChkYXRhLmxlbmd0aCAvIHRoaXMuQVRUUklCVVRFUylcbiAgICAgICk7XG4gICAgfSxcbiAgICBpbml0UHJvZ3JhbTogZnVuY3Rpb24oZ2wpIHtcbiAgICAgIHZhciB2ZXJ0ZXhTaGFkZXIsXG4gICAgICAgICAgZnJhZ21lbnRTaGFkZXIsXG4gICAgICAgICAgcHJvZ3JhbTtcblxuICAgICAgdmVydGV4U2hhZGVyID0gc2lnbWEudXRpbHMubG9hZFNoYWRlcihcbiAgICAgICAgZ2wsXG4gICAgICAgIFtcbiAgICAgICAgICAnYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9jb2xvcjsnLFxuXG4gICAgICAgICAgJ3VuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247JyxcbiAgICAgICAgICAndW5pZm9ybSBtYXQzIHVfbWF0cml4OycsXG5cbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXG5cbiAgICAgICAgICAndm9pZCBtYWluKCkgeycsXG4gICAgICAgICAgICAvLyBTY2FsZSBmcm9tIFtbLTEgMV0gWy0xIDFdXSB0byB0aGUgY29udGFpbmVyOlxuICAgICAgICAgICAgJ2dsX1Bvc2l0aW9uID0gdmVjNCgnLFxuICAgICAgICAgICAgICAnKCh1X21hdHJpeCAqIHZlYzMoYV9wb3NpdGlvbiwgMSkpLnh5IC8nLFxuICAgICAgICAgICAgICAgICd1X3Jlc29sdXRpb24gKiAyLjAgLSAxLjApICogdmVjMigxLCAtMSksJyxcbiAgICAgICAgICAgICAgJzAsJyxcbiAgICAgICAgICAgICAgJzEnLFxuICAgICAgICAgICAgJyk7JyxcblxuICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgY29sb3I6XG4gICAgICAgICAgICAnZmxvYXQgYyA9IGFfY29sb3I7JyxcbiAgICAgICAgICAgICdjb2xvci5iID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcbiAgICAgICAgICAgICdjb2xvci5nID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcbiAgICAgICAgICAgICdjb2xvci5yID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7IGNvbG9yIC89IDI1NS4wOycsXG4gICAgICAgICAgICAnY29sb3IuYSA9IDEuMDsnLFxuICAgICAgICAgICd9J1xuICAgICAgICBdLmpvaW4oJ1xcbicpLFxuICAgICAgICBnbC5WRVJURVhfU0hBREVSXG4gICAgICApO1xuXG4gICAgICBmcmFnbWVudFNoYWRlciA9IHNpZ21hLnV0aWxzLmxvYWRTaGFkZXIoXG4gICAgICAgIGdsLFxuICAgICAgICBbXG4gICAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG5cbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXG5cbiAgICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yOycsXG4gICAgICAgICAgJ30nXG4gICAgICAgIF0uam9pbignXFxuJyksXG4gICAgICAgIGdsLkZSQUdNRU5UX1NIQURFUlxuICAgICAgKTtcblxuICAgICAgcHJvZ3JhbSA9IHNpZ21hLnV0aWxzLmxvYWRQcm9ncmFtKGdsLCBbdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcl0pO1xuXG4gICAgICByZXR1cm4gcHJvZ3JhbTtcbiAgICB9XG4gIH07XG59KSgpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS53ZWJnbC5lZGdlcycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGVkZ2UgcmVuZGVyZXIgd2lsbCBkaXNwbGF5IGVkZ2VzIGFzIGFycm93cyBnb2luZyBmcm9tIHRoZSBzb3VyY2Ugbm9kZVxuICAgKiB0byB0aGUgdGFyZ2V0IG5vZGUuIFRvIGRlYWwgd2l0aCBlZGdlIHRoaWNrbmVzc2VzLCB0aGUgbGluZXMgYXJlIG1hZGUgb2ZcbiAgICogdGhyZWUgdHJpYW5nbGVzOiB0d28gZm9ybWluZyByZWN0YW5nbGVzLCB3aXRoIHRoZSBnbC5UUklBTkdMRVMgZHJhd2luZ1xuICAgKiBtb2RlLlxuICAgKlxuICAgKiBJdCBpcyBleHBlbnNpdmUsIHNpbmNlIGRyYXdpbmcgYSBzaW5nbGUgZWRnZSByZXF1aXJlcyA5IHBvaW50cywgZWFjaFxuICAgKiBoYXZpbmcgYSBsb3Qgb2YgYXR0cmlidXRlcy5cbiAgICovXG4gIHNpZ21hLndlYmdsLmVkZ2VzLmFycm93ID0ge1xuICAgIFBPSU5UUzogOSxcbiAgICBBVFRSSUJVVEVTOiAxMSxcbiAgICBhZGRFZGdlOiBmdW5jdGlvbihlZGdlLCBzb3VyY2UsIHRhcmdldCwgZGF0YSwgaSwgcHJlZml4LCBzZXR0aW5ncykge1xuICAgICAgdmFyIHcgPSAoZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEpIC8gMixcbiAgICAgICAgICB4MSA9IHNvdXJjZVtwcmVmaXggKyAneCddLFxuICAgICAgICAgIHkxID0gc291cmNlW3ByZWZpeCArICd5J10sXG4gICAgICAgICAgeDIgPSB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICB5MiA9IHRhcmdldFtwcmVmaXggKyAneSddLFxuICAgICAgICAgIHRhcmdldFNpemUgPSB0YXJnZXRbcHJlZml4ICsgJ3NpemUnXSxcbiAgICAgICAgICBjb2xvciA9IGVkZ2UuY29sb3I7XG5cbiAgICAgIGlmICghY29sb3IpXG4gICAgICAgIHN3aXRjaCAoc2V0dGluZ3MoJ2VkZ2VDb2xvcicpKSB7XG4gICAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICAgIGNvbG9yID0gc291cmNlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgICAgY29sb3IgPSB0YXJnZXQuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAvLyBOb3JtYWxpemUgY29sb3I6XG4gICAgICBjb2xvciA9IHNpZ21hLnV0aWxzLmZsb2F0Q29sb3IoY29sb3IpO1xuXG4gICAgICBkYXRhW2krK10gPSB4MTtcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IHc7XG4gICAgICBkYXRhW2krK10gPSB0YXJnZXRTaXplO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG5cbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xuICAgICAgZGF0YVtpKytdID0geTI7XG4gICAgICBkYXRhW2krK10gPSB4MTtcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xuICAgICAgZGF0YVtpKytdID0gdztcbiAgICAgIGRhdGFbaSsrXSA9IHRhcmdldFNpemU7XG4gICAgICBkYXRhW2krK10gPSAxLjA7XG4gICAgICBkYXRhW2krK10gPSAxLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcblxuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSB3O1xuICAgICAgZGF0YVtpKytdID0gdGFyZ2V0U2l6ZTtcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuXG4gICAgICBkYXRhW2krK10gPSB4MjtcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xuICAgICAgZGF0YVtpKytdID0geDE7XG4gICAgICBkYXRhW2krK10gPSB5MTtcbiAgICAgIGRhdGFbaSsrXSA9IHc7XG4gICAgICBkYXRhW2krK10gPSB0YXJnZXRTaXplO1xuICAgICAgZGF0YVtpKytdID0gMS4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG5cbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSB4MjtcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xuICAgICAgZGF0YVtpKytdID0gdztcbiAgICAgIGRhdGFbaSsrXSA9IHRhcmdldFNpemU7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSAxLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcblxuICAgICAgZGF0YVtpKytdID0geDE7XG4gICAgICBkYXRhW2krK10gPSB5MTtcbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xuICAgICAgZGF0YVtpKytdID0geTI7XG4gICAgICBkYXRhW2krK10gPSB3O1xuICAgICAgZGF0YVtpKytdID0gdGFyZ2V0U2l6ZTtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuXG4gICAgICAvLyBBcnJvdyBoZWFkOlxuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSB3O1xuICAgICAgZGF0YVtpKytdID0gdGFyZ2V0U2l6ZTtcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcbiAgICAgIGRhdGFbaSsrXSA9IC0xLjA7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcblxuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSB3O1xuICAgICAgZGF0YVtpKytdID0gdGFyZ2V0U2l6ZTtcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuXG4gICAgICBkYXRhW2krK10gPSB4MjtcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xuICAgICAgZGF0YVtpKytdID0geDE7XG4gICAgICBkYXRhW2krK10gPSB5MTtcbiAgICAgIGRhdGFbaSsrXSA9IHc7XG4gICAgICBkYXRhW2krK10gPSB0YXJnZXRTaXplO1xuICAgICAgZGF0YVtpKytdID0gMS4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMS4wO1xuICAgICAgZGF0YVtpKytdID0gMS4wO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtLCBkYXRhLCBwYXJhbXMpIHtcbiAgICAgIHZhciBidWZmZXI7XG5cbiAgICAgIC8vIERlZmluZSBhdHRyaWJ1dGVzOlxuICAgICAgdmFyIHBvc2l0aW9uTG9jYXRpb24xID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3BvczEnKSxcbiAgICAgICAgICBwb3NpdGlvbkxvY2F0aW9uMiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9wb3MyJyksXG4gICAgICAgICAgdGhpY2tuZXNzTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfdGhpY2tuZXNzJyksXG4gICAgICAgICAgdGFyZ2V0U2l6ZUxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3RTaXplJyksXG4gICAgICAgICAgZGVsYXlMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9kZWxheScpLFxuICAgICAgICAgIG1pbnVzTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfbWludXMnKSxcbiAgICAgICAgICBoZWFkTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfaGVhZCcpLFxuICAgICAgICAgIGhlYWRQb3NpdGlvbkxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX2hlYWRQb3NpdGlvbicpLFxuICAgICAgICAgIGNvbG9yTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfY29sb3InKSxcbiAgICAgICAgICByZXNvbHV0aW9uTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3Jlc29sdXRpb24nKSxcbiAgICAgICAgICBtYXRyaXhMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfbWF0cml4JyksXG4gICAgICAgICAgbWF0cml4SGFsZlBpTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X21hdHJpeEhhbGZQaScpLFxuICAgICAgICAgIG1hdHJpeEhhbGZQaU1pbnVzTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X21hdHJpeEhhbGZQaU1pbnVzJyksXG4gICAgICAgICAgcmF0aW9Mb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfcmF0aW8nKSxcbiAgICAgICAgICBub2RlUmF0aW9Mb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Vfbm9kZVJhdGlvJyksXG4gICAgICAgICAgYXJyb3dIZWFkTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X2Fycm93SGVhZCcpLFxuICAgICAgICAgIHNjYWxlTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3NjYWxlJyk7XG5cbiAgICAgIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZGF0YSwgZ2wuU1RBVElDX0RSQVcpO1xuXG4gICAgICBnbC51bmlmb3JtMmYocmVzb2x1dGlvbkxvY2F0aW9uLCBwYXJhbXMud2lkdGgsIHBhcmFtcy5oZWlnaHQpO1xuICAgICAgZ2wudW5pZm9ybTFmKFxuICAgICAgICByYXRpb0xvY2F0aW9uLFxuICAgICAgICBwYXJhbXMucmF0aW8gLyBNYXRoLnBvdyhwYXJhbXMucmF0aW8sIHBhcmFtcy5zZXR0aW5ncygnZWRnZXNQb3dSYXRpbycpKVxuICAgICAgKTtcbiAgICAgIGdsLnVuaWZvcm0xZihcbiAgICAgICAgbm9kZVJhdGlvTG9jYXRpb24sXG4gICAgICAgIE1hdGgucG93KHBhcmFtcy5yYXRpbywgcGFyYW1zLnNldHRpbmdzKCdub2Rlc1Bvd1JhdGlvJykpIC9cbiAgICAgICAgcGFyYW1zLnJhdGlvXG4gICAgICApO1xuICAgICAgZ2wudW5pZm9ybTFmKGFycm93SGVhZExvY2F0aW9uLCA1LjApO1xuICAgICAgZ2wudW5pZm9ybTFmKHNjYWxlTG9jYXRpb24sIHBhcmFtcy5zY2FsaW5nUmF0aW8pO1xuICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihtYXRyaXhMb2NhdGlvbiwgZmFsc2UsIHBhcmFtcy5tYXRyaXgpO1xuICAgICAgZ2wudW5pZm9ybU1hdHJpeDJmdihcbiAgICAgICAgbWF0cml4SGFsZlBpTG9jYXRpb24sXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBzaWdtYS51dGlscy5tYXRyaWNlcy5yb3RhdGlvbihNYXRoLlBJIC8gMiwgdHJ1ZSlcbiAgICAgICk7XG4gICAgICBnbC51bmlmb3JtTWF0cml4MmZ2KFxuICAgICAgICBtYXRyaXhIYWxmUGlNaW51c0xvY2F0aW9uLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgc2lnbWEudXRpbHMubWF0cmljZXMucm90YXRpb24oLU1hdGguUEkgLyAyLCB0cnVlKVxuICAgICAgKTtcblxuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25Mb2NhdGlvbjEpO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25Mb2NhdGlvbjIpO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpY2tuZXNzTG9jYXRpb24pO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGFyZ2V0U2l6ZUxvY2F0aW9uKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGRlbGF5TG9jYXRpb24pO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkobWludXNMb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShoZWFkTG9jYXRpb24pO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaGVhZFBvc2l0aW9uTG9jYXRpb24pO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoY29sb3JMb2NhdGlvbik7XG5cbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocG9zaXRpb25Mb2NhdGlvbjEsXG4gICAgICAgIDIsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICAwXG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NpdGlvbkxvY2F0aW9uMixcbiAgICAgICAgMixcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDhcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaWNrbmVzc0xvY2F0aW9uLFxuICAgICAgICAxLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMTZcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRhcmdldFNpemVMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDIwXG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihkZWxheUxvY2F0aW9uLFxuICAgICAgICAxLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMjRcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKG1pbnVzTG9jYXRpb24sXG4gICAgICAgIDEsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICAyOFxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoaGVhZExvY2F0aW9uLFxuICAgICAgICAxLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMzJcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGhlYWRQb3NpdGlvbkxvY2F0aW9uLFxuICAgICAgICAxLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMzZcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGNvbG9yTG9jYXRpb24sXG4gICAgICAgIDEsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICA0MFxuICAgICAgKTtcblxuICAgICAgZ2wuZHJhd0FycmF5cyhcbiAgICAgICAgZ2wuVFJJQU5HTEVTLFxuICAgICAgICBwYXJhbXMuc3RhcnQgfHwgMCxcbiAgICAgICAgcGFyYW1zLmNvdW50IHx8IChkYXRhLmxlbmd0aCAvIHRoaXMuQVRUUklCVVRFUylcbiAgICAgICk7XG4gICAgfSxcbiAgICBpbml0UHJvZ3JhbTogZnVuY3Rpb24oZ2wpIHtcbiAgICAgIHZhciB2ZXJ0ZXhTaGFkZXIsXG4gICAgICAgICAgZnJhZ21lbnRTaGFkZXIsXG4gICAgICAgICAgcHJvZ3JhbTtcblxuICAgICAgdmVydGV4U2hhZGVyID0gc2lnbWEudXRpbHMubG9hZFNoYWRlcihcbiAgICAgICAgZ2wsXG4gICAgICAgIFtcbiAgICAgICAgICAnYXR0cmlidXRlIHZlYzIgYV9wb3MxOycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfcG9zMjsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV90aGlja25lc3M7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfdFNpemU7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfZGVsYXk7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfbWludXM7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfaGVhZDsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9oZWFkUG9zaXRpb247JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfY29sb3I7JyxcblxuICAgICAgICAgICd1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uOycsXG4gICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdV9yYXRpbzsnLFxuICAgICAgICAgICd1bmlmb3JtIGZsb2F0IHVfbm9kZVJhdGlvOycsXG4gICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdV9hcnJvd0hlYWQ7JyxcbiAgICAgICAgICAndW5pZm9ybSBmbG9hdCB1X3NjYWxlOycsXG4gICAgICAgICAgJ3VuaWZvcm0gbWF0MyB1X21hdHJpeDsnLFxuICAgICAgICAgICd1bmlmb3JtIG1hdDIgdV9tYXRyaXhIYWxmUGk7JyxcbiAgICAgICAgICAndW5pZm9ybSBtYXQyIHVfbWF0cml4SGFsZlBpTWludXM7JyxcblxuICAgICAgICAgICd2YXJ5aW5nIHZlYzQgY29sb3I7JyxcblxuICAgICAgICAgICd2b2lkIG1haW4oKSB7JyxcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGdvb2QgcG9pbnQ6XG4gICAgICAgICAgICAndmVjMiBwb3MgPSBub3JtYWxpemUoYV9wb3MyIC0gYV9wb3MxKTsnLFxuXG4gICAgICAgICAgICAnbWF0MiBtYXRyaXggPSAoMS4wIC0gYV9oZWFkKSAqJyxcbiAgICAgICAgICAgICAgJygnLFxuICAgICAgICAgICAgICAgICdhX21pbnVzICogdV9tYXRyaXhIYWxmUGlNaW51cyArJyxcbiAgICAgICAgICAgICAgICAnKDEuMCAtIGFfbWludXMpICogdV9tYXRyaXhIYWxmUGknLFxuICAgICAgICAgICAgICAnKSArIGFfaGVhZCAqICgnLFxuICAgICAgICAgICAgICAgICdhX2hlYWRQb3NpdGlvbiAqIHVfbWF0cml4SGFsZlBpTWludXMgKiAwLjYgKycsXG4gICAgICAgICAgICAgICAgJyhhX2hlYWRQb3NpdGlvbiAqIGFfaGVhZFBvc2l0aW9uIC0gMS4wKSAqIG1hdDIoMS4wKScsXG4gICAgICAgICAgICAgICcpOycsXG5cbiAgICAgICAgICAgICdwb3MgPSBhX3BvczEgKyAoJyxcbiAgICAgICAgICAgICAgLy8gRGVhbCB3aXRoIGJvZHk6XG4gICAgICAgICAgICAgICcoMS4wIC0gYV9oZWFkKSAqIGFfdGhpY2tuZXNzICogdV9yYXRpbyAqIG1hdHJpeCAqIHBvcyArJyxcbiAgICAgICAgICAgICAgLy8gRGVhbCB3aXRoIGhlYWQ6XG4gICAgICAgICAgICAgICdhX2hlYWQgKiB1X2Fycm93SGVhZCAqIGFfdGhpY2tuZXNzICogdV9yYXRpbyAqIG1hdHJpeCAqIHBvcyArJyxcbiAgICAgICAgICAgICAgLy8gRGVhbCB3aXRoIGRlbGF5OlxuICAgICAgICAgICAgICAnYV9kZWxheSAqIHBvcyAqICgnLFxuICAgICAgICAgICAgICAgICdhX3RTaXplIC8gdV9ub2RlUmF0aW8gKycsXG4gICAgICAgICAgICAgICAgJ3VfYXJyb3dIZWFkICogYV90aGlja25lc3MgKiB1X3JhdGlvJyxcbiAgICAgICAgICAgICAgJyknLFxuICAgICAgICAgICAgJyk7JyxcblxuICAgICAgICAgICAgLy8gU2NhbGUgZnJvbSBbWy0xIDFdIFstMSAxXV0gdG8gdGhlIGNvbnRhaW5lcjpcbiAgICAgICAgICAgICdnbF9Qb3NpdGlvbiA9IHZlYzQoJyxcbiAgICAgICAgICAgICAgJygodV9tYXRyaXggKiB2ZWMzKHBvcywgMSkpLnh5IC8nLFxuICAgICAgICAgICAgICAgICd1X3Jlc29sdXRpb24gKiAyLjAgLSAxLjApICogdmVjMigxLCAtMSksJyxcbiAgICAgICAgICAgICAgJzAsJyxcbiAgICAgICAgICAgICAgJzEnLFxuICAgICAgICAgICAgJyk7JyxcblxuICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgY29sb3I6XG4gICAgICAgICAgICAnZmxvYXQgYyA9IGFfY29sb3I7JyxcbiAgICAgICAgICAgICdjb2xvci5iID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcbiAgICAgICAgICAgICdjb2xvci5nID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcbiAgICAgICAgICAgICdjb2xvci5yID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7IGNvbG9yIC89IDI1NS4wOycsXG4gICAgICAgICAgICAnY29sb3IuYSA9IDEuMDsnLFxuICAgICAgICAgICd9J1xuICAgICAgICBdLmpvaW4oJ1xcbicpLFxuICAgICAgICBnbC5WRVJURVhfU0hBREVSXG4gICAgICApO1xuXG4gICAgICBmcmFnbWVudFNoYWRlciA9IHNpZ21hLnV0aWxzLmxvYWRTaGFkZXIoXG4gICAgICAgIGdsLFxuICAgICAgICBbXG4gICAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG5cbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXG5cbiAgICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yOycsXG4gICAgICAgICAgJ30nXG4gICAgICAgIF0uam9pbignXFxuJyksXG4gICAgICAgIGdsLkZSQUdNRU5UX1NIQURFUlxuICAgICAgKTtcblxuICAgICAgcHJvZ3JhbSA9IHNpZ21hLnV0aWxzLmxvYWRQcm9ncmFtKGdsLCBbdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcl0pO1xuXG4gICAgICByZXR1cm4gcHJvZ3JhbTtcbiAgICB9XG4gIH07XG59KSgpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMubGFiZWxzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgbGFiZWwgcmVuZGVyZXIgd2lsbCBqdXN0IGRpc3BsYXkgdGhlIGxhYmVsIG9uIHRoZSByaWdodCBvZiB0aGUgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBub2RlICAgICBUaGUgbm9kZSBvYmplY3QuXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAgVGhlIGNhbnZhcyBjb250ZXh0LlxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICovXG4gIHNpZ21hLmNhbnZhcy5sYWJlbHMuZGVmID0gZnVuY3Rpb24obm9kZSwgY29udGV4dCwgc2V0dGluZ3MpIHtcbiAgICB2YXIgZm9udFNpemUsXG4gICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgc2l6ZSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXTtcblxuICAgIGlmIChzaXplIDwgc2V0dGluZ3MoJ2xhYmVsVGhyZXNob2xkJykpXG4gICAgICByZXR1cm47XG5cbiAgICBpZiAoIW5vZGUubGFiZWwgfHwgdHlwZW9mIG5vZGUubGFiZWwgIT09ICdzdHJpbmcnKVxuICAgICAgcmV0dXJuO1xuXG4gICAgZm9udFNpemUgPSAoc2V0dGluZ3MoJ2xhYmVsU2l6ZScpID09PSAnZml4ZWQnKSA/XG4gICAgICBzZXR0aW5ncygnZGVmYXVsdExhYmVsU2l6ZScpIDpcbiAgICAgIHNldHRpbmdzKCdsYWJlbFNpemVSYXRpbycpICogc2l6ZTtcblxuICAgIGNvbnRleHQuZm9udCA9IChzZXR0aW5ncygnZm9udFN0eWxlJykgPyBzZXR0aW5ncygnZm9udFN0eWxlJykgKyAnICcgOiAnJykgK1xuICAgICAgZm9udFNpemUgKyAncHggJyArIHNldHRpbmdzKCdmb250Jyk7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSAoc2V0dGluZ3MoJ2xhYmVsQ29sb3InKSA9PT0gJ25vZGUnKSA/XG4gICAgICAobm9kZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpKSA6XG4gICAgICBzZXR0aW5ncygnZGVmYXVsdExhYmVsQ29sb3InKTtcblxuICAgIGNvbnRleHQuZmlsbFRleHQoXG4gICAgICBub2RlLmxhYmVsLFxuICAgICAgTWF0aC5yb3VuZChub2RlW3ByZWZpeCArICd4J10gKyBzaXplICsgMyksXG4gICAgICBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3knXSArIGZvbnRTaXplIC8gMylcbiAgICApO1xuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLmhvdmVycycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGhvdmVyIHJlbmRlcmVyIHdpbGwgYmFzaWNhbGx5IGRpc3BsYXkgdGhlIGxhYmVsIHdpdGggYSBiYWNrZ3JvdW5kLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIG5vZGUgICAgIFRoZSBub2RlIG9iamVjdC5cbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0ICBUaGUgY2FudmFzIGNvbnRleHQuXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgKi9cbiAgc2lnbWEuY2FudmFzLmhvdmVycy5kZWYgPSBmdW5jdGlvbihub2RlLCBjb250ZXh0LCBzZXR0aW5ncykge1xuICAgIHZhciB4LFxuICAgICAgICB5LFxuICAgICAgICB3LFxuICAgICAgICBoLFxuICAgICAgICBlLFxuICAgICAgICBmb250U3R5bGUgPSBzZXR0aW5ncygnaG92ZXJGb250U3R5bGUnKSB8fCBzZXR0aW5ncygnZm9udFN0eWxlJyksXG4gICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgc2l6ZSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXSxcbiAgICAgICAgZm9udFNpemUgPSAoc2V0dGluZ3MoJ2xhYmVsU2l6ZScpID09PSAnZml4ZWQnKSA/XG4gICAgICAgICAgc2V0dGluZ3MoJ2RlZmF1bHRMYWJlbFNpemUnKSA6XG4gICAgICAgICAgc2V0dGluZ3MoJ2xhYmVsU2l6ZVJhdGlvJykgKiBzaXplO1xuXG4gICAgLy8gTGFiZWwgYmFja2dyb3VuZDpcbiAgICBjb250ZXh0LmZvbnQgPSAoZm9udFN0eWxlID8gZm9udFN0eWxlICsgJyAnIDogJycpICtcbiAgICAgIGZvbnRTaXplICsgJ3B4ICcgKyAoc2V0dGluZ3MoJ2hvdmVyRm9udCcpIHx8IHNldHRpbmdzKCdmb250JykpO1xuXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHNldHRpbmdzKCdsYWJlbEhvdmVyQkdDb2xvcicpID09PSAnbm9kZScgP1xuICAgICAgKG5vZGUuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSkgOlxuICAgICAgc2V0dGluZ3MoJ2RlZmF1bHRIb3ZlckxhYmVsQkdDb2xvcicpO1xuXG4gICAgaWYgKG5vZGUubGFiZWwgJiYgc2V0dGluZ3MoJ2xhYmVsSG92ZXJTaGFkb3cnKSkge1xuICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRYID0gMDtcbiAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WSA9IDA7XG4gICAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSA4O1xuICAgICAgY29udGV4dC5zaGFkb3dDb2xvciA9IHNldHRpbmdzKCdsYWJlbEhvdmVyU2hhZG93Q29sb3InKTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5sYWJlbCAmJiB0eXBlb2Ygbm9kZS5sYWJlbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHggPSBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3gnXSAtIGZvbnRTaXplIC8gMiAtIDIpO1xuICAgICAgeSA9IE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneSddIC0gZm9udFNpemUgLyAyIC0gMik7XG4gICAgICB3ID0gTWF0aC5yb3VuZChcbiAgICAgICAgY29udGV4dC5tZWFzdXJlVGV4dChub2RlLmxhYmVsKS53aWR0aCArIGZvbnRTaXplIC8gMiArIHNpemUgKyA3XG4gICAgICApO1xuICAgICAgaCA9IE1hdGgucm91bmQoZm9udFNpemUgKyA0KTtcbiAgICAgIGUgPSBNYXRoLnJvdW5kKGZvbnRTaXplIC8gMiArIDIpO1xuXG4gICAgICBjb250ZXh0Lm1vdmVUbyh4LCB5ICsgZSk7XG4gICAgICBjb250ZXh0LmFyY1RvKHgsIHksIHggKyBlLCB5LCBlKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHggKyB3LCB5KTtcbiAgICAgIGNvbnRleHQubGluZVRvKHggKyB3LCB5ICsgaCk7XG4gICAgICBjb250ZXh0LmxpbmVUbyh4ICsgZSwgeSArIGgpO1xuICAgICAgY29udGV4dC5hcmNUbyh4LCB5ICsgaCwgeCwgeSArIGggLSBlLCBlKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHgsIHkgKyBlKTtcblxuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuXG4gICAgICBjb250ZXh0LnNoYWRvd09mZnNldFggPSAwO1xuICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgICAgIGNvbnRleHQuc2hhZG93Qmx1ciA9IDA7XG4gICAgfVxuXG4gICAgLy8gTm9kZSBib3JkZXI6XG4gICAgaWYgKHNldHRpbmdzKCdib3JkZXJTaXplJykgPiAwKSB7XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBzZXR0aW5ncygnbm9kZUJvcmRlckNvbG9yJykgPT09ICdub2RlJyA/XG4gICAgICAgIChub2RlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJykpIDpcbiAgICAgICAgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQm9yZGVyQ29sb3InKTtcbiAgICAgIGNvbnRleHQuYXJjKFxuICAgICAgICBub2RlW3ByZWZpeCArICd4J10sXG4gICAgICAgIG5vZGVbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgc2l6ZSArIHNldHRpbmdzKCdib3JkZXJTaXplJyksXG4gICAgICAgIDAsXG4gICAgICAgIE1hdGguUEkgKiAyLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIH1cblxuICAgIC8vIE5vZGU6XG4gICAgdmFyIG5vZGVSZW5kZXJlciA9IHNpZ21hLmNhbnZhcy5ub2Rlc1tub2RlLnR5cGVdIHx8IHNpZ21hLmNhbnZhcy5ub2Rlcy5kZWY7XG4gICAgbm9kZVJlbmRlcmVyKG5vZGUsIGNvbnRleHQsIHNldHRpbmdzKTtcblxuICAgIC8vIERpc3BsYXkgdGhlIGxhYmVsOlxuICAgIGlmIChub2RlLmxhYmVsICYmIHR5cGVvZiBub2RlLmxhYmVsID09PSAnc3RyaW5nJykge1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAoc2V0dGluZ3MoJ2xhYmVsSG92ZXJDb2xvcicpID09PSAnbm9kZScpID9cbiAgICAgICAgKG5vZGUuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSkgOlxuICAgICAgICBzZXR0aW5ncygnZGVmYXVsdExhYmVsSG92ZXJDb2xvcicpO1xuXG4gICAgICBjb250ZXh0LmZpbGxUZXh0KFxuICAgICAgICBub2RlLmxhYmVsLFxuICAgICAgICBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3gnXSArIHNpemUgKyAzKSxcbiAgICAgICAgTWF0aC5yb3VuZChub2RlW3ByZWZpeCArICd5J10gKyBmb250U2l6ZSAvIDMpXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5ub2RlcycpO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBub2RlIHJlbmRlcmVyLiBJdCByZW5kZXJzIHRoZSBub2RlIGFzIGEgc2ltcGxlIGRpc2MuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgbm9kZSAgICAgVGhlIG5vZGUgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgIFRoZSBjYW52YXMgY29udGV4dC5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqL1xuICBzaWdtYS5jYW52YXMubm9kZXMuZGVmID0gZnVuY3Rpb24obm9kZSwgY29udGV4dCwgc2V0dGluZ3MpIHtcbiAgICB2YXIgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnO1xuXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBub2RlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyk7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0LmFyYyhcbiAgICAgIG5vZGVbcHJlZml4ICsgJ3gnXSxcbiAgICAgIG5vZGVbcHJlZml4ICsgJ3knXSxcbiAgICAgIG5vZGVbcHJlZml4ICsgJ3NpemUnXSxcbiAgICAgIDAsXG4gICAgICBNYXRoLlBJICogMixcbiAgICAgIHRydWVcbiAgICApO1xuXG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5lZGdlcycpO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBlZGdlIHJlbmRlcmVyLiBJdCByZW5kZXJzIHRoZSBlZGdlIGFzIGEgc2ltcGxlIGxpbmUuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgZWRnZSAgICAgICAgIFRoZSBlZGdlIG9iamVjdC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBzb3VyY2Ugbm9kZSAgVGhlIGVkZ2Ugc291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgdGFyZ2V0IG5vZGUgIFRoZSBlZGdlIHRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgICAgICBUaGUgY2FudmFzIGNvbnRleHQuXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICovXG4gIHNpZ21hLmNhbnZhcy5lZGdlcy5kZWYgPSBmdW5jdGlvbihlZGdlLCBzb3VyY2UsIHRhcmdldCwgY29udGV4dCwgc2V0dGluZ3MpIHtcbiAgICB2YXIgY29sb3IgPSBlZGdlLmNvbG9yLFxuICAgICAgICBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXG4gICAgICAgIHNpemUgPSBlZGdlW3ByZWZpeCArICdzaXplJ10gfHwgMSxcbiAgICAgICAgZWRnZUNvbG9yID0gc2V0dGluZ3MoJ2VkZ2VDb2xvcicpLFxuICAgICAgICBkZWZhdWx0Tm9kZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSxcbiAgICAgICAgZGVmYXVsdEVkZ2VDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyk7XG5cbiAgICBpZiAoIWNvbG9yKVxuICAgICAgc3dpdGNoIChlZGdlQ29sb3IpIHtcbiAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICBjb2xvciA9IHNvdXJjZS5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgIGNvbG9yID0gdGFyZ2V0LmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29sb3IgPSBkZWZhdWx0RWRnZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gc2l6ZTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvKFxuICAgICAgc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICBzb3VyY2VbcHJlZml4ICsgJ3knXVxuICAgICk7XG4gICAgY29udGV4dC5saW5lVG8oXG4gICAgICB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgIHRhcmdldFtwcmVmaXggKyAneSddXG4gICAgKTtcbiAgICBjb250ZXh0LnN0cm9rZSgpO1xuICB9O1xufSkoKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLmVkZ2VzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgZWRnZSByZW5kZXJlciB3aWxsIGRpc3BsYXkgZWRnZXMgYXMgYXJyb3dzIGdvaW5nIGZyb20gdGhlIHNvdXJjZSBub2RlXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgZWRnZSAgICAgICAgIFRoZSBlZGdlIG9iamVjdC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBzb3VyY2Ugbm9kZSAgVGhlIGVkZ2Ugc291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgdGFyZ2V0IG5vZGUgIFRoZSBlZGdlIHRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgICAgICBUaGUgY2FudmFzIGNvbnRleHQuXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICovXG4gIHNpZ21hLmNhbnZhcy5lZGdlcy5hcnJvdyA9IGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBjb250ZXh0LCBzZXR0aW5ncykge1xuICAgIHZhciBjb2xvciA9IGVkZ2UuY29sb3IsXG4gICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgZWRnZUNvbG9yID0gc2V0dGluZ3MoJ2VkZ2VDb2xvcicpLFxuICAgICAgICBkZWZhdWx0Tm9kZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSxcbiAgICAgICAgZGVmYXVsdEVkZ2VDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyksXG4gICAgICAgIHNpemUgPSBlZGdlW3ByZWZpeCArICdzaXplJ10gfHwgMSxcbiAgICAgICAgdFNpemUgPSB0YXJnZXRbcHJlZml4ICsgJ3NpemUnXSxcbiAgICAgICAgc1ggPSBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgc1kgPSBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgdFggPSB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgdFkgPSB0YXJnZXRbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgYVNpemUgPSBNYXRoLm1heChzaXplICogMi41LCBzZXR0aW5ncygnbWluQXJyb3dTaXplJykpLFxuICAgICAgICBkID0gTWF0aC5zcXJ0KE1hdGgucG93KHRYIC0gc1gsIDIpICsgTWF0aC5wb3codFkgLSBzWSwgMikpLFxuICAgICAgICBhWCA9IHNYICsgKHRYIC0gc1gpICogKGQgLSBhU2l6ZSAtIHRTaXplKSAvIGQsXG4gICAgICAgIGFZID0gc1kgKyAodFkgLSBzWSkgKiAoZCAtIGFTaXplIC0gdFNpemUpIC8gZCxcbiAgICAgICAgdlggPSAodFggLSBzWCkgKiBhU2l6ZSAvIGQsXG4gICAgICAgIHZZID0gKHRZIC0gc1kpICogYVNpemUgLyBkO1xuXG4gICAgaWYgKCFjb2xvcilcbiAgICAgIHN3aXRjaCAoZWRnZUNvbG9yKSB7XG4gICAgICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICAgICAgY29sb3IgPSBzb3VyY2UuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGFyZ2V0JzpcbiAgICAgICAgICBjb2xvciA9IHRhcmdldC5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbG9yID0gZGVmYXVsdEVkZ2VDb2xvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHNpemU7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhzWCwgc1kpO1xuICAgIGNvbnRleHQubGluZVRvKFxuICAgICAgYVgsXG4gICAgICBhWVxuICAgICk7XG4gICAgY29udGV4dC5zdHJva2UoKTtcblxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY29sb3I7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhhWCArIHZYLCBhWSArIHZZKTtcbiAgICBjb250ZXh0LmxpbmVUbyhhWCArIHZZICogMC42LCBhWSAtIHZYICogMC42KTtcbiAgICBjb250ZXh0LmxpbmVUbyhhWCAtIHZZICogMC42LCBhWSArIHZYICogMC42KTtcbiAgICBjb250ZXh0LmxpbmVUbyhhWCArIHZYLCBhWSArIHZZKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIGNvbnRleHQuZmlsbCgpO1xuICB9O1xufSkoKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLmVkZ2Vob3ZlcnMnKTtcblxuICAvKipcbiAgICogVGhpcyBob3ZlciByZW5kZXJlciB3aWxsIGRpc3BsYXkgdGhlIGVkZ2Ugd2l0aCBhIGRpZmZlcmVudCBjb2xvciBvciBzaXplLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgICBUaGUgZWRnZSBvYmplY3QuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgc291cmNlIG5vZGUgIFRoZSBlZGdlIHNvdXJjZSBub2RlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCBub2RlICBUaGUgZWRnZSB0YXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0ICAgICAgVGhlIGNhbnZhcyBjb250ZXh0LlxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgICBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqL1xuICBzaWdtYS5jYW52YXMuZWRnZWhvdmVycy5kZWYgPVxuICAgIGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBjb250ZXh0LCBzZXR0aW5ncykge1xuICAgICAgdmFyIGNvbG9yID0gZWRnZS5jb2xvcixcbiAgICAgICAgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxuICAgICAgICBzaXplID0gZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEsXG4gICAgICAgIGVkZ2VDb2xvciA9IHNldHRpbmdzKCdlZGdlQ29sb3InKSxcbiAgICAgICAgZGVmYXVsdE5vZGVDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyksXG4gICAgICAgIGRlZmF1bHRFZGdlQ29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdEVkZ2VDb2xvcicpO1xuXG4gICAgaWYgKCFjb2xvcilcbiAgICAgIHN3aXRjaCAoZWRnZUNvbG9yKSB7XG4gICAgICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICAgICAgY29sb3IgPSBzb3VyY2UuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGFyZ2V0JzpcbiAgICAgICAgICBjb2xvciA9IHRhcmdldC5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbG9yID0gZGVmYXVsdEVkZ2VDb2xvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGlmIChzZXR0aW5ncygnZWRnZUhvdmVyQ29sb3InKSA9PT0gJ2VkZ2UnKSB7XG4gICAgICBjb2xvciA9IGVkZ2UuaG92ZXJfY29sb3IgfHwgY29sb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbG9yID0gZWRnZS5ob3Zlcl9jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdEVkZ2VIb3ZlckNvbG9yJykgfHwgY29sb3I7XG4gICAgfVxuICAgIHNpemUgKj0gc2V0dGluZ3MoJ2VkZ2VIb3ZlclNpemVSYXRpbycpO1xuXG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gc2l6ZTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvKFxuICAgICAgc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICBzb3VyY2VbcHJlZml4ICsgJ3knXVxuICAgICk7XG4gICAgY29udGV4dC5saW5lVG8oXG4gICAgICB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgIHRhcmdldFtwcmVmaXggKyAneSddXG4gICAgKTtcbiAgICBjb250ZXh0LnN0cm9rZSgpO1xuICB9O1xufSkoKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLmVkZ2Vob3ZlcnMnKTtcblxuICAvKipcbiAgICogVGhpcyBob3ZlciByZW5kZXJlciB3aWxsIGRpc3BsYXkgdGhlIGVkZ2Ugd2l0aCBhIGRpZmZlcmVudCBjb2xvciBvciBzaXplLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgICBUaGUgZWRnZSBvYmplY3QuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgc291cmNlIG5vZGUgIFRoZSBlZGdlIHNvdXJjZSBub2RlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCBub2RlICBUaGUgZWRnZSB0YXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0ICAgICAgVGhlIGNhbnZhcyBjb250ZXh0LlxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgICBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqL1xuICBzaWdtYS5jYW52YXMuZWRnZWhvdmVycy5jdXJ2ZSA9XG4gICAgZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIGNvbnRleHQsIHNldHRpbmdzKSB7XG4gICAgdmFyIGNvbG9yID0gZWRnZS5jb2xvcixcbiAgICAgICAgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxuICAgICAgICBzaXplID0gc2V0dGluZ3MoJ2VkZ2VIb3ZlclNpemVSYXRpbycpICogKGVkZ2VbcHJlZml4ICsgJ3NpemUnXSB8fCAxKSxcbiAgICAgICAgZWRnZUNvbG9yID0gc2V0dGluZ3MoJ2VkZ2VDb2xvcicpLFxuICAgICAgICBkZWZhdWx0Tm9kZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSxcbiAgICAgICAgZGVmYXVsdEVkZ2VDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyksXG4gICAgICAgIGNwID0ge30sXG4gICAgICAgIHNTaXplID0gc291cmNlW3ByZWZpeCArICdzaXplJ10sXG4gICAgICAgIHNYID0gc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICAgIHNZID0gc291cmNlW3ByZWZpeCArICd5J10sXG4gICAgICAgIHRYID0gdGFyZ2V0W3ByZWZpeCArICd4J10sXG4gICAgICAgIHRZID0gdGFyZ2V0W3ByZWZpeCArICd5J107XG5cbiAgICBjcCA9IChzb3VyY2UuaWQgPT09IHRhcmdldC5pZCkgP1xuICAgICAgc2lnbWEudXRpbHMuZ2V0U2VsZkxvb3BDb250cm9sUG9pbnRzKHNYLCBzWSwgc1NpemUpIDpcbiAgICAgIHNpZ21hLnV0aWxzLmdldFF1YWRyYXRpY0NvbnRyb2xQb2ludChzWCwgc1ksIHRYLCB0WSk7XG5cbiAgICBpZiAoIWNvbG9yKVxuICAgICAgc3dpdGNoIChlZGdlQ29sb3IpIHtcbiAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICBjb2xvciA9IHNvdXJjZS5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgIGNvbG9yID0gdGFyZ2V0LmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29sb3IgPSBkZWZhdWx0RWRnZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgaWYgKHNldHRpbmdzKCdlZGdlSG92ZXJDb2xvcicpID09PSAnZWRnZScpIHtcbiAgICAgIGNvbG9yID0gZWRnZS5ob3Zlcl9jb2xvciB8fCBjb2xvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29sb3IgPSBlZGdlLmhvdmVyX2NvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0RWRnZUhvdmVyQ29sb3InKSB8fCBjb2xvcjtcbiAgICB9XG5cbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSBzaXplO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oc1gsIHNZKTtcbiAgICBpZiAoc291cmNlLmlkID09PSB0YXJnZXQuaWQpIHtcbiAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyhjcC54MSwgY3AueTEsIGNwLngyLCBjcC55MiwgdFgsIHRZKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKGNwLngsIGNwLnksIHRYLCB0WSk7XG4gICAgfVxuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gIH07XG59KSgpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMuZWRnZWhvdmVycycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGhvdmVyIHJlbmRlcmVyIHdpbGwgZGlzcGxheSB0aGUgZWRnZSB3aXRoIGEgZGlmZmVyZW50IGNvbG9yIG9yIHNpemUuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgZWRnZSAgICAgICAgIFRoZSBlZGdlIG9iamVjdC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBzb3VyY2Ugbm9kZSAgVGhlIGVkZ2Ugc291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgdGFyZ2V0IG5vZGUgIFRoZSBlZGdlIHRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgICAgICBUaGUgY2FudmFzIGNvbnRleHQuXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICovXG4gIHNpZ21hLmNhbnZhcy5lZGdlaG92ZXJzLmFycm93ID1cbiAgICBmdW5jdGlvbihlZGdlLCBzb3VyY2UsIHRhcmdldCwgY29udGV4dCwgc2V0dGluZ3MpIHtcbiAgICB2YXIgY29sb3IgPSBlZGdlLmNvbG9yLFxuICAgICAgICBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXG4gICAgICAgIGVkZ2VDb2xvciA9IHNldHRpbmdzKCdlZGdlQ29sb3InKSxcbiAgICAgICAgZGVmYXVsdE5vZGVDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyksXG4gICAgICAgIGRlZmF1bHRFZGdlQ29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdEVkZ2VDb2xvcicpLFxuICAgICAgICBzaXplID0gZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEsXG4gICAgICAgIHRTaXplID0gdGFyZ2V0W3ByZWZpeCArICdzaXplJ10sXG4gICAgICAgIHNYID0gc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICAgIHNZID0gc291cmNlW3ByZWZpeCArICd5J10sXG4gICAgICAgIHRYID0gdGFyZ2V0W3ByZWZpeCArICd4J10sXG4gICAgICAgIHRZID0gdGFyZ2V0W3ByZWZpeCArICd5J107XG5cbiAgICBzaXplID0gKGVkZ2UuaG92ZXIpID9cbiAgICAgIHNldHRpbmdzKCdlZGdlSG92ZXJTaXplUmF0aW8nKSAqIHNpemUgOiBzaXplO1xuICAgIHZhciBhU2l6ZSA9IHNpemUgKiAyLjUsXG4gICAgICAgIGQgPSBNYXRoLnNxcnQoTWF0aC5wb3codFggLSBzWCwgMikgKyBNYXRoLnBvdyh0WSAtIHNZLCAyKSksXG4gICAgICAgIGFYID0gc1ggKyAodFggLSBzWCkgKiAoZCAtIGFTaXplIC0gdFNpemUpIC8gZCxcbiAgICAgICAgYVkgPSBzWSArICh0WSAtIHNZKSAqIChkIC0gYVNpemUgLSB0U2l6ZSkgLyBkLFxuICAgICAgICB2WCA9ICh0WCAtIHNYKSAqIGFTaXplIC8gZCxcbiAgICAgICAgdlkgPSAodFkgLSBzWSkgKiBhU2l6ZSAvIGQ7XG5cbiAgICBpZiAoIWNvbG9yKVxuICAgICAgc3dpdGNoIChlZGdlQ29sb3IpIHtcbiAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICBjb2xvciA9IHNvdXJjZS5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgIGNvbG9yID0gdGFyZ2V0LmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29sb3IgPSBkZWZhdWx0RWRnZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgaWYgKHNldHRpbmdzKCdlZGdlSG92ZXJDb2xvcicpID09PSAnZWRnZScpIHtcbiAgICAgIGNvbG9yID0gZWRnZS5ob3Zlcl9jb2xvciB8fCBjb2xvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29sb3IgPSBlZGdlLmhvdmVyX2NvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0RWRnZUhvdmVyQ29sb3InKSB8fCBjb2xvcjtcbiAgICB9XG5cbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSBzaXplO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oc1gsIHNZKTtcbiAgICBjb250ZXh0LmxpbmVUbyhcbiAgICAgIGFYLFxuICAgICAgYVlcbiAgICApO1xuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG5cbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oYVggKyB2WCwgYVkgKyB2WSk7XG4gICAgY29udGV4dC5saW5lVG8oYVggKyB2WSAqIDAuNiwgYVkgLSB2WCAqIDAuNik7XG4gICAgY29udGV4dC5saW5lVG8oYVggLSB2WSAqIDAuNiwgYVkgKyB2WCAqIDAuNik7XG4gICAgY29udGV4dC5saW5lVG8oYVggKyB2WCwgYVkgKyB2WSk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5lZGdlaG92ZXJzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgaG92ZXIgcmVuZGVyZXIgd2lsbCBkaXNwbGF5IHRoZSBlZGdlIHdpdGggYSBkaWZmZXJlbnQgY29sb3Igb3Igc2l6ZS5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBlZGdlICAgICAgICAgVGhlIGVkZ2Ugb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHNvdXJjZSBub2RlICBUaGUgZWRnZSBzb3VyY2Ugbm9kZS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICB0YXJnZXQgbm9kZSAgVGhlIGVkZ2UgdGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAgICAgIFRoZSBjYW52YXMgY29udGV4dC5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyAgICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgKi9cbiAgc2lnbWEuY2FudmFzLmVkZ2Vob3ZlcnMuY3VydmVkQXJyb3cgPVxuICAgIGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBjb250ZXh0LCBzZXR0aW5ncykge1xuICAgIHZhciBjb2xvciA9IGVkZ2UuY29sb3IsXG4gICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgZWRnZUNvbG9yID0gc2V0dGluZ3MoJ2VkZ2VDb2xvcicpLFxuICAgICAgICBkZWZhdWx0Tm9kZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSxcbiAgICAgICAgZGVmYXVsdEVkZ2VDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyksXG4gICAgICAgIGNwID0ge30sXG4gICAgICAgIHNpemUgPSBzZXR0aW5ncygnZWRnZUhvdmVyU2l6ZVJhdGlvJykgKiAoZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEpLFxuICAgICAgICB0U2l6ZSA9IHRhcmdldFtwcmVmaXggKyAnc2l6ZSddLFxuICAgICAgICBzWCA9IHNvdXJjZVtwcmVmaXggKyAneCddLFxuICAgICAgICBzWSA9IHNvdXJjZVtwcmVmaXggKyAneSddLFxuICAgICAgICB0WCA9IHRhcmdldFtwcmVmaXggKyAneCddLFxuICAgICAgICB0WSA9IHRhcmdldFtwcmVmaXggKyAneSddLFxuICAgICAgICBkLFxuICAgICAgICBhU2l6ZSxcbiAgICAgICAgYVgsXG4gICAgICAgIGFZLFxuICAgICAgICB2WCxcbiAgICAgICAgdlk7XG5cbiAgICBjcCA9IChzb3VyY2UuaWQgPT09IHRhcmdldC5pZCkgP1xuICAgICAgc2lnbWEudXRpbHMuZ2V0U2VsZkxvb3BDb250cm9sUG9pbnRzKHNYLCBzWSwgdFNpemUpIDpcbiAgICAgIHNpZ21hLnV0aWxzLmdldFF1YWRyYXRpY0NvbnRyb2xQb2ludChzWCwgc1ksIHRYLCB0WSk7XG5cbiAgICBpZiAoc291cmNlLmlkID09PSB0YXJnZXQuaWQpIHtcbiAgICAgIGQgPSBNYXRoLnNxcnQoTWF0aC5wb3codFggLSBjcC54MSwgMikgKyBNYXRoLnBvdyh0WSAtIGNwLnkxLCAyKSk7XG4gICAgICBhU2l6ZSA9IHNpemUgKiAyLjU7XG4gICAgICBhWCA9IGNwLngxICsgKHRYIC0gY3AueDEpICogKGQgLSBhU2l6ZSAtIHRTaXplKSAvIGQ7XG4gICAgICBhWSA9IGNwLnkxICsgKHRZIC0gY3AueTEpICogKGQgLSBhU2l6ZSAtIHRTaXplKSAvIGQ7XG4gICAgICB2WCA9ICh0WCAtIGNwLngxKSAqIGFTaXplIC8gZDtcbiAgICAgIHZZID0gKHRZIC0gY3AueTEpICogYVNpemUgLyBkO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGQgPSBNYXRoLnNxcnQoTWF0aC5wb3codFggLSBjcC54LCAyKSArIE1hdGgucG93KHRZIC0gY3AueSwgMikpO1xuICAgICAgYVNpemUgPSBzaXplICogMi41O1xuICAgICAgYVggPSBjcC54ICsgKHRYIC0gY3AueCkgKiAoZCAtIGFTaXplIC0gdFNpemUpIC8gZDtcbiAgICAgIGFZID0gY3AueSArICh0WSAtIGNwLnkpICogKGQgLSBhU2l6ZSAtIHRTaXplKSAvIGQ7XG4gICAgICB2WCA9ICh0WCAtIGNwLngpICogYVNpemUgLyBkO1xuICAgICAgdlkgPSAodFkgLSBjcC55KSAqIGFTaXplIC8gZDtcbiAgICB9XG5cbiAgICBpZiAoIWNvbG9yKVxuICAgICAgc3dpdGNoIChlZGdlQ29sb3IpIHtcbiAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICBjb2xvciA9IHNvdXJjZS5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgIGNvbG9yID0gdGFyZ2V0LmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29sb3IgPSBkZWZhdWx0RWRnZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgaWYgKHNldHRpbmdzKCdlZGdlSG92ZXJDb2xvcicpID09PSAnZWRnZScpIHtcbiAgICAgIGNvbG9yID0gZWRnZS5ob3Zlcl9jb2xvciB8fCBjb2xvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29sb3IgPSBlZGdlLmhvdmVyX2NvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0RWRnZUhvdmVyQ29sb3InKSB8fCBjb2xvcjtcbiAgICB9XG5cbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSBzaXplO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oc1gsIHNZKTtcbiAgICBpZiAoc291cmNlLmlkID09PSB0YXJnZXQuaWQpIHtcbiAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyhjcC54MiwgY3AueTIsIGNwLngxLCBjcC55MSwgYVgsIGFZKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKGNwLngsIGNwLnksIGFYLCBhWSk7XG4gICAgfVxuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG5cbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oYVggKyB2WCwgYVkgKyB2WSk7XG4gICAgY29udGV4dC5saW5lVG8oYVggKyB2WSAqIDAuNiwgYVkgLSB2WCAqIDAuNik7XG4gICAgY29udGV4dC5saW5lVG8oYVggLSB2WSAqIDAuNiwgYVkgKyB2WCAqIDAuNik7XG4gICAgY29udGV4dC5saW5lVG8oYVggKyB2WCwgYVkgKyB2WSk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5leHRyZW1pdGllcycpO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCByZW5kZXJlciBmb3IgaG92ZXJlZCBlZGdlIGV4dHJlbWl0aWVzLiBJdCByZW5kZXJzIHRoZSBlZGdlXG4gICAqIGV4dHJlbWl0aWVzIGFzIGhvdmVyZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgZWRnZSAgICAgICAgIFRoZSBlZGdlIG9iamVjdC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBzb3VyY2Ugbm9kZSAgVGhlIGVkZ2Ugc291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgdGFyZ2V0IG5vZGUgIFRoZSBlZGdlIHRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgICAgICBUaGUgY2FudmFzIGNvbnRleHQuXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICovXG4gIHNpZ21hLmNhbnZhcy5leHRyZW1pdGllcy5kZWYgPVxuICAgIGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBjb250ZXh0LCBzZXR0aW5ncykge1xuICAgIC8vIFNvdXJjZSBOb2RlOlxuICAgIChcbiAgICAgIHNpZ21hLmNhbnZhcy5ob3ZlcnNbc291cmNlLnR5cGVdIHx8XG4gICAgICBzaWdtYS5jYW52YXMuaG92ZXJzLmRlZlxuICAgICkgKFxuICAgICAgc291cmNlLCBjb250ZXh0LCBzZXR0aW5nc1xuICAgICk7XG5cbiAgICAvLyBUYXJnZXQgTm9kZTpcbiAgICAoXG4gICAgICBzaWdtYS5jYW52YXMuaG92ZXJzW3RhcmdldC50eXBlXSB8fFxuICAgICAgc2lnbWEuY2FudmFzLmhvdmVycy5kZWZcbiAgICApIChcbiAgICAgIHRhcmdldCwgY29udGV4dCwgc2V0dGluZ3NcbiAgICApO1xuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc3ZnLnV0aWxzJyk7XG5cbiAgLyoqXG4gICAqIFNvbWUgdXNlZnVsIGZ1bmN0aW9ucyB1c2VkIGJ5IHNpZ21hJ3MgU1ZHIHJlbmRlcmVyLlxuICAgKi9cbiAgc2lnbWEuc3ZnLnV0aWxzID0ge1xuXG4gICAgLyoqXG4gICAgICogU1ZHIEVsZW1lbnQgc2hvdy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9ICAgICAgICAgICAgICAgZWxlbWVudCAgIFRoZSBET00gZWxlbWVudCB0byBzaG93LlxuICAgICAqL1xuICAgIHNob3c6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNWRyBFbGVtZW50IGhpZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSAgICAgICAgICAgICAgIGVsZW1lbnQgICBUaGUgRE9NIGVsZW1lbnQgdG8gaGlkZS5cbiAgICAgKi9cbiAgICBoaWRlOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG59KSgpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5zdmcubm9kZXMnKTtcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgbm9kZSByZW5kZXJlci4gSXQgcmVuZGVycyB0aGUgbm9kZSBhcyBhIHNpbXBsZSBkaXNjLlxuICAgKi9cbiAgc2lnbWEuc3ZnLm5vZGVzLmRlZiA9IHtcblxuICAgIC8qKlxuICAgICAqIFNWRyBFbGVtZW50IGNyZWF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBub2RlICAgICBUaGUgbm9kZSBvYmplY3QuXG4gICAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAgICovXG4gICAgY3JlYXRlOiBmdW5jdGlvbihub2RlLCBzZXR0aW5ncykge1xuICAgICAgdmFyIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgICBjaXJjbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc2V0dGluZ3MoJ3htbG5zJyksICdjaXJjbGUnKTtcblxuICAgICAgLy8gRGVmaW5pbmcgdGhlIG5vZGUncyBjaXJjbGVcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZGF0YS1ub2RlLWlkJywgbm9kZS5pZCk7XG4gICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2NsYXNzJywgc2V0dGluZ3MoJ2NsYXNzUHJlZml4JykgKyAnLW5vZGUnKTtcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGVOUyhcbiAgICAgICAgbnVsbCwgJ2ZpbGwnLCBub2RlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJykpO1xuXG4gICAgICAvLyBSZXR1cm5pbmcgdGhlIERPTSBFbGVtZW50XG4gICAgICByZXR1cm4gY2lyY2xlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTVkcgRWxlbWVudCB1cGRhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIG5vZGUgICAgIFRoZSBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSAgICAgICAgICAgICAgIGNpcmNsZSAgIFRoZSBub2RlIERPTSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHVwZGF0ZTogZnVuY3Rpb24obm9kZSwgY2lyY2xlLCBzZXR0aW5ncykge1xuICAgICAgdmFyIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJztcblxuICAgICAgLy8gQXBwbHlpbmcgY2hhbmdlc1xuICAgICAgLy8gVE9ETzogb3B0aW1pemUgLSBjaGVjayBpZiBuZWNlc3NhcnlcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY3gnLCBub2RlW3ByZWZpeCArICd4J10pO1xuICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdjeScsIG5vZGVbcHJlZml4ICsgJ3knXSk7XG4gICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3InLCBub2RlW3ByZWZpeCArICdzaXplJ10pO1xuXG4gICAgICAvLyBVcGRhdGluZyBvbmx5IGlmIG5vdCBmcmVlc3R5bGVcbiAgICAgIGlmICghc2V0dGluZ3MoJ2ZyZWVTdHlsZScpKVxuICAgICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMoXG4gICAgICAgICAgbnVsbCwgJ2ZpbGwnLCBub2RlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJykpO1xuXG4gICAgICAvLyBTaG93aW5nXG4gICAgICBjaXJjbGUuc3R5bGUuZGlzcGxheSA9ICcnO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG59KSgpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5zdmcuZWRnZXMnKTtcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgZWRnZSByZW5kZXJlci4gSXQgcmVuZGVycyB0aGUgbm9kZSBhcyBhIHNpbXBsZSBsaW5lLlxuICAgKi9cbiAgc2lnbWEuc3ZnLmVkZ2VzLmRlZiA9IHtcblxuICAgIC8qKlxuICAgICAqIFNWRyBFbGVtZW50IGNyZWF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBlZGdlICAgICAgIFRoZSBlZGdlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHNvdXJjZSAgICAgVGhlIHNvdXJjZSBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCAgICAgVGhlIHRhcmdldCBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGNyZWF0ZTogZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIHNldHRpbmdzKSB7XG4gICAgICB2YXIgY29sb3IgPSBlZGdlLmNvbG9yLFxuICAgICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgICBlZGdlQ29sb3IgPSBzZXR0aW5ncygnZWRnZUNvbG9yJyksXG4gICAgICAgICAgZGVmYXVsdE5vZGVDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyksXG4gICAgICAgICAgZGVmYXVsdEVkZ2VDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyk7XG5cbiAgICAgIGlmICghY29sb3IpXG4gICAgICAgIHN3aXRjaCAoZWRnZUNvbG9yKSB7XG4gICAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICAgIGNvbG9yID0gc291cmNlLmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgICAgY29sb3IgPSB0YXJnZXQuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb2xvciA9IGRlZmF1bHRFZGdlQ29sb3I7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICB2YXIgbGluZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzZXR0aW5ncygneG1sbnMnKSwgJ2xpbmUnKTtcblxuICAgICAgLy8gQXR0cmlidXRlc1xuICAgICAgbGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZGF0YS1lZGdlLWlkJywgZWRnZS5pZCk7XG4gICAgICBsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsICdjbGFzcycsIHNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1lZGdlJyk7XG4gICAgICBsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsICdzdHJva2UnLCBjb2xvcik7XG5cbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTVkcgRWxlbWVudCB1cGRhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgVGhlIGVkZ2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9ICAgICAgICAgICAgICAgbGluZSAgICAgICBUaGUgbGluZSBET00gRWxlbWVudC5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHNvdXJjZSAgICAgVGhlIHNvdXJjZSBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCAgICAgVGhlIHRhcmdldCBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHVwZGF0ZTogZnVuY3Rpb24oZWRnZSwgbGluZSwgc291cmNlLCB0YXJnZXQsIHNldHRpbmdzKSB7XG4gICAgICB2YXIgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnO1xuXG4gICAgICBsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsICdzdHJva2Utd2lkdGgnLCBlZGdlW3ByZWZpeCArICdzaXplJ10gfHwgMSk7XG4gICAgICBsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsICd4MScsIHNvdXJjZVtwcmVmaXggKyAneCddKTtcbiAgICAgIGxpbmUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3kxJywgc291cmNlW3ByZWZpeCArICd5J10pO1xuICAgICAgbGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneDInLCB0YXJnZXRbcHJlZml4ICsgJ3gnXSk7XG4gICAgICBsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsICd5MicsIHRhcmdldFtwcmVmaXggKyAneSddKTtcblxuICAgICAgLy8gU2hvd2luZ1xuICAgICAgbGluZS5zdHlsZS5kaXNwbGF5ID0gJyc7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnN2Zy5lZGdlcycpO1xuXG4gIC8qKlxuICAgKiBUaGUgY3VydmUgZWRnZSByZW5kZXJlci4gSXQgcmVuZGVycyB0aGUgbm9kZSBhcyBhIGJlemllciBjdXJ2ZS5cbiAgICovXG4gIHNpZ21hLnN2Zy5lZGdlcy5jdXJ2ZSA9IHtcblxuICAgIC8qKlxuICAgICAqIFNWRyBFbGVtZW50IGNyZWF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBlZGdlICAgICAgIFRoZSBlZGdlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHNvdXJjZSAgICAgVGhlIHNvdXJjZSBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCAgICAgVGhlIHRhcmdldCBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGNyZWF0ZTogZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIHNldHRpbmdzKSB7XG4gICAgICB2YXIgY29sb3IgPSBlZGdlLmNvbG9yLFxuICAgICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgICBlZGdlQ29sb3IgPSBzZXR0aW5ncygnZWRnZUNvbG9yJyksXG4gICAgICAgICAgZGVmYXVsdE5vZGVDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyksXG4gICAgICAgICAgZGVmYXVsdEVkZ2VDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyk7XG5cbiAgICAgIGlmICghY29sb3IpXG4gICAgICAgIHN3aXRjaCAoZWRnZUNvbG9yKSB7XG4gICAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICAgIGNvbG9yID0gc291cmNlLmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgICAgY29sb3IgPSB0YXJnZXQuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb2xvciA9IGRlZmF1bHRFZGdlQ29sb3I7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICB2YXIgcGF0aCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzZXR0aW5ncygneG1sbnMnKSwgJ3BhdGgnKTtcblxuICAgICAgLy8gQXR0cmlidXRlc1xuICAgICAgcGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZGF0YS1lZGdlLWlkJywgZWRnZS5pZCk7XG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICdjbGFzcycsIHNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1lZGdlJyk7XG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICdzdHJva2UnLCBjb2xvcik7XG5cbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTVkcgRWxlbWVudCB1cGRhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgVGhlIGVkZ2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9ICAgICAgICAgICAgICAgbGluZSAgICAgICBUaGUgbGluZSBET00gRWxlbWVudC5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHNvdXJjZSAgICAgVGhlIHNvdXJjZSBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCAgICAgVGhlIHRhcmdldCBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHVwZGF0ZTogZnVuY3Rpb24oZWRnZSwgcGF0aCwgc291cmNlLCB0YXJnZXQsIHNldHRpbmdzKSB7XG4gICAgICB2YXIgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnO1xuXG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICdzdHJva2Utd2lkdGgnLCBlZGdlW3ByZWZpeCArICdzaXplJ10gfHwgMSk7XG5cbiAgICAgIC8vIENvbnRyb2wgcG9pbnRcbiAgICAgIHZhciBjeCA9IChzb3VyY2VbcHJlZml4ICsgJ3gnXSArIHRhcmdldFtwcmVmaXggKyAneCddKSAvIDIgK1xuICAgICAgICAodGFyZ2V0W3ByZWZpeCArICd5J10gLSBzb3VyY2VbcHJlZml4ICsgJ3knXSkgLyA0LFxuICAgICAgICAgIGN5ID0gKHNvdXJjZVtwcmVmaXggKyAneSddICsgdGFyZ2V0W3ByZWZpeCArICd5J10pIC8gMiArXG4gICAgICAgIChzb3VyY2VbcHJlZml4ICsgJ3gnXSAtIHRhcmdldFtwcmVmaXggKyAneCddKSAvIDQ7XG5cbiAgICAgIC8vIFBhdGhcbiAgICAgIHZhciBwID0gJ00nICsgc291cmNlW3ByZWZpeCArICd4J10gKyAnLCcgKyBzb3VyY2VbcHJlZml4ICsgJ3knXSArICcgJyArXG4gICAgICAgICAgICAgICdRJyArIGN4ICsgJywnICsgY3kgKyAnICcgK1xuICAgICAgICAgICAgICB0YXJnZXRbcHJlZml4ICsgJ3gnXSArICcsJyArIHRhcmdldFtwcmVmaXggKyAneSddO1xuXG4gICAgICAvLyBVcGRhdGluZyBhdHRyaWJ1dGVzXG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkJywgcCk7XG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICdmaWxsJywgJ25vbmUnKTtcblxuICAgICAgLy8gU2hvd2luZ1xuICAgICAgcGF0aC5zdHlsZS5kaXNwbGF5ID0gJyc7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnN2Zy5sYWJlbHMnKTtcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgbGFiZWwgcmVuZGVyZXIuIEl0IHJlbmRlcnMgdGhlIGxhYmVsIGFzIGEgc2ltcGxlIHRleHQuXG4gICAqL1xuICBzaWdtYS5zdmcubGFiZWxzLmRlZiA9IHtcblxuICAgIC8qKlxuICAgICAqIFNWRyBFbGVtZW50IGNyZWF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBub2RlICAgICAgIFRoZSBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGNyZWF0ZTogZnVuY3Rpb24obm9kZSwgc2V0dGluZ3MpIHtcbiAgICAgIHZhciBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXG4gICAgICAgICAgc2l6ZSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXSxcbiAgICAgICAgICB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHNldHRpbmdzKCd4bWxucycpLCAndGV4dCcpO1xuXG4gICAgICB2YXIgZm9udFNpemUgPSAoc2V0dGluZ3MoJ2xhYmVsU2l6ZScpID09PSAnZml4ZWQnKSA/XG4gICAgICAgIHNldHRpbmdzKCdkZWZhdWx0TGFiZWxTaXplJykgOlxuICAgICAgICBzZXR0aW5ncygnbGFiZWxTaXplUmF0aW8nKSAqIHNpemU7XG5cbiAgICAgIHZhciBmb250Q29sb3IgPSAoc2V0dGluZ3MoJ2xhYmVsQ29sb3InKSA9PT0gJ25vZGUnKSA/XG4gICAgICAgIChub2RlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJykpIDpcbiAgICAgICAgc2V0dGluZ3MoJ2RlZmF1bHRMYWJlbENvbG9yJyk7XG5cbiAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2RhdGEtbGFiZWwtdGFyZ2V0Jywgbm9kZS5pZCk7XG4gICAgICB0ZXh0LnNldEF0dHJpYnV0ZU5TKG51bGwsICdjbGFzcycsIHNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1sYWJlbCcpO1xuICAgICAgdGV4dC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZm9udC1zaXplJywgZm9udFNpemUpO1xuICAgICAgdGV4dC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZm9udC1mYW1pbHknLCBzZXR0aW5ncygnZm9udCcpKTtcbiAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZpbGwnLCBmb250Q29sb3IpO1xuXG4gICAgICB0ZXh0LmlubmVySFRNTCA9IG5vZGUubGFiZWw7XG4gICAgICB0ZXh0LnRleHRDb250ZW50ID0gbm9kZS5sYWJlbDtcblxuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNWRyBFbGVtZW50IHVwZGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgbm9kZSAgICAgVGhlIG5vZGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9ICAgICAgICAgICAgICAgdGV4dCAgICAgVGhlIGxhYmVsIERPTSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHVwZGF0ZTogZnVuY3Rpb24obm9kZSwgdGV4dCwgc2V0dGluZ3MpIHtcbiAgICAgIHZhciBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXG4gICAgICAgICAgc2l6ZSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXTtcblxuICAgICAgdmFyIGZvbnRTaXplID0gKHNldHRpbmdzKCdsYWJlbFNpemUnKSA9PT0gJ2ZpeGVkJykgP1xuICAgICAgICBzZXR0aW5ncygnZGVmYXVsdExhYmVsU2l6ZScpIDpcbiAgICAgICAgc2V0dGluZ3MoJ2xhYmVsU2l6ZVJhdGlvJykgKiBzaXplO1xuXG4gICAgICAvLyBDYXNlIHdoZW4gd2UgZG9uJ3Qgd2FudCB0byBkaXNwbGF5IHRoZSBsYWJlbFxuICAgICAgaWYgKCFzZXR0aW5ncygnZm9yY2VMYWJlbHMnKSAmJiBzaXplIDwgc2V0dGluZ3MoJ2xhYmVsVGhyZXNob2xkJykpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgaWYgKHR5cGVvZiBub2RlLmxhYmVsICE9PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICAvLyBVcGRhdGluZ1xuICAgICAgdGV4dC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneCcsXG4gICAgICAgIE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneCddICsgc2l6ZSArIDMpKTtcbiAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3knLFxuICAgICAgICBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3knXSArIGZvbnRTaXplIC8gMykpO1xuXG4gICAgICAvLyBTaG93aW5nXG4gICAgICB0ZXh0LnN0eWxlLmRpc3BsYXkgPSAnJztcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc3ZnLmhvdmVycycpO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBob3ZlciByZW5kZXJlci5cbiAgICovXG4gIHNpZ21hLnN2Zy5ob3ZlcnMuZGVmID0ge1xuXG4gICAgLyoqXG4gICAgICogU1ZHIEVsZW1lbnQgY3JlYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICBub2RlICAgICAgICAgICAgICAgVGhlIG5vZGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge0NhbnZhc0VsZW1lbnR9ICAgIG1lYXN1cmVtZW50Q2FudmFzICBBIGZha2UgY2FudmFzIGhhbmRsZWQgYnlcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgc3ZnIHRvIHBlcmZvcm0gc29tZSBtZWFzdXJlbWVudHMgYW5kXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzc2VkIGJ5IHRoZSByZW5kZXJlci5cbiAgICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSAgICAgICBub2RlQ2lyY2xlICAgICAgICAgVGhlIG5vZGUgRE9NIEVsZW1lbnQuXG4gICAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgc2V0dGluZ3MgICAgICAgICAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBjcmVhdGU6IGZ1bmN0aW9uKG5vZGUsIG5vZGVDaXJjbGUsIG1lYXN1cmVtZW50Q2FudmFzLCBzZXR0aW5ncykge1xuXG4gICAgICAvLyBEZWZpbmluZyB2aXN1YWwgcHJvcGVydGllc1xuICAgICAgdmFyIHgsXG4gICAgICAgICAgeSxcbiAgICAgICAgICB3LFxuICAgICAgICAgIGgsXG4gICAgICAgICAgZSxcbiAgICAgICAgICBkLFxuICAgICAgICAgIGZvbnRTdHlsZSA9IHNldHRpbmdzKCdob3ZlckZvbnRTdHlsZScpIHx8IHNldHRpbmdzKCdmb250U3R5bGUnKSxcbiAgICAgICAgICBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXG4gICAgICAgICAgc2l6ZSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXSxcbiAgICAgICAgICBmb250U2l6ZSA9IChzZXR0aW5ncygnbGFiZWxTaXplJykgPT09ICdmaXhlZCcpID9cbiAgICAgICAgICAgIHNldHRpbmdzKCdkZWZhdWx0TGFiZWxTaXplJykgOlxuICAgICAgICAgICAgc2V0dGluZ3MoJ2xhYmVsU2l6ZVJhdGlvJykgKiBzaXplLFxuICAgICAgICAgIGZvbnRDb2xvciA9IChzZXR0aW5ncygnbGFiZWxIb3ZlckNvbG9yJykgPT09ICdub2RlJykgP1xuICAgICAgICAgICAgICAgICAgICAgICAgKG5vZGUuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MoJ2RlZmF1bHRMYWJlbEhvdmVyQ29sb3InKTtcblxuICAgICAgLy8gQ3JlYXRpbmcgZWxlbWVudHNcbiAgICAgIHZhciBncm91cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzZXR0aW5ncygneG1sbnMnKSwgJ2cnKSxcbiAgICAgICAgICByZWN0YW5nbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc2V0dGluZ3MoJ3htbG5zJyksICdyZWN0JyksXG4gICAgICAgICAgY2lyY2xlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHNldHRpbmdzKCd4bWxucycpLCAnY2lyY2xlJyksXG4gICAgICAgICAgdGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzZXR0aW5ncygneG1sbnMnKSwgJ3RleHQnKTtcblxuICAgICAgLy8gRGVmaW5pbmcgcHJvcGVydGllc1xuICAgICAgZ3JvdXAuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2NsYXNzJywgc2V0dGluZ3MoJ2NsYXNzUHJlZml4JykgKyAnLWhvdmVyJyk7XG4gICAgICBncm91cC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZGF0YS1ub2RlLWlkJywgbm9kZS5pZCk7XG5cbiAgICAgIGlmICh0eXBlb2Ygbm9kZS5sYWJlbCA9PT0gJ3N0cmluZycpIHtcblxuICAgICAgICAvLyBUZXh0XG4gICAgICAgIHRleHQuaW5uZXJIVE1MID0gbm9kZS5sYWJlbDtcbiAgICAgICAgdGV4dC50ZXh0Q29udGVudCA9IG5vZGUubGFiZWw7XG4gICAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMoXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgJ2NsYXNzJyxcbiAgICAgICAgICAgIHNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1ob3Zlci1sYWJlbCcpO1xuICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZU5TKG51bGwsICdmb250LXNpemUnLCBmb250U2l6ZSk7XG4gICAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZvbnQtZmFtaWx5Jywgc2V0dGluZ3MoJ2ZvbnQnKSk7XG4gICAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZpbGwnLCBmb250Q29sb3IpO1xuICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZU5TKG51bGwsICd4JyxcbiAgICAgICAgICBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3gnXSArIHNpemUgKyAzKSk7XG4gICAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3knLFxuICAgICAgICAgIE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneSddICsgZm9udFNpemUgLyAzKSk7XG5cbiAgICAgICAgLy8gTWVhc3VyZXNcbiAgICAgICAgLy8gT1BUSU1JWkU6IEZpbmQgYSBiZXR0ZXIgd2F5IHRoYW4gYSBtZWFzdXJlbWVudCBjYW52YXNcbiAgICAgICAgeCA9IE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneCddIC0gZm9udFNpemUgLyAyIC0gMik7XG4gICAgICAgIHkgPSBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3knXSAtIGZvbnRTaXplIC8gMiAtIDIpO1xuICAgICAgICB3ID0gTWF0aC5yb3VuZChcbiAgICAgICAgICBtZWFzdXJlbWVudENhbnZhcy5tZWFzdXJlVGV4dChub2RlLmxhYmVsKS53aWR0aCArXG4gICAgICAgICAgICBmb250U2l6ZSAvIDIgKyBzaXplICsgOVxuICAgICAgICApO1xuICAgICAgICBoID0gTWF0aC5yb3VuZChmb250U2l6ZSArIDQpO1xuICAgICAgICBlID0gTWF0aC5yb3VuZChmb250U2l6ZSAvIDIgKyAyKTtcblxuICAgICAgICAvLyBDaXJjbGVcbiAgICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZU5TKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICdjbGFzcycsXG4gICAgICAgICAgICBzZXR0aW5ncygnY2xhc3NQcmVmaXgnKSArICctaG92ZXItYXJlYScpO1xuICAgICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZpbGwnLCAnI2ZmZicpO1xuICAgICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2N4Jywgbm9kZVtwcmVmaXggKyAneCddKTtcbiAgICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdjeScsIG5vZGVbcHJlZml4ICsgJ3knXSk7XG4gICAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAncicsIGUpO1xuXG4gICAgICAgIC8vIFJlY3RhbmdsZVxuICAgICAgICByZWN0YW5nbGUuc2V0QXR0cmlidXRlTlMoXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgJ2NsYXNzJyxcbiAgICAgICAgICAgIHNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1ob3Zlci1hcmVhJyk7XG4gICAgICAgIHJlY3RhbmdsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZmlsbCcsICcjZmZmJyk7XG4gICAgICAgIHJlY3RhbmdsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneCcsIG5vZGVbcHJlZml4ICsgJ3gnXSArIGUgLyA0KTtcbiAgICAgICAgcmVjdGFuZ2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICd5Jywgbm9kZVtwcmVmaXggKyAneSddIC0gZSk7XG4gICAgICAgIHJlY3RhbmdsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnd2lkdGgnLCB3KTtcbiAgICAgICAgcmVjdGFuZ2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdoZWlnaHQnLCBoKTtcbiAgICAgIH1cblxuICAgICAgLy8gQXBwZW5kaW5nIGNoaWxkc1xuICAgICAgZ3JvdXAuYXBwZW5kQ2hpbGQoY2lyY2xlKTtcbiAgICAgIGdyb3VwLmFwcGVuZENoaWxkKHJlY3RhbmdsZSk7XG4gICAgICBncm91cC5hcHBlbmRDaGlsZCh0ZXh0KTtcbiAgICAgIGdyb3VwLmFwcGVuZENoaWxkKG5vZGVDaXJjbGUpO1xuXG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfVxuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEubWlkZGxld2FyZXMnKTtcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS51dGlscycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1pZGRsZXdhcmUgd2lsbCByZXNjYWxlIHRoZSBncmFwaCBzdWNoIHRoYXQgaXQgdGFrZXMgYW4gb3B0aW1hbCBzcGFjZVxuICAgKiBvbiB0aGUgcmVuZGVyZXIuXG4gICAqXG4gICAqIEFzIGVhY2ggbWlkZGxld2FyZSwgdGhpcyBmdW5jdGlvbiBpcyBleGVjdXRlZCBpbiB0aGUgc2NvcGUgb2YgdGhlIHNpZ21hXG4gICAqIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IHJlYWRQcmVmaXggIFRoZSByZWFkIHByZWZpeC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSB3cml0ZVByZWZpeCBUaGUgd3JpdGUgcHJlZml4LlxuICAgKiBAcGFyYW0ge29iamVjdH0gIG9wdGlvbnMgICAgIFRoZSBwYXJhbWV0ZXJzLlxuICAgKi9cbiAgc2lnbWEubWlkZGxld2FyZXMucmVzY2FsZSA9IGZ1bmN0aW9uKHJlYWRQcmVmaXgsIHdyaXRlUHJlZml4LCBvcHRpb25zKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIGEsXG4gICAgICAgIGIsXG4gICAgICAgIGMsXG4gICAgICAgIGQsXG4gICAgICAgIHNjYWxlLFxuICAgICAgICBtYXJnaW4sXG4gICAgICAgIG4gPSB0aGlzLmdyYXBoLm5vZGVzKCksXG4gICAgICAgIGUgPSB0aGlzLmdyYXBoLmVkZ2VzKCksXG4gICAgICAgIHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncy5lbWJlZE9iamVjdHMob3B0aW9ucyB8fCB7fSksXG4gICAgICAgIGJvdW5kcyA9IHNldHRpbmdzKCdib3VuZHMnKSB8fCBzaWdtYS51dGlscy5nZXRCb3VuZGFyaWVzKFxuICAgICAgICAgIHRoaXMuZ3JhcGgsXG4gICAgICAgICAgcmVhZFByZWZpeCxcbiAgICAgICAgICB0cnVlXG4gICAgICAgICksXG4gICAgICAgIG1pblggPSBib3VuZHMubWluWCxcbiAgICAgICAgbWluWSA9IGJvdW5kcy5taW5ZLFxuICAgICAgICBtYXhYID0gYm91bmRzLm1heFgsXG4gICAgICAgIG1heFkgPSBib3VuZHMubWF4WSxcbiAgICAgICAgc2l6ZU1heCA9IGJvdW5kcy5zaXplTWF4LFxuICAgICAgICB3ZWlnaHRNYXggPSBib3VuZHMud2VpZ2h0TWF4LFxuICAgICAgICB3ID0gc2V0dGluZ3MoJ3dpZHRoJykgfHwgMSxcbiAgICAgICAgaCA9IHNldHRpbmdzKCdoZWlnaHQnKSB8fCAxLFxuICAgICAgICByZXNjYWxlU2V0dGluZ3MgPSBzZXR0aW5ncygnYXV0b1Jlc2NhbGUnKSxcbiAgICAgICAgdmFsaWRTZXR0aW5ncyA9IHtcbiAgICAgICAgICBub2RlUG9zaXRpb246IDEsXG4gICAgICAgICAgbm9kZVNpemU6IDEsXG4gICAgICAgICAgZWRnZVNpemU6IDFcbiAgICAgICAgfTtcblxuICAgIC8qKlxuICAgICAqIFdoYXQgZWxlbWVudHMgc2hvdWxkIHdlIHJlc2NhbGU/XG4gICAgICovXG4gICAgaWYgKCEocmVzY2FsZVNldHRpbmdzIGluc3RhbmNlb2YgQXJyYXkpKVxuICAgICAgcmVzY2FsZVNldHRpbmdzID0gWydub2RlUG9zaXRpb24nLCAnbm9kZVNpemUnLCAnZWRnZVNpemUnXTtcblxuICAgIGZvciAoaSA9IDAsIGwgPSByZXNjYWxlU2V0dGluZ3MubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgaWYgKCF2YWxpZFNldHRpbmdzW3Jlc2NhbGVTZXR0aW5nc1tpXV0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnVGhlIHJlc2NhbGUgc2V0dGluZyBcIicgKyByZXNjYWxlU2V0dGluZ3NbaV0gKyAnXCIgaXMgbm90IHJlY29nbml6ZWQuJ1xuICAgICAgICApO1xuXG4gICAgdmFyIG5wID0gfnJlc2NhbGVTZXR0aW5ncy5pbmRleE9mKCdub2RlUG9zaXRpb24nKSxcbiAgICAgICAgbnMgPSB+cmVzY2FsZVNldHRpbmdzLmluZGV4T2YoJ25vZGVTaXplJyksXG4gICAgICAgIGVzID0gfnJlc2NhbGVTZXR0aW5ncy5pbmRleE9mKCdlZGdlU2l6ZScpO1xuXG4gICAgLyoqXG4gICAgICogRmlyc3QsIHdlIGNvbXB1dGUgdGhlIHNjYWxpbmcgcmF0aW8sIHdpdGhvdXQgY29uc2lkZXJpbmcgdGhlIHNpemVzXG4gICAgICogb2YgdGhlIG5vZGVzIDogRWFjaCBub2RlIHdpbGwgaGF2ZSBpdHMgY2VudGVyIGluIHRoZSBjYW52YXMsIGJ1dCBtaWdodFxuICAgICAqIGJlIHBhcnRpYWxseSBvdXQgb2YgaXQuXG4gICAgICovXG4gICAgc2NhbGUgPSBzZXR0aW5ncygnc2NhbGluZ01vZGUnKSA9PT0gJ291dHNpZGUnID9cbiAgICAgIE1hdGgubWF4KFxuICAgICAgICB3IC8gTWF0aC5tYXgobWF4WCAtIG1pblgsIDEpLFxuICAgICAgICBoIC8gTWF0aC5tYXgobWF4WSAtIG1pblksIDEpXG4gICAgICApIDpcbiAgICAgIE1hdGgubWluKFxuICAgICAgICB3IC8gTWF0aC5tYXgobWF4WCAtIG1pblgsIDEpLFxuICAgICAgICBoIC8gTWF0aC5tYXgobWF4WSAtIG1pblksIDEpXG4gICAgICApO1xuXG4gICAgLyoqXG4gICAgICogVGhlbiwgd2UgY29ycmVjdCB0aGF0IHNjYWxpbmcgcmF0aW8gY29uc2lkZXJpbmcgYSBtYXJnaW4sIHdoaWNoIGlzXG4gICAgICogYmFzaWNhbGx5IHRoZSBzaXplIG9mIHRoZSBiaWdnZXN0IG5vZGUuXG4gICAgICogVGhpcyBoYXMgdG8gYmUgZG9uZSBhcyBhIGNvcnJlY3Rpb24gc2luY2UgdG8gY29tcGFyZSB0aGUgc2l6ZSBvZiB0aGVcbiAgICAgKiBiaWdnZXN0IG5vZGUgdG8gdGhlIFggYW5kIFkgdmFsdWVzLCB3ZSBoYXZlIHRvIGZpcnN0IGdldCBhblxuICAgICAqIGFwcHJveGltYXRpb24gb2YgdGhlIHNjYWxpbmcgcmF0aW8uXG4gICAgICoqL1xuICAgIG1hcmdpbiA9XG4gICAgICAoXG4gICAgICAgIHNldHRpbmdzKCdyZXNjYWxlSWdub3JlU2l6ZScpID9cbiAgICAgICAgICAwIDpcbiAgICAgICAgICAoc2V0dGluZ3MoJ21heE5vZGVTaXplJykgfHwgc2l6ZU1heCkgLyBzY2FsZVxuICAgICAgKSArXG4gICAgICAoc2V0dGluZ3MoJ3NpZGVNYXJnaW4nKSB8fCAwKTtcbiAgICBtYXhYICs9IG1hcmdpbjtcbiAgICBtaW5YIC09IG1hcmdpbjtcbiAgICBtYXhZICs9IG1hcmdpbjtcbiAgICBtaW5ZIC09IG1hcmdpbjtcblxuICAgIC8vIEZpeCB0aGUgc2NhbGluZyB3aXRoIHRoZSBuZXcgZXh0cmVtYTpcbiAgICBzY2FsZSA9IHNldHRpbmdzKCdzY2FsaW5nTW9kZScpID09PSAnb3V0c2lkZScgP1xuICAgICAgTWF0aC5tYXgoXG4gICAgICAgIHcgLyBNYXRoLm1heChtYXhYIC0gbWluWCwgMSksXG4gICAgICAgIGggLyBNYXRoLm1heChtYXhZIC0gbWluWSwgMSlcbiAgICAgICkgOlxuICAgICAgTWF0aC5taW4oXG4gICAgICAgIHcgLyBNYXRoLm1heChtYXhYIC0gbWluWCwgMSksXG4gICAgICAgIGggLyBNYXRoLm1heChtYXhZIC0gbWluWSwgMSlcbiAgICAgICk7XG5cbiAgICAvLyBTaXplIGhvbW90aGV0aWMgcGFyYW1ldGVyczpcbiAgICBpZiAoIXNldHRpbmdzKCdtYXhOb2RlU2l6ZScpICYmICFzZXR0aW5ncygnbWluTm9kZVNpemUnKSkge1xuICAgICAgYSA9IDE7XG4gICAgICBiID0gMDtcbiAgICB9IGVsc2UgaWYgKHNldHRpbmdzKCdtYXhOb2RlU2l6ZScpID09PSBzZXR0aW5ncygnbWluTm9kZVNpemUnKSkge1xuICAgICAgYSA9IDA7XG4gICAgICBiID0gK3NldHRpbmdzKCdtYXhOb2RlU2l6ZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gKHNldHRpbmdzKCdtYXhOb2RlU2l6ZScpIC0gc2V0dGluZ3MoJ21pbk5vZGVTaXplJykpIC8gc2l6ZU1heDtcbiAgICAgIGIgPSArc2V0dGluZ3MoJ21pbk5vZGVTaXplJyk7XG4gICAgfVxuXG4gICAgaWYgKCFzZXR0aW5ncygnbWF4RWRnZVNpemUnKSAmJiAhc2V0dGluZ3MoJ21pbkVkZ2VTaXplJykpIHtcbiAgICAgIGMgPSAxO1xuICAgICAgZCA9IDA7XG4gICAgfSBlbHNlIGlmIChzZXR0aW5ncygnbWF4RWRnZVNpemUnKSA9PT0gc2V0dGluZ3MoJ21pbkVkZ2VTaXplJykpIHtcbiAgICAgIGMgPSAwO1xuICAgICAgZCA9ICtzZXR0aW5ncygnbWluRWRnZVNpemUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYyA9IChzZXR0aW5ncygnbWF4RWRnZVNpemUnKSAtIHNldHRpbmdzKCdtaW5FZGdlU2l6ZScpKSAvIHdlaWdodE1heDtcbiAgICAgIGQgPSArc2V0dGluZ3MoJ21pbkVkZ2VTaXplJyk7XG4gICAgfVxuXG4gICAgLy8gUmVzY2FsZSB0aGUgbm9kZXMgYW5kIGVkZ2VzOlxuICAgIGZvciAoaSA9IDAsIGwgPSBlLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIGVbaV1bd3JpdGVQcmVmaXggKyAnc2l6ZSddID1cbiAgICAgICAgZVtpXVtyZWFkUHJlZml4ICsgJ3NpemUnXSAqIChlcyA/IGMgOiAxKSArIChlcyA/IGQgOiAwKTtcblxuICAgIGZvciAoaSA9IDAsIGwgPSBuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbltpXVt3cml0ZVByZWZpeCArICdzaXplJ10gPVxuICAgICAgICBuW2ldW3JlYWRQcmVmaXggKyAnc2l6ZSddICogKG5zID8gYSA6IDEpICsgKG5zID8gYiA6IDApO1xuICAgICAgbltpXVt3cml0ZVByZWZpeCArICd4J10gPVxuICAgICAgICAobltpXVtyZWFkUHJlZml4ICsgJ3gnXSAtIChtYXhYICsgbWluWCkgLyAyKSAqIChucCA/IHNjYWxlIDogMSk7XG4gICAgICBuW2ldW3dyaXRlUHJlZml4ICsgJ3knXSA9XG4gICAgICAgIChuW2ldW3JlYWRQcmVmaXggKyAneSddIC0gKG1heFkgKyBtaW5ZKSAvIDIpICogKG5wID8gc2NhbGUgOiAxKTtcbiAgICB9XG4gIH07XG5cbiAgc2lnbWEudXRpbHMuZ2V0Qm91bmRhcmllcyA9IGZ1bmN0aW9uKGdyYXBoLCBwcmVmaXgsIGRvRWRnZXMpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgZSA9IGdyYXBoLmVkZ2VzKCksXG4gICAgICAgIG4gPSBncmFwaC5ub2RlcygpLFxuICAgICAgICB3ZWlnaHRNYXggPSAtSW5maW5pdHksXG4gICAgICAgIHNpemVNYXggPSAtSW5maW5pdHksXG4gICAgICAgIG1pblggPSBJbmZpbml0eSxcbiAgICAgICAgbWluWSA9IEluZmluaXR5LFxuICAgICAgICBtYXhYID0gLUluZmluaXR5LFxuICAgICAgICBtYXhZID0gLUluZmluaXR5O1xuXG4gICAgaWYgKGRvRWRnZXMpXG4gICAgICBmb3IgKGkgPSAwLCBsID0gZS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIHdlaWdodE1heCA9IE1hdGgubWF4KGVbaV1bcHJlZml4ICsgJ3NpemUnXSwgd2VpZ2h0TWF4KTtcblxuICAgIGZvciAoaSA9IDAsIGwgPSBuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgc2l6ZU1heCA9IE1hdGgubWF4KG5baV1bcHJlZml4ICsgJ3NpemUnXSwgc2l6ZU1heCk7XG4gICAgICBtYXhYID0gTWF0aC5tYXgobltpXVtwcmVmaXggKyAneCddLCBtYXhYKTtcbiAgICAgIG1pblggPSBNYXRoLm1pbihuW2ldW3ByZWZpeCArICd4J10sIG1pblgpO1xuICAgICAgbWF4WSA9IE1hdGgubWF4KG5baV1bcHJlZml4ICsgJ3knXSwgbWF4WSk7XG4gICAgICBtaW5ZID0gTWF0aC5taW4obltpXVtwcmVmaXggKyAneSddLCBtaW5ZKTtcbiAgICB9XG5cbiAgICB3ZWlnaHRNYXggPSB3ZWlnaHRNYXggfHwgMTtcbiAgICBzaXplTWF4ID0gc2l6ZU1heCB8fCAxO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHdlaWdodE1heDogd2VpZ2h0TWF4LFxuICAgICAgc2l6ZU1heDogc2l6ZU1heCxcbiAgICAgIG1pblg6IG1pblgsXG4gICAgICBtaW5ZOiBtaW5ZLFxuICAgICAgbWF4WDogbWF4WCxcbiAgICAgIG1heFk6IG1heFlcbiAgICB9O1xuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEubWlkZGxld2FyZXMnKTtcblxuICAvKipcbiAgICogVGhpcyBtaWRkbGV3YXJlIHdpbGwganVzdCBjb3B5IHRoZSBncmFwaGljIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gcmVhZFByZWZpeCAgVGhlIHJlYWQgcHJlZml4LlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IHdyaXRlUHJlZml4IFRoZSB3cml0ZSBwcmVmaXguXG4gICAqL1xuICBzaWdtYS5taWRkbGV3YXJlcy5jb3B5ID0gZnVuY3Rpb24ocmVhZFByZWZpeCwgd3JpdGVQcmVmaXgpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgYTtcblxuICAgIGlmICh3cml0ZVByZWZpeCArICcnID09PSByZWFkUHJlZml4ICsgJycpXG4gICAgICByZXR1cm47XG5cbiAgICBhID0gdGhpcy5ncmFwaC5ub2RlcygpO1xuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgYVtpXVt3cml0ZVByZWZpeCArICd4J10gPSBhW2ldW3JlYWRQcmVmaXggKyAneCddO1xuICAgICAgYVtpXVt3cml0ZVByZWZpeCArICd5J10gPSBhW2ldW3JlYWRQcmVmaXggKyAneSddO1xuICAgICAgYVtpXVt3cml0ZVByZWZpeCArICdzaXplJ10gPSBhW2ldW3JlYWRQcmVmaXggKyAnc2l6ZSddO1xuICAgIH1cblxuICAgIGEgPSB0aGlzLmdyYXBoLmVkZ2VzKCk7XG4gICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgYVtpXVt3cml0ZVByZWZpeCArICdzaXplJ10gPSBhW2ldW3JlYWRQcmVmaXggKyAnc2l6ZSddO1xuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEubWlzYy5hbmltYXRpb24ucnVubmluZycpO1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSB1bmlxdWUgSUQgZm9yIHRoZSBhbmltYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gUmV0dXJucyB0aGUgbmV3IElELlxuICAgKi9cbiAgdmFyIF9nZXRJRCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgaWQgPSAwO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnJyArICgrK2lkKTtcbiAgICB9O1xuICB9KSgpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFuaW1hdGVzIGEgY2FtZXJhLiBJdCBoYXMgdG8gYmUgY2FsbGVkIHdpdGggdGhlIGNhbWVyYSB0b1xuICAgKiBhbmltYXRlLCB0aGUgdmFsdWVzIG9mIHRoZSBjb29yZGluYXRlcyB0byByZWFjaCBhbmQgZXZlbnR1YWxseSBzb21lXG4gICAqIG9wdGlvbnMuIEl0IHJldHVybnMgYSBudW1iZXIgaWQsIHRoYXQgeW91IGNhbiB1c2UgdG8ga2lsbCB0aGUgYW5pbWF0aW9uLFxuICAgKiB3aXRoIHRoZSBtZXRob2Qgc2lnbWEubWlzYy5hbmltYXRpb24ua2lsbChpZCkuXG4gICAqXG4gICAqIFRoZSBhdmFpbGFibGUgb3B0aW9ucyBhcmU6XG4gICAqXG4gICAqICAgez9udW1iZXJ9ICAgICAgICAgICAgZHVyYXRpb24gICBUaGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbi5cbiAgICogICB7P2Z1bmN0aW9ufSAgICAgICAgICBvbk5ld0ZyYW1lIEEgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHRoZSBhbmltYXRpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudGVyIGEgbmV3IGZyYW1lLlxuICAgKiAgIHs/ZnVuY3Rpb259ICAgICAgICAgIG9uQ29tcGxldGUgQSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gdGhlIGFuaW1hdGlvblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgY29tcGxldGVkIG9yIGtpbGxlZC5cbiAgICogICB7PyhzdHJpbmd8ZnVuY3Rpb24pfSBlYXNpbmcgICAgIFRoZSBuYW1lIG9mIGEgZnVuY3Rpb24gZnJvbSB0aGUgcGFja2FnZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbWEudXRpbHMuZWFzaW5ncywgb3IgYSBjdXN0b20gZWFzaW5nXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtICB7Y2FtZXJhfSAgY2FtZXJhICBUaGUgY2FtZXJhIHRvIGFuaW1hdGUuXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHRhcmdldCAgVGhlIGNvb3JkaW5hdGVzIHRvIHJlYWNoLlxuICAgKiBAcGFyYW0gIHs/b2JqZWN0fSBvcHRpb25zIEV2ZW50dWFsbHkgYW4gb2JqZWN0IHRvIHNwZWNpZnkgc29tZSBvcHRpb25zIHRvXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGZ1bmN0aW9uLiBUaGUgYXZhaWxhYmxlIG9wdGlvbnMgYXJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VudGVkIGluIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgICAgVGhlIGFuaW1hdGlvbiBpZCwgdG8gbWFrZSBpdCBlYXN5IHRvIGtpbGxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdWdoIHRoZSBtZXRob2QgXCJzaWdtYS5taXNjLmFuaW1hdGlvbi5raWxsXCIuXG4gICAqL1xuICBzaWdtYS5taXNjLmFuaW1hdGlvbi5jYW1lcmEgPSBmdW5jdGlvbihjYW1lcmEsIHZhbCwgb3B0aW9ucykge1xuICAgIGlmIChcbiAgICAgICEoY2FtZXJhIGluc3RhbmNlb2Ygc2lnbWEuY2xhc3Nlcy5jYW1lcmEpIHx8XG4gICAgICB0eXBlb2YgdmFsICE9PSAnb2JqZWN0JyB8fFxuICAgICAgIXZhbFxuICAgIClcbiAgICAgIHRocm93ICdhbmltYXRpb24uY2FtZXJhOiBXcm9uZyBhcmd1bWVudHMuJztcblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiB2YWwueCAhPT0gJ251bWJlcicgJiZcbiAgICAgIHR5cGVvZiB2YWwueSAhPT0gJ251bWJlcicgJiZcbiAgICAgIHR5cGVvZiB2YWwucmF0aW8gIT09ICdudW1iZXInICYmXG4gICAgICB0eXBlb2YgdmFsLmFuZ2xlICE9PSAnbnVtYmVyJ1xuICAgIClcbiAgICAgIHRocm93ICdUaGVyZSBtdXN0IGJlIGF0IGxlYXN0IG9uZSB2YWxpZCBjb29yZGluYXRlIGluIHRoZSBnaXZlbiB2YWwuJztcblxuICAgIHZhciBmbixcbiAgICAgICAgaWQsXG4gICAgICAgIGFuaW0sXG4gICAgICAgIGVhc2luZyxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGluaXRpYWxWYWwsXG4gICAgICAgIG8gPSBvcHRpb25zIHx8IHt9LFxuICAgICAgICBzdGFydCA9IHNpZ21hLnV0aWxzLmRhdGVOb3coKTtcblxuICAgIC8vIFN0b3JlIGluaXRpYWwgdmFsdWVzOlxuICAgIGluaXRpYWxWYWwgPSB7XG4gICAgICB4OiBjYW1lcmEueCxcbiAgICAgIHk6IGNhbWVyYS55LFxuICAgICAgcmF0aW86IGNhbWVyYS5yYXRpbyxcbiAgICAgIGFuZ2xlOiBjYW1lcmEuYW5nbGVcbiAgICB9O1xuXG4gICAgZHVyYXRpb24gPSBvLmR1cmF0aW9uO1xuICAgIGVhc2luZyA9IHR5cGVvZiBvLmVhc2luZyAhPT0gJ2Z1bmN0aW9uJyA/XG4gICAgICBzaWdtYS51dGlscy5lYXNpbmdzW28uZWFzaW5nIHx8ICdxdWFkcmF0aWNJbk91dCddIDpcbiAgICAgIG8uZWFzaW5nO1xuXG4gICAgZm4gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb2VmLFxuICAgICAgICAgIHQgPSBvLmR1cmF0aW9uID8gKHNpZ21hLnV0aWxzLmRhdGVOb3coKSAtIHN0YXJ0KSAvIG8uZHVyYXRpb24gOiAxO1xuXG4gICAgICAvLyBJZiB0aGUgYW5pbWF0aW9uIGlzIG92ZXI6XG4gICAgICBpZiAodCA+PSAxKSB7XG4gICAgICAgIGNhbWVyYS5pc0FuaW1hdGVkID0gZmFsc2U7XG4gICAgICAgIGNhbWVyYS5nb1RvKHtcbiAgICAgICAgICB4OiB2YWwueCAhPT0gdW5kZWZpbmVkID8gdmFsLnggOiBpbml0aWFsVmFsLngsXG4gICAgICAgICAgeTogdmFsLnkgIT09IHVuZGVmaW5lZCA/IHZhbC55IDogaW5pdGlhbFZhbC55LFxuICAgICAgICAgIHJhdGlvOiB2YWwucmF0aW8gIT09IHVuZGVmaW5lZCA/IHZhbC5yYXRpbyA6IGluaXRpYWxWYWwucmF0aW8sXG4gICAgICAgICAgYW5nbGU6IHZhbC5hbmdsZSAhPT0gdW5kZWZpbmVkID8gdmFsLmFuZ2xlIDogaW5pdGlhbFZhbC5hbmdsZVxuICAgICAgICB9KTtcblxuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShpZCk7XG4gICAgICAgIGRlbGV0ZSBzaWdtYS5taXNjLmFuaW1hdGlvbi5ydW5uaW5nW2lkXTtcblxuICAgICAgICAvLyBDaGVjayBjYWxsYmFja3M6XG4gICAgICAgIGlmICh0eXBlb2Ygby5vbkNvbXBsZXRlID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgIG8ub25Db21wbGV0ZSgpO1xuXG4gICAgICAvLyBFbHNlLCBsZXQncyBrZWVwIGdvaW5nOlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29lZiA9IGVhc2luZyh0KTtcbiAgICAgICAgY2FtZXJhLmlzQW5pbWF0ZWQgPSB0cnVlO1xuICAgICAgICBjYW1lcmEuZ29Ubyh7XG4gICAgICAgICAgeDogdmFsLnggIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICBpbml0aWFsVmFsLnggKyAodmFsLnggLSBpbml0aWFsVmFsLngpICogY29lZiA6XG4gICAgICAgICAgICBpbml0aWFsVmFsLngsXG4gICAgICAgICAgeTogdmFsLnkgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICBpbml0aWFsVmFsLnkgKyAodmFsLnkgLSBpbml0aWFsVmFsLnkpICogY29lZiA6XG4gICAgICAgICAgICBpbml0aWFsVmFsLnksXG4gICAgICAgICAgcmF0aW86IHZhbC5yYXRpbyAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIGluaXRpYWxWYWwucmF0aW8gKyAodmFsLnJhdGlvIC0gaW5pdGlhbFZhbC5yYXRpbykgKiBjb2VmIDpcbiAgICAgICAgICAgIGluaXRpYWxWYWwucmF0aW8sXG4gICAgICAgICAgYW5nbGU6IHZhbC5hbmdsZSAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIGluaXRpYWxWYWwuYW5nbGUgKyAodmFsLmFuZ2xlIC0gaW5pdGlhbFZhbC5hbmdsZSkgKiBjb2VmIDpcbiAgICAgICAgICAgIGluaXRpYWxWYWwuYW5nbGVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ2hlY2sgY2FsbGJhY2tzOlxuICAgICAgICBpZiAodHlwZW9mIG8ub25OZXdGcmFtZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICBvLm9uTmV3RnJhbWUoKTtcblxuICAgICAgICBhbmltLmZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZCA9IF9nZXRJRCgpO1xuICAgIGFuaW0gPSB7XG4gICAgICBmcmFtZUlkOiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pLFxuICAgICAgdGFyZ2V0OiBjYW1lcmEsXG4gICAgICB0eXBlOiAnY2FtZXJhJyxcbiAgICAgIG9wdGlvbnM6IG8sXG4gICAgICBmbjogZm5cbiAgICB9O1xuICAgIHNpZ21hLm1pc2MuYW5pbWF0aW9uLnJ1bm5pbmdbaWRdID0gYW5pbTtcblxuICAgIHJldHVybiBpZDtcbiAgfTtcblxuICAvKipcbiAgICogS2lsbHMgYSBydW5uaW5nIGFuaW1hdGlvbi4gSXQgdHJpZ2dlcnMgdGhlIGV2ZW50dWFsIG9uQ29tcGxldGUgY2FsbGJhY2suXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0gaWQgIFRoZSBpZCBvZiB0aGUgYW5pbWF0aW9uIHRvIGtpbGwuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgIFJldHVybnMgdGhlIHNpZ21hLm1pc2MuYW5pbWF0aW9uIHBhY2thZ2UuXG4gICAqL1xuICBzaWdtYS5taXNjLmFuaW1hdGlvbi5raWxsID0gZnVuY3Rpb24oaWQpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMSB8fCB0eXBlb2YgaWQgIT09ICdudW1iZXInKVxuICAgICAgdGhyb3cgJ2FuaW1hdGlvbi5raWxsOiBXcm9uZyBhcmd1bWVudHMuJztcblxuICAgIHZhciBvID0gc2lnbWEubWlzYy5hbmltYXRpb24ucnVubmluZ1tpZF07XG5cbiAgICBpZiAobykge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpO1xuICAgICAgZGVsZXRlIHNpZ21hLm1pc2MuYW5pbWF0aW9uLnJ1bm5pbmdbby5mcmFtZUlkXTtcblxuICAgICAgaWYgKG8udHlwZSA9PT0gJ2NhbWVyYScpXG4gICAgICAgIG8udGFyZ2V0LmlzQW5pbWF0ZWQgPSBmYWxzZTtcblxuICAgICAgLy8gQ2hlY2sgY2FsbGJhY2tzOlxuICAgICAgaWYgKHR5cGVvZiAoby5vcHRpb25zIHx8IHt9KS5vbkNvbXBsZXRlID09PSAnZnVuY3Rpb24nKVxuICAgICAgICBvLm9wdGlvbnMub25Db21wbGV0ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBLaWxscyBldmVyeSBydW5uaW5nIGFuaW1hdGlvbnMsIG9yIG9ubHkgdGhlIG9uZSB3aXRoIHRoZSBzcGVjaWZpZWQgdHlwZSxcbiAgICogaWYgYSBzdHJpbmcgcGFyYW1ldGVyIGlzIGdpdmVuLlxuICAgKlxuICAgKiBAcGFyYW0gIHs/KHN0cmluZ3xvYmplY3QpfSBmaWx0ZXIgQSBzdHJpbmcgdG8gZmlsdGVyIHRoZSBhbmltYXRpb25zIHRvIGtpbGxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uIHRoZWlyIHR5cGUgKGV4YW1wbGU6IFwiY2FtZXJhXCIpLCBvciBhblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0IHRvIGZpbHRlciBvbiB0aGVpciB0YXJnZXQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgICAgICAgICAgICBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYW5pbWF0aW9ucyBraWxsZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQgd2F5LlxuICAgKi9cbiAgc2lnbWEubWlzYy5hbmltYXRpb24ua2lsbEFsbCA9IGZ1bmN0aW9uKGZpbHRlcikge1xuICAgIHZhciBvLFxuICAgICAgICBpZCxcbiAgICAgICAgY291bnQgPSAwLFxuICAgICAgICB0eXBlID0gdHlwZW9mIGZpbHRlciA9PT0gJ3N0cmluZycgPyBmaWx0ZXIgOiBudWxsLFxuICAgICAgICB0YXJnZXQgPSB0eXBlb2YgZmlsdGVyID09PSAnb2JqZWN0JyA/IGZpbHRlciA6IG51bGwsXG4gICAgICAgIHJ1bm5pbmcgPSBzaWdtYS5taXNjLmFuaW1hdGlvbi5ydW5uaW5nO1xuXG4gICAgZm9yIChpZCBpbiBydW5uaW5nKVxuICAgICAgaWYgKFxuICAgICAgICAoIXR5cGUgfHwgcnVubmluZ1tpZF0udHlwZSA9PT0gdHlwZSkgJiZcbiAgICAgICAgKCF0YXJnZXQgfHwgcnVubmluZ1tpZF0udGFyZ2V0ID09PSB0YXJnZXQpXG4gICAgICApIHtcbiAgICAgICAgbyA9IHNpZ21hLm1pc2MuYW5pbWF0aW9uLnJ1bm5pbmdbaWRdO1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShvLmZyYW1lSWQpO1xuICAgICAgICBkZWxldGUgc2lnbWEubWlzYy5hbmltYXRpb24ucnVubmluZ1tpZF07XG5cbiAgICAgICAgaWYgKG8udHlwZSA9PT0gJ2NhbWVyYScpXG4gICAgICAgICAgby50YXJnZXQuaXNBbmltYXRlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEluY3JlbWVudCBjb3VudGVyOlxuICAgICAgICBjb3VudCsrO1xuXG4gICAgICAgIC8vIENoZWNrIGNhbGxiYWNrczpcbiAgICAgICAgaWYgKHR5cGVvZiAoby5vcHRpb25zIHx8IHt9KS5vbkNvbXBsZXRlID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgIG8ub3B0aW9ucy5vbkNvbXBsZXRlKCk7XG4gICAgICB9XG5cbiAgICByZXR1cm4gY291bnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgXCJ0cnVlXCIgaWYgYW55IGFuaW1hdGlvbiB0aGF0IGlzIGN1cnJlbnRseSBzdGlsbCBydW5uaW5nIG1hdGNoZXNcbiAgICogdGhlIGZpbHRlciBnaXZlbiB0byB0aGUgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ3xvYmplY3R9IGZpbHRlciBBIHN0cmluZyB0byBmaWx0ZXIgdGhlIGFuaW1hdGlvbnMgdG8ga2lsbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb24gdGhlaXIgdHlwZSAoZXhhbXBsZTogXCJjYW1lcmFcIiksIG9yIGFuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QgdG8gZmlsdGVyIG9uIHRoZWlyIHRhcmdldC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gICAgICAgICAgICAgIFJldHVybnMgdHJ1ZSBpZiBhbnkgcnVubmluZyBhbmltYXRpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXMuXG4gICAqL1xuICBzaWdtYS5taXNjLmFuaW1hdGlvbi5oYXMgPSBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICB2YXIgaWQsXG4gICAgICAgIHR5cGUgPSB0eXBlb2YgZmlsdGVyID09PSAnc3RyaW5nJyA/IGZpbHRlciA6IG51bGwsXG4gICAgICAgIHRhcmdldCA9IHR5cGVvZiBmaWx0ZXIgPT09ICdvYmplY3QnID8gZmlsdGVyIDogbnVsbCxcbiAgICAgICAgcnVubmluZyA9IHNpZ21hLm1pc2MuYW5pbWF0aW9uLnJ1bm5pbmc7XG5cbiAgICBmb3IgKGlkIGluIHJ1bm5pbmcpXG4gICAgICBpZiAoXG4gICAgICAgICghdHlwZSB8fCBydW5uaW5nW2lkXS50eXBlID09PSB0eXBlKSAmJlxuICAgICAgICAoIXRhcmdldCB8fCBydW5uaW5nW2lkXS50YXJnZXQgPT09IHRhcmdldClcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5taXNjJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgaGVscGVyIHdpbGwgYmluZCBhbnkgbm8tRE9NIHJlbmRlcmVyIChmb3IgaW5zdGFuY2UgY2FudmFzIG9yIFdlYkdMKVxuICAgKiB0byBpdHMgY2FwdG9ycywgdG8gcHJvcGVybHkgZGlzcGF0Y2ggdGhlIGdvb2QgZXZlbnRzIHRvIHRoZSBzaWdtYSBpbnN0YW5jZVxuICAgKiB0byBtYW5hZ2UgY2xpY2tpbmcsIGhvdmVyaW5nIGV0Yy4uLlxuICAgKlxuICAgKiBJdCBoYXMgdG8gYmUgY2FsbGVkIGluIHRoZSBzY29wZSBvZiB0aGUgcmVsYXRlZCByZW5kZXJlci5cbiAgICovXG4gIHNpZ21hLm1pc2MuYmluZEV2ZW50cyA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICBtWCxcbiAgICAgICAgbVksXG4gICAgICAgIGNhcHRvcixcbiAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiBnZXROb2RlcyhlKSB7XG4gICAgICBpZiAoZSkge1xuICAgICAgICBtWCA9ICd4JyBpbiBlLmRhdGEgPyBlLmRhdGEueCA6IG1YO1xuICAgICAgICBtWSA9ICd5JyBpbiBlLmRhdGEgPyBlLmRhdGEueSA6IG1ZO1xuICAgICAgfVxuXG4gICAgICB2YXIgaSxcbiAgICAgICAgICBqLFxuICAgICAgICAgIGwsXG4gICAgICAgICAgbixcbiAgICAgICAgICB4LFxuICAgICAgICAgIHksXG4gICAgICAgICAgcyxcbiAgICAgICAgICBpbnNlcnRlZCxcbiAgICAgICAgICBzZWxlY3RlZCA9IFtdLFxuICAgICAgICAgIG1vZGlmaWVkWCA9IG1YICsgc2VsZi53aWR0aCAvIDIsXG4gICAgICAgICAgbW9kaWZpZWRZID0gbVkgKyBzZWxmLmhlaWdodCAvIDIsXG4gICAgICAgICAgcG9pbnQgPSBzZWxmLmNhbWVyYS5jYW1lcmFQb3NpdGlvbihcbiAgICAgICAgICAgIG1YLFxuICAgICAgICAgICAgbVlcbiAgICAgICAgICApLFxuICAgICAgICAgIG5vZGVzID0gc2VsZi5jYW1lcmEucXVhZHRyZWUucG9pbnQoXG4gICAgICAgICAgICBwb2ludC54LFxuICAgICAgICAgICAgcG9pbnQueVxuICAgICAgICAgICk7XG5cbiAgICAgIGlmIChub2Rlcy5sZW5ndGgpXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBuID0gbm9kZXNbaV07XG4gICAgICAgICAgeCA9IG5bcHJlZml4ICsgJ3gnXTtcbiAgICAgICAgICB5ID0gbltwcmVmaXggKyAneSddO1xuICAgICAgICAgIHMgPSBuW3ByZWZpeCArICdzaXplJ107XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhbi5oaWRkZW4gJiZcbiAgICAgICAgICAgIG1vZGlmaWVkWCA+IHggLSBzICYmXG4gICAgICAgICAgICBtb2RpZmllZFggPCB4ICsgcyAmJlxuICAgICAgICAgICAgbW9kaWZpZWRZID4geSAtIHMgJiZcbiAgICAgICAgICAgIG1vZGlmaWVkWSA8IHkgKyBzICYmXG4gICAgICAgICAgICBNYXRoLnNxcnQoXG4gICAgICAgICAgICAgIE1hdGgucG93KG1vZGlmaWVkWCAtIHgsIDIpICtcbiAgICAgICAgICAgICAgTWF0aC5wb3cobW9kaWZpZWRZIC0geSwgMilcbiAgICAgICAgICAgICkgPCBzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBJbnNlcnQgdGhlIG5vZGU6XG4gICAgICAgICAgICBpbnNlcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgc2VsZWN0ZWQubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgIGlmIChuLnNpemUgPiBzZWxlY3RlZFtqXS5zaXplKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQuc3BsaWNlKGosIDAsIG4pO1xuICAgICAgICAgICAgICAgIGluc2VydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWluc2VydGVkKVxuICAgICAgICAgICAgICBzZWxlY3RlZC5wdXNoKG4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBnZXRFZGdlcyhlKSB7XG4gICAgICBpZiAoIXNlbGYuc2V0dGluZ3MoJ2VuYWJsZUVkZ2VIb3ZlcmluZycpKSB7XG4gICAgICAgIC8vIE5vIGV2ZW50IGlmIHRoZSBzZXR0aW5nIGlzIG9mZjpcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNDYW52YXMgPSAoXG4gICAgICAgIHNpZ21hLnJlbmRlcmVycy5jYW52YXMgJiYgc2VsZiBpbnN0YW5jZW9mIHNpZ21hLnJlbmRlcmVycy5jYW52YXMpO1xuXG4gICAgICBpZiAoIWlzQ2FudmFzKSB7XG4gICAgICAgIC8vIEEgcXVpY2sgaGFyZGNvZGVkIHJ1bGUgdG8gcHJldmVudCBwZW9wbGUgZnJvbSB1c2luZyB0aGlzIGZlYXR1cmVcbiAgICAgICAgLy8gd2l0aCB0aGUgV2ViR0wgcmVuZGVyZXIgKHdoaWNoIGlzIG5vdCBnb29kIGVub3VnaCBhdCB0aGUgbW9tZW50KTpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdUaGUgZWRnZSBldmVudHMgZmVhdHVyZSBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSBXZWJHTCByZW5kZXJlcidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGUpIHtcbiAgICAgICAgbVggPSAneCcgaW4gZS5kYXRhID8gZS5kYXRhLnggOiBtWDtcbiAgICAgICAgbVkgPSAneScgaW4gZS5kYXRhID8gZS5kYXRhLnkgOiBtWTtcbiAgICAgIH1cblxuICAgICAgdmFyIGksXG4gICAgICAgICAgaixcbiAgICAgICAgICBsLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgZWRnZSxcbiAgICAgICAgICBzLFxuICAgICAgICAgIG1heEVwc2lsb24gPSBzZWxmLnNldHRpbmdzKCdlZGdlSG92ZXJQcmVjaXNpb24nKSxcbiAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIGNwLFxuICAgICAgICAgIG5vZGVJbmRleCA9IHt9LFxuICAgICAgICAgIGluc2VydGVkLFxuICAgICAgICAgIHNlbGVjdGVkID0gW10sXG4gICAgICAgICAgbW9kaWZpZWRYID0gbVggKyBzZWxmLndpZHRoIC8gMixcbiAgICAgICAgICBtb2RpZmllZFkgPSBtWSArIHNlbGYuaGVpZ2h0IC8gMixcbiAgICAgICAgICBwb2ludCA9IHNlbGYuY2FtZXJhLmNhbWVyYVBvc2l0aW9uKFxuICAgICAgICAgICAgbVgsXG4gICAgICAgICAgICBtWVxuICAgICAgICAgICksXG4gICAgICAgICAgZWRnZXMgPSBbXTtcblxuICAgICAgaWYgKGlzQ2FudmFzKSB7XG4gICAgICAgIHZhciBub2Rlc09uU2NyZWVuID0gc2VsZi5jYW1lcmEucXVhZHRyZWUuYXJlYShcbiAgICAgICAgICBzZWxmLmNhbWVyYS5nZXRSZWN0YW5nbGUoc2VsZi53aWR0aCwgc2VsZi5oZWlnaHQpXG4gICAgICAgICk7XG4gICAgICAgIGZvciAoYSA9IG5vZGVzT25TY3JlZW4sIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgbm9kZUluZGV4W2FbaV0uaWRdID0gYVtpXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYuY2FtZXJhLmVkZ2VxdWFkdHJlZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVkZ2VzID0gc2VsZi5jYW1lcmEuZWRnZXF1YWR0cmVlLnBvaW50KFxuICAgICAgICAgIHBvaW50LngsXG4gICAgICAgICAgcG9pbnQueVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpbnNlcnRFZGdlKHNlbGVjdGVkLCBlZGdlKSB7XG4gICAgICAgIGluc2VydGVkID0gZmFsc2U7XG5cbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHNlbGVjdGVkLmxlbmd0aDsgaisrKVxuICAgICAgICAgIGlmIChlZGdlLnNpemUgPiBzZWxlY3RlZFtqXS5zaXplKSB7XG4gICAgICAgICAgICBzZWxlY3RlZC5zcGxpY2UoaiwgMCwgZWRnZSk7XG4gICAgICAgICAgICBpbnNlcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpbnNlcnRlZClcbiAgICAgICAgICBzZWxlY3RlZC5wdXNoKGVkZ2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWRnZXMubGVuZ3RoKVxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZWRnZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgZWRnZSA9IGVkZ2VzW2ldO1xuICAgICAgICAgIHNvdXJjZSA9IHNlbGYuZ3JhcGgubm9kZXMoZWRnZS5zb3VyY2UpO1xuICAgICAgICAgIHRhcmdldCA9IHNlbGYuZ3JhcGgubm9kZXMoZWRnZS50YXJnZXQpO1xuICAgICAgICAgIC8vIChIQUNLKSB3ZSBjYW4ndCBnZXQgZWRnZVtwcmVmaXggKyAnc2l6ZSddIG9uIFdlYkdMIHJlbmRlcmVyOlxuICAgICAgICAgIHMgPSBlZGdlW3ByZWZpeCArICdzaXplJ10gfHxcbiAgICAgICAgICAgICAgZWRnZVsncmVhZF8nICsgcHJlZml4ICsgJ3NpemUnXTtcblxuICAgICAgICAgIC8vIEZpcnN0LCBsZXQncyBpZGVudGlmeSB3aGljaCBlZGdlcyBhcmUgZHJhd24uIFRvIGRvIHRoaXMsIHdlIGtlZXBcbiAgICAgICAgICAvLyBldmVyeSBlZGdlcyB0aGF0IGhhdmUgYXQgbGVhc3Qgb25lIGV4dHJlbWl0eSBkaXNwbGF5ZWQgYWNjb3JkaW5nIHRvXG4gICAgICAgICAgLy8gdGhlIHF1YWR0cmVlIGFuZCB0aGUgXCJoaWRkZW5cIiBhdHRyaWJ1dGUuIFdlIGFsc28gZG8gbm90IGtlZXAgaGlkZGVuXG4gICAgICAgICAgLy8gZWRnZXMuXG4gICAgICAgICAgLy8gVGhlbiwgbGV0J3MgY2hlY2sgaWYgdGhlIG1vdXNlIGlzIG9uIHRoZSBlZGdlICh3ZSBzdXBwb3NlIHRoYXQgaXRcbiAgICAgICAgICAvLyBpcyBhIGxpbmUgc2VnbWVudCkuXG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhZWRnZS5oaWRkZW4gJiZcbiAgICAgICAgICAgICFzb3VyY2UuaGlkZGVuICYmICF0YXJnZXQuaGlkZGVuICYmXG4gICAgICAgICAgICAoIWlzQ2FudmFzIHx8XG4gICAgICAgICAgICAgIChub2RlSW5kZXhbZWRnZS5zb3VyY2VdIHx8IG5vZGVJbmRleFtlZGdlLnRhcmdldF0pKSAmJlxuICAgICAgICAgICAgc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoXG4gICAgICAgICAgICAgIHNvdXJjZVtwcmVmaXggKyAneCddLFxuICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICAgICAgbW9kaWZpZWRYLFxuICAgICAgICAgICAgICBtb2RpZmllZFkpID4gc291cmNlW3ByZWZpeCArICdzaXplJ10gJiZcbiAgICAgICAgICAgIHNpZ21hLnV0aWxzLmdldERpc3RhbmNlKFxuICAgICAgICAgICAgICB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICAgICAgdGFyZ2V0W3ByZWZpeCArICd5J10sXG4gICAgICAgICAgICAgIG1vZGlmaWVkWCxcbiAgICAgICAgICAgICAgbW9kaWZpZWRZKSA+IHRhcmdldFtwcmVmaXggKyAnc2l6ZSddXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoZWRnZS50eXBlID09ICdjdXJ2ZScgfHwgZWRnZS50eXBlID09ICdjdXJ2ZWRBcnJvdycpIHtcbiAgICAgICAgICAgICAgaWYgKHNvdXJjZS5pZCA9PT0gdGFyZ2V0LmlkKSB7XG4gICAgICAgICAgICAgICAgY3AgPSBzaWdtYS51dGlscy5nZXRTZWxmTG9vcENvbnRyb2xQb2ludHMoXG4gICAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICAgICAgICAgIHNvdXJjZVtwcmVmaXggKyAneSddLFxuICAgICAgICAgICAgICAgICAgc291cmNlW3ByZWZpeCArICdzaXplJ11cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIHNpZ21hLnV0aWxzLmlzUG9pbnRPbkJlemllckN1cnZlKFxuICAgICAgICAgICAgICAgICAgbW9kaWZpZWRYLFxuICAgICAgICAgICAgICAgICAgbW9kaWZpZWRZLFxuICAgICAgICAgICAgICAgICAgc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICAgICAgICAgIHRhcmdldFtwcmVmaXggKyAneCddLFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0W3ByZWZpeCArICd5J10sXG4gICAgICAgICAgICAgICAgICBjcC54MSxcbiAgICAgICAgICAgICAgICAgIGNwLnkxLFxuICAgICAgICAgICAgICAgICAgY3AueDIsXG4gICAgICAgICAgICAgICAgICBjcC55MixcbiAgICAgICAgICAgICAgICAgIE1hdGgubWF4KHMsIG1heEVwc2lsb24pXG4gICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgaW5zZXJ0RWRnZShzZWxlY3RlZCwgZWRnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNwID0gc2lnbWEudXRpbHMuZ2V0UXVhZHJhdGljQ29udHJvbFBvaW50KFxuICAgICAgICAgICAgICAgICAgc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICAgICAgICAgIHRhcmdldFtwcmVmaXggKyAneCddLFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0W3ByZWZpeCArICd5J10pO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIHNpZ21hLnV0aWxzLmlzUG9pbnRPblF1YWRyYXRpY0N1cnZlKFxuICAgICAgICAgICAgICAgICAgbW9kaWZpZWRYLFxuICAgICAgICAgICAgICAgICAgbW9kaWZpZWRZLFxuICAgICAgICAgICAgICAgICAgc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICAgICAgICAgIHRhcmdldFtwcmVmaXggKyAneCddLFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0W3ByZWZpeCArICd5J10sXG4gICAgICAgICAgICAgICAgICBjcC54LFxuICAgICAgICAgICAgICAgICAgY3AueSxcbiAgICAgICAgICAgICAgICAgIE1hdGgubWF4KHMsIG1heEVwc2lsb24pXG4gICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgaW5zZXJ0RWRnZShzZWxlY3RlZCwgZWRnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHNpZ21hLnV0aWxzLmlzUG9pbnRPblNlZ21lbnQoXG4gICAgICAgICAgICAgICAgbW9kaWZpZWRYLFxuICAgICAgICAgICAgICAgIG1vZGlmaWVkWSxcbiAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICAgICAgICB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICAgICAgICB0YXJnZXRbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICAgICAgICBNYXRoLm1heChzLCBtYXhFcHNpbG9uKVxuICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgIGluc2VydEVkZ2Uoc2VsZWN0ZWQsIGVkZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBiaW5kQ2FwdG9yKGNhcHRvcikge1xuICAgICAgdmFyIG5vZGVzLFxuICAgICAgICAgIGVkZ2VzLFxuICAgICAgICAgIG92ZXJOb2RlcyA9IHt9LFxuICAgICAgICAgIG92ZXJFZGdlcyA9IHt9O1xuXG4gICAgICBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICAgICAgaWYgKCFzZWxmLnNldHRpbmdzKCdldmVudHNFbmFibGVkJykpXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnY2xpY2snLCBlLmRhdGEpO1xuXG4gICAgICAgIG5vZGVzID0gZ2V0Tm9kZXMoZSk7XG4gICAgICAgIGVkZ2VzID0gZ2V0RWRnZXMoZSk7XG5cbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnY2xpY2tOb2RlJywge1xuICAgICAgICAgICAgbm9kZTogbm9kZXNbMF0sXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnY2xpY2tOb2RlcycsIHtcbiAgICAgICAgICAgIG5vZGU6IG5vZGVzLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChlZGdlcy5sZW5ndGgpIHtcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2NsaWNrRWRnZScsIHtcbiAgICAgICAgICAgIGVkZ2U6IGVkZ2VzWzBdLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2NsaWNrRWRnZXMnLCB7XG4gICAgICAgICAgICBlZGdlOiBlZGdlcyxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnY2xpY2tTdGFnZScsIHtjYXB0b3I6IGUuZGF0YX0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvbkRvdWJsZUNsaWNrKGUpIHtcbiAgICAgICAgaWYgKCFzZWxmLnNldHRpbmdzKCdldmVudHNFbmFibGVkJykpXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZG91YmxlQ2xpY2snLCBlLmRhdGEpO1xuXG4gICAgICAgIG5vZGVzID0gZ2V0Tm9kZXMoZSk7XG4gICAgICAgIGVkZ2VzID0gZ2V0RWRnZXMoZSk7XG5cbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZG91YmxlQ2xpY2tOb2RlJywge1xuICAgICAgICAgICAgbm9kZTogbm9kZXNbMF0sXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZG91YmxlQ2xpY2tOb2RlcycsIHtcbiAgICAgICAgICAgIG5vZGU6IG5vZGVzLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChlZGdlcy5sZW5ndGgpIHtcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2RvdWJsZUNsaWNrRWRnZScsIHtcbiAgICAgICAgICAgIGVkZ2U6IGVkZ2VzWzBdLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2RvdWJsZUNsaWNrRWRnZXMnLCB7XG4gICAgICAgICAgICBlZGdlOiBlZGdlcyxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZG91YmxlQ2xpY2tTdGFnZScsIHtjYXB0b3I6IGUuZGF0YX0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvblJpZ2h0Q2xpY2soZSkge1xuICAgICAgICBpZiAoIXNlbGYuc2V0dGluZ3MoJ2V2ZW50c0VuYWJsZWQnKSlcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdyaWdodENsaWNrJywgZS5kYXRhKTtcblxuICAgICAgICBub2RlcyA9IGdldE5vZGVzKGUpO1xuICAgICAgICBlZGdlcyA9IGdldEVkZ2VzKGUpO1xuXG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ3JpZ2h0Q2xpY2tOb2RlJywge1xuICAgICAgICAgICAgbm9kZTogbm9kZXNbMF0sXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgncmlnaHRDbGlja05vZGVzJywge1xuICAgICAgICAgICAgbm9kZTogbm9kZXMsXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGVkZ2VzLmxlbmd0aCkge1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgncmlnaHRDbGlja0VkZ2UnLCB7XG4gICAgICAgICAgICBlZGdlOiBlZGdlc1swXSxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdyaWdodENsaWNrRWRnZXMnLCB7XG4gICAgICAgICAgICBlZGdlOiBlZGdlcyxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgncmlnaHRDbGlja1N0YWdlJywge2NhcHRvcjogZS5kYXRhfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uT3V0KGUpIHtcbiAgICAgICAgaWYgKCFzZWxmLnNldHRpbmdzKCdldmVudHNFbmFibGVkJykpXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHZhciBrLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBsZSxcbiAgICAgICAgICAgIG91dE5vZGVzID0gW10sXG4gICAgICAgICAgICBvdXRFZGdlcyA9IFtdO1xuXG4gICAgICAgIGZvciAoayBpbiBvdmVyTm9kZXMpXG4gICAgICAgICAgb3V0Tm9kZXMucHVzaChvdmVyTm9kZXNba10pO1xuXG4gICAgICAgIG92ZXJOb2RlcyA9IHt9O1xuICAgICAgICAvLyBEaXNwYXRjaCBib3RoIHNpbmdsZSBhbmQgbXVsdGkgZXZlbnRzOlxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gb3V0Tm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3V0Tm9kZScsIHtcbiAgICAgICAgICAgIG5vZGU6IG91dE5vZGVzW2ldLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKG91dE5vZGVzLmxlbmd0aClcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ291dE5vZGVzJywge1xuICAgICAgICAgICAgbm9kZXM6IG91dE5vZGVzLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcblxuICAgICAgICBvdmVyRWRnZXMgPSB7fTtcbiAgICAgICAgLy8gRGlzcGF0Y2ggYm90aCBzaW5nbGUgYW5kIG11bHRpIGV2ZW50czpcbiAgICAgICAgZm9yIChpID0gMCwgbGUgPSBvdXRFZGdlcy5sZW5ndGg7IGkgPCBsZTsgaSsrKVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3V0RWRnZScsIHtcbiAgICAgICAgICAgIGVkZ2U6IG91dEVkZ2VzW2ldLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKG91dEVkZ2VzLmxlbmd0aClcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ291dEVkZ2VzJywge1xuICAgICAgICAgICAgZWRnZXM6IG91dEVkZ2VzLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25Nb3ZlKGUpIHtcbiAgICAgICAgaWYgKCFzZWxmLnNldHRpbmdzKCdldmVudHNFbmFibGVkJykpXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIG5vZGVzID0gZ2V0Tm9kZXMoZSk7XG4gICAgICAgIGVkZ2VzID0gZ2V0RWRnZXMoZSk7XG5cbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBrLFxuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIGVkZ2UsXG4gICAgICAgICAgICBuZXdPdXROb2RlcyA9IFtdLFxuICAgICAgICAgICAgbmV3T3Zlck5vZGVzID0gW10sXG4gICAgICAgICAgICBjdXJyZW50T3Zlck5vZGVzID0ge30sXG4gICAgICAgICAgICBsID0gbm9kZXMubGVuZ3RoLFxuICAgICAgICAgICAgbmV3T3V0RWRnZXMgPSBbXSxcbiAgICAgICAgICAgIG5ld092ZXJFZGdlcyA9IFtdLFxuICAgICAgICAgICAgY3VycmVudE92ZXJFZGdlcyA9IHt9LFxuICAgICAgICAgICAgbGUgPSBlZGdlcy5sZW5ndGg7XG5cbiAgICAgICAgLy8gQ2hlY2sgbmV3bHkgb3ZlcnJlZCBub2RlczpcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICBjdXJyZW50T3Zlck5vZGVzW25vZGUuaWRdID0gbm9kZTtcbiAgICAgICAgICBpZiAoIW92ZXJOb2Rlc1tub2RlLmlkXSkge1xuICAgICAgICAgICAgbmV3T3Zlck5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICBvdmVyTm9kZXNbbm9kZS5pZF0gPSBub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIG5vIG1vcmUgb3ZlcnJlZCBub2RlczpcbiAgICAgICAgZm9yIChrIGluIG92ZXJOb2RlcylcbiAgICAgICAgICBpZiAoIWN1cnJlbnRPdmVyTm9kZXNba10pIHtcbiAgICAgICAgICAgIG5ld091dE5vZGVzLnB1c2gob3Zlck5vZGVzW2tdKTtcbiAgICAgICAgICAgIGRlbGV0ZSBvdmVyTm9kZXNba107XG4gICAgICAgICAgfVxuXG4gICAgICAgIC8vIERpc3BhdGNoIGJvdGggc2luZ2xlIGFuZCBtdWx0aSBldmVudHM6XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBuZXdPdmVyTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3Zlck5vZGUnLCB7XG4gICAgICAgICAgICBub2RlOiBuZXdPdmVyTm9kZXNbaV0sXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gbmV3T3V0Tm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3V0Tm9kZScsIHtcbiAgICAgICAgICAgIG5vZGU6IG5ld091dE5vZGVzW2ldLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKG5ld092ZXJOb2Rlcy5sZW5ndGgpXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdvdmVyTm9kZXMnLCB7XG4gICAgICAgICAgICBub2RlczogbmV3T3Zlck5vZGVzLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKG5ld091dE5vZGVzLmxlbmd0aClcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ291dE5vZGVzJywge1xuICAgICAgICAgICAgbm9kZXM6IG5ld091dE5vZGVzLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBDaGVjayBuZXdseSBvdmVycmVkIGVkZ2VzOlxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGU7IGkrKykge1xuICAgICAgICAgIGVkZ2UgPSBlZGdlc1tpXTtcbiAgICAgICAgICBjdXJyZW50T3ZlckVkZ2VzW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgICBpZiAoIW92ZXJFZGdlc1tlZGdlLmlkXSkge1xuICAgICAgICAgICAgbmV3T3ZlckVkZ2VzLnB1c2goZWRnZSk7XG4gICAgICAgICAgICBvdmVyRWRnZXNbZWRnZS5pZF0gPSBlZGdlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIG5vIG1vcmUgb3ZlcnJlZCBlZGdlczpcbiAgICAgICAgZm9yIChrIGluIG92ZXJFZGdlcylcbiAgICAgICAgICBpZiAoIWN1cnJlbnRPdmVyRWRnZXNba10pIHtcbiAgICAgICAgICAgIG5ld091dEVkZ2VzLnB1c2gob3ZlckVkZ2VzW2tdKTtcbiAgICAgICAgICAgIGRlbGV0ZSBvdmVyRWRnZXNba107XG4gICAgICAgICAgfVxuXG4gICAgICAgIC8vIERpc3BhdGNoIGJvdGggc2luZ2xlIGFuZCBtdWx0aSBldmVudHM6XG4gICAgICAgIGZvciAoaSA9IDAsIGxlID0gbmV3T3ZlckVkZ2VzLmxlbmd0aDsgaSA8IGxlOyBpKyspXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdvdmVyRWRnZScsIHtcbiAgICAgICAgICAgIGVkZ2U6IG5ld092ZXJFZGdlc1tpXSxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlID0gbmV3T3V0RWRnZXMubGVuZ3RoOyBpIDwgbGU7IGkrKylcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ291dEVkZ2UnLCB7XG4gICAgICAgICAgICBlZGdlOiBuZXdPdXRFZGdlc1tpXSxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIGlmIChuZXdPdmVyRWRnZXMubGVuZ3RoKVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3ZlckVkZ2VzJywge1xuICAgICAgICAgICAgZWRnZXM6IG5ld092ZXJFZGdlcyxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIGlmIChuZXdPdXRFZGdlcy5sZW5ndGgpXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdvdXRFZGdlcycsIHtcbiAgICAgICAgICAgIGVkZ2VzOiBuZXdPdXRFZGdlcyxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEJpbmQgZXZlbnRzOlxuICAgICAgY2FwdG9yLmJpbmQoJ2NsaWNrJywgb25DbGljayk7XG4gICAgICBjYXB0b3IuYmluZCgnbW91c2Vkb3duJywgb25Nb3ZlKTtcbiAgICAgIGNhcHRvci5iaW5kKCdtb3VzZXVwJywgb25Nb3ZlKTtcbiAgICAgIGNhcHRvci5iaW5kKCdtb3VzZW1vdmUnLCBvbk1vdmUpO1xuICAgICAgY2FwdG9yLmJpbmQoJ21vdXNlb3V0Jywgb25PdXQpO1xuICAgICAgY2FwdG9yLmJpbmQoJ2RvdWJsZWNsaWNrJywgb25Eb3VibGVDbGljayk7XG4gICAgICBjYXB0b3IuYmluZCgncmlnaHRjbGljaycsIG9uUmlnaHRDbGljayk7XG4gICAgICBzZWxmLmJpbmQoJ3JlbmRlcicsIG9uTW92ZSk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgbCA9IHRoaXMuY2FwdG9ycy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICBiaW5kQ2FwdG9yKHRoaXMuY2FwdG9yc1tpXSk7XG4gIH07XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5taXNjJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgaGVscGVyIHdpbGwgYmluZCBhbnkgRE9NIHJlbmRlcmVyIChmb3IgaW5zdGFuY2Ugc3ZnKVxuICAgKiB0byBpdHMgY2FwdG9ycywgdG8gcHJvcGVybHkgZGlzcGF0Y2ggdGhlIGdvb2QgZXZlbnRzIHRvIHRoZSBzaWdtYSBpbnN0YW5jZVxuICAgKiB0byBtYW5hZ2UgY2xpY2tpbmcsIGhvdmVyaW5nIGV0Yy4uLlxuICAgKlxuICAgKiBJdCBoYXMgdG8gYmUgY2FsbGVkIGluIHRoZSBzY29wZSBvZiB0aGUgcmVsYXRlZCByZW5kZXJlci5cbiAgICovXG4gIHNpZ21hLm1pc2MuYmluZERPTUV2ZW50cyA9IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgZ3JhcGggPSB0aGlzLmdyYXBoO1xuXG4gICAgLy8gRE9NRWxlbWVudCBhYnN0cmFjdGlvblxuICAgIGZ1bmN0aW9uIEVsZW1lbnQoZG9tRWxlbWVudCkge1xuXG4gICAgICAvLyBIZWxwZXJzXG4gICAgICB0aGlzLmF0dHIgPSBmdW5jdGlvbihhdHRyTmFtZSkge1xuICAgICAgICByZXR1cm4gZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGVOUyhudWxsLCBhdHRyTmFtZSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBQcm9wZXJ0aWVzXG4gICAgICB0aGlzLnRhZyA9IGRvbUVsZW1lbnQudGFnTmFtZTtcbiAgICAgIHRoaXMuY2xhc3MgPSB0aGlzLmF0dHIoJ2NsYXNzJyk7XG4gICAgICB0aGlzLmlkID0gdGhpcy5hdHRyKCdpZCcpO1xuXG4gICAgICAvLyBNZXRob2RzXG4gICAgICB0aGlzLmlzTm9kZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF+dGhpcy5jbGFzcy5pbmRleE9mKHNlbGYuc2V0dGluZ3MoJ2NsYXNzUHJlZml4JykgKyAnLW5vZGUnKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuaXNFZGdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhIX50aGlzLmNsYXNzLmluZGV4T2Yoc2VsZi5zZXR0aW5ncygnY2xhc3NQcmVmaXgnKSArICctZWRnZScpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5pc0hvdmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhIX50aGlzLmNsYXNzLmluZGV4T2Yoc2VsZi5zZXR0aW5ncygnY2xhc3NQcmVmaXgnKSArICctaG92ZXInKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQ2xpY2tcbiAgICBmdW5jdGlvbiBjbGljayhlKSB7XG4gICAgICBpZiAoIXNlbGYuc2V0dGluZ3MoJ2V2ZW50c0VuYWJsZWQnKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICAvLyBHZW5lcmljIGV2ZW50XG4gICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2NsaWNrJywgZSk7XG5cbiAgICAgIC8vIEFyZSB3ZSBvbiBhIG5vZGU/XG4gICAgICB2YXIgZWxlbWVudCA9IG5ldyBFbGVtZW50KGUudGFyZ2V0KTtcblxuICAgICAgaWYgKGVsZW1lbnQuaXNOb2RlKCkpXG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnY2xpY2tOb2RlJywge1xuICAgICAgICAgIG5vZGU6IGdyYXBoLm5vZGVzKGVsZW1lbnQuYXR0cignZGF0YS1ub2RlLWlkJykpXG4gICAgICAgIH0pO1xuICAgICAgZWxzZVxuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2NsaWNrU3RhZ2UnKTtcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICAvLyBEb3VibGUgY2xpY2tcbiAgICBmdW5jdGlvbiBkb3VibGVDbGljayhlKSB7XG4gICAgICBpZiAoIXNlbGYuc2V0dGluZ3MoJ2V2ZW50c0VuYWJsZWQnKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICAvLyBHZW5lcmljIGV2ZW50XG4gICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2RvdWJsZUNsaWNrJywgZSk7XG5cbiAgICAgIC8vIEFyZSB3ZSBvbiBhIG5vZGU/XG4gICAgICB2YXIgZWxlbWVudCA9IG5ldyBFbGVtZW50KGUudGFyZ2V0KTtcblxuICAgICAgaWYgKGVsZW1lbnQuaXNOb2RlKCkpXG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZG91YmxlQ2xpY2tOb2RlJywge1xuICAgICAgICAgIG5vZGU6IGdyYXBoLm5vZGVzKGVsZW1lbnQuYXR0cignZGF0YS1ub2RlLWlkJykpXG4gICAgICAgIH0pO1xuICAgICAgZWxzZVxuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2RvdWJsZUNsaWNrU3RhZ2UnKTtcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICAvLyBPbiBvdmVyXG4gICAgZnVuY3Rpb24gb25PdmVyKGUpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBlLnRvRWxlbWVudCB8fCBlLnRhcmdldDtcblxuICAgICAgaWYgKCFzZWxmLnNldHRpbmdzKCdldmVudHNFbmFibGVkJykgfHwgIXRhcmdldClcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICB2YXIgZWwgPSBuZXcgRWxlbWVudCh0YXJnZXQpO1xuXG4gICAgICBpZiAoZWwuaXNOb2RlKCkpIHtcbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdvdmVyTm9kZScsIHtcbiAgICAgICAgICBub2RlOiBncmFwaC5ub2RlcyhlbC5hdHRyKCdkYXRhLW5vZGUtaWQnKSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChlbC5pc0VkZ2UoKSkge1xuICAgICAgICB2YXIgZWRnZSA9IGdyYXBoLmVkZ2VzKGVsLmF0dHIoJ2RhdGEtZWRnZS1pZCcpKTtcbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdvdmVyRWRnZScsIHtcbiAgICAgICAgICBlZGdlOiBlZGdlLFxuICAgICAgICAgIHNvdXJjZTogZ3JhcGgubm9kZXMoZWRnZS5zb3VyY2UpLFxuICAgICAgICAgIHRhcmdldDogZ3JhcGgubm9kZXMoZWRnZS50YXJnZXQpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9uIG91dFxuICAgIGZ1bmN0aW9uIG9uT3V0KGUpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBlLmZyb21FbGVtZW50IHx8IGUub3JpZ2luYWxUYXJnZXQ7XG5cbiAgICAgIGlmICghc2VsZi5zZXR0aW5ncygnZXZlbnRzRW5hYmxlZCcpKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIHZhciBlbCA9IG5ldyBFbGVtZW50KHRhcmdldCk7XG5cbiAgICAgIGlmIChlbC5pc05vZGUoKSkge1xuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ291dE5vZGUnLCB7XG4gICAgICAgICAgbm9kZTogZ3JhcGgubm9kZXMoZWwuYXR0cignZGF0YS1ub2RlLWlkJykpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZWwuaXNFZGdlKCkpIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBncmFwaC5lZGdlcyhlbC5hdHRyKCdkYXRhLWVkZ2UtaWQnKSk7XG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3V0RWRnZScsIHtcbiAgICAgICAgICBlZGdlOiBlZGdlLFxuICAgICAgICAgIHNvdXJjZTogZ3JhcGgubm9kZXMoZWRnZS5zb3VyY2UpLFxuICAgICAgICAgIHRhcmdldDogZ3JhcGgubm9kZXMoZWRnZS50YXJnZXQpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlZ2lzdGVyaW5nIEV2ZW50czpcblxuICAgIC8vIENsaWNrXG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2xpY2ssIGZhbHNlKTtcbiAgICBzaWdtYS51dGlscy5kb3VibGVDbGljayhjb250YWluZXIsICdjbGljaycsIGRvdWJsZUNsaWNrKTtcblxuICAgIC8vIFRvdWNoIGNvdW50ZXJwYXJ0c1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgY2xpY2ssIGZhbHNlKTtcbiAgICBzaWdtYS51dGlscy5kb3VibGVDbGljayhjb250YWluZXIsICd0b3VjaHN0YXJ0JywgZG91YmxlQ2xpY2spO1xuXG4gICAgLy8gTW91c2VvdmVyXG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIG9uT3ZlciwgdHJ1ZSk7XG5cbiAgICAvLyBNb3VzZW91dFxuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIG9uT3V0LCB0cnVlKTtcbiAgfTtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLm1pc2MnKTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgbGlzdGVucyB0byBcIm92ZXJOb2RlXCIsIFwib3V0Tm9kZVwiLCBcIm92ZXJFZGdlXCIgYW5kIFwib3V0RWRnZVwiXG4gICAqIGV2ZW50cyBmcm9tIGEgcmVuZGVyZXIgYW5kIHJlbmRlcnMgdGhlIG5vZGVzIGRpZmZlcmVudGx5IG9uIHRoZSB0b3AgbGF5ZXIuXG4gICAqIFRoZSBnb2FsIGlzIHRvIG1ha2UgYW55IG5vZGUgbGFiZWwgcmVhZGFibGUgd2l0aCB0aGUgbW91c2UsIGFuZCB0b1xuICAgKiBoaWdobGlnaHQgaG92ZXJlZCBub2RlcyBhbmQgZWRnZXMuXG4gICAqXG4gICAqIEl0IGhhcyB0byBiZSBjYWxsZWQgaW4gdGhlIHNjb3BlIG9mIHRoZSByZWxhdGVkIHJlbmRlcmVyLlxuICAgKi9cbiAgc2lnbWEubWlzYy5kcmF3SG92ZXJzID0gZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBob3ZlcmVkTm9kZXMgPSB7fSxcbiAgICAgICAgaG92ZXJlZEVkZ2VzID0ge307XG5cbiAgICB0aGlzLmJpbmQoJ292ZXJOb2RlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHZhciBub2RlID0gZXZlbnQuZGF0YS5ub2RlO1xuICAgICAgaWYgKCFub2RlLmhpZGRlbikge1xuICAgICAgICBob3ZlcmVkTm9kZXNbbm9kZS5pZF0gPSBub2RlO1xuICAgICAgICBkcmF3KCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmJpbmQoJ291dE5vZGUnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgZGVsZXRlIGhvdmVyZWROb2Rlc1tldmVudC5kYXRhLm5vZGUuaWRdO1xuICAgICAgZHJhdygpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5iaW5kKCdvdmVyRWRnZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICB2YXIgZWRnZSA9IGV2ZW50LmRhdGEuZWRnZTtcbiAgICAgIGlmICghZWRnZS5oaWRkZW4pIHtcbiAgICAgICAgaG92ZXJlZEVkZ2VzW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgZHJhdygpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5iaW5kKCdvdXRFZGdlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGRlbGV0ZSBob3ZlcmVkRWRnZXNbZXZlbnQuZGF0YS5lZGdlLmlkXTtcbiAgICAgIGRyYXcoKTtcbiAgICB9KTtcblxuICAgIHRoaXMuYmluZCgncmVuZGVyJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGRyYXcoKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGRyYXcoKSB7XG5cbiAgICAgIHZhciBrLFxuICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgaG92ZXJlZE5vZGUsXG4gICAgICAgICAgaG92ZXJlZEVkZ2UsXG4gICAgICAgICAgYyA9IHNlbGYuY29udGV4dHMuaG92ZXIuY2FudmFzLFxuICAgICAgICAgIGRlZmF1bHROb2RlVHlwZSA9IHNlbGYuc2V0dGluZ3MoJ2RlZmF1bHROb2RlVHlwZScpLFxuICAgICAgICAgIGRlZmF1bHRFZGdlVHlwZSA9IHNlbGYuc2V0dGluZ3MoJ2RlZmF1bHRFZGdlVHlwZScpLFxuICAgICAgICAgIG5vZGVSZW5kZXJlcnMgPSBzaWdtYS5jYW52YXMuaG92ZXJzLFxuICAgICAgICAgIGVkZ2VSZW5kZXJlcnMgPSBzaWdtYS5jYW52YXMuZWRnZWhvdmVycyxcbiAgICAgICAgICBleHRyZW1pdGllc1JlbmRlcmVycyA9IHNpZ21hLmNhbnZhcy5leHRyZW1pdGllcyxcbiAgICAgICAgICBlbWJlZFNldHRpbmdzID0gc2VsZi5zZXR0aW5ncy5lbWJlZE9iamVjdHMoe1xuICAgICAgICAgICAgcHJlZml4OiBwcmVmaXhcbiAgICAgICAgICB9KTtcblxuICAgICAgLy8gQ2xlYXIgc2VsZi5jb250ZXh0cy5ob3ZlcjpcbiAgICAgIHNlbGYuY29udGV4dHMuaG92ZXIuY2xlYXJSZWN0KDAsIDAsIGMud2lkdGgsIGMuaGVpZ2h0KTtcblxuICAgICAgLy8gTm9kZSByZW5kZXI6IHNpbmdsZSBob3ZlclxuICAgICAgaWYgKFxuICAgICAgICBlbWJlZFNldHRpbmdzKCdlbmFibGVIb3ZlcmluZycpICYmXG4gICAgICAgIGVtYmVkU2V0dGluZ3MoJ3NpbmdsZUhvdmVyJykgJiZcbiAgICAgICAgT2JqZWN0LmtleXMoaG92ZXJlZE5vZGVzKS5sZW5ndGhcbiAgICAgICkge1xuICAgICAgICBob3ZlcmVkTm9kZSA9IGhvdmVyZWROb2Rlc1tPYmplY3Qua2V5cyhob3ZlcmVkTm9kZXMpWzBdXTtcbiAgICAgICAgKFxuICAgICAgICAgIG5vZGVSZW5kZXJlcnNbaG92ZXJlZE5vZGUudHlwZV0gfHxcbiAgICAgICAgICBub2RlUmVuZGVyZXJzW2RlZmF1bHROb2RlVHlwZV0gfHxcbiAgICAgICAgICBub2RlUmVuZGVyZXJzLmRlZlxuICAgICAgICApKFxuICAgICAgICAgIGhvdmVyZWROb2RlLFxuICAgICAgICAgIHNlbGYuY29udGV4dHMuaG92ZXIsXG4gICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBOb2RlIHJlbmRlcjogbXVsdGlwbGUgaG92ZXJcbiAgICAgIGlmIChcbiAgICAgICAgZW1iZWRTZXR0aW5ncygnZW5hYmxlSG92ZXJpbmcnKSAmJlxuICAgICAgICAhZW1iZWRTZXR0aW5ncygnc2luZ2xlSG92ZXInKVxuICAgICAgKVxuICAgICAgICBmb3IgKGsgaW4gaG92ZXJlZE5vZGVzKVxuICAgICAgICAgIChcbiAgICAgICAgICAgIG5vZGVSZW5kZXJlcnNbaG92ZXJlZE5vZGVzW2tdLnR5cGVdIHx8XG4gICAgICAgICAgICBub2RlUmVuZGVyZXJzW2RlZmF1bHROb2RlVHlwZV0gfHxcbiAgICAgICAgICAgIG5vZGVSZW5kZXJlcnMuZGVmXG4gICAgICAgICAgKShcbiAgICAgICAgICAgIGhvdmVyZWROb2Rlc1trXSxcbiAgICAgICAgICAgIHNlbGYuY29udGV4dHMuaG92ZXIsXG4gICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgKTtcblxuICAgICAgLy8gRWRnZSByZW5kZXI6IHNpbmdsZSBob3ZlclxuICAgICAgaWYgKFxuICAgICAgICBlbWJlZFNldHRpbmdzKCdlbmFibGVFZGdlSG92ZXJpbmcnKSAmJlxuICAgICAgICBlbWJlZFNldHRpbmdzKCdzaW5nbGVIb3ZlcicpICYmXG4gICAgICAgIE9iamVjdC5rZXlzKGhvdmVyZWRFZGdlcykubGVuZ3RoXG4gICAgICApIHtcbiAgICAgICAgaG92ZXJlZEVkZ2UgPSBob3ZlcmVkRWRnZXNbT2JqZWN0LmtleXMoaG92ZXJlZEVkZ2VzKVswXV07XG4gICAgICAgIHNvdXJjZSA9IHNlbGYuZ3JhcGgubm9kZXMoaG92ZXJlZEVkZ2Uuc291cmNlKTtcbiAgICAgICAgdGFyZ2V0ID0gc2VsZi5ncmFwaC5ub2Rlcyhob3ZlcmVkRWRnZS50YXJnZXQpO1xuXG4gICAgICAgIGlmICghIGhvdmVyZWRFZGdlLmhpZGRlbikge1xuICAgICAgICAgIChcbiAgICAgICAgICAgIGVkZ2VSZW5kZXJlcnNbaG92ZXJlZEVkZ2UudHlwZV0gfHxcbiAgICAgICAgICAgIGVkZ2VSZW5kZXJlcnNbZGVmYXVsdEVkZ2VUeXBlXSB8fFxuICAgICAgICAgICAgZWRnZVJlbmRlcmVycy5kZWZcbiAgICAgICAgICApIChcbiAgICAgICAgICAgIGhvdmVyZWRFZGdlLFxuICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgc2VsZi5jb250ZXh0cy5ob3ZlcixcbiAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKGVtYmVkU2V0dGluZ3MoJ2VkZ2VIb3ZlckV4dHJlbWl0aWVzJykpIHtcbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgZXh0cmVtaXRpZXNSZW5kZXJlcnNbaG92ZXJlZEVkZ2UudHlwZV0gfHxcbiAgICAgICAgICAgICAgZXh0cmVtaXRpZXNSZW5kZXJlcnMuZGVmXG4gICAgICAgICAgICApKFxuICAgICAgICAgICAgICBob3ZlcmVkRWRnZSxcbiAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgIHNlbGYuY29udGV4dHMuaG92ZXIsXG4gICAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQXZvaWQgZWRnZXMgcmVuZGVyZWQgb3ZlciBub2RlczpcbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgc2lnbWEuY2FudmFzLm5vZGVzW3NvdXJjZS50eXBlXSB8fFxuICAgICAgICAgICAgICBzaWdtYS5jYW52YXMubm9kZXMuZGVmXG4gICAgICAgICAgICApIChcbiAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICBzZWxmLmNvbnRleHRzLmhvdmVyLFxuICAgICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgKFxuICAgICAgICAgICAgICBzaWdtYS5jYW52YXMubm9kZXNbdGFyZ2V0LnR5cGVdIHx8XG4gICAgICAgICAgICAgIHNpZ21hLmNhbnZhcy5ub2Rlcy5kZWZcbiAgICAgICAgICAgICkgKFxuICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgIHNlbGYuY29udGV4dHMuaG92ZXIsXG4gICAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEVkZ2UgcmVuZGVyOiBtdWx0aXBsZSBob3ZlclxuICAgICAgaWYgKFxuICAgICAgICBlbWJlZFNldHRpbmdzKCdlbmFibGVFZGdlSG92ZXJpbmcnKSAmJlxuICAgICAgICAhZW1iZWRTZXR0aW5ncygnc2luZ2xlSG92ZXInKVxuICAgICAgKSB7XG4gICAgICAgIGZvciAoayBpbiBob3ZlcmVkRWRnZXMpIHtcbiAgICAgICAgICBob3ZlcmVkRWRnZSA9IGhvdmVyZWRFZGdlc1trXTtcbiAgICAgICAgICBzb3VyY2UgPSBzZWxmLmdyYXBoLm5vZGVzKGhvdmVyZWRFZGdlLnNvdXJjZSk7XG4gICAgICAgICAgdGFyZ2V0ID0gc2VsZi5ncmFwaC5ub2Rlcyhob3ZlcmVkRWRnZS50YXJnZXQpO1xuXG4gICAgICAgICAgaWYgKCFob3ZlcmVkRWRnZS5oaWRkZW4pIHtcbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgZWRnZVJlbmRlcmVyc1tob3ZlcmVkRWRnZS50eXBlXSB8fFxuICAgICAgICAgICAgICBlZGdlUmVuZGVyZXJzW2RlZmF1bHRFZGdlVHlwZV0gfHxcbiAgICAgICAgICAgICAgZWRnZVJlbmRlcmVycy5kZWZcbiAgICAgICAgICAgICkgKFxuICAgICAgICAgICAgICBob3ZlcmVkRWRnZSxcbiAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgIHNlbGYuY29udGV4dHMuaG92ZXIsXG4gICAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmIChlbWJlZFNldHRpbmdzKCdlZGdlSG92ZXJFeHRyZW1pdGllcycpKSB7XG4gICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICBleHRyZW1pdGllc1JlbmRlcmVyc1tob3ZlcmVkRWRnZS50eXBlXSB8fFxuICAgICAgICAgICAgICAgIGV4dHJlbWl0aWVzUmVuZGVyZXJzLmRlZlxuICAgICAgICAgICAgICApKFxuICAgICAgICAgICAgICAgIGhvdmVyZWRFZGdlLFxuICAgICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgc2VsZi5jb250ZXh0cy5ob3ZlcixcbiAgICAgICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBBdm9pZCBlZGdlcyByZW5kZXJlZCBvdmVyIG5vZGVzOlxuICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgc2lnbWEuY2FudmFzLm5vZGVzW3NvdXJjZS50eXBlXSB8fFxuICAgICAgICAgICAgICAgIHNpZ21hLmNhbnZhcy5ub2Rlcy5kZWZcbiAgICAgICAgICAgICAgKSAoXG4gICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgIHNlbGYuY29udGV4dHMuaG92ZXIsXG4gICAgICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgc2lnbWEuY2FudmFzLm5vZGVzW3RhcmdldC50eXBlXSB8fFxuICAgICAgICAgICAgICAgIHNpZ21hLmNhbnZhcy5ub2Rlcy5kZWZcbiAgICAgICAgICAgICAgKSAoXG4gICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgIHNlbGYuY29udGV4dHMuaG92ZXIsXG4gICAgICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn0pLmNhbGwodGhpcyk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/sigma/build/sigma.require.js\n");

/***/ }),

/***/ "./node_modules/sigma/plugins/sigma.layout.noverlap/sigma.layout.noverlap.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sigma/plugins/sigma.layout.noverlap/sigma.layout.noverlap.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval(";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw new Error('sigma is not declared');\n\n  // Initialize package:\n  sigma.utils.pkg('sigma.layout.noverlap');\n\n  /**\n   * Noverlap Layout\n   * ===============================\n   *\n   * Author: @apitts / Andrew Pitts\n   * Algorithm: @jacomyma / Mathieu Jacomy (originally contributed to Gephi and ported to sigma.js under the MIT license by @andpitts with permission)\n   * Acknowledgement: @sheyman / Sbastien Heymann (some inspiration has been taken from other MIT licensed layout algorithms authored by @sheyman)\n   * Version: 0.1\n   */\n\n  var settings = {\n    speed: 1,\n    scaleNodes: 1.2,\n    nodeMargin: 5.0,\n    gridSize: 20,\n    permittedExpansion: 1.1,\n    rendererIndex: 0,\n    maxIterations: 500\n  };\n\n  var _instance = {};\n\n  /**\n   * Event emitter Object\n   * ------------------\n   */\n  var _eventEmitter = {};\n\n   /**\n   * Noverlap Object\n   * ------------------\n   */\n  function Noverlap() {\n    var self = this;\n\n    this.init = function (sigInst, options) {\n      options = options || {};\n\n      // Properties\n      this.sigInst = sigInst;\n      this.config = sigma.utils.extend(options, settings);\n      this.easing = options.easing;\n      this.duration = options.duration;\n\n      if (options.nodes) {\n        this.nodes = options.nodes;\n        delete options.nodes;\n      }\n\n      if (!sigma.plugins || typeof sigma.plugins.animate === 'undefined') {\n        throw new Error('sigma.plugins.animate is not declared');\n      }\n\n      // State\n      this.running = false;\n    };\n\n    /**\n     * Single layout iteration.\n     */\n    this.atomicGo = function () {\n      if (!this.running || this.iterCount < 1) return false;\n\n      var nodes = this.nodes || this.sigInst.graph.nodes(),\n          nodesCount = nodes.length,\n          i,\n          n,\n          n1,\n          n2,\n          xmin = Infinity,\n          xmax = -Infinity,\n          ymin = Infinity,\n          ymax = -Infinity,\n          xwidth,\n          yheight,\n          xcenter,\n          ycenter,\n          grid,\n          row,\n          col,\n          minXBox,\n          maxXBox,\n          minYBox,\n          maxYBox,\n          adjacentNodes,\n          subRow,\n          subCol,\n          nxmin,\n          nxmax,\n          nymin,\n          nymax;\n\n      this.iterCount--;\n      this.running = false;\n\n      for (i=0; i < nodesCount; i++) {\n        n = nodes[i];\n        n.dn.dx = 0;\n        n.dn.dy = 0;\n\n        //Find the min and max for both x and y across all nodes\n        xmin = Math.min(xmin, n.dn_x - (n.dn_size*self.config.scaleNodes + self.config.nodeMargin) );\n        xmax = Math.max(xmax, n.dn_x + (n.dn_size*self.config.scaleNodes + self.config.nodeMargin) );\n        ymin = Math.min(ymin, n.dn_y - (n.dn_size*self.config.scaleNodes + self.config.nodeMargin) );\n        ymax = Math.max(ymax, n.dn_y + (n.dn_size*self.config.scaleNodes + self.config.nodeMargin) );\n\n      }\n\n      xwidth = xmax - xmin;\n      yheight = ymax - ymin;\n      xcenter = (xmin + xmax) / 2;\n      ycenter = (ymin + ymax) / 2;\n      xmin = xcenter - self.config.permittedExpansion*xwidth / 2;\n      xmax = xcenter + self.config.permittedExpansion*xwidth / 2;\n      ymin = ycenter - self.config.permittedExpansion*yheight / 2;\n      ymax = ycenter + self.config.permittedExpansion*yheight / 2;\n\n      grid = {}; //An object of objects where grid[row][col] is an array of node ids representing nodes that fall in that grid. Nodes can fall in more than one grid\n\n      for(row = 0; row < self.config.gridSize; row++) {\n        grid[row] = {};\n        for(col = 0; col < self.config.gridSize; col++) {\n          grid[row][col] = [];\n        }\n      }\n\n      //Place nodes in grid\n      for (i=0; i < nodesCount; i++) {\n        n = nodes[i];\n\n        nxmin = n.dn_x - (n.dn_size*self.config.scaleNodes + self.config.nodeMargin);\n        nxmax = n.dn_x + (n.dn_size*self.config.scaleNodes + self.config.nodeMargin);\n        nymin = n.dn_y - (n.dn_size*self.config.scaleNodes + self.config.nodeMargin);\n        nymax = n.dn_y + (n.dn_size*self.config.scaleNodes + self.config.nodeMargin);\n\n        minXBox = Math.floor(self.config.gridSize* (nxmin - xmin) / (xmax - xmin) );\n        maxXBox = Math.floor(self.config.gridSize* (nxmax - xmin) / (xmax - xmin) );\n        minYBox = Math.floor(self.config.gridSize* (nymin - ymin) / (ymax - ymin) );\n        maxYBox = Math.floor(self.config.gridSize* (nymax - ymin) / (ymax - ymin) );\n        for(col = minXBox; col <= maxXBox; col++) {\n          for(row = minYBox; row <= maxYBox; row++) {\n            grid[row][col].push(n.id);\n          }\n        }\n      }\n\n\n      adjacentNodes = {}; //An object that stores the node ids of adjacent nodes (either in same grid box or adjacent grid box) for all nodes\n\n      for(row = 0; row < self.config.gridSize; row++) {\n        for(col = 0; col < self.config.gridSize; col++) {\n          grid[row][col].forEach(function(nodeId) {\n            if(!adjacentNodes[nodeId]) {\n              adjacentNodes[nodeId] = [];\n            }\n            for(subRow = Math.max(0, row - 1); subRow <= Math.min(row + 1, self.config.gridSize - 1); subRow++) {\n              for(subCol = Math.max(0, col - 1); subCol <= Math.min(col + 1,  self.config.gridSize - 1); subCol++) {\n                grid[subRow][subCol].forEach(function(subNodeId) {\n                  if(subNodeId !== nodeId && adjacentNodes[nodeId].indexOf(subNodeId) === -1) {\n                    adjacentNodes[nodeId].push(subNodeId);\n                  }\n                });\n              }\n            }\n          });\n        }\n      }\n\n      //If two nodes overlap then repulse them\n      for (i=0; i < nodesCount; i++) {\n        n1 = nodes[i];\n        adjacentNodes[n1.id].forEach(function(nodeId) {\n          var n2 = self.sigInst.graph.nodes(nodeId);\n          var xDist = n2.dn_x - n1.dn_x;\n          var yDist = n2.dn_y - n1.dn_y;\n          var dist = Math.sqrt(xDist*xDist + yDist*yDist);\n          var collision = (dist < ((n1.dn_size*self.config.scaleNodes + self.config.nodeMargin) + (n2.dn_size*self.config.scaleNodes + self.config.nodeMargin)));\n          if(collision) {\n            self.running = true;\n            if(dist > 0) {\n              n2.dn.dx += xDist / dist * (1 + n1.dn_size);\n              n2.dn.dy += yDist / dist * (1 + n1.dn_size);\n            } else {\n              n2.dn.dx += xwidth * 0.01 * (0.5 - Math.random());\n              n2.dn.dy += yheight * 0.01 * (0.5 - Math.random());\n            }\n          }\n        });\n      }\n\n      for (i=0; i < nodesCount; i++) {\n        n = nodes[i];\n        if(!n.fixed) {\n          n.dn_x = n.dn_x + n.dn.dx * 0.1 * self.config.speed;\n          n.dn_y = n.dn_y + n.dn.dy * 0.1 * self.config.speed;\n        }\n      }\n\n      if(this.running && this.iterCount < 1) {\n        this.running = false;\n      }\n\n      return this.running;\n    };\n\n    this.go = function () {\n      this.iterCount = this.config.maxIterations;\n\n      while (this.running) {\n        this.atomicGo();\n      };\n\n      this.stop();\n    };\n\n    this.start = function() {\n      if (this.running) return;\n\n      var nodes = this.sigInst.graph.nodes();\n\n      var prefix = this.sigInst.renderers[self.config.rendererIndex].options.prefix;\n\n      this.running = true;\n\n      // Init nodes\n      for (var i = 0; i < nodes.length; i++) {\n        nodes[i].dn_x = nodes[i][prefix + 'x'];\n        nodes[i].dn_y = nodes[i][prefix + 'y'];\n        nodes[i].dn_size = nodes[i][prefix + 'size'];\n        nodes[i].dn = {\n          dx: 0,\n          dy: 0\n        };\n      }\n      _eventEmitter[self.sigInst.id].dispatchEvent('start');\n      this.go();\n    };\n\n    this.stop = function() {\n      var nodes = this.sigInst.graph.nodes();\n\n      this.running = false;\n\n      if (this.easing) {\n        _eventEmitter[self.sigInst.id].dispatchEvent('interpolate');\n        sigma.plugins.animate(\n          self.sigInst,\n          {\n            x: 'dn_x',\n            y: 'dn_y'\n          },\n          {\n            easing: self.easing,\n            onComplete: function() {\n              self.sigInst.refresh();\n              for (var i = 0; i < nodes.length; i++) {\n                nodes[i].dn = null;\n                nodes[i].dn_x = null;\n                nodes[i].dn_y = null;\n              }\n              _eventEmitter[self.sigInst.id].dispatchEvent('stop');\n            },\n            duration: self.duration\n          }\n        );\n      }\n      else {\n        // Apply changes\n        for (var i = 0; i < nodes.length; i++) {\n          nodes[i].x = nodes[i].dn_x;\n          nodes[i].y = nodes[i].dn_y;\n        }\n\n        this.sigInst.refresh();\n\n        for (var i = 0; i < nodes.length; i++) {\n          nodes[i].dn = null;\n          nodes[i].dn_x = null;\n          nodes[i].dn_y = null;\n        }\n        _eventEmitter[self.sigInst.id].dispatchEvent('stop');\n      }\n    };\n\n    this.kill = function() {\n      this.sigInst = null;\n      this.config = null;\n      this.easing = null;\n    };\n  };\n\n  /**\n   * Interface\n   * ----------\n   */\n\n  /**\n   * Configure the layout algorithm.\n\n   * Recognized options:\n   * **********************\n   * Here is the exhaustive list of every accepted parameter in the settings\n   * object:\n   *\n   *   {?number}            speed               A larger value increases the convergence speed at the cost of precision\n   *   {?number}            scaleNodes          The ratio to scale nodes by - a larger ratio will lead to more space around larger nodes\n   *   {?number}            nodeMargin          A fixed margin to apply around nodes regardless of size\n   *   {?number}            maxIterations       The maximum number of iterations to perform before the layout completes.\n   *   {?integer}           gridSize            The number of rows and columns to use when partioning nodes into a grid for efficient computation\n   *   {?number}            permittedExpansion  A permitted expansion factor to the overall size of the network applied at each iteration\n   *   {?integer}           rendererIndex       The index of the renderer to use for node co-ordinates. Defaults to zero.\n   *   {?(function|string)} easing              Either the name of an easing in the sigma.utils.easings package or a function. If not specified, the\n   *                                            quadraticInOut easing from this package will be used instead.\n   *   {?number}            duration            The duration of the animation. If not specified, the \"animationsTime\" setting value of the sigma instance will be used instead.\n   *\n   *\n   * @param  {object} config  The optional configuration object.\n   *\n   * @return {sigma.classes.dispatcher} Returns an event emitter.\n   */\n  sigma.prototype.configNoverlap = function(config) {\n\n    var sigInst = this;\n\n    if (!config) throw new Error('Missing argument: \"config\"');\n\n    // Create instance if undefined\n    if (!_instance[sigInst.id]) {\n      _instance[sigInst.id] = new Noverlap();\n\n      _eventEmitter[sigInst.id] = {};\n      sigma.classes.dispatcher.extend(_eventEmitter[sigInst.id]);\n\n      // Binding on kill to clear the references\n      sigInst.bind('kill', function() {\n        _instance[sigInst.id].kill();\n        _instance[sigInst.id] = null;\n        _eventEmitter[sigInst.id] = null;\n      });\n    }\n\n    _instance[sigInst.id].init(sigInst, config);\n\n    return _eventEmitter[sigInst.id];\n  };\n\n  /**\n   * Start the layout algorithm. It will use the existing configuration if no\n   * new configuration is passed.\n\n   * Recognized options:\n   * **********************\n   * Here is the exhaustive list of every accepted parameter in the settings\n   * object\n   *\n   *   {?number}            speed               A larger value increases the convergence speed at the cost of precision\n   *   {?number}            scaleNodes          The ratio to scale nodes by - a larger ratio will lead to more space around larger nodes\n   *   {?number}            nodeMargin          A fixed margin to apply around nodes regardless of size\n   *   {?number}            maxIterations       The maximum number of iterations to perform before the layout completes.\n   *   {?integer}           gridSize            The number of rows and columns to use when partioning nodes into a grid for efficient computation\n   *   {?number}            permittedExpansion  A permitted expansion factor to the overall size of the network applied at each iteration\n   *   {?integer}           rendererIndex       The index of the renderer to use for node co-ordinates. Defaults to zero.\n   *   {?(function|string)} easing              Either the name of an easing in the sigma.utils.easings package or a function. If not specified, the\n   *                                            quadraticInOut easing from this package will be used instead.\n   *   {?number}            duration            The duration of the animation. If not specified, the \"animationsTime\" setting value of the sigma instance will be used instead.\n   *\n   *\n   *\n   * @param  {object} config  The optional configuration object.\n   *\n   * @return {sigma.classes.dispatcher} Returns an event emitter.\n   */\n\n  sigma.prototype.startNoverlap = function(config) {\n\n    var sigInst = this;\n\n    if (config) {\n      this.configNoverlap(sigInst, config);\n    }\n\n    _instance[sigInst.id].start();\n\n    return _eventEmitter[sigInst.id];\n  };\n\n  /**\n   * Returns true if the layout has started and is not completed.\n   *\n   * @return {boolean}\n   */\n  sigma.prototype.isNoverlapRunning = function() {\n\n    var sigInst = this;\n\n    return !!_instance[sigInst.id] && _instance[sigInst.id].running;\n  };\n\n}).call(this);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2lnbWEvcGx1Z2lucy9zaWdtYS5sYXlvdXQubm92ZXJsYXAvc2lnbWEubGF5b3V0Lm5vdmVybGFwLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NpZ21hL3BsdWdpbnMvc2lnbWEubGF5b3V0Lm5vdmVybGFwL3NpZ21hLmxheW91dC5ub3ZlcmxhcC5qcz82YTNkIl0sInNvdXJjZXNDb250ZW50IjpbIjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCcpO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZTpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5sYXlvdXQubm92ZXJsYXAnKTtcblxuICAvKipcbiAgICogTm92ZXJsYXAgTGF5b3V0XG4gICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICpcbiAgICogQXV0aG9yOiBAYXBpdHRzIC8gQW5kcmV3IFBpdHRzXG4gICAqIEFsZ29yaXRobTogQGphY29teW1hIC8gTWF0aGlldSBKYWNvbXkgKG9yaWdpbmFsbHkgY29udHJpYnV0ZWQgdG8gR2VwaGkgYW5kIHBvcnRlZCB0byBzaWdtYS5qcyB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgYnkgQGFuZHBpdHRzIHdpdGggcGVybWlzc2lvbilcbiAgICogQWNrbm93bGVkZ2VtZW50OiBAc2hleW1hbiAvIFPDqWJhc3RpZW4gSGV5bWFubiAoc29tZSBpbnNwaXJhdGlvbiBoYXMgYmVlbiB0YWtlbiBmcm9tIG90aGVyIE1JVCBsaWNlbnNlZCBsYXlvdXQgYWxnb3JpdGhtcyBhdXRob3JlZCBieSBAc2hleW1hbilcbiAgICogVmVyc2lvbjogMC4xXG4gICAqL1xuXG4gIHZhciBzZXR0aW5ncyA9IHtcbiAgICBzcGVlZDogMSxcbiAgICBzY2FsZU5vZGVzOiAxLjIsXG4gICAgbm9kZU1hcmdpbjogNS4wLFxuICAgIGdyaWRTaXplOiAyMCxcbiAgICBwZXJtaXR0ZWRFeHBhbnNpb246IDEuMSxcbiAgICByZW5kZXJlckluZGV4OiAwLFxuICAgIG1heEl0ZXJhdGlvbnM6IDUwMFxuICB9O1xuXG4gIHZhciBfaW5zdGFuY2UgPSB7fTtcblxuICAvKipcbiAgICogRXZlbnQgZW1pdHRlciBPYmplY3RcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuICB2YXIgX2V2ZW50RW1pdHRlciA9IHt9O1xuXG4gICAvKipcbiAgICogTm92ZXJsYXAgT2JqZWN0XG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cbiAgZnVuY3Rpb24gTm92ZXJsYXAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy5pbml0ID0gZnVuY3Rpb24gKHNpZ0luc3QsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAvLyBQcm9wZXJ0aWVzXG4gICAgICB0aGlzLnNpZ0luc3QgPSBzaWdJbnN0O1xuICAgICAgdGhpcy5jb25maWcgPSBzaWdtYS51dGlscy5leHRlbmQob3B0aW9ucywgc2V0dGluZ3MpO1xuICAgICAgdGhpcy5lYXNpbmcgPSBvcHRpb25zLmVhc2luZztcbiAgICAgIHRoaXMuZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uO1xuXG4gICAgICBpZiAob3B0aW9ucy5ub2Rlcykge1xuICAgICAgICB0aGlzLm5vZGVzID0gb3B0aW9ucy5ub2RlcztcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMubm9kZXM7XG4gICAgICB9XG5cbiAgICAgIGlmICghc2lnbWEucGx1Z2lucyB8fCB0eXBlb2Ygc2lnbWEucGx1Z2lucy5hbmltYXRlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ21hLnBsdWdpbnMuYW5pbWF0ZSBpcyBub3QgZGVjbGFyZWQnKTtcbiAgICAgIH1cblxuICAgICAgLy8gU3RhdGVcbiAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTaW5nbGUgbGF5b3V0IGl0ZXJhdGlvbi5cbiAgICAgKi9cbiAgICB0aGlzLmF0b21pY0dvID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLnJ1bm5pbmcgfHwgdGhpcy5pdGVyQ291bnQgPCAxKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMgfHwgdGhpcy5zaWdJbnN0LmdyYXBoLm5vZGVzKCksXG4gICAgICAgICAgbm9kZXNDb3VudCA9IG5vZGVzLmxlbmd0aCxcbiAgICAgICAgICBpLFxuICAgICAgICAgIG4sXG4gICAgICAgICAgbjEsXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgeG1pbiA9IEluZmluaXR5LFxuICAgICAgICAgIHhtYXggPSAtSW5maW5pdHksXG4gICAgICAgICAgeW1pbiA9IEluZmluaXR5LFxuICAgICAgICAgIHltYXggPSAtSW5maW5pdHksXG4gICAgICAgICAgeHdpZHRoLFxuICAgICAgICAgIHloZWlnaHQsXG4gICAgICAgICAgeGNlbnRlcixcbiAgICAgICAgICB5Y2VudGVyLFxuICAgICAgICAgIGdyaWQsXG4gICAgICAgICAgcm93LFxuICAgICAgICAgIGNvbCxcbiAgICAgICAgICBtaW5YQm94LFxuICAgICAgICAgIG1heFhCb3gsXG4gICAgICAgICAgbWluWUJveCxcbiAgICAgICAgICBtYXhZQm94LFxuICAgICAgICAgIGFkamFjZW50Tm9kZXMsXG4gICAgICAgICAgc3ViUm93LFxuICAgICAgICAgIHN1YkNvbCxcbiAgICAgICAgICBueG1pbixcbiAgICAgICAgICBueG1heCxcbiAgICAgICAgICBueW1pbixcbiAgICAgICAgICBueW1heDtcblxuICAgICAgdGhpcy5pdGVyQ291bnQtLTtcbiAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuXG4gICAgICBmb3IgKGk9MDsgaSA8IG5vZGVzQ291bnQ7IGkrKykge1xuICAgICAgICBuID0gbm9kZXNbaV07XG4gICAgICAgIG4uZG4uZHggPSAwO1xuICAgICAgICBuLmRuLmR5ID0gMDtcblxuICAgICAgICAvL0ZpbmQgdGhlIG1pbiBhbmQgbWF4IGZvciBib3RoIHggYW5kIHkgYWNyb3NzIGFsbCBub2Rlc1xuICAgICAgICB4bWluID0gTWF0aC5taW4oeG1pbiwgbi5kbl94IC0gKG4uZG5fc2l6ZSpzZWxmLmNvbmZpZy5zY2FsZU5vZGVzICsgc2VsZi5jb25maWcubm9kZU1hcmdpbikgKTtcbiAgICAgICAgeG1heCA9IE1hdGgubWF4KHhtYXgsIG4uZG5feCArIChuLmRuX3NpemUqc2VsZi5jb25maWcuc2NhbGVOb2RlcyArIHNlbGYuY29uZmlnLm5vZGVNYXJnaW4pICk7XG4gICAgICAgIHltaW4gPSBNYXRoLm1pbih5bWluLCBuLmRuX3kgLSAobi5kbl9zaXplKnNlbGYuY29uZmlnLnNjYWxlTm9kZXMgKyBzZWxmLmNvbmZpZy5ub2RlTWFyZ2luKSApO1xuICAgICAgICB5bWF4ID0gTWF0aC5tYXgoeW1heCwgbi5kbl95ICsgKG4uZG5fc2l6ZSpzZWxmLmNvbmZpZy5zY2FsZU5vZGVzICsgc2VsZi5jb25maWcubm9kZU1hcmdpbikgKTtcblxuICAgICAgfVxuXG4gICAgICB4d2lkdGggPSB4bWF4IC0geG1pbjtcbiAgICAgIHloZWlnaHQgPSB5bWF4IC0geW1pbjtcbiAgICAgIHhjZW50ZXIgPSAoeG1pbiArIHhtYXgpIC8gMjtcbiAgICAgIHljZW50ZXIgPSAoeW1pbiArIHltYXgpIC8gMjtcbiAgICAgIHhtaW4gPSB4Y2VudGVyIC0gc2VsZi5jb25maWcucGVybWl0dGVkRXhwYW5zaW9uKnh3aWR0aCAvIDI7XG4gICAgICB4bWF4ID0geGNlbnRlciArIHNlbGYuY29uZmlnLnBlcm1pdHRlZEV4cGFuc2lvbip4d2lkdGggLyAyO1xuICAgICAgeW1pbiA9IHljZW50ZXIgLSBzZWxmLmNvbmZpZy5wZXJtaXR0ZWRFeHBhbnNpb24qeWhlaWdodCAvIDI7XG4gICAgICB5bWF4ID0geWNlbnRlciArIHNlbGYuY29uZmlnLnBlcm1pdHRlZEV4cGFuc2lvbip5aGVpZ2h0IC8gMjtcblxuICAgICAgZ3JpZCA9IHt9OyAvL0FuIG9iamVjdCBvZiBvYmplY3RzIHdoZXJlIGdyaWRbcm93XVtjb2xdIGlzIGFuIGFycmF5IG9mIG5vZGUgaWRzIHJlcHJlc2VudGluZyBub2RlcyB0aGF0IGZhbGwgaW4gdGhhdCBncmlkLiBOb2RlcyBjYW4gZmFsbCBpbiBtb3JlIHRoYW4gb25lIGdyaWRcblxuICAgICAgZm9yKHJvdyA9IDA7IHJvdyA8IHNlbGYuY29uZmlnLmdyaWRTaXplOyByb3crKykge1xuICAgICAgICBncmlkW3Jvd10gPSB7fTtcbiAgICAgICAgZm9yKGNvbCA9IDA7IGNvbCA8IHNlbGYuY29uZmlnLmdyaWRTaXplOyBjb2wrKykge1xuICAgICAgICAgIGdyaWRbcm93XVtjb2xdID0gW107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy9QbGFjZSBub2RlcyBpbiBncmlkXG4gICAgICBmb3IgKGk9MDsgaSA8IG5vZGVzQ291bnQ7IGkrKykge1xuICAgICAgICBuID0gbm9kZXNbaV07XG5cbiAgICAgICAgbnhtaW4gPSBuLmRuX3ggLSAobi5kbl9zaXplKnNlbGYuY29uZmlnLnNjYWxlTm9kZXMgKyBzZWxmLmNvbmZpZy5ub2RlTWFyZ2luKTtcbiAgICAgICAgbnhtYXggPSBuLmRuX3ggKyAobi5kbl9zaXplKnNlbGYuY29uZmlnLnNjYWxlTm9kZXMgKyBzZWxmLmNvbmZpZy5ub2RlTWFyZ2luKTtcbiAgICAgICAgbnltaW4gPSBuLmRuX3kgLSAobi5kbl9zaXplKnNlbGYuY29uZmlnLnNjYWxlTm9kZXMgKyBzZWxmLmNvbmZpZy5ub2RlTWFyZ2luKTtcbiAgICAgICAgbnltYXggPSBuLmRuX3kgKyAobi5kbl9zaXplKnNlbGYuY29uZmlnLnNjYWxlTm9kZXMgKyBzZWxmLmNvbmZpZy5ub2RlTWFyZ2luKTtcblxuICAgICAgICBtaW5YQm94ID0gTWF0aC5mbG9vcihzZWxmLmNvbmZpZy5ncmlkU2l6ZSogKG54bWluIC0geG1pbikgLyAoeG1heCAtIHhtaW4pICk7XG4gICAgICAgIG1heFhCb3ggPSBNYXRoLmZsb29yKHNlbGYuY29uZmlnLmdyaWRTaXplKiAobnhtYXggLSB4bWluKSAvICh4bWF4IC0geG1pbikgKTtcbiAgICAgICAgbWluWUJveCA9IE1hdGguZmxvb3Ioc2VsZi5jb25maWcuZ3JpZFNpemUqIChueW1pbiAtIHltaW4pIC8gKHltYXggLSB5bWluKSApO1xuICAgICAgICBtYXhZQm94ID0gTWF0aC5mbG9vcihzZWxmLmNvbmZpZy5ncmlkU2l6ZSogKG55bWF4IC0geW1pbikgLyAoeW1heCAtIHltaW4pICk7XG4gICAgICAgIGZvcihjb2wgPSBtaW5YQm94OyBjb2wgPD0gbWF4WEJveDsgY29sKyspIHtcbiAgICAgICAgICBmb3Iocm93ID0gbWluWUJveDsgcm93IDw9IG1heFlCb3g7IHJvdysrKSB7XG4gICAgICAgICAgICBncmlkW3Jvd11bY29sXS5wdXNoKG4uaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG5cbiAgICAgIGFkamFjZW50Tm9kZXMgPSB7fTsgLy9BbiBvYmplY3QgdGhhdCBzdG9yZXMgdGhlIG5vZGUgaWRzIG9mIGFkamFjZW50IG5vZGVzIChlaXRoZXIgaW4gc2FtZSBncmlkIGJveCBvciBhZGphY2VudCBncmlkIGJveCkgZm9yIGFsbCBub2Rlc1xuXG4gICAgICBmb3Iocm93ID0gMDsgcm93IDwgc2VsZi5jb25maWcuZ3JpZFNpemU7IHJvdysrKSB7XG4gICAgICAgIGZvcihjb2wgPSAwOyBjb2wgPCBzZWxmLmNvbmZpZy5ncmlkU2l6ZTsgY29sKyspIHtcbiAgICAgICAgICBncmlkW3Jvd11bY29sXS5mb3JFYWNoKGZ1bmN0aW9uKG5vZGVJZCkge1xuICAgICAgICAgICAgaWYoIWFkamFjZW50Tm9kZXNbbm9kZUlkXSkge1xuICAgICAgICAgICAgICBhZGphY2VudE5vZGVzW25vZGVJZF0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvcihzdWJSb3cgPSBNYXRoLm1heCgwLCByb3cgLSAxKTsgc3ViUm93IDw9IE1hdGgubWluKHJvdyArIDEsIHNlbGYuY29uZmlnLmdyaWRTaXplIC0gMSk7IHN1YlJvdysrKSB7XG4gICAgICAgICAgICAgIGZvcihzdWJDb2wgPSBNYXRoLm1heCgwLCBjb2wgLSAxKTsgc3ViQ29sIDw9IE1hdGgubWluKGNvbCArIDEsICBzZWxmLmNvbmZpZy5ncmlkU2l6ZSAtIDEpOyBzdWJDb2wrKykge1xuICAgICAgICAgICAgICAgIGdyaWRbc3ViUm93XVtzdWJDb2xdLmZvckVhY2goZnVuY3Rpb24oc3ViTm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgICBpZihzdWJOb2RlSWQgIT09IG5vZGVJZCAmJiBhZGphY2VudE5vZGVzW25vZGVJZF0uaW5kZXhPZihzdWJOb2RlSWQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBhZGphY2VudE5vZGVzW25vZGVJZF0ucHVzaChzdWJOb2RlSWQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy9JZiB0d28gbm9kZXMgb3ZlcmxhcCB0aGVuIHJlcHVsc2UgdGhlbVxuICAgICAgZm9yIChpPTA7IGkgPCBub2Rlc0NvdW50OyBpKyspIHtcbiAgICAgICAgbjEgPSBub2Rlc1tpXTtcbiAgICAgICAgYWRqYWNlbnROb2Rlc1tuMS5pZF0uZm9yRWFjaChmdW5jdGlvbihub2RlSWQpIHtcbiAgICAgICAgICB2YXIgbjIgPSBzZWxmLnNpZ0luc3QuZ3JhcGgubm9kZXMobm9kZUlkKTtcbiAgICAgICAgICB2YXIgeERpc3QgPSBuMi5kbl94IC0gbjEuZG5feDtcbiAgICAgICAgICB2YXIgeURpc3QgPSBuMi5kbl95IC0gbjEuZG5feTtcbiAgICAgICAgICB2YXIgZGlzdCA9IE1hdGguc3FydCh4RGlzdCp4RGlzdCArIHlEaXN0KnlEaXN0KTtcbiAgICAgICAgICB2YXIgY29sbGlzaW9uID0gKGRpc3QgPCAoKG4xLmRuX3NpemUqc2VsZi5jb25maWcuc2NhbGVOb2RlcyArIHNlbGYuY29uZmlnLm5vZGVNYXJnaW4pICsgKG4yLmRuX3NpemUqc2VsZi5jb25maWcuc2NhbGVOb2RlcyArIHNlbGYuY29uZmlnLm5vZGVNYXJnaW4pKSk7XG4gICAgICAgICAgaWYoY29sbGlzaW9uKSB7XG4gICAgICAgICAgICBzZWxmLnJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgaWYoZGlzdCA+IDApIHtcbiAgICAgICAgICAgICAgbjIuZG4uZHggKz0geERpc3QgLyBkaXN0ICogKDEgKyBuMS5kbl9zaXplKTtcbiAgICAgICAgICAgICAgbjIuZG4uZHkgKz0geURpc3QgLyBkaXN0ICogKDEgKyBuMS5kbl9zaXplKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG4yLmRuLmR4ICs9IHh3aWR0aCAqIDAuMDEgKiAoMC41IC0gTWF0aC5yYW5kb20oKSk7XG4gICAgICAgICAgICAgIG4yLmRuLmR5ICs9IHloZWlnaHQgKiAwLjAxICogKDAuNSAtIE1hdGgucmFuZG9tKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaT0wOyBpIDwgbm9kZXNDb3VudDsgaSsrKSB7XG4gICAgICAgIG4gPSBub2Rlc1tpXTtcbiAgICAgICAgaWYoIW4uZml4ZWQpIHtcbiAgICAgICAgICBuLmRuX3ggPSBuLmRuX3ggKyBuLmRuLmR4ICogMC4xICogc2VsZi5jb25maWcuc3BlZWQ7XG4gICAgICAgICAgbi5kbl95ID0gbi5kbl95ICsgbi5kbi5keSAqIDAuMSAqIHNlbGYuY29uZmlnLnNwZWVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKHRoaXMucnVubmluZyAmJiB0aGlzLml0ZXJDb3VudCA8IDEpIHtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ1bm5pbmc7XG4gICAgfTtcblxuICAgIHRoaXMuZ28gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLml0ZXJDb3VudCA9IHRoaXMuY29uZmlnLm1heEl0ZXJhdGlvbnM7XG5cbiAgICAgIHdoaWxlICh0aGlzLnJ1bm5pbmcpIHtcbiAgICAgICAgdGhpcy5hdG9taWNHbygpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5zdG9wKCk7XG4gICAgfTtcblxuICAgIHRoaXMuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnJ1bm5pbmcpIHJldHVybjtcblxuICAgICAgdmFyIG5vZGVzID0gdGhpcy5zaWdJbnN0LmdyYXBoLm5vZGVzKCk7XG5cbiAgICAgIHZhciBwcmVmaXggPSB0aGlzLnNpZ0luc3QucmVuZGVyZXJzW3NlbGYuY29uZmlnLnJlbmRlcmVySW5kZXhdLm9wdGlvbnMucHJlZml4O1xuXG4gICAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuXG4gICAgICAvLyBJbml0IG5vZGVzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5vZGVzW2ldLmRuX3ggPSBub2Rlc1tpXVtwcmVmaXggKyAneCddO1xuICAgICAgICBub2Rlc1tpXS5kbl95ID0gbm9kZXNbaV1bcHJlZml4ICsgJ3knXTtcbiAgICAgICAgbm9kZXNbaV0uZG5fc2l6ZSA9IG5vZGVzW2ldW3ByZWZpeCArICdzaXplJ107XG4gICAgICAgIG5vZGVzW2ldLmRuID0ge1xuICAgICAgICAgIGR4OiAwLFxuICAgICAgICAgIGR5OiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBfZXZlbnRFbWl0dGVyW3NlbGYuc2lnSW5zdC5pZF0uZGlzcGF0Y2hFdmVudCgnc3RhcnQnKTtcbiAgICAgIHRoaXMuZ28oKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLnNpZ0luc3QuZ3JhcGgubm9kZXMoKTtcblxuICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLmVhc2luZykge1xuICAgICAgICBfZXZlbnRFbWl0dGVyW3NlbGYuc2lnSW5zdC5pZF0uZGlzcGF0Y2hFdmVudCgnaW50ZXJwb2xhdGUnKTtcbiAgICAgICAgc2lnbWEucGx1Z2lucy5hbmltYXRlKFxuICAgICAgICAgIHNlbGYuc2lnSW5zdCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB4OiAnZG5feCcsXG4gICAgICAgICAgICB5OiAnZG5feSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVhc2luZzogc2VsZi5lYXNpbmcsXG4gICAgICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgc2VsZi5zaWdJbnN0LnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG5vZGVzW2ldLmRuID0gbnVsbDtcbiAgICAgICAgICAgICAgICBub2Rlc1tpXS5kbl94ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBub2Rlc1tpXS5kbl95ID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfZXZlbnRFbWl0dGVyW3NlbGYuc2lnSW5zdC5pZF0uZGlzcGF0Y2hFdmVudCgnc3RvcCcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBzZWxmLmR1cmF0aW9uXG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIEFwcGx5IGNoYW5nZXNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5vZGVzW2ldLnggPSBub2Rlc1tpXS5kbl94O1xuICAgICAgICAgIG5vZGVzW2ldLnkgPSBub2Rlc1tpXS5kbl95O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zaWdJbnN0LnJlZnJlc2goKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbm9kZXNbaV0uZG4gPSBudWxsO1xuICAgICAgICAgIG5vZGVzW2ldLmRuX3ggPSBudWxsO1xuICAgICAgICAgIG5vZGVzW2ldLmRuX3kgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIF9ldmVudEVtaXR0ZXJbc2VsZi5zaWdJbnN0LmlkXS5kaXNwYXRjaEV2ZW50KCdzdG9wJyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMua2lsbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zaWdJbnN0ID0gbnVsbDtcbiAgICAgIHRoaXMuY29uZmlnID0gbnVsbDtcbiAgICAgIHRoaXMuZWFzaW5nID0gbnVsbDtcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbnRlcmZhY2VcbiAgICogLS0tLS0tLS0tLVxuICAgKi9cblxuICAvKipcbiAgICogQ29uZmlndXJlIHRoZSBsYXlvdXQgYWxnb3JpdGhtLlxuXG4gICAqIFJlY29nbml6ZWQgb3B0aW9uczpcbiAgICogKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBIZXJlIGlzIHRoZSBleGhhdXN0aXZlIGxpc3Qgb2YgZXZlcnkgYWNjZXB0ZWQgcGFyYW1ldGVyIGluIHRoZSBzZXR0aW5nc1xuICAgKiBvYmplY3Q6XG4gICAqXG4gICAqICAgez9udW1iZXJ9ICAgICAgICAgICAgc3BlZWQgICAgICAgICAgICAgICBBIGxhcmdlciB2YWx1ZSBpbmNyZWFzZXMgdGhlIGNvbnZlcmdlbmNlIHNwZWVkIGF0IHRoZSBjb3N0IG9mIHByZWNpc2lvblxuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIHNjYWxlTm9kZXMgICAgICAgICAgVGhlIHJhdGlvIHRvIHNjYWxlIG5vZGVzIGJ5IC0gYSBsYXJnZXIgcmF0aW8gd2lsbCBsZWFkIHRvIG1vcmUgc3BhY2UgYXJvdW5kIGxhcmdlciBub2Rlc1xuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIG5vZGVNYXJnaW4gICAgICAgICAgQSBmaXhlZCBtYXJnaW4gdG8gYXBwbHkgYXJvdW5kIG5vZGVzIHJlZ2FyZGxlc3Mgb2Ygc2l6ZVxuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIG1heEl0ZXJhdGlvbnMgICAgICAgVGhlIG1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcGVyZm9ybSBiZWZvcmUgdGhlIGxheW91dCBjb21wbGV0ZXMuXG4gICAqICAgez9pbnRlZ2VyfSAgICAgICAgICAgZ3JpZFNpemUgICAgICAgICAgICBUaGUgbnVtYmVyIG9mIHJvd3MgYW5kIGNvbHVtbnMgdG8gdXNlIHdoZW4gcGFydGlvbmluZyBub2RlcyBpbnRvIGEgZ3JpZCBmb3IgZWZmaWNpZW50IGNvbXB1dGF0aW9uXG4gICAqICAgez9udW1iZXJ9ICAgICAgICAgICAgcGVybWl0dGVkRXhwYW5zaW9uICBBIHBlcm1pdHRlZCBleHBhbnNpb24gZmFjdG9yIHRvIHRoZSBvdmVyYWxsIHNpemUgb2YgdGhlIG5ldHdvcmsgYXBwbGllZCBhdCBlYWNoIGl0ZXJhdGlvblxuICAgKiAgIHs/aW50ZWdlcn0gICAgICAgICAgIHJlbmRlcmVySW5kZXggICAgICAgVGhlIGluZGV4IG9mIHRoZSByZW5kZXJlciB0byB1c2UgZm9yIG5vZGUgY28tb3JkaW5hdGVzLiBEZWZhdWx0cyB0byB6ZXJvLlxuICAgKiAgIHs/KGZ1bmN0aW9ufHN0cmluZyl9IGVhc2luZyAgICAgICAgICAgICAgRWl0aGVyIHRoZSBuYW1lIG9mIGFuIGVhc2luZyBpbiB0aGUgc2lnbWEudXRpbHMuZWFzaW5ncyBwYWNrYWdlIG9yIGEgZnVuY3Rpb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVhZHJhdGljSW5PdXQgZWFzaW5nIGZyb20gdGhpcyBwYWNrYWdlIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIGR1cmF0aW9uICAgICAgICAgICAgVGhlIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBcImFuaW1hdGlvbnNUaW1lXCIgc2V0dGluZyB2YWx1ZSBvZiB0aGUgc2lnbWEgaW5zdGFuY2Ugd2lsbCBiZSB1c2VkIGluc3RlYWQuXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gY29uZmlnICBUaGUgb3B0aW9uYWwgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4ge3NpZ21hLmNsYXNzZXMuZGlzcGF0Y2hlcn0gUmV0dXJucyBhbiBldmVudCBlbWl0dGVyLlxuICAgKi9cbiAgc2lnbWEucHJvdG90eXBlLmNvbmZpZ05vdmVybGFwID0gZnVuY3Rpb24oY29uZmlnKSB7XG5cbiAgICB2YXIgc2lnSW5zdCA9IHRoaXM7XG5cbiAgICBpZiAoIWNvbmZpZykgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGFyZ3VtZW50OiBcImNvbmZpZ1wiJyk7XG5cbiAgICAvLyBDcmVhdGUgaW5zdGFuY2UgaWYgdW5kZWZpbmVkXG4gICAgaWYgKCFfaW5zdGFuY2Vbc2lnSW5zdC5pZF0pIHtcbiAgICAgIF9pbnN0YW5jZVtzaWdJbnN0LmlkXSA9IG5ldyBOb3ZlcmxhcCgpO1xuXG4gICAgICBfZXZlbnRFbWl0dGVyW3NpZ0luc3QuaWRdID0ge307XG4gICAgICBzaWdtYS5jbGFzc2VzLmRpc3BhdGNoZXIuZXh0ZW5kKF9ldmVudEVtaXR0ZXJbc2lnSW5zdC5pZF0pO1xuXG4gICAgICAvLyBCaW5kaW5nIG9uIGtpbGwgdG8gY2xlYXIgdGhlIHJlZmVyZW5jZXNcbiAgICAgIHNpZ0luc3QuYmluZCgna2lsbCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBfaW5zdGFuY2Vbc2lnSW5zdC5pZF0ua2lsbCgpO1xuICAgICAgICBfaW5zdGFuY2Vbc2lnSW5zdC5pZF0gPSBudWxsO1xuICAgICAgICBfZXZlbnRFbWl0dGVyW3NpZ0luc3QuaWRdID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIF9pbnN0YW5jZVtzaWdJbnN0LmlkXS5pbml0KHNpZ0luc3QsIGNvbmZpZyk7XG5cbiAgICByZXR1cm4gX2V2ZW50RW1pdHRlcltzaWdJbnN0LmlkXTtcbiAgfTtcblxuICAvKipcbiAgICogU3RhcnQgdGhlIGxheW91dCBhbGdvcml0aG0uIEl0IHdpbGwgdXNlIHRoZSBleGlzdGluZyBjb25maWd1cmF0aW9uIGlmIG5vXG4gICAqIG5ldyBjb25maWd1cmF0aW9uIGlzIHBhc3NlZC5cblxuICAgKiBSZWNvZ25pemVkIG9wdGlvbnM6XG4gICAqICoqKioqKioqKioqKioqKioqKioqKipcbiAgICogSGVyZSBpcyB0aGUgZXhoYXVzdGl2ZSBsaXN0IG9mIGV2ZXJ5IGFjY2VwdGVkIHBhcmFtZXRlciBpbiB0aGUgc2V0dGluZ3NcbiAgICogb2JqZWN0XG4gICAqXG4gICAqICAgez9udW1iZXJ9ICAgICAgICAgICAgc3BlZWQgICAgICAgICAgICAgICBBIGxhcmdlciB2YWx1ZSBpbmNyZWFzZXMgdGhlIGNvbnZlcmdlbmNlIHNwZWVkIGF0IHRoZSBjb3N0IG9mIHByZWNpc2lvblxuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIHNjYWxlTm9kZXMgICAgICAgICAgVGhlIHJhdGlvIHRvIHNjYWxlIG5vZGVzIGJ5IC0gYSBsYXJnZXIgcmF0aW8gd2lsbCBsZWFkIHRvIG1vcmUgc3BhY2UgYXJvdW5kIGxhcmdlciBub2Rlc1xuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIG5vZGVNYXJnaW4gICAgICAgICAgQSBmaXhlZCBtYXJnaW4gdG8gYXBwbHkgYXJvdW5kIG5vZGVzIHJlZ2FyZGxlc3Mgb2Ygc2l6ZVxuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIG1heEl0ZXJhdGlvbnMgICAgICAgVGhlIG1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcGVyZm9ybSBiZWZvcmUgdGhlIGxheW91dCBjb21wbGV0ZXMuXG4gICAqICAgez9pbnRlZ2VyfSAgICAgICAgICAgZ3JpZFNpemUgICAgICAgICAgICBUaGUgbnVtYmVyIG9mIHJvd3MgYW5kIGNvbHVtbnMgdG8gdXNlIHdoZW4gcGFydGlvbmluZyBub2RlcyBpbnRvIGEgZ3JpZCBmb3IgZWZmaWNpZW50IGNvbXB1dGF0aW9uXG4gICAqICAgez9udW1iZXJ9ICAgICAgICAgICAgcGVybWl0dGVkRXhwYW5zaW9uICBBIHBlcm1pdHRlZCBleHBhbnNpb24gZmFjdG9yIHRvIHRoZSBvdmVyYWxsIHNpemUgb2YgdGhlIG5ldHdvcmsgYXBwbGllZCBhdCBlYWNoIGl0ZXJhdGlvblxuICAgKiAgIHs/aW50ZWdlcn0gICAgICAgICAgIHJlbmRlcmVySW5kZXggICAgICAgVGhlIGluZGV4IG9mIHRoZSByZW5kZXJlciB0byB1c2UgZm9yIG5vZGUgY28tb3JkaW5hdGVzLiBEZWZhdWx0cyB0byB6ZXJvLlxuICAgKiAgIHs/KGZ1bmN0aW9ufHN0cmluZyl9IGVhc2luZyAgICAgICAgICAgICAgRWl0aGVyIHRoZSBuYW1lIG9mIGFuIGVhc2luZyBpbiB0aGUgc2lnbWEudXRpbHMuZWFzaW5ncyBwYWNrYWdlIG9yIGEgZnVuY3Rpb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVhZHJhdGljSW5PdXQgZWFzaW5nIGZyb20gdGhpcyBwYWNrYWdlIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIGR1cmF0aW9uICAgICAgICAgICAgVGhlIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBcImFuaW1hdGlvbnNUaW1lXCIgc2V0dGluZyB2YWx1ZSBvZiB0aGUgc2lnbWEgaW5zdGFuY2Ugd2lsbCBiZSB1c2VkIGluc3RlYWQuXG4gICAqXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gY29uZmlnICBUaGUgb3B0aW9uYWwgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4ge3NpZ21hLmNsYXNzZXMuZGlzcGF0Y2hlcn0gUmV0dXJucyBhbiBldmVudCBlbWl0dGVyLlxuICAgKi9cblxuICBzaWdtYS5wcm90b3R5cGUuc3RhcnROb3ZlcmxhcCA9IGZ1bmN0aW9uKGNvbmZpZykge1xuXG4gICAgdmFyIHNpZ0luc3QgPSB0aGlzO1xuXG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgdGhpcy5jb25maWdOb3ZlcmxhcChzaWdJbnN0LCBjb25maWcpO1xuICAgIH1cblxuICAgIF9pbnN0YW5jZVtzaWdJbnN0LmlkXS5zdGFydCgpO1xuXG4gICAgcmV0dXJuIF9ldmVudEVtaXR0ZXJbc2lnSW5zdC5pZF07XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgbGF5b3V0IGhhcyBzdGFydGVkIGFuZCBpcyBub3QgY29tcGxldGVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc2lnbWEucHJvdG90eXBlLmlzTm92ZXJsYXBSdW5uaW5nID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgc2lnSW5zdCA9IHRoaXM7XG5cbiAgICByZXR1cm4gISFfaW5zdGFuY2Vbc2lnSW5zdC5pZF0gJiYgX2luc3RhbmNlW3NpZ0luc3QuaWRdLnJ1bm5pbmc7XG4gIH07XG5cbn0pLmNhbGwodGhpcyk7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/sigma/plugins/sigma.layout.noverlap/sigma.layout.noverlap.js\n");

/***/ }),

/***/ "./node_modules/sigma/plugins/sigma.plugins.animate/sigma.plugins.animate.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sigma/plugins/sigma.plugins.animate/sigma.plugins.animate.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * This plugin provides a method to animate a sigma instance by interpolating\n * some node properties. Check the sigma.plugins.animate function doc or the\n * examples/animate.html code sample to know more.\n */\n(function() {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  sigma.utils.pkg('sigma.plugins');\n\n  var _id = 0,\n      _cache = {};\n\n  // TOOLING FUNCTIONS:\n  // ******************\n  function parseColor(val) {\n    if (_cache[val])\n      return _cache[val];\n\n    var result = [0, 0, 0];\n\n    if (val.match(/^#/)) {\n      val = (val || '').replace(/^#/, '');\n      result = (val.length === 3) ?\n        [\n          parseInt(val.charAt(0) + val.charAt(0), 16),\n          parseInt(val.charAt(1) + val.charAt(1), 16),\n          parseInt(val.charAt(2) + val.charAt(2), 16)\n        ] :\n        [\n          parseInt(val.charAt(0) + val.charAt(1), 16),\n          parseInt(val.charAt(2) + val.charAt(3), 16),\n          parseInt(val.charAt(4) + val.charAt(5), 16)\n        ];\n    } else if (val.match(/^ *rgba? *\\(/)) {\n      val = val.match(\n        /^ *rgba? *\\( *([0-9]*) *, *([0-9]*) *, *([0-9]*) *(,.*)?\\) *$/\n      );\n      result = [\n        +val[1],\n        +val[2],\n        +val[3]\n      ];\n    }\n\n    _cache[val] = {\n      r: result[0],\n      g: result[1],\n      b: result[2]\n    };\n\n    return _cache[val];\n  }\n\n  function interpolateColors(c1, c2, p) {\n    c1 = parseColor(c1);\n    c2 = parseColor(c2);\n\n    var c = {\n      r: c1.r * (1 - p) + c2.r * p,\n      g: c1.g * (1 - p) + c2.g * p,\n      b: c1.b * (1 - p) + c2.b * p\n    };\n\n    return 'rgb(' + [c.r | 0, c.g | 0, c.b | 0].join(',') + ')';\n  }\n\n  /**\n   * This function will animate some specified node properties. It will\n   * basically call requestAnimationFrame, interpolate the values and call the\n   * refresh method during a specified duration.\n   *\n   * Recognized parameters:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters in the settings\n   * object:\n   *\n   *   {?array}             nodes      An array of node objects or node ids. If\n   *                                   not specified, all nodes of the graph\n   *                                   will be animated.\n   *   {?(function|string)} easing     Either the name of an easing in the\n   *                                   sigma.utils.easings package or a\n   *                                   function. If not specified, the\n   *                                   quadraticInOut easing from this package\n   *                                   will be used instead.\n   *   {?number}            duration   The duration of the animation. If not\n   *                                   specified, the \"animationsTime\" setting\n   *                                   value of the sigma instance will be used\n   *                                   instead.\n   *   {?function}          onComplete Eventually a function to call when the\n   *                                   animation is ended.\n   *\n   * @param  {sigma}   s       The related sigma instance.\n   * @param  {object}  animate An hash with the keys being the node properties\n   *                           to interpolate, and the values being the related\n   *                           target values.\n   * @param  {?object} options Eventually an object with options.\n   */\n  sigma.plugins.animate = function(s, animate, options) {\n    var o = options || {},\n        id = ++_id,\n        duration = o.duration || s.settings('animationsTime'),\n        easing = typeof o.easing === 'string' ?\n          sigma.utils.easings[o.easing] :\n          typeof o.easing === 'function' ?\n          o.easing :\n          sigma.utils.easings.quadraticInOut,\n        start = sigma.utils.dateNow(),\n        nodes,\n        startPositions;\n\n    if (o.nodes && o.nodes.length) {\n      if (typeof o.nodes[0] === 'object')\n        nodes = o.nodes;\n      else\n        nodes = s.graph.nodes(o.nodes); // argument is an array of IDs\n    }\n    else\n      nodes = s.graph.nodes();\n\n    // Store initial positions:\n    startPositions = nodes.reduce(function(res, node) {\n      var k;\n      res[node.id] = {};\n      for (k in animate)\n        if (k in node)\n          res[node.id][k] = node[k];\n      return res;\n    }, {});\n\n    s.animations = s.animations || Object.create({});\n    sigma.plugins.kill(s);\n\n    // Do not refresh edgequadtree during drag:\n    var k,\n        c;\n    for (k in s.cameras) {\n      c = s.cameras[k];\n      c.edgequadtree._enabled = false;\n    }\n\n    function step() {\n      var p = (sigma.utils.dateNow() - start) / duration;\n\n      if (p >= 1) {\n        nodes.forEach(function(node) {\n          for (var k in animate)\n            if (k in animate)\n              node[k] = node[animate[k]];\n        });\n\n        // Allow to refresh edgequadtree:\n        var k,\n            c;\n        for (k in s.cameras) {\n          c = s.cameras[k];\n          c.edgequadtree._enabled = true;\n        }\n\n        s.refresh();\n        if (typeof o.onComplete === 'function')\n          o.onComplete();\n      } else {\n        p = easing(p);\n        nodes.forEach(function(node) {\n          for (var k in animate)\n            if (k in animate) {\n              if (k.match(/color$/))\n                node[k] = interpolateColors(\n                  startPositions[node.id][k],\n                  node[animate[k]],\n                  p\n                );\n              else\n                node[k] =\n                  node[animate[k]] * p +\n                  startPositions[node.id][k] * (1 - p);\n            }\n        });\n\n        s.refresh();\n        s.animations[id] = requestAnimationFrame(step);\n      }\n    }\n\n    step();\n  };\n\n  sigma.plugins.kill = function(s) {\n    for (var k in (s.animations || {}))\n      cancelAnimationFrame(s.animations[k]);\n\n    // Allow to refresh edgequadtree:\n    var k,\n        c;\n    for (k in s.cameras) {\n      c = s.cameras[k];\n      c.edgequadtree._enabled = true;\n    }\n  };\n}).call(window);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2lnbWEvcGx1Z2lucy9zaWdtYS5wbHVnaW5zLmFuaW1hdGUvc2lnbWEucGx1Z2lucy5hbmltYXRlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NpZ21hL3BsdWdpbnMvc2lnbWEucGx1Z2lucy5hbmltYXRlL3NpZ21hLnBsdWdpbnMuYW5pbWF0ZS5qcz9jNDI5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhpcyBwbHVnaW4gcHJvdmlkZXMgYSBtZXRob2QgdG8gYW5pbWF0ZSBhIHNpZ21hIGluc3RhbmNlIGJ5IGludGVycG9sYXRpbmdcbiAqIHNvbWUgbm9kZSBwcm9wZXJ0aWVzLiBDaGVjayB0aGUgc2lnbWEucGx1Z2lucy5hbmltYXRlIGZ1bmN0aW9uIGRvYyBvciB0aGVcbiAqIGV4YW1wbGVzL2FuaW1hdGUuaHRtbCBjb2RlIHNhbXBsZSB0byBrbm93IG1vcmUuXG4gKi9cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEucGx1Z2lucycpO1xuXG4gIHZhciBfaWQgPSAwLFxuICAgICAgX2NhY2hlID0ge307XG5cbiAgLy8gVE9PTElORyBGVU5DVElPTlM6XG4gIC8vICoqKioqKioqKioqKioqKioqKlxuICBmdW5jdGlvbiBwYXJzZUNvbG9yKHZhbCkge1xuICAgIGlmIChfY2FjaGVbdmFsXSlcbiAgICAgIHJldHVybiBfY2FjaGVbdmFsXTtcblxuICAgIHZhciByZXN1bHQgPSBbMCwgMCwgMF07XG5cbiAgICBpZiAodmFsLm1hdGNoKC9eIy8pKSB7XG4gICAgICB2YWwgPSAodmFsIHx8ICcnKS5yZXBsYWNlKC9eIy8sICcnKTtcbiAgICAgIHJlc3VsdCA9ICh2YWwubGVuZ3RoID09PSAzKSA/XG4gICAgICAgIFtcbiAgICAgICAgICBwYXJzZUludCh2YWwuY2hhckF0KDApICsgdmFsLmNoYXJBdCgwKSwgMTYpLFxuICAgICAgICAgIHBhcnNlSW50KHZhbC5jaGFyQXQoMSkgKyB2YWwuY2hhckF0KDEpLCAxNiksXG4gICAgICAgICAgcGFyc2VJbnQodmFsLmNoYXJBdCgyKSArIHZhbC5jaGFyQXQoMiksIDE2KVxuICAgICAgICBdIDpcbiAgICAgICAgW1xuICAgICAgICAgIHBhcnNlSW50KHZhbC5jaGFyQXQoMCkgKyB2YWwuY2hhckF0KDEpLCAxNiksXG4gICAgICAgICAgcGFyc2VJbnQodmFsLmNoYXJBdCgyKSArIHZhbC5jaGFyQXQoMyksIDE2KSxcbiAgICAgICAgICBwYXJzZUludCh2YWwuY2hhckF0KDQpICsgdmFsLmNoYXJBdCg1KSwgMTYpXG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmICh2YWwubWF0Y2goL14gKnJnYmE/ICpcXCgvKSkge1xuICAgICAgdmFsID0gdmFsLm1hdGNoKFxuICAgICAgICAvXiAqcmdiYT8gKlxcKCAqKFswLTldKikgKiwgKihbMC05XSopICosICooWzAtOV0qKSAqKCwuKik/XFwpICokL1xuICAgICAgKTtcbiAgICAgIHJlc3VsdCA9IFtcbiAgICAgICAgK3ZhbFsxXSxcbiAgICAgICAgK3ZhbFsyXSxcbiAgICAgICAgK3ZhbFszXVxuICAgICAgXTtcbiAgICB9XG5cbiAgICBfY2FjaGVbdmFsXSA9IHtcbiAgICAgIHI6IHJlc3VsdFswXSxcbiAgICAgIGc6IHJlc3VsdFsxXSxcbiAgICAgIGI6IHJlc3VsdFsyXVxuICAgIH07XG5cbiAgICByZXR1cm4gX2NhY2hlW3ZhbF07XG4gIH1cblxuICBmdW5jdGlvbiBpbnRlcnBvbGF0ZUNvbG9ycyhjMSwgYzIsIHApIHtcbiAgICBjMSA9IHBhcnNlQ29sb3IoYzEpO1xuICAgIGMyID0gcGFyc2VDb2xvcihjMik7XG5cbiAgICB2YXIgYyA9IHtcbiAgICAgIHI6IGMxLnIgKiAoMSAtIHApICsgYzIuciAqIHAsXG4gICAgICBnOiBjMS5nICogKDEgLSBwKSArIGMyLmcgKiBwLFxuICAgICAgYjogYzEuYiAqICgxIC0gcCkgKyBjMi5iICogcFxuICAgIH07XG5cbiAgICByZXR1cm4gJ3JnYignICsgW2MuciB8IDAsIGMuZyB8IDAsIGMuYiB8IDBdLmpvaW4oJywnKSArICcpJztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYW5pbWF0ZSBzb21lIHNwZWNpZmllZCBub2RlIHByb3BlcnRpZXMuIEl0IHdpbGxcbiAgICogYmFzaWNhbGx5IGNhbGwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBpbnRlcnBvbGF0ZSB0aGUgdmFsdWVzIGFuZCBjYWxsIHRoZVxuICAgKiByZWZyZXNoIG1ldGhvZCBkdXJpbmcgYSBzcGVjaWZpZWQgZHVyYXRpb24uXG4gICAqXG4gICAqIFJlY29nbml6ZWQgcGFyYW1ldGVyczpcbiAgICogKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBIZXJlIGlzIHRoZSBleGhhdXN0aXZlIGxpc3Qgb2YgZXZlcnkgYWNjZXB0ZWQgcGFyYW1ldGVycyBpbiB0aGUgc2V0dGluZ3NcbiAgICogb2JqZWN0OlxuICAgKlxuICAgKiAgIHs/YXJyYXl9ICAgICAgICAgICAgIG5vZGVzICAgICAgQW4gYXJyYXkgb2Ygbm9kZSBvYmplY3RzIG9yIG5vZGUgaWRzLiBJZlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90IHNwZWNpZmllZCwgYWxsIG5vZGVzIG9mIHRoZSBncmFwaFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBiZSBhbmltYXRlZC5cbiAgICogICB7PyhmdW5jdGlvbnxzdHJpbmcpfSBlYXNpbmcgICAgIEVpdGhlciB0aGUgbmFtZSBvZiBhbiBlYXNpbmcgaW4gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWdtYS51dGlscy5lYXNpbmdzIHBhY2thZ2Ugb3IgYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVhZHJhdGljSW5PdXQgZWFzaW5nIGZyb20gdGhpcyBwYWNrYWdlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cbiAgICogICB7P251bWJlcn0gICAgICAgICAgICBkdXJhdGlvbiAgIFRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uLiBJZiBub3RcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpZmllZCwgdGhlIFwiYW5pbWF0aW9uc1RpbWVcIiBzZXR0aW5nXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSBvZiB0aGUgc2lnbWEgaW5zdGFuY2Ugd2lsbCBiZSB1c2VkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0ZWFkLlxuICAgKiAgIHs/ZnVuY3Rpb259ICAgICAgICAgIG9uQ29tcGxldGUgRXZlbnR1YWxseSBhIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbiBpcyBlbmRlZC5cbiAgICpcbiAgICogQHBhcmFtICB7c2lnbWF9ICAgcyAgICAgICBUaGUgcmVsYXRlZCBzaWdtYSBpbnN0YW5jZS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgYW5pbWF0ZSBBbiBoYXNoIHdpdGggdGhlIGtleXMgYmVpbmcgdGhlIG5vZGUgcHJvcGVydGllc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGludGVycG9sYXRlLCBhbmQgdGhlIHZhbHVlcyBiZWluZyB0aGUgcmVsYXRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCB2YWx1ZXMuXG4gICAqIEBwYXJhbSAgez9vYmplY3R9IG9wdGlvbnMgRXZlbnR1YWxseSBhbiBvYmplY3Qgd2l0aCBvcHRpb25zLlxuICAgKi9cbiAgc2lnbWEucGx1Z2lucy5hbmltYXRlID0gZnVuY3Rpb24ocywgYW5pbWF0ZSwgb3B0aW9ucykge1xuICAgIHZhciBvID0gb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgaWQgPSArK19pZCxcbiAgICAgICAgZHVyYXRpb24gPSBvLmR1cmF0aW9uIHx8IHMuc2V0dGluZ3MoJ2FuaW1hdGlvbnNUaW1lJyksXG4gICAgICAgIGVhc2luZyA9IHR5cGVvZiBvLmVhc2luZyA9PT0gJ3N0cmluZycgP1xuICAgICAgICAgIHNpZ21hLnV0aWxzLmVhc2luZ3Nbby5lYXNpbmddIDpcbiAgICAgICAgICB0eXBlb2Ygby5lYXNpbmcgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICAgIG8uZWFzaW5nIDpcbiAgICAgICAgICBzaWdtYS51dGlscy5lYXNpbmdzLnF1YWRyYXRpY0luT3V0LFxuICAgICAgICBzdGFydCA9IHNpZ21hLnV0aWxzLmRhdGVOb3coKSxcbiAgICAgICAgbm9kZXMsXG4gICAgICAgIHN0YXJ0UG9zaXRpb25zO1xuXG4gICAgaWYgKG8ubm9kZXMgJiYgby5ub2Rlcy5sZW5ndGgpIHtcbiAgICAgIGlmICh0eXBlb2Ygby5ub2Rlc1swXSA9PT0gJ29iamVjdCcpXG4gICAgICAgIG5vZGVzID0gby5ub2RlcztcbiAgICAgIGVsc2VcbiAgICAgICAgbm9kZXMgPSBzLmdyYXBoLm5vZGVzKG8ubm9kZXMpOyAvLyBhcmd1bWVudCBpcyBhbiBhcnJheSBvZiBJRHNcbiAgICB9XG4gICAgZWxzZVxuICAgICAgbm9kZXMgPSBzLmdyYXBoLm5vZGVzKCk7XG5cbiAgICAvLyBTdG9yZSBpbml0aWFsIHBvc2l0aW9uczpcbiAgICBzdGFydFBvc2l0aW9ucyA9IG5vZGVzLnJlZHVjZShmdW5jdGlvbihyZXMsIG5vZGUpIHtcbiAgICAgIHZhciBrO1xuICAgICAgcmVzW25vZGUuaWRdID0ge307XG4gICAgICBmb3IgKGsgaW4gYW5pbWF0ZSlcbiAgICAgICAgaWYgKGsgaW4gbm9kZSlcbiAgICAgICAgICByZXNbbm9kZS5pZF1ba10gPSBub2RlW2tdO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9LCB7fSk7XG5cbiAgICBzLmFuaW1hdGlvbnMgPSBzLmFuaW1hdGlvbnMgfHwgT2JqZWN0LmNyZWF0ZSh7fSk7XG4gICAgc2lnbWEucGx1Z2lucy5raWxsKHMpO1xuXG4gICAgLy8gRG8gbm90IHJlZnJlc2ggZWRnZXF1YWR0cmVlIGR1cmluZyBkcmFnOlxuICAgIHZhciBrLFxuICAgICAgICBjO1xuICAgIGZvciAoayBpbiBzLmNhbWVyYXMpIHtcbiAgICAgIGMgPSBzLmNhbWVyYXNba107XG4gICAgICBjLmVkZ2VxdWFkdHJlZS5fZW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0ZXAoKSB7XG4gICAgICB2YXIgcCA9IChzaWdtYS51dGlscy5kYXRlTm93KCkgLSBzdGFydCkgLyBkdXJhdGlvbjtcblxuICAgICAgaWYgKHAgPj0gMSkge1xuICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICBmb3IgKHZhciBrIGluIGFuaW1hdGUpXG4gICAgICAgICAgICBpZiAoayBpbiBhbmltYXRlKVxuICAgICAgICAgICAgICBub2RlW2tdID0gbm9kZVthbmltYXRlW2tdXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQWxsb3cgdG8gcmVmcmVzaCBlZGdlcXVhZHRyZWU6XG4gICAgICAgIHZhciBrLFxuICAgICAgICAgICAgYztcbiAgICAgICAgZm9yIChrIGluIHMuY2FtZXJhcykge1xuICAgICAgICAgIGMgPSBzLmNhbWVyYXNba107XG4gICAgICAgICAgYy5lZGdlcXVhZHRyZWUuX2VuYWJsZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcy5yZWZyZXNoKCk7XG4gICAgICAgIGlmICh0eXBlb2Ygby5vbkNvbXBsZXRlID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgIG8ub25Db21wbGV0ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcCA9IGVhc2luZyhwKTtcbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgZm9yICh2YXIgayBpbiBhbmltYXRlKVxuICAgICAgICAgICAgaWYgKGsgaW4gYW5pbWF0ZSkge1xuICAgICAgICAgICAgICBpZiAoay5tYXRjaCgvY29sb3IkLykpXG4gICAgICAgICAgICAgICAgbm9kZVtrXSA9IGludGVycG9sYXRlQ29sb3JzKFxuICAgICAgICAgICAgICAgICAgc3RhcnRQb3NpdGlvbnNbbm9kZS5pZF1ba10sXG4gICAgICAgICAgICAgICAgICBub2RlW2FuaW1hdGVba11dLFxuICAgICAgICAgICAgICAgICAgcFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBub2RlW2tdID1cbiAgICAgICAgICAgICAgICAgIG5vZGVbYW5pbWF0ZVtrXV0gKiBwICtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0UG9zaXRpb25zW25vZGUuaWRdW2tdICogKDEgLSBwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcy5yZWZyZXNoKCk7XG4gICAgICAgIHMuYW5pbWF0aW9uc1tpZF0gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RlcCgpO1xuICB9O1xuXG4gIHNpZ21hLnBsdWdpbnMua2lsbCA9IGZ1bmN0aW9uKHMpIHtcbiAgICBmb3IgKHZhciBrIGluIChzLmFuaW1hdGlvbnMgfHwge30pKVxuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocy5hbmltYXRpb25zW2tdKTtcblxuICAgIC8vIEFsbG93IHRvIHJlZnJlc2ggZWRnZXF1YWR0cmVlOlxuICAgIHZhciBrLFxuICAgICAgICBjO1xuICAgIGZvciAoayBpbiBzLmNhbWVyYXMpIHtcbiAgICAgIGMgPSBzLmNhbWVyYXNba107XG4gICAgICBjLmVkZ2VxdWFkdHJlZS5fZW5hYmxlZCA9IHRydWU7XG4gICAgfVxuICB9O1xufSkuY2FsbCh3aW5kb3cpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/sigma/plugins/sigma.plugins.animate/sigma.plugins.animate.js\n");

/***/ }),

/***/ "./node_modules/sigma/plugins/sigma.plugins.dragNodes/sigma.plugins.dragNodes.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/sigma/plugins/sigma.plugins.dragNodes/sigma.plugins.dragNodes.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * This plugin provides a method to drag & drop nodes. Check the\n * sigma.plugins.dragNodes function doc or the examples/basic.html &\n * examples/api-candy.html code samples to know more.\n */\n(function() {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  sigma.utils.pkg('sigma.plugins');\n\n\n  /**\n   * This function will add `mousedown`, `mouseup` & `mousemove` events to the\n   * nodes in the `overNode`event to perform drag & drop operations. It uses\n   * `linear interpolation` [http://en.wikipedia.org/wiki/Linear_interpolation]\n   * and `rotation matrix` [http://en.wikipedia.org/wiki/Rotation_matrix] to\n   * calculate the X and Y coordinates from the `cam` or `renderer` node\n   * attributes. These attributes represent the coordinates of the nodes in\n   * the real container, not in canvas.\n   *\n   * Fired events:\n   * *************\n   * startdrag  Fired at the beginning of the drag.\n   * drag       Fired while the node is dragged.\n   * drop       Fired at the end of the drag if the node has been dragged.\n   * dragend    Fired at the end of the drag.\n   *\n   * Recognized parameters:\n   * **********************\n   * @param  {sigma}    s        The related sigma instance.\n   * @param  {renderer} renderer The related renderer instance.\n   */\n  function DragNodes(s, renderer) {\n    sigma.classes.dispatcher.extend(this);\n\n    // A quick hardcoded rule to prevent people from using this plugin with the\n    // WebGL renderer (which is impossible at the moment):\n    // if (\n    //   sigma.renderers.webgl &&\n    //   renderer instanceof sigma.renderers.webgl\n    // )\n    //   throw new Error(\n    //     'The sigma.plugins.dragNodes is not compatible with the WebGL renderer'\n    //   );\n\n    // Init variables:\n    var _self = this,\n      _s = s,\n      _body = document.body,\n      _renderer = renderer,\n      _mouse = renderer.container.lastChild,\n      _camera = renderer.camera,\n      _node = null,\n      _prefix = '',\n      _hoverStack = [],\n      _hoverIndex = {},\n      _isMouseDown = false,\n      _isMouseOverCanvas = false,\n      _drag = false;\n\n    if (renderer instanceof sigma.renderers.svg) {\n        _mouse = renderer.container.firstChild;\n    }\n\n    // It removes the initial substring ('read_') if it's a WegGL renderer.\n    if (renderer instanceof sigma.renderers.webgl) {\n      _prefix = renderer.options.prefix.substr(5);\n    } else {\n      _prefix = renderer.options.prefix;\n    }\n\n    renderer.bind('overNode', nodeMouseOver);\n    renderer.bind('outNode', treatOutNode);\n    renderer.bind('click', click);\n\n    _s.bind('kill', function() {\n      _self.unbindAll();\n    });\n\n    /**\n     * Unbind all event listeners.\n     */\n    this.unbindAll = function() {\n      _mouse.removeEventListener('mousedown', nodeMouseDown);\n      _body.removeEventListener('mousemove', nodeMouseMove);\n      _body.removeEventListener('mouseup', nodeMouseUp);\n      _renderer.unbind('overNode', nodeMouseOver);\n      _renderer.unbind('outNode', treatOutNode);\n    }\n\n    // Calculates the global offset of the given element more accurately than\n    // element.offsetTop and element.offsetLeft.\n    function calculateOffset(element) {\n      var style = window.getComputedStyle(element);\n      var getCssProperty = function(prop) {\n        return parseInt(style.getPropertyValue(prop).replace('px', '')) || 0;\n      };\n      return {\n        left: element.getBoundingClientRect().left + getCssProperty('padding-left'),\n        top: element.getBoundingClientRect().top + getCssProperty('padding-top')\n      };\n    };\n\n    function click(event) {\n      // event triggered at the end of the click\n      _isMouseDown = false;\n      _body.removeEventListener('mousemove', nodeMouseMove);\n      _body.removeEventListener('mouseup', nodeMouseUp);\n\n      if (!_hoverStack.length) {\n        _node = null;\n      }\n    };\n\n    function nodeMouseOver(event) {\n      // Don't treat the node if it is already registered\n      if (_hoverIndex[event.data.node.id]) {\n        return;\n      }\n\n      // Add node to array of current nodes over\n      _hoverStack.push(event.data.node);\n      _hoverIndex[event.data.node.id] = true;\n\n      if(_hoverStack.length && ! _isMouseDown) {\n        // Set the current node to be the last one in the array\n        _node = _hoverStack[_hoverStack.length - 1];\n        _mouse.addEventListener('mousedown', nodeMouseDown);\n      }\n    };\n\n    function treatOutNode(event) {\n      // Remove the node from the array\n      var indexCheck = _hoverStack.map(function(e) { return e; }).indexOf(event.data.node);\n      _hoverStack.splice(indexCheck, 1);\n      delete _hoverIndex[event.data.node.id];\n\n      if(_hoverStack.length && ! _isMouseDown) {\n        // On out, set the current node to be the next stated in array\n        _node = _hoverStack[_hoverStack.length - 1];\n      } else {\n        _mouse.removeEventListener('mousedown', nodeMouseDown);\n      }\n    };\n\n    function nodeMouseDown(event) {\n      _isMouseDown = true;\n      var size = _s.graph.nodes().length;\n\n      // when there is only node in the graph, the plugin cannot apply\n      // linear interpolation. So treat it as if a user is dragging\n      // the graph\n      if (_node && size > 1) {\n        _mouse.removeEventListener('mousedown', nodeMouseDown);\n        _body.addEventListener('mousemove', nodeMouseMove);\n        _body.addEventListener('mouseup', nodeMouseUp);\n\n        // Do not refresh edgequadtree during drag:\n        var k,\n            c;\n        for (k in _s.cameras) {\n          c = _s.cameras[k];\n          if (c.edgequadtree !== undefined) {\n            c.edgequadtree._enabled = false;\n          }\n        }\n\n        // Deactivate drag graph.\n        _renderer.settings({mouseEnabled: false, enableHovering: false});\n        _s.refresh();\n\n        _self.dispatchEvent('startdrag', {\n          node: _node,\n          captor: event,\n          renderer: _renderer\n        });\n      }\n    };\n\n    function nodeMouseUp(event) {\n      _isMouseDown = false;\n      _mouse.addEventListener('mousedown', nodeMouseDown);\n      _body.removeEventListener('mousemove', nodeMouseMove);\n      _body.removeEventListener('mouseup', nodeMouseUp);\n\n      // Allow to refresh edgequadtree:\n      var k,\n          c;\n      for (k in _s.cameras) {\n        c = _s.cameras[k];\n        if (c.edgequadtree !== undefined) {\n          c.edgequadtree._enabled = true;\n        }\n      }\n\n      // Activate drag graph.\n      _renderer.settings({mouseEnabled: true, enableHovering: true});\n      _s.refresh();\n\n      if (_drag) {\n        _self.dispatchEvent('drop', {\n          node: _node,\n          captor: event,\n          renderer: _renderer\n        });\n      }\n      _self.dispatchEvent('dragend', {\n        node: _node,\n        captor: event,\n        renderer: _renderer\n      });\n\n      _drag = false;\n      _node = null;\n    };\n\n    function nodeMouseMove(event) {\n      if(navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {\n        clearTimeout(timeOut);\n        var timeOut = setTimeout(executeNodeMouseMove, 0);\n      } else {\n        executeNodeMouseMove();\n      }\n\n      function executeNodeMouseMove() {\n        var offset = calculateOffset(_renderer.container),\n            x = event.clientX - offset.left,\n            y = event.clientY - offset.top,\n            cos = Math.cos(_camera.angle),\n            sin = Math.sin(_camera.angle),\n            nodes = _s.graph.nodes(),\n            ref = [];\n\n        // Getting and derotating the reference coordinates.\n        for (var i = 0; i < 2; i++) {\n          var n = nodes[i];\n          var aux = {\n            x: n.x * cos + n.y * sin,\n            y: n.y * cos - n.x * sin,\n            renX: n[_prefix + 'x'],\n            renY: n[_prefix + 'y'],\n          };\n          ref.push(aux);\n        }\n\n        // Applying linear interpolation.\n        // if the nodes are on top of each other, we use the camera ratio to interpolate\n        if (ref[0].x === ref[1].x && ref[0].y === ref[1].y) {\n          var xRatio = (ref[0].renX === 0) ? 1 : ref[0].renX;\n          var yRatio = (ref[0].renY === 0) ? 1 : ref[0].renY;\n          x = (ref[0].x / xRatio) * (x - ref[0].renX) + ref[0].x;\n          y = (ref[0].y / yRatio) * (y - ref[0].renY) + ref[0].y;\n        } else {\n          var xRatio = (ref[1].renX - ref[0].renX) / (ref[1].x - ref[0].x);\n          var yRatio = (ref[1].renY - ref[0].renY) / (ref[1].y - ref[0].y);\n\n          // if the coordinates are the same, we use the other ratio to interpolate\n          if (ref[1].x === ref[0].x) {\n            xRatio = yRatio;\n          }\n\n          if (ref[1].y === ref[0].y) {\n            yRatio = xRatio;\n          }\n\n          x = (x - ref[0].renX) / xRatio + ref[0].x;\n          y = (y - ref[0].renY) / yRatio + ref[0].y;\n        }\n\n        // Rotating the coordinates.\n        _node.x = x * cos - y * sin;\n        _node.y = y * cos + x * sin;\n\n        _s.refresh();\n\n        _drag = true;\n        _self.dispatchEvent('drag', {\n          node: _node,\n          captor: event,\n          renderer: _renderer\n        });\n      }\n    };\n  };\n\n  /**\n   * Interface\n   * ------------------\n   *\n   * > var dragNodesListener = sigma.plugins.dragNodes(s, s.renderers[0]);\n   */\n  var _instance = {};\n\n  /**\n   * @param  {sigma} s The related sigma instance.\n   * @param  {renderer} renderer The related renderer instance.\n   */\n  sigma.plugins.dragNodes = function(s, renderer) {\n    // Create object if undefined\n    if (!_instance[s.id]) {\n      _instance[s.id] = new DragNodes(s, renderer);\n    }\n\n    s.bind('kill', function() {\n      sigma.plugins.killDragNodes(s);\n    });\n\n    return _instance[s.id];\n  };\n\n  /**\n   * This method removes the event listeners and kills the dragNodes instance.\n   *\n   * @param  {sigma} s The related sigma instance.\n   */\n  sigma.plugins.killDragNodes = function(s) {\n    if (_instance[s.id] instanceof DragNodes) {\n      _instance[s.id].unbindAll();\n      delete _instance[s.id];\n    }\n  };\n\n}).call(window);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2lnbWEvcGx1Z2lucy9zaWdtYS5wbHVnaW5zLmRyYWdOb2Rlcy9zaWdtYS5wbHVnaW5zLmRyYWdOb2Rlcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zaWdtYS9wbHVnaW5zL3NpZ21hLnBsdWdpbnMuZHJhZ05vZGVzL3NpZ21hLnBsdWdpbnMuZHJhZ05vZGVzLmpzPzgwM2UiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUaGlzIHBsdWdpbiBwcm92aWRlcyBhIG1ldGhvZCB0byBkcmFnICYgZHJvcCBub2Rlcy4gQ2hlY2sgdGhlXG4gKiBzaWdtYS5wbHVnaW5zLmRyYWdOb2RlcyBmdW5jdGlvbiBkb2Mgb3IgdGhlIGV4YW1wbGVzL2Jhc2ljLmh0bWwgJlxuICogZXhhbXBsZXMvYXBpLWNhbmR5Lmh0bWwgY29kZSBzYW1wbGVzIHRvIGtub3cgbW9yZS5cbiAqL1xuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5wbHVnaW5zJyk7XG5cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIGFkZCBgbW91c2Vkb3duYCwgYG1vdXNldXBgICYgYG1vdXNlbW92ZWAgZXZlbnRzIHRvIHRoZVxuICAgKiBub2RlcyBpbiB0aGUgYG92ZXJOb2RlYGV2ZW50IHRvIHBlcmZvcm0gZHJhZyAmIGRyb3Agb3BlcmF0aW9ucy4gSXQgdXNlc1xuICAgKiBgbGluZWFyIGludGVycG9sYXRpb25gIFtodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpbmVhcl9pbnRlcnBvbGF0aW9uXVxuICAgKiBhbmQgYHJvdGF0aW9uIG1hdHJpeGAgW2h0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUm90YXRpb25fbWF0cml4XSB0b1xuICAgKiBjYWxjdWxhdGUgdGhlIFggYW5kIFkgY29vcmRpbmF0ZXMgZnJvbSB0aGUgYGNhbWAgb3IgYHJlbmRlcmVyYCBub2RlXG4gICAqIGF0dHJpYnV0ZXMuIFRoZXNlIGF0dHJpYnV0ZXMgcmVwcmVzZW50IHRoZSBjb29yZGluYXRlcyBvZiB0aGUgbm9kZXMgaW5cbiAgICogdGhlIHJlYWwgY29udGFpbmVyLCBub3QgaW4gY2FudmFzLlxuICAgKlxuICAgKiBGaXJlZCBldmVudHM6XG4gICAqICoqKioqKioqKioqKipcbiAgICogc3RhcnRkcmFnICBGaXJlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkcmFnLlxuICAgKiBkcmFnICAgICAgIEZpcmVkIHdoaWxlIHRoZSBub2RlIGlzIGRyYWdnZWQuXG4gICAqIGRyb3AgICAgICAgRmlyZWQgYXQgdGhlIGVuZCBvZiB0aGUgZHJhZyBpZiB0aGUgbm9kZSBoYXMgYmVlbiBkcmFnZ2VkLlxuICAgKiBkcmFnZW5kICAgIEZpcmVkIGF0IHRoZSBlbmQgb2YgdGhlIGRyYWcuXG4gICAqXG4gICAqIFJlY29nbml6ZWQgcGFyYW1ldGVyczpcbiAgICogKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBAcGFyYW0gIHtzaWdtYX0gICAgcyAgICAgICAgVGhlIHJlbGF0ZWQgc2lnbWEgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSAge3JlbmRlcmVyfSByZW5kZXJlciBUaGUgcmVsYXRlZCByZW5kZXJlciBpbnN0YW5jZS5cbiAgICovXG4gIGZ1bmN0aW9uIERyYWdOb2RlcyhzLCByZW5kZXJlcikge1xuICAgIHNpZ21hLmNsYXNzZXMuZGlzcGF0Y2hlci5leHRlbmQodGhpcyk7XG5cbiAgICAvLyBBIHF1aWNrIGhhcmRjb2RlZCBydWxlIHRvIHByZXZlbnQgcGVvcGxlIGZyb20gdXNpbmcgdGhpcyBwbHVnaW4gd2l0aCB0aGVcbiAgICAvLyBXZWJHTCByZW5kZXJlciAod2hpY2ggaXMgaW1wb3NzaWJsZSBhdCB0aGUgbW9tZW50KTpcbiAgICAvLyBpZiAoXG4gICAgLy8gICBzaWdtYS5yZW5kZXJlcnMud2ViZ2wgJiZcbiAgICAvLyAgIHJlbmRlcmVyIGluc3RhbmNlb2Ygc2lnbWEucmVuZGVyZXJzLndlYmdsXG4gICAgLy8gKVxuICAgIC8vICAgdGhyb3cgbmV3IEVycm9yKFxuICAgIC8vICAgICAnVGhlIHNpZ21hLnBsdWdpbnMuZHJhZ05vZGVzIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhlIFdlYkdMIHJlbmRlcmVyJ1xuICAgIC8vICAgKTtcblxuICAgIC8vIEluaXQgdmFyaWFibGVzOlxuICAgIHZhciBfc2VsZiA9IHRoaXMsXG4gICAgICBfcyA9IHMsXG4gICAgICBfYm9keSA9IGRvY3VtZW50LmJvZHksXG4gICAgICBfcmVuZGVyZXIgPSByZW5kZXJlcixcbiAgICAgIF9tb3VzZSA9IHJlbmRlcmVyLmNvbnRhaW5lci5sYXN0Q2hpbGQsXG4gICAgICBfY2FtZXJhID0gcmVuZGVyZXIuY2FtZXJhLFxuICAgICAgX25vZGUgPSBudWxsLFxuICAgICAgX3ByZWZpeCA9ICcnLFxuICAgICAgX2hvdmVyU3RhY2sgPSBbXSxcbiAgICAgIF9ob3ZlckluZGV4ID0ge30sXG4gICAgICBfaXNNb3VzZURvd24gPSBmYWxzZSxcbiAgICAgIF9pc01vdXNlT3ZlckNhbnZhcyA9IGZhbHNlLFxuICAgICAgX2RyYWcgPSBmYWxzZTtcblxuICAgIGlmIChyZW5kZXJlciBpbnN0YW5jZW9mIHNpZ21hLnJlbmRlcmVycy5zdmcpIHtcbiAgICAgICAgX21vdXNlID0gcmVuZGVyZXIuY29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgLy8gSXQgcmVtb3ZlcyB0aGUgaW5pdGlhbCBzdWJzdHJpbmcgKCdyZWFkXycpIGlmIGl0J3MgYSBXZWdHTCByZW5kZXJlci5cbiAgICBpZiAocmVuZGVyZXIgaW5zdGFuY2VvZiBzaWdtYS5yZW5kZXJlcnMud2ViZ2wpIHtcbiAgICAgIF9wcmVmaXggPSByZW5kZXJlci5vcHRpb25zLnByZWZpeC5zdWJzdHIoNSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9wcmVmaXggPSByZW5kZXJlci5vcHRpb25zLnByZWZpeDtcbiAgICB9XG5cbiAgICByZW5kZXJlci5iaW5kKCdvdmVyTm9kZScsIG5vZGVNb3VzZU92ZXIpO1xuICAgIHJlbmRlcmVyLmJpbmQoJ291dE5vZGUnLCB0cmVhdE91dE5vZGUpO1xuICAgIHJlbmRlcmVyLmJpbmQoJ2NsaWNrJywgY2xpY2spO1xuXG4gICAgX3MuYmluZCgna2lsbCcsIGZ1bmN0aW9uKCkge1xuICAgICAgX3NlbGYudW5iaW5kQWxsKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBVbmJpbmQgYWxsIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgKi9cbiAgICB0aGlzLnVuYmluZEFsbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgX21vdXNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG5vZGVNb3VzZURvd24pO1xuICAgICAgX2JvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbm9kZU1vdXNlTW92ZSk7XG4gICAgICBfYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbm9kZU1vdXNlVXApO1xuICAgICAgX3JlbmRlcmVyLnVuYmluZCgnb3Zlck5vZGUnLCBub2RlTW91c2VPdmVyKTtcbiAgICAgIF9yZW5kZXJlci51bmJpbmQoJ291dE5vZGUnLCB0cmVhdE91dE5vZGUpO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZXMgdGhlIGdsb2JhbCBvZmZzZXQgb2YgdGhlIGdpdmVuIGVsZW1lbnQgbW9yZSBhY2N1cmF0ZWx5IHRoYW5cbiAgICAvLyBlbGVtZW50Lm9mZnNldFRvcCBhbmQgZWxlbWVudC5vZmZzZXRMZWZ0LlxuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZU9mZnNldChlbGVtZW50KSB7XG4gICAgICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgICAgIHZhciBnZXRDc3NQcm9wZXJ0eSA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJvcCkucmVwbGFjZSgncHgnLCAnJykpIHx8IDA7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0ICsgZ2V0Q3NzUHJvcGVydHkoJ3BhZGRpbmctbGVmdCcpLFxuICAgICAgICB0b3A6IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgZ2V0Q3NzUHJvcGVydHkoJ3BhZGRpbmctdG9wJylcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNsaWNrKGV2ZW50KSB7XG4gICAgICAvLyBldmVudCB0cmlnZ2VyZWQgYXQgdGhlIGVuZCBvZiB0aGUgY2xpY2tcbiAgICAgIF9pc01vdXNlRG93biA9IGZhbHNlO1xuICAgICAgX2JvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbm9kZU1vdXNlTW92ZSk7XG4gICAgICBfYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbm9kZU1vdXNlVXApO1xuXG4gICAgICBpZiAoIV9ob3ZlclN0YWNrLmxlbmd0aCkge1xuICAgICAgICBfbm9kZSA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG5vZGVNb3VzZU92ZXIoZXZlbnQpIHtcbiAgICAgIC8vIERvbid0IHRyZWF0IHRoZSBub2RlIGlmIGl0IGlzIGFscmVhZHkgcmVnaXN0ZXJlZFxuICAgICAgaWYgKF9ob3ZlckluZGV4W2V2ZW50LmRhdGEubm9kZS5pZF0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgbm9kZSB0byBhcnJheSBvZiBjdXJyZW50IG5vZGVzIG92ZXJcbiAgICAgIF9ob3ZlclN0YWNrLnB1c2goZXZlbnQuZGF0YS5ub2RlKTtcbiAgICAgIF9ob3ZlckluZGV4W2V2ZW50LmRhdGEubm9kZS5pZF0gPSB0cnVlO1xuXG4gICAgICBpZihfaG92ZXJTdGFjay5sZW5ndGggJiYgISBfaXNNb3VzZURvd24pIHtcbiAgICAgICAgLy8gU2V0IHRoZSBjdXJyZW50IG5vZGUgdG8gYmUgdGhlIGxhc3Qgb25lIGluIHRoZSBhcnJheVxuICAgICAgICBfbm9kZSA9IF9ob3ZlclN0YWNrW19ob3ZlclN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICBfbW91c2UuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbm9kZU1vdXNlRG93bik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHRyZWF0T3V0Tm9kZShldmVudCkge1xuICAgICAgLy8gUmVtb3ZlIHRoZSBub2RlIGZyb20gdGhlIGFycmF5XG4gICAgICB2YXIgaW5kZXhDaGVjayA9IF9ob3ZlclN0YWNrLm1hcChmdW5jdGlvbihlKSB7IHJldHVybiBlOyB9KS5pbmRleE9mKGV2ZW50LmRhdGEubm9kZSk7XG4gICAgICBfaG92ZXJTdGFjay5zcGxpY2UoaW5kZXhDaGVjaywgMSk7XG4gICAgICBkZWxldGUgX2hvdmVySW5kZXhbZXZlbnQuZGF0YS5ub2RlLmlkXTtcblxuICAgICAgaWYoX2hvdmVyU3RhY2subGVuZ3RoICYmICEgX2lzTW91c2VEb3duKSB7XG4gICAgICAgIC8vIE9uIG91dCwgc2V0IHRoZSBjdXJyZW50IG5vZGUgdG8gYmUgdGhlIG5leHQgc3RhdGVkIGluIGFycmF5XG4gICAgICAgIF9ub2RlID0gX2hvdmVyU3RhY2tbX2hvdmVyU3RhY2subGVuZ3RoIC0gMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfbW91c2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbm9kZU1vdXNlRG93bik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG5vZGVNb3VzZURvd24oZXZlbnQpIHtcbiAgICAgIF9pc01vdXNlRG93biA9IHRydWU7XG4gICAgICB2YXIgc2l6ZSA9IF9zLmdyYXBoLm5vZGVzKCkubGVuZ3RoO1xuXG4gICAgICAvLyB3aGVuIHRoZXJlIGlzIG9ubHkgbm9kZSBpbiB0aGUgZ3JhcGgsIHRoZSBwbHVnaW4gY2Fubm90IGFwcGx5XG4gICAgICAvLyBsaW5lYXIgaW50ZXJwb2xhdGlvbi4gU28gdHJlYXQgaXQgYXMgaWYgYSB1c2VyIGlzIGRyYWdnaW5nXG4gICAgICAvLyB0aGUgZ3JhcGhcbiAgICAgIGlmIChfbm9kZSAmJiBzaXplID4gMSkge1xuICAgICAgICBfbW91c2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbm9kZU1vdXNlRG93bik7XG4gICAgICAgIF9ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG5vZGVNb3VzZU1vdmUpO1xuICAgICAgICBfYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbm9kZU1vdXNlVXApO1xuXG4gICAgICAgIC8vIERvIG5vdCByZWZyZXNoIGVkZ2VxdWFkdHJlZSBkdXJpbmcgZHJhZzpcbiAgICAgICAgdmFyIGssXG4gICAgICAgICAgICBjO1xuICAgICAgICBmb3IgKGsgaW4gX3MuY2FtZXJhcykge1xuICAgICAgICAgIGMgPSBfcy5jYW1lcmFzW2tdO1xuICAgICAgICAgIGlmIChjLmVkZ2VxdWFkdHJlZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjLmVkZ2VxdWFkdHJlZS5fZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlYWN0aXZhdGUgZHJhZyBncmFwaC5cbiAgICAgICAgX3JlbmRlcmVyLnNldHRpbmdzKHttb3VzZUVuYWJsZWQ6IGZhbHNlLCBlbmFibGVIb3ZlcmluZzogZmFsc2V9KTtcbiAgICAgICAgX3MucmVmcmVzaCgpO1xuXG4gICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ3N0YXJ0ZHJhZycsIHtcbiAgICAgICAgICBub2RlOiBfbm9kZSxcbiAgICAgICAgICBjYXB0b3I6IGV2ZW50LFxuICAgICAgICAgIHJlbmRlcmVyOiBfcmVuZGVyZXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG5vZGVNb3VzZVVwKGV2ZW50KSB7XG4gICAgICBfaXNNb3VzZURvd24gPSBmYWxzZTtcbiAgICAgIF9tb3VzZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBub2RlTW91c2VEb3duKTtcbiAgICAgIF9ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG5vZGVNb3VzZU1vdmUpO1xuICAgICAgX2JvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG5vZGVNb3VzZVVwKTtcblxuICAgICAgLy8gQWxsb3cgdG8gcmVmcmVzaCBlZGdlcXVhZHRyZWU6XG4gICAgICB2YXIgayxcbiAgICAgICAgICBjO1xuICAgICAgZm9yIChrIGluIF9zLmNhbWVyYXMpIHtcbiAgICAgICAgYyA9IF9zLmNhbWVyYXNba107XG4gICAgICAgIGlmIChjLmVkZ2VxdWFkdHJlZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYy5lZGdlcXVhZHRyZWUuX2VuYWJsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFjdGl2YXRlIGRyYWcgZ3JhcGguXG4gICAgICBfcmVuZGVyZXIuc2V0dGluZ3Moe21vdXNlRW5hYmxlZDogdHJ1ZSwgZW5hYmxlSG92ZXJpbmc6IHRydWV9KTtcbiAgICAgIF9zLnJlZnJlc2goKTtcblxuICAgICAgaWYgKF9kcmFnKSB7XG4gICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ2Ryb3AnLCB7XG4gICAgICAgICAgbm9kZTogX25vZGUsXG4gICAgICAgICAgY2FwdG9yOiBldmVudCxcbiAgICAgICAgICByZW5kZXJlcjogX3JlbmRlcmVyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnZHJhZ2VuZCcsIHtcbiAgICAgICAgbm9kZTogX25vZGUsXG4gICAgICAgIGNhcHRvcjogZXZlbnQsXG4gICAgICAgIHJlbmRlcmVyOiBfcmVuZGVyZXJcbiAgICAgIH0pO1xuXG4gICAgICBfZHJhZyA9IGZhbHNlO1xuICAgICAgX25vZGUgPSBudWxsO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBub2RlTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgICBpZihuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZmlyZWZveCcpID4gLTEpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVPdXQpO1xuICAgICAgICB2YXIgdGltZU91dCA9IHNldFRpbWVvdXQoZXhlY3V0ZU5vZGVNb3VzZU1vdmUsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhlY3V0ZU5vZGVNb3VzZU1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZXhlY3V0ZU5vZGVNb3VzZU1vdmUoKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBjYWxjdWxhdGVPZmZzZXQoX3JlbmRlcmVyLmNvbnRhaW5lciksXG4gICAgICAgICAgICB4ID0gZXZlbnQuY2xpZW50WCAtIG9mZnNldC5sZWZ0LFxuICAgICAgICAgICAgeSA9IGV2ZW50LmNsaWVudFkgLSBvZmZzZXQudG9wLFxuICAgICAgICAgICAgY29zID0gTWF0aC5jb3MoX2NhbWVyYS5hbmdsZSksXG4gICAgICAgICAgICBzaW4gPSBNYXRoLnNpbihfY2FtZXJhLmFuZ2xlKSxcbiAgICAgICAgICAgIG5vZGVzID0gX3MuZ3JhcGgubm9kZXMoKSxcbiAgICAgICAgICAgIHJlZiA9IFtdO1xuXG4gICAgICAgIC8vIEdldHRpbmcgYW5kIGRlcm90YXRpbmcgdGhlIHJlZmVyZW5jZSBjb29yZGluYXRlcy5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgICB2YXIgbiA9IG5vZGVzW2ldO1xuICAgICAgICAgIHZhciBhdXggPSB7XG4gICAgICAgICAgICB4OiBuLnggKiBjb3MgKyBuLnkgKiBzaW4sXG4gICAgICAgICAgICB5OiBuLnkgKiBjb3MgLSBuLnggKiBzaW4sXG4gICAgICAgICAgICByZW5YOiBuW19wcmVmaXggKyAneCddLFxuICAgICAgICAgICAgcmVuWTogbltfcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJlZi5wdXNoKGF1eCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcHBseWluZyBsaW5lYXIgaW50ZXJwb2xhdGlvbi5cbiAgICAgICAgLy8gaWYgdGhlIG5vZGVzIGFyZSBvbiB0b3Agb2YgZWFjaCBvdGhlciwgd2UgdXNlIHRoZSBjYW1lcmEgcmF0aW8gdG8gaW50ZXJwb2xhdGVcbiAgICAgICAgaWYgKHJlZlswXS54ID09PSByZWZbMV0ueCAmJiByZWZbMF0ueSA9PT0gcmVmWzFdLnkpIHtcbiAgICAgICAgICB2YXIgeFJhdGlvID0gKHJlZlswXS5yZW5YID09PSAwKSA/IDEgOiByZWZbMF0ucmVuWDtcbiAgICAgICAgICB2YXIgeVJhdGlvID0gKHJlZlswXS5yZW5ZID09PSAwKSA/IDEgOiByZWZbMF0ucmVuWTtcbiAgICAgICAgICB4ID0gKHJlZlswXS54IC8geFJhdGlvKSAqICh4IC0gcmVmWzBdLnJlblgpICsgcmVmWzBdLng7XG4gICAgICAgICAgeSA9IChyZWZbMF0ueSAvIHlSYXRpbykgKiAoeSAtIHJlZlswXS5yZW5ZKSArIHJlZlswXS55O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB4UmF0aW8gPSAocmVmWzFdLnJlblggLSByZWZbMF0ucmVuWCkgLyAocmVmWzFdLnggLSByZWZbMF0ueCk7XG4gICAgICAgICAgdmFyIHlSYXRpbyA9IChyZWZbMV0ucmVuWSAtIHJlZlswXS5yZW5ZKSAvIChyZWZbMV0ueSAtIHJlZlswXS55KTtcblxuICAgICAgICAgIC8vIGlmIHRoZSBjb29yZGluYXRlcyBhcmUgdGhlIHNhbWUsIHdlIHVzZSB0aGUgb3RoZXIgcmF0aW8gdG8gaW50ZXJwb2xhdGVcbiAgICAgICAgICBpZiAocmVmWzFdLnggPT09IHJlZlswXS54KSB7XG4gICAgICAgICAgICB4UmF0aW8gPSB5UmF0aW87XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJlZlsxXS55ID09PSByZWZbMF0ueSkge1xuICAgICAgICAgICAgeVJhdGlvID0geFJhdGlvO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHggPSAoeCAtIHJlZlswXS5yZW5YKSAvIHhSYXRpbyArIHJlZlswXS54O1xuICAgICAgICAgIHkgPSAoeSAtIHJlZlswXS5yZW5ZKSAvIHlSYXRpbyArIHJlZlswXS55O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUm90YXRpbmcgdGhlIGNvb3JkaW5hdGVzLlxuICAgICAgICBfbm9kZS54ID0geCAqIGNvcyAtIHkgKiBzaW47XG4gICAgICAgIF9ub2RlLnkgPSB5ICogY29zICsgeCAqIHNpbjtcblxuICAgICAgICBfcy5yZWZyZXNoKCk7XG5cbiAgICAgICAgX2RyYWcgPSB0cnVlO1xuICAgICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdkcmFnJywge1xuICAgICAgICAgIG5vZGU6IF9ub2RlLFxuICAgICAgICAgIGNhcHRvcjogZXZlbnQsXG4gICAgICAgICAgcmVuZGVyZXI6IF9yZW5kZXJlclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbnRlcmZhY2VcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqXG4gICAqID4gdmFyIGRyYWdOb2Rlc0xpc3RlbmVyID0gc2lnbWEucGx1Z2lucy5kcmFnTm9kZXMocywgcy5yZW5kZXJlcnNbMF0pO1xuICAgKi9cbiAgdmFyIF9pbnN0YW5jZSA9IHt9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtzaWdtYX0gcyBUaGUgcmVsYXRlZCBzaWdtYSBpbnN0YW5jZS5cbiAgICogQHBhcmFtICB7cmVuZGVyZXJ9IHJlbmRlcmVyIFRoZSByZWxhdGVkIHJlbmRlcmVyIGluc3RhbmNlLlxuICAgKi9cbiAgc2lnbWEucGx1Z2lucy5kcmFnTm9kZXMgPSBmdW5jdGlvbihzLCByZW5kZXJlcikge1xuICAgIC8vIENyZWF0ZSBvYmplY3QgaWYgdW5kZWZpbmVkXG4gICAgaWYgKCFfaW5zdGFuY2Vbcy5pZF0pIHtcbiAgICAgIF9pbnN0YW5jZVtzLmlkXSA9IG5ldyBEcmFnTm9kZXMocywgcmVuZGVyZXIpO1xuICAgIH1cblxuICAgIHMuYmluZCgna2lsbCcsIGZ1bmN0aW9uKCkge1xuICAgICAgc2lnbWEucGx1Z2lucy5raWxsRHJhZ05vZGVzKHMpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIF9pbnN0YW5jZVtzLmlkXTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgcmVtb3ZlcyB0aGUgZXZlbnQgbGlzdGVuZXJzIGFuZCBraWxscyB0aGUgZHJhZ05vZGVzIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzaWdtYX0gcyBUaGUgcmVsYXRlZCBzaWdtYSBpbnN0YW5jZS5cbiAgICovXG4gIHNpZ21hLnBsdWdpbnMua2lsbERyYWdOb2RlcyA9IGZ1bmN0aW9uKHMpIHtcbiAgICBpZiAoX2luc3RhbmNlW3MuaWRdIGluc3RhbmNlb2YgRHJhZ05vZGVzKSB7XG4gICAgICBfaW5zdGFuY2Vbcy5pZF0udW5iaW5kQWxsKCk7XG4gICAgICBkZWxldGUgX2luc3RhbmNlW3MuaWRdO1xuICAgIH1cbiAgfTtcblxufSkuY2FsbCh3aW5kb3cpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/sigma/plugins/sigma.plugins.dragNodes/sigma.plugins.dragNodes.js\n");

/***/ }),

/***/ "./node_modules/unidragger/unidragger.js":
/*!***********************************************!*\
  !*** ./node_modules/unidragger/unidragger.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Unidragger v2.3.0\n * Draggable base class\n * MIT license\n */\n\n/*jshint browser: true, unused: true, undef: true, strict: true */\n\n( function( window, factory ) {\n  // universal module definition\n  /*jshint strict: false */ /*globals define, module, require */\n\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n      __webpack_require__(/*! unipointer/unipointer */ \"./node_modules/unipointer/unipointer.js\")\n    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function( Unipointer ) {\n      return factory( window, Unipointer );\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n}( window, function factory( window, Unipointer ) {\n\n'use strict';\n\n// -------------------------- Unidragger -------------------------- //\n\nfunction Unidragger() {}\n\n// inherit Unipointer & EvEmitter\nvar proto = Unidragger.prototype = Object.create( Unipointer.prototype );\n\n// ----- bind start ----- //\n\nproto.bindHandles = function() {\n  this._bindHandles( true );\n};\n\nproto.unbindHandles = function() {\n  this._bindHandles( false );\n};\n\n/**\n * Add or remove start event\n * @param {Boolean} isAdd\n */\nproto._bindHandles = function( isAdd ) {\n  // munge isAdd, default to true\n  isAdd = isAdd === undefined ? true : isAdd;\n  // bind each handle\n  var bindMethod = isAdd ? 'addEventListener' : 'removeEventListener';\n  var touchAction = isAdd ? this._touchActionValue : '';\n  for ( var i=0; i < this.handles.length; i++ ) {\n    var handle = this.handles[i];\n    this._bindStartEvent( handle, isAdd );\n    handle[ bindMethod ]( 'click', this );\n    // touch-action: none to override browser touch gestures. metafizzy/flickity#540\n    if ( window.PointerEvent ) {\n      handle.style.touchAction = touchAction;\n    }\n  }\n};\n\n// prototype so it can be overwriteable by Flickity\nproto._touchActionValue = 'none';\n\n// ----- start event ----- //\n\n/**\n * pointer start\n * @param {Event} event\n * @param {Event or Touch} pointer\n */\nproto.pointerDown = function( event, pointer ) {\n  var isOkay = this.okayPointerDown( event );\n  if ( !isOkay ) {\n    return;\n  }\n  // track start event position\n  this.pointerDownPointer = pointer;\n\n  event.preventDefault();\n  this.pointerDownBlur();\n  // bind move and end events\n  this._bindPostStartEvents( event );\n  this.emitEvent( 'pointerDown', [ event, pointer ] );\n};\n\n// nodes that have text fields\nvar cursorNodes = {\n  TEXTAREA: true,\n  INPUT: true,\n  SELECT: true,\n  OPTION: true,\n};\n\n// input types that do not have text fields\nvar clickTypes = {\n  radio: true,\n  checkbox: true,\n  button: true,\n  submit: true,\n  image: true,\n  file: true,\n};\n\n// dismiss inputs with text fields. flickity#403, flickity#404\nproto.okayPointerDown = function( event ) {\n  var isCursorNode = cursorNodes[ event.target.nodeName ];\n  var isClickType = clickTypes[ event.target.type ];\n  var isOkay = !isCursorNode || isClickType;\n  if ( !isOkay ) {\n    this._pointerReset();\n  }\n  return isOkay;\n};\n\n// kludge to blur previously focused input\nproto.pointerDownBlur = function() {\n  var focused = document.activeElement;\n  // do not blur body for IE10, metafizzy/flickity#117\n  var canBlur = focused && focused.blur && focused != document.body;\n  if ( canBlur ) {\n    focused.blur();\n  }\n};\n\n// ----- move event ----- //\n\n/**\n * drag move\n * @param {Event} event\n * @param {Event or Touch} pointer\n */\nproto.pointerMove = function( event, pointer ) {\n  var moveVector = this._dragPointerMove( event, pointer );\n  this.emitEvent( 'pointerMove', [ event, pointer, moveVector ] );\n  this._dragMove( event, pointer, moveVector );\n};\n\n// base pointer move logic\nproto._dragPointerMove = function( event, pointer ) {\n  var moveVector = {\n    x: pointer.pageX - this.pointerDownPointer.pageX,\n    y: pointer.pageY - this.pointerDownPointer.pageY\n  };\n  // start drag if pointer has moved far enough to start drag\n  if ( !this.isDragging && this.hasDragStarted( moveVector ) ) {\n    this._dragStart( event, pointer );\n  }\n  return moveVector;\n};\n\n// condition if pointer has moved far enough to start drag\nproto.hasDragStarted = function( moveVector ) {\n  return Math.abs( moveVector.x ) > 3 || Math.abs( moveVector.y ) > 3;\n};\n\n// ----- end event ----- //\n\n/**\n * pointer up\n * @param {Event} event\n * @param {Event or Touch} pointer\n */\nproto.pointerUp = function( event, pointer ) {\n  this.emitEvent( 'pointerUp', [ event, pointer ] );\n  this._dragPointerUp( event, pointer );\n};\n\nproto._dragPointerUp = function( event, pointer ) {\n  if ( this.isDragging ) {\n    this._dragEnd( event, pointer );\n  } else {\n    // pointer didn't move enough for drag to start\n    this._staticClick( event, pointer );\n  }\n};\n\n// -------------------------- drag -------------------------- //\n\n// dragStart\nproto._dragStart = function( event, pointer ) {\n  this.isDragging = true;\n  // prevent clicks\n  this.isPreventingClicks = true;\n  this.dragStart( event, pointer );\n};\n\nproto.dragStart = function( event, pointer ) {\n  this.emitEvent( 'dragStart', [ event, pointer ] );\n};\n\n// dragMove\nproto._dragMove = function( event, pointer, moveVector ) {\n  // do not drag if not dragging yet\n  if ( !this.isDragging ) {\n    return;\n  }\n\n  this.dragMove( event, pointer, moveVector );\n};\n\nproto.dragMove = function( event, pointer, moveVector ) {\n  event.preventDefault();\n  this.emitEvent( 'dragMove', [ event, pointer, moveVector ] );\n};\n\n// dragEnd\nproto._dragEnd = function( event, pointer ) {\n  // set flags\n  this.isDragging = false;\n  // re-enable clicking async\n  setTimeout( function() {\n    delete this.isPreventingClicks;\n  }.bind( this ) );\n\n  this.dragEnd( event, pointer );\n};\n\nproto.dragEnd = function( event, pointer ) {\n  this.emitEvent( 'dragEnd', [ event, pointer ] );\n};\n\n// ----- onclick ----- //\n\n// handle all clicks and prevent clicks when dragging\nproto.onclick = function( event ) {\n  if ( this.isPreventingClicks ) {\n    event.preventDefault();\n  }\n};\n\n// ----- staticClick ----- //\n\n// triggered after pointer down & up with no/tiny movement\nproto._staticClick = function( event, pointer ) {\n  // ignore emulated mouse up clicks\n  if ( this.isIgnoringMouseUp && event.type == 'mouseup' ) {\n    return;\n  }\n\n  this.staticClick( event, pointer );\n\n  // set flag for emulated clicks 300ms after touchend\n  if ( event.type != 'mouseup' ) {\n    this.isIgnoringMouseUp = true;\n    // reset flag after 300ms\n    setTimeout( function() {\n      delete this.isIgnoringMouseUp;\n    }.bind( this ), 400 );\n  }\n};\n\nproto.staticClick = function( event, pointer ) {\n  this.emitEvent( 'staticClick', [ event, pointer ] );\n};\n\n// ----- utils ----- //\n\nUnidragger.getPointerPoint = Unipointer.getPointerPoint;\n\n// -----  ----- //\n\nreturn Unidragger;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdW5pZHJhZ2dlci91bmlkcmFnZ2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuaWRyYWdnZXIvdW5pZHJhZ2dlci5qcz9lZjYyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVW5pZHJhZ2dlciB2Mi4zLjBcbiAqIERyYWdnYWJsZSBiYXNlIGNsYXNzXG4gKiBNSVQgbGljZW5zZVxuICovXG5cbi8qanNoaW50IGJyb3dzZXI6IHRydWUsIHVudXNlZDogdHJ1ZSwgdW5kZWY6IHRydWUsIHN0cmljdDogdHJ1ZSAqL1xuXG4oIGZ1bmN0aW9uKCB3aW5kb3csIGZhY3RvcnkgKSB7XG4gIC8vIHVuaXZlcnNhbCBtb2R1bGUgZGVmaW5pdGlvblxuICAvKmpzaGludCBzdHJpY3Q6IGZhbHNlICovIC8qZ2xvYmFscyBkZWZpbmUsIG1vZHVsZSwgcmVxdWlyZSAqL1xuXG4gIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG4gICAgLy8gQU1EXG4gICAgZGVmaW5lKCBbXG4gICAgICAndW5pcG9pbnRlci91bmlwb2ludGVyJ1xuICAgIF0sIGZ1bmN0aW9uKCBVbmlwb2ludGVyICkge1xuICAgICAgcmV0dXJuIGZhY3RvcnkoIHdpbmRvdywgVW5pcG9pbnRlciApO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzICkge1xuICAgIC8vIENvbW1vbkpTXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KFxuICAgICAgd2luZG93LFxuICAgICAgcmVxdWlyZSgndW5pcG9pbnRlcicpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBicm93c2VyIGdsb2JhbFxuICAgIHdpbmRvdy5VbmlkcmFnZ2VyID0gZmFjdG9yeShcbiAgICAgIHdpbmRvdyxcbiAgICAgIHdpbmRvdy5Vbmlwb2ludGVyXG4gICAgKTtcbiAgfVxuXG59KCB3aW5kb3csIGZ1bmN0aW9uIGZhY3RvcnkoIHdpbmRvdywgVW5pcG9pbnRlciApIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBVbmlkcmFnZ2VyIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbmZ1bmN0aW9uIFVuaWRyYWdnZXIoKSB7fVxuXG4vLyBpbmhlcml0IFVuaXBvaW50ZXIgJiBFdkVtaXR0ZXJcbnZhciBwcm90byA9IFVuaWRyYWdnZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVW5pcG9pbnRlci5wcm90b3R5cGUgKTtcblxuLy8gLS0tLS0gYmluZCBzdGFydCAtLS0tLSAvL1xuXG5wcm90by5iaW5kSGFuZGxlcyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9iaW5kSGFuZGxlcyggdHJ1ZSApO1xufTtcblxucHJvdG8udW5iaW5kSGFuZGxlcyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9iaW5kSGFuZGxlcyggZmFsc2UgKTtcbn07XG5cbi8qKlxuICogQWRkIG9yIHJlbW92ZSBzdGFydCBldmVudFxuICogQHBhcmFtIHtCb29sZWFufSBpc0FkZFxuICovXG5wcm90by5fYmluZEhhbmRsZXMgPSBmdW5jdGlvbiggaXNBZGQgKSB7XG4gIC8vIG11bmdlIGlzQWRkLCBkZWZhdWx0IHRvIHRydWVcbiAgaXNBZGQgPSBpc0FkZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGlzQWRkO1xuICAvLyBiaW5kIGVhY2ggaGFuZGxlXG4gIHZhciBiaW5kTWV0aG9kID0gaXNBZGQgPyAnYWRkRXZlbnRMaXN0ZW5lcicgOiAncmVtb3ZlRXZlbnRMaXN0ZW5lcic7XG4gIHZhciB0b3VjaEFjdGlvbiA9IGlzQWRkID8gdGhpcy5fdG91Y2hBY3Rpb25WYWx1ZSA6ICcnO1xuICBmb3IgKCB2YXIgaT0wOyBpIDwgdGhpcy5oYW5kbGVzLmxlbmd0aDsgaSsrICkge1xuICAgIHZhciBoYW5kbGUgPSB0aGlzLmhhbmRsZXNbaV07XG4gICAgdGhpcy5fYmluZFN0YXJ0RXZlbnQoIGhhbmRsZSwgaXNBZGQgKTtcbiAgICBoYW5kbGVbIGJpbmRNZXRob2QgXSggJ2NsaWNrJywgdGhpcyApO1xuICAgIC8vIHRvdWNoLWFjdGlvbjogbm9uZSB0byBvdmVycmlkZSBicm93c2VyIHRvdWNoIGdlc3R1cmVzLiBtZXRhZml6enkvZmxpY2tpdHkjNTQwXG4gICAgaWYgKCB3aW5kb3cuUG9pbnRlckV2ZW50ICkge1xuICAgICAgaGFuZGxlLnN0eWxlLnRvdWNoQWN0aW9uID0gdG91Y2hBY3Rpb247XG4gICAgfVxuICB9XG59O1xuXG4vLyBwcm90b3R5cGUgc28gaXQgY2FuIGJlIG92ZXJ3cml0ZWFibGUgYnkgRmxpY2tpdHlcbnByb3RvLl90b3VjaEFjdGlvblZhbHVlID0gJ25vbmUnO1xuXG4vLyAtLS0tLSBzdGFydCBldmVudCAtLS0tLSAvL1xuXG4vKipcbiAqIHBvaW50ZXIgc3RhcnRcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50IG9yIFRvdWNofSBwb2ludGVyXG4gKi9cbnByb3RvLnBvaW50ZXJEb3duID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICB2YXIgaXNPa2F5ID0gdGhpcy5va2F5UG9pbnRlckRvd24oIGV2ZW50ICk7XG4gIGlmICggIWlzT2theSApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gdHJhY2sgc3RhcnQgZXZlbnQgcG9zaXRpb25cbiAgdGhpcy5wb2ludGVyRG93blBvaW50ZXIgPSBwb2ludGVyO1xuXG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIHRoaXMucG9pbnRlckRvd25CbHVyKCk7XG4gIC8vIGJpbmQgbW92ZSBhbmQgZW5kIGV2ZW50c1xuICB0aGlzLl9iaW5kUG9zdFN0YXJ0RXZlbnRzKCBldmVudCApO1xuICB0aGlzLmVtaXRFdmVudCggJ3BvaW50ZXJEb3duJywgWyBldmVudCwgcG9pbnRlciBdICk7XG59O1xuXG4vLyBub2RlcyB0aGF0IGhhdmUgdGV4dCBmaWVsZHNcbnZhciBjdXJzb3JOb2RlcyA9IHtcbiAgVEVYVEFSRUE6IHRydWUsXG4gIElOUFVUOiB0cnVlLFxuICBTRUxFQ1Q6IHRydWUsXG4gIE9QVElPTjogdHJ1ZSxcbn07XG5cbi8vIGlucHV0IHR5cGVzIHRoYXQgZG8gbm90IGhhdmUgdGV4dCBmaWVsZHNcbnZhciBjbGlja1R5cGVzID0ge1xuICByYWRpbzogdHJ1ZSxcbiAgY2hlY2tib3g6IHRydWUsXG4gIGJ1dHRvbjogdHJ1ZSxcbiAgc3VibWl0OiB0cnVlLFxuICBpbWFnZTogdHJ1ZSxcbiAgZmlsZTogdHJ1ZSxcbn07XG5cbi8vIGRpc21pc3MgaW5wdXRzIHdpdGggdGV4dCBmaWVsZHMuIGZsaWNraXR5IzQwMywgZmxpY2tpdHkjNDA0XG5wcm90by5va2F5UG9pbnRlckRvd24gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIHZhciBpc0N1cnNvck5vZGUgPSBjdXJzb3JOb2Rlc1sgZXZlbnQudGFyZ2V0Lm5vZGVOYW1lIF07XG4gIHZhciBpc0NsaWNrVHlwZSA9IGNsaWNrVHlwZXNbIGV2ZW50LnRhcmdldC50eXBlIF07XG4gIHZhciBpc09rYXkgPSAhaXNDdXJzb3JOb2RlIHx8IGlzQ2xpY2tUeXBlO1xuICBpZiAoICFpc09rYXkgKSB7XG4gICAgdGhpcy5fcG9pbnRlclJlc2V0KCk7XG4gIH1cbiAgcmV0dXJuIGlzT2theTtcbn07XG5cbi8vIGtsdWRnZSB0byBibHVyIHByZXZpb3VzbHkgZm9jdXNlZCBpbnB1dFxucHJvdG8ucG9pbnRlckRvd25CbHVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBmb2N1c2VkID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgLy8gZG8gbm90IGJsdXIgYm9keSBmb3IgSUUxMCwgbWV0YWZpenp5L2ZsaWNraXR5IzExN1xuICB2YXIgY2FuQmx1ciA9IGZvY3VzZWQgJiYgZm9jdXNlZC5ibHVyICYmIGZvY3VzZWQgIT0gZG9jdW1lbnQuYm9keTtcbiAgaWYgKCBjYW5CbHVyICkge1xuICAgIGZvY3VzZWQuYmx1cigpO1xuICB9XG59O1xuXG4vLyAtLS0tLSBtb3ZlIGV2ZW50IC0tLS0tIC8vXG5cbi8qKlxuICogZHJhZyBtb3ZlXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHBhcmFtIHtFdmVudCBvciBUb3VjaH0gcG9pbnRlclxuICovXG5wcm90by5wb2ludGVyTW92ZSA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdmFyIG1vdmVWZWN0b3IgPSB0aGlzLl9kcmFnUG9pbnRlck1vdmUoIGV2ZW50LCBwb2ludGVyICk7XG4gIHRoaXMuZW1pdEV2ZW50KCAncG9pbnRlck1vdmUnLCBbIGV2ZW50LCBwb2ludGVyLCBtb3ZlVmVjdG9yIF0gKTtcbiAgdGhpcy5fZHJhZ01vdmUoIGV2ZW50LCBwb2ludGVyLCBtb3ZlVmVjdG9yICk7XG59O1xuXG4vLyBiYXNlIHBvaW50ZXIgbW92ZSBsb2dpY1xucHJvdG8uX2RyYWdQb2ludGVyTW92ZSA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdmFyIG1vdmVWZWN0b3IgPSB7XG4gICAgeDogcG9pbnRlci5wYWdlWCAtIHRoaXMucG9pbnRlckRvd25Qb2ludGVyLnBhZ2VYLFxuICAgIHk6IHBvaW50ZXIucGFnZVkgLSB0aGlzLnBvaW50ZXJEb3duUG9pbnRlci5wYWdlWVxuICB9O1xuICAvLyBzdGFydCBkcmFnIGlmIHBvaW50ZXIgaGFzIG1vdmVkIGZhciBlbm91Z2ggdG8gc3RhcnQgZHJhZ1xuICBpZiAoICF0aGlzLmlzRHJhZ2dpbmcgJiYgdGhpcy5oYXNEcmFnU3RhcnRlZCggbW92ZVZlY3RvciApICkge1xuICAgIHRoaXMuX2RyYWdTdGFydCggZXZlbnQsIHBvaW50ZXIgKTtcbiAgfVxuICByZXR1cm4gbW92ZVZlY3Rvcjtcbn07XG5cbi8vIGNvbmRpdGlvbiBpZiBwb2ludGVyIGhhcyBtb3ZlZCBmYXIgZW5vdWdoIHRvIHN0YXJ0IGRyYWdcbnByb3RvLmhhc0RyYWdTdGFydGVkID0gZnVuY3Rpb24oIG1vdmVWZWN0b3IgKSB7XG4gIHJldHVybiBNYXRoLmFicyggbW92ZVZlY3Rvci54ICkgPiAzIHx8IE1hdGguYWJzKCBtb3ZlVmVjdG9yLnkgKSA+IDM7XG59O1xuXG4vLyAtLS0tLSBlbmQgZXZlbnQgLS0tLS0gLy9cblxuLyoqXG4gKiBwb2ludGVyIHVwXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHBhcmFtIHtFdmVudCBvciBUb3VjaH0gcG9pbnRlclxuICovXG5wcm90by5wb2ludGVyVXAgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XG4gIHRoaXMuZW1pdEV2ZW50KCAncG9pbnRlclVwJywgWyBldmVudCwgcG9pbnRlciBdICk7XG4gIHRoaXMuX2RyYWdQb2ludGVyVXAoIGV2ZW50LCBwb2ludGVyICk7XG59O1xuXG5wcm90by5fZHJhZ1BvaW50ZXJVcCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgaWYgKCB0aGlzLmlzRHJhZ2dpbmcgKSB7XG4gICAgdGhpcy5fZHJhZ0VuZCggZXZlbnQsIHBvaW50ZXIgKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBwb2ludGVyIGRpZG4ndCBtb3ZlIGVub3VnaCBmb3IgZHJhZyB0byBzdGFydFxuICAgIHRoaXMuX3N0YXRpY0NsaWNrKCBldmVudCwgcG9pbnRlciApO1xuICB9XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBkcmFnIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbi8vIGRyYWdTdGFydFxucHJvdG8uX2RyYWdTdGFydCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgLy8gcHJldmVudCBjbGlja3NcbiAgdGhpcy5pc1ByZXZlbnRpbmdDbGlja3MgPSB0cnVlO1xuICB0aGlzLmRyYWdTdGFydCggZXZlbnQsIHBvaW50ZXIgKTtcbn07XG5cbnByb3RvLmRyYWdTdGFydCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdGhpcy5lbWl0RXZlbnQoICdkcmFnU3RhcnQnLCBbIGV2ZW50LCBwb2ludGVyIF0gKTtcbn07XG5cbi8vIGRyYWdNb3ZlXG5wcm90by5fZHJhZ01vdmUgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIsIG1vdmVWZWN0b3IgKSB7XG4gIC8vIGRvIG5vdCBkcmFnIGlmIG5vdCBkcmFnZ2luZyB5ZXRcbiAgaWYgKCAhdGhpcy5pc0RyYWdnaW5nICkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuZHJhZ01vdmUoIGV2ZW50LCBwb2ludGVyLCBtb3ZlVmVjdG9yICk7XG59O1xuXG5wcm90by5kcmFnTW92ZSA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciwgbW92ZVZlY3RvciApIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgdGhpcy5lbWl0RXZlbnQoICdkcmFnTW92ZScsIFsgZXZlbnQsIHBvaW50ZXIsIG1vdmVWZWN0b3IgXSApO1xufTtcblxuLy8gZHJhZ0VuZFxucHJvdG8uX2RyYWdFbmQgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XG4gIC8vIHNldCBmbGFnc1xuICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgLy8gcmUtZW5hYmxlIGNsaWNraW5nIGFzeW5jXG4gIHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuICAgIGRlbGV0ZSB0aGlzLmlzUHJldmVudGluZ0NsaWNrcztcbiAgfS5iaW5kKCB0aGlzICkgKTtcblxuICB0aGlzLmRyYWdFbmQoIGV2ZW50LCBwb2ludGVyICk7XG59O1xuXG5wcm90by5kcmFnRW5kID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICB0aGlzLmVtaXRFdmVudCggJ2RyYWdFbmQnLCBbIGV2ZW50LCBwb2ludGVyIF0gKTtcbn07XG5cbi8vIC0tLS0tIG9uY2xpY2sgLS0tLS0gLy9cblxuLy8gaGFuZGxlIGFsbCBjbGlja3MgYW5kIHByZXZlbnQgY2xpY2tzIHdoZW4gZHJhZ2dpbmdcbnByb3RvLm9uY2xpY2sgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIGlmICggdGhpcy5pc1ByZXZlbnRpbmdDbGlja3MgKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxufTtcblxuLy8gLS0tLS0gc3RhdGljQ2xpY2sgLS0tLS0gLy9cblxuLy8gdHJpZ2dlcmVkIGFmdGVyIHBvaW50ZXIgZG93biAmIHVwIHdpdGggbm8vdGlueSBtb3ZlbWVudFxucHJvdG8uX3N0YXRpY0NsaWNrID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICAvLyBpZ25vcmUgZW11bGF0ZWQgbW91c2UgdXAgY2xpY2tzXG4gIGlmICggdGhpcy5pc0lnbm9yaW5nTW91c2VVcCAmJiBldmVudC50eXBlID09ICdtb3VzZXVwJyApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLnN0YXRpY0NsaWNrKCBldmVudCwgcG9pbnRlciApO1xuXG4gIC8vIHNldCBmbGFnIGZvciBlbXVsYXRlZCBjbGlja3MgMzAwbXMgYWZ0ZXIgdG91Y2hlbmRcbiAgaWYgKCBldmVudC50eXBlICE9ICdtb3VzZXVwJyApIHtcbiAgICB0aGlzLmlzSWdub3JpbmdNb3VzZVVwID0gdHJ1ZTtcbiAgICAvLyByZXNldCBmbGFnIGFmdGVyIDMwMG1zXG4gICAgc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG4gICAgICBkZWxldGUgdGhpcy5pc0lnbm9yaW5nTW91c2VVcDtcbiAgICB9LmJpbmQoIHRoaXMgKSwgNDAwICk7XG4gIH1cbn07XG5cbnByb3RvLnN0YXRpY0NsaWNrID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICB0aGlzLmVtaXRFdmVudCggJ3N0YXRpY0NsaWNrJywgWyBldmVudCwgcG9pbnRlciBdICk7XG59O1xuXG4vLyAtLS0tLSB1dGlscyAtLS0tLSAvL1xuXG5VbmlkcmFnZ2VyLmdldFBvaW50ZXJQb2ludCA9IFVuaXBvaW50ZXIuZ2V0UG9pbnRlclBvaW50O1xuXG4vLyAtLS0tLSAgLS0tLS0gLy9cblxucmV0dXJuIFVuaWRyYWdnZXI7XG5cbn0pKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBLFdBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/unidragger/unidragger.js\n");

/***/ }),

/***/ "./node_modules/unipointer/unipointer.js":
/*!***********************************************!*\
  !*** ./node_modules/unipointer/unipointer.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Unipointer v2.3.0\n * base class for doing one thing with pointer event\n * MIT license\n */\n\n/*jshint browser: true, undef: true, unused: true, strict: true */\n\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */ /*global define, module, require */\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n      __webpack_require__(/*! ev-emitter/ev-emitter */ \"./node_modules/ev-emitter/ev-emitter.js\")\n    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function( EvEmitter ) {\n      return factory( window, EvEmitter );\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n}( window, function factory( window, EvEmitter ) {\n\n'use strict';\n\nfunction noop() {}\n\nfunction Unipointer() {}\n\n// inherit EvEmitter\nvar proto = Unipointer.prototype = Object.create( EvEmitter.prototype );\n\nproto.bindStartEvent = function( elem ) {\n  this._bindStartEvent( elem, true );\n};\n\nproto.unbindStartEvent = function( elem ) {\n  this._bindStartEvent( elem, false );\n};\n\n/**\n * Add or remove start event\n * @param {Boolean} isAdd - remove if falsey\n */\nproto._bindStartEvent = function( elem, isAdd ) {\n  // munge isAdd, default to true\n  isAdd = isAdd === undefined ? true : isAdd;\n  var bindMethod = isAdd ? 'addEventListener' : 'removeEventListener';\n\n  // default to mouse events\n  var startEvent = 'mousedown';\n  if ( window.PointerEvent ) {\n    // Pointer Events\n    startEvent = 'pointerdown';\n  } else if ( 'ontouchstart' in window ) {\n    // Touch Events. iOS Safari\n    startEvent = 'touchstart';\n  }\n  elem[ bindMethod ]( startEvent, this );\n};\n\n// trigger handler methods for events\nproto.handleEvent = function( event ) {\n  var method = 'on' + event.type;\n  if ( this[ method ] ) {\n    this[ method ]( event );\n  }\n};\n\n// returns the touch that we're keeping track of\nproto.getTouch = function( touches ) {\n  for ( var i=0; i < touches.length; i++ ) {\n    var touch = touches[i];\n    if ( touch.identifier == this.pointerIdentifier ) {\n      return touch;\n    }\n  }\n};\n\n// ----- start event ----- //\n\nproto.onmousedown = function( event ) {\n  // dismiss clicks from right or middle buttons\n  var button = event.button;\n  if ( button && ( button !== 0 && button !== 1 ) ) {\n    return;\n  }\n  this._pointerDown( event, event );\n};\n\nproto.ontouchstart = function( event ) {\n  this._pointerDown( event, event.changedTouches[0] );\n};\n\nproto.onpointerdown = function( event ) {\n  this._pointerDown( event, event );\n};\n\n/**\n * pointer start\n * @param {Event} event\n * @param {Event or Touch} pointer\n */\nproto._pointerDown = function( event, pointer ) {\n  // dismiss right click and other pointers\n  // button = 0 is okay, 1-4 not\n  if ( event.button || this.isPointerDown ) {\n    return;\n  }\n\n  this.isPointerDown = true;\n  // save pointer identifier to match up touch events\n  this.pointerIdentifier = pointer.pointerId !== undefined ?\n    // pointerId for pointer events, touch.indentifier for touch events\n    pointer.pointerId : pointer.identifier;\n\n  this.pointerDown( event, pointer );\n};\n\nproto.pointerDown = function( event, pointer ) {\n  this._bindPostStartEvents( event );\n  this.emitEvent( 'pointerDown', [ event, pointer ] );\n};\n\n// hash of events to be bound after start event\nvar postStartEvents = {\n  mousedown: [ 'mousemove', 'mouseup' ],\n  touchstart: [ 'touchmove', 'touchend', 'touchcancel' ],\n  pointerdown: [ 'pointermove', 'pointerup', 'pointercancel' ],\n};\n\nproto._bindPostStartEvents = function( event ) {\n  if ( !event ) {\n    return;\n  }\n  // get proper events to match start event\n  var events = postStartEvents[ event.type ];\n  // bind events to node\n  events.forEach( function( eventName ) {\n    window.addEventListener( eventName, this );\n  }, this );\n  // save these arguments\n  this._boundPointerEvents = events;\n};\n\nproto._unbindPostStartEvents = function() {\n  // check for _boundEvents, in case dragEnd triggered twice (old IE8 bug)\n  if ( !this._boundPointerEvents ) {\n    return;\n  }\n  this._boundPointerEvents.forEach( function( eventName ) {\n    window.removeEventListener( eventName, this );\n  }, this );\n\n  delete this._boundPointerEvents;\n};\n\n// ----- move event ----- //\n\nproto.onmousemove = function( event ) {\n  this._pointerMove( event, event );\n};\n\nproto.onpointermove = function( event ) {\n  if ( event.pointerId == this.pointerIdentifier ) {\n    this._pointerMove( event, event );\n  }\n};\n\nproto.ontouchmove = function( event ) {\n  var touch = this.getTouch( event.changedTouches );\n  if ( touch ) {\n    this._pointerMove( event, touch );\n  }\n};\n\n/**\n * pointer move\n * @param {Event} event\n * @param {Event or Touch} pointer\n * @private\n */\nproto._pointerMove = function( event, pointer ) {\n  this.pointerMove( event, pointer );\n};\n\n// public\nproto.pointerMove = function( event, pointer ) {\n  this.emitEvent( 'pointerMove', [ event, pointer ] );\n};\n\n// ----- end event ----- //\n\n\nproto.onmouseup = function( event ) {\n  this._pointerUp( event, event );\n};\n\nproto.onpointerup = function( event ) {\n  if ( event.pointerId == this.pointerIdentifier ) {\n    this._pointerUp( event, event );\n  }\n};\n\nproto.ontouchend = function( event ) {\n  var touch = this.getTouch( event.changedTouches );\n  if ( touch ) {\n    this._pointerUp( event, touch );\n  }\n};\n\n/**\n * pointer up\n * @param {Event} event\n * @param {Event or Touch} pointer\n * @private\n */\nproto._pointerUp = function( event, pointer ) {\n  this._pointerDone();\n  this.pointerUp( event, pointer );\n};\n\n// public\nproto.pointerUp = function( event, pointer ) {\n  this.emitEvent( 'pointerUp', [ event, pointer ] );\n};\n\n// ----- pointer done ----- //\n\n// triggered on pointer up & pointer cancel\nproto._pointerDone = function() {\n  this._pointerReset();\n  this._unbindPostStartEvents();\n  this.pointerDone();\n};\n\nproto._pointerReset = function() {\n  // reset properties\n  this.isPointerDown = false;\n  delete this.pointerIdentifier;\n};\n\nproto.pointerDone = noop;\n\n// ----- pointer cancel ----- //\n\nproto.onpointercancel = function( event ) {\n  if ( event.pointerId == this.pointerIdentifier ) {\n    this._pointerCancel( event, event );\n  }\n};\n\nproto.ontouchcancel = function( event ) {\n  var touch = this.getTouch( event.changedTouches );\n  if ( touch ) {\n    this._pointerCancel( event, touch );\n  }\n};\n\n/**\n * pointer cancel\n * @param {Event} event\n * @param {Event or Touch} pointer\n * @private\n */\nproto._pointerCancel = function( event, pointer ) {\n  this._pointerDone();\n  this.pointerCancel( event, pointer );\n};\n\n// public\nproto.pointerCancel = function( event, pointer ) {\n  this.emitEvent( 'pointerCancel', [ event, pointer ] );\n};\n\n// -----  ----- //\n\n// utility function for getting x/y coords from event\nUnipointer.getPointerPoint = function( pointer ) {\n  return {\n    x: pointer.pageX,\n    y: pointer.pageY\n  };\n};\n\n// -----  ----- //\n\nreturn Unipointer;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdW5pcG9pbnRlci91bmlwb2ludGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuaXBvaW50ZXIvdW5pcG9pbnRlci5qcz9lMGY1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVW5pcG9pbnRlciB2Mi4zLjBcbiAqIGJhc2UgY2xhc3MgZm9yIGRvaW5nIG9uZSB0aGluZyB3aXRoIHBvaW50ZXIgZXZlbnRcbiAqIE1JVCBsaWNlbnNlXG4gKi9cblxuLypqc2hpbnQgYnJvd3NlcjogdHJ1ZSwgdW5kZWY6IHRydWUsIHVudXNlZDogdHJ1ZSwgc3RyaWN0OiB0cnVlICovXG5cbiggZnVuY3Rpb24oIHdpbmRvdywgZmFjdG9yeSApIHtcbiAgLy8gdW5pdmVyc2FsIG1vZHVsZSBkZWZpbml0aW9uXG4gIC8qIGpzaGludCBzdHJpY3Q6IGZhbHNlICovIC8qZ2xvYmFsIGRlZmluZSwgbW9kdWxlLCByZXF1aXJlICovXG4gIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG4gICAgLy8gQU1EXG4gICAgZGVmaW5lKCBbXG4gICAgICAnZXYtZW1pdHRlci9ldi1lbWl0dGVyJ1xuICAgIF0sIGZ1bmN0aW9uKCBFdkVtaXR0ZXIgKSB7XG4gICAgICByZXR1cm4gZmFjdG9yeSggd2luZG93LCBFdkVtaXR0ZXIgKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcbiAgICAvLyBDb21tb25KU1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShcbiAgICAgIHdpbmRvdyxcbiAgICAgIHJlcXVpcmUoJ2V2LWVtaXR0ZXInKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgLy8gYnJvd3NlciBnbG9iYWxcbiAgICB3aW5kb3cuVW5pcG9pbnRlciA9IGZhY3RvcnkoXG4gICAgICB3aW5kb3csXG4gICAgICB3aW5kb3cuRXZFbWl0dGVyXG4gICAgKTtcbiAgfVxuXG59KCB3aW5kb3csIGZ1bmN0aW9uIGZhY3RvcnkoIHdpbmRvdywgRXZFbWl0dGVyICkge1xuXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5mdW5jdGlvbiBVbmlwb2ludGVyKCkge31cblxuLy8gaW5oZXJpdCBFdkVtaXR0ZXJcbnZhciBwcm90byA9IFVuaXBvaW50ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXZFbWl0dGVyLnByb3RvdHlwZSApO1xuXG5wcm90by5iaW5kU3RhcnRFdmVudCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuICB0aGlzLl9iaW5kU3RhcnRFdmVudCggZWxlbSwgdHJ1ZSApO1xufTtcblxucHJvdG8udW5iaW5kU3RhcnRFdmVudCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuICB0aGlzLl9iaW5kU3RhcnRFdmVudCggZWxlbSwgZmFsc2UgKTtcbn07XG5cbi8qKlxuICogQWRkIG9yIHJlbW92ZSBzdGFydCBldmVudFxuICogQHBhcmFtIHtCb29sZWFufSBpc0FkZCAtIHJlbW92ZSBpZiBmYWxzZXlcbiAqL1xucHJvdG8uX2JpbmRTdGFydEV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIGlzQWRkICkge1xuICAvLyBtdW5nZSBpc0FkZCwgZGVmYXVsdCB0byB0cnVlXG4gIGlzQWRkID0gaXNBZGQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBpc0FkZDtcbiAgdmFyIGJpbmRNZXRob2QgPSBpc0FkZCA/ICdhZGRFdmVudExpc3RlbmVyJyA6ICdyZW1vdmVFdmVudExpc3RlbmVyJztcblxuICAvLyBkZWZhdWx0IHRvIG1vdXNlIGV2ZW50c1xuICB2YXIgc3RhcnRFdmVudCA9ICdtb3VzZWRvd24nO1xuICBpZiAoIHdpbmRvdy5Qb2ludGVyRXZlbnQgKSB7XG4gICAgLy8gUG9pbnRlciBFdmVudHNcbiAgICBzdGFydEV2ZW50ID0gJ3BvaW50ZXJkb3duJztcbiAgfSBlbHNlIGlmICggJ29udG91Y2hzdGFydCcgaW4gd2luZG93ICkge1xuICAgIC8vIFRvdWNoIEV2ZW50cy4gaU9TIFNhZmFyaVxuICAgIHN0YXJ0RXZlbnQgPSAndG91Y2hzdGFydCc7XG4gIH1cbiAgZWxlbVsgYmluZE1ldGhvZCBdKCBzdGFydEV2ZW50LCB0aGlzICk7XG59O1xuXG4vLyB0cmlnZ2VyIGhhbmRsZXIgbWV0aG9kcyBmb3IgZXZlbnRzXG5wcm90by5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgdmFyIG1ldGhvZCA9ICdvbicgKyBldmVudC50eXBlO1xuICBpZiAoIHRoaXNbIG1ldGhvZCBdICkge1xuICAgIHRoaXNbIG1ldGhvZCBdKCBldmVudCApO1xuICB9XG59O1xuXG4vLyByZXR1cm5zIHRoZSB0b3VjaCB0aGF0IHdlJ3JlIGtlZXBpbmcgdHJhY2sgb2ZcbnByb3RvLmdldFRvdWNoID0gZnVuY3Rpb24oIHRvdWNoZXMgKSB7XG4gIGZvciAoIHZhciBpPTA7IGkgPCB0b3VjaGVzLmxlbmd0aDsgaSsrICkge1xuICAgIHZhciB0b3VjaCA9IHRvdWNoZXNbaV07XG4gICAgaWYgKCB0b3VjaC5pZGVudGlmaWVyID09IHRoaXMucG9pbnRlcklkZW50aWZpZXIgKSB7XG4gICAgICByZXR1cm4gdG91Y2g7XG4gICAgfVxuICB9XG59O1xuXG4vLyAtLS0tLSBzdGFydCBldmVudCAtLS0tLSAvL1xuXG5wcm90by5vbm1vdXNlZG93biA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgLy8gZGlzbWlzcyBjbGlja3MgZnJvbSByaWdodCBvciBtaWRkbGUgYnV0dG9uc1xuICB2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuICBpZiAoIGJ1dHRvbiAmJiAoIGJ1dHRvbiAhPT0gMCAmJiBidXR0b24gIT09IDEgKSApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5fcG9pbnRlckRvd24oIGV2ZW50LCBldmVudCApO1xufTtcblxucHJvdG8ub250b3VjaHN0YXJ0ID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICB0aGlzLl9wb2ludGVyRG93biggZXZlbnQsIGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdICk7XG59O1xuXG5wcm90by5vbnBvaW50ZXJkb3duID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICB0aGlzLl9wb2ludGVyRG93biggZXZlbnQsIGV2ZW50ICk7XG59O1xuXG4vKipcbiAqIHBvaW50ZXIgc3RhcnRcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50IG9yIFRvdWNofSBwb2ludGVyXG4gKi9cbnByb3RvLl9wb2ludGVyRG93biA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgLy8gZGlzbWlzcyByaWdodCBjbGljayBhbmQgb3RoZXIgcG9pbnRlcnNcbiAgLy8gYnV0dG9uID0gMCBpcyBva2F5LCAxLTQgbm90XG4gIGlmICggZXZlbnQuYnV0dG9uIHx8IHRoaXMuaXNQb2ludGVyRG93biApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmlzUG9pbnRlckRvd24gPSB0cnVlO1xuICAvLyBzYXZlIHBvaW50ZXIgaWRlbnRpZmllciB0byBtYXRjaCB1cCB0b3VjaCBldmVudHNcbiAgdGhpcy5wb2ludGVySWRlbnRpZmllciA9IHBvaW50ZXIucG9pbnRlcklkICE9PSB1bmRlZmluZWQgP1xuICAgIC8vIHBvaW50ZXJJZCBmb3IgcG9pbnRlciBldmVudHMsIHRvdWNoLmluZGVudGlmaWVyIGZvciB0b3VjaCBldmVudHNcbiAgICBwb2ludGVyLnBvaW50ZXJJZCA6IHBvaW50ZXIuaWRlbnRpZmllcjtcblxuICB0aGlzLnBvaW50ZXJEb3duKCBldmVudCwgcG9pbnRlciApO1xufTtcblxucHJvdG8ucG9pbnRlckRvd24gPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XG4gIHRoaXMuX2JpbmRQb3N0U3RhcnRFdmVudHMoIGV2ZW50ICk7XG4gIHRoaXMuZW1pdEV2ZW50KCAncG9pbnRlckRvd24nLCBbIGV2ZW50LCBwb2ludGVyIF0gKTtcbn07XG5cbi8vIGhhc2ggb2YgZXZlbnRzIHRvIGJlIGJvdW5kIGFmdGVyIHN0YXJ0IGV2ZW50XG52YXIgcG9zdFN0YXJ0RXZlbnRzID0ge1xuICBtb3VzZWRvd246IFsgJ21vdXNlbW92ZScsICdtb3VzZXVwJyBdLFxuICB0b3VjaHN0YXJ0OiBbICd0b3VjaG1vdmUnLCAndG91Y2hlbmQnLCAndG91Y2hjYW5jZWwnIF0sXG4gIHBvaW50ZXJkb3duOiBbICdwb2ludGVybW92ZScsICdwb2ludGVydXAnLCAncG9pbnRlcmNhbmNlbCcgXSxcbn07XG5cbnByb3RvLl9iaW5kUG9zdFN0YXJ0RXZlbnRzID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICBpZiAoICFldmVudCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gZ2V0IHByb3BlciBldmVudHMgdG8gbWF0Y2ggc3RhcnQgZXZlbnRcbiAgdmFyIGV2ZW50cyA9IHBvc3RTdGFydEV2ZW50c1sgZXZlbnQudHlwZSBdO1xuICAvLyBiaW5kIGV2ZW50cyB0byBub2RlXG4gIGV2ZW50cy5mb3JFYWNoKCBmdW5jdGlvbiggZXZlbnROYW1lICkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBldmVudE5hbWUsIHRoaXMgKTtcbiAgfSwgdGhpcyApO1xuICAvLyBzYXZlIHRoZXNlIGFyZ3VtZW50c1xuICB0aGlzLl9ib3VuZFBvaW50ZXJFdmVudHMgPSBldmVudHM7XG59O1xuXG5wcm90by5fdW5iaW5kUG9zdFN0YXJ0RXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gIC8vIGNoZWNrIGZvciBfYm91bmRFdmVudHMsIGluIGNhc2UgZHJhZ0VuZCB0cmlnZ2VyZWQgdHdpY2UgKG9sZCBJRTggYnVnKVxuICBpZiAoICF0aGlzLl9ib3VuZFBvaW50ZXJFdmVudHMgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuX2JvdW5kUG9pbnRlckV2ZW50cy5mb3JFYWNoKCBmdW5jdGlvbiggZXZlbnROYW1lICkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBldmVudE5hbWUsIHRoaXMgKTtcbiAgfSwgdGhpcyApO1xuXG4gIGRlbGV0ZSB0aGlzLl9ib3VuZFBvaW50ZXJFdmVudHM7XG59O1xuXG4vLyAtLS0tLSBtb3ZlIGV2ZW50IC0tLS0tIC8vXG5cbnByb3RvLm9ubW91c2Vtb3ZlID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICB0aGlzLl9wb2ludGVyTW92ZSggZXZlbnQsIGV2ZW50ICk7XG59O1xuXG5wcm90by5vbnBvaW50ZXJtb3ZlID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICBpZiAoIGV2ZW50LnBvaW50ZXJJZCA9PSB0aGlzLnBvaW50ZXJJZGVudGlmaWVyICkge1xuICAgIHRoaXMuX3BvaW50ZXJNb3ZlKCBldmVudCwgZXZlbnQgKTtcbiAgfVxufTtcblxucHJvdG8ub250b3VjaG1vdmUgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIHZhciB0b3VjaCA9IHRoaXMuZ2V0VG91Y2goIGV2ZW50LmNoYW5nZWRUb3VjaGVzICk7XG4gIGlmICggdG91Y2ggKSB7XG4gICAgdGhpcy5fcG9pbnRlck1vdmUoIGV2ZW50LCB0b3VjaCApO1xuICB9XG59O1xuXG4vKipcbiAqIHBvaW50ZXIgbW92ZVxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwYXJhbSB7RXZlbnQgb3IgVG91Y2h9IHBvaW50ZXJcbiAqIEBwcml2YXRlXG4gKi9cbnByb3RvLl9wb2ludGVyTW92ZSA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdGhpcy5wb2ludGVyTW92ZSggZXZlbnQsIHBvaW50ZXIgKTtcbn07XG5cbi8vIHB1YmxpY1xucHJvdG8ucG9pbnRlck1vdmUgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XG4gIHRoaXMuZW1pdEV2ZW50KCAncG9pbnRlck1vdmUnLCBbIGV2ZW50LCBwb2ludGVyIF0gKTtcbn07XG5cbi8vIC0tLS0tIGVuZCBldmVudCAtLS0tLSAvL1xuXG5cbnByb3RvLm9ubW91c2V1cCA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgdGhpcy5fcG9pbnRlclVwKCBldmVudCwgZXZlbnQgKTtcbn07XG5cbnByb3RvLm9ucG9pbnRlcnVwID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICBpZiAoIGV2ZW50LnBvaW50ZXJJZCA9PSB0aGlzLnBvaW50ZXJJZGVudGlmaWVyICkge1xuICAgIHRoaXMuX3BvaW50ZXJVcCggZXZlbnQsIGV2ZW50ICk7XG4gIH1cbn07XG5cbnByb3RvLm9udG91Y2hlbmQgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIHZhciB0b3VjaCA9IHRoaXMuZ2V0VG91Y2goIGV2ZW50LmNoYW5nZWRUb3VjaGVzICk7XG4gIGlmICggdG91Y2ggKSB7XG4gICAgdGhpcy5fcG9pbnRlclVwKCBldmVudCwgdG91Y2ggKTtcbiAgfVxufTtcblxuLyoqXG4gKiBwb2ludGVyIHVwXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHBhcmFtIHtFdmVudCBvciBUb3VjaH0gcG9pbnRlclxuICogQHByaXZhdGVcbiAqL1xucHJvdG8uX3BvaW50ZXJVcCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdGhpcy5fcG9pbnRlckRvbmUoKTtcbiAgdGhpcy5wb2ludGVyVXAoIGV2ZW50LCBwb2ludGVyICk7XG59O1xuXG4vLyBwdWJsaWNcbnByb3RvLnBvaW50ZXJVcCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdGhpcy5lbWl0RXZlbnQoICdwb2ludGVyVXAnLCBbIGV2ZW50LCBwb2ludGVyIF0gKTtcbn07XG5cbi8vIC0tLS0tIHBvaW50ZXIgZG9uZSAtLS0tLSAvL1xuXG4vLyB0cmlnZ2VyZWQgb24gcG9pbnRlciB1cCAmIHBvaW50ZXIgY2FuY2VsXG5wcm90by5fcG9pbnRlckRvbmUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fcG9pbnRlclJlc2V0KCk7XG4gIHRoaXMuX3VuYmluZFBvc3RTdGFydEV2ZW50cygpO1xuICB0aGlzLnBvaW50ZXJEb25lKCk7XG59O1xuXG5wcm90by5fcG9pbnRlclJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gIC8vIHJlc2V0IHByb3BlcnRpZXNcbiAgdGhpcy5pc1BvaW50ZXJEb3duID0gZmFsc2U7XG4gIGRlbGV0ZSB0aGlzLnBvaW50ZXJJZGVudGlmaWVyO1xufTtcblxucHJvdG8ucG9pbnRlckRvbmUgPSBub29wO1xuXG4vLyAtLS0tLSBwb2ludGVyIGNhbmNlbCAtLS0tLSAvL1xuXG5wcm90by5vbnBvaW50ZXJjYW5jZWwgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIGlmICggZXZlbnQucG9pbnRlcklkID09IHRoaXMucG9pbnRlcklkZW50aWZpZXIgKSB7XG4gICAgdGhpcy5fcG9pbnRlckNhbmNlbCggZXZlbnQsIGV2ZW50ICk7XG4gIH1cbn07XG5cbnByb3RvLm9udG91Y2hjYW5jZWwgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIHZhciB0b3VjaCA9IHRoaXMuZ2V0VG91Y2goIGV2ZW50LmNoYW5nZWRUb3VjaGVzICk7XG4gIGlmICggdG91Y2ggKSB7XG4gICAgdGhpcy5fcG9pbnRlckNhbmNlbCggZXZlbnQsIHRvdWNoICk7XG4gIH1cbn07XG5cbi8qKlxuICogcG9pbnRlciBjYW5jZWxcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50IG9yIFRvdWNofSBwb2ludGVyXG4gKiBAcHJpdmF0ZVxuICovXG5wcm90by5fcG9pbnRlckNhbmNlbCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdGhpcy5fcG9pbnRlckRvbmUoKTtcbiAgdGhpcy5wb2ludGVyQ2FuY2VsKCBldmVudCwgcG9pbnRlciApO1xufTtcblxuLy8gcHVibGljXG5wcm90by5wb2ludGVyQ2FuY2VsID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICB0aGlzLmVtaXRFdmVudCggJ3BvaW50ZXJDYW5jZWwnLCBbIGV2ZW50LCBwb2ludGVyIF0gKTtcbn07XG5cbi8vIC0tLS0tICAtLS0tLSAvL1xuXG4vLyB1dGlsaXR5IGZ1bmN0aW9uIGZvciBnZXR0aW5nIHgveSBjb29yZHMgZnJvbSBldmVudFxuVW5pcG9pbnRlci5nZXRQb2ludGVyUG9pbnQgPSBmdW5jdGlvbiggcG9pbnRlciApIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBwb2ludGVyLnBhZ2VYLFxuICAgIHk6IHBvaW50ZXIucGFnZVlcbiAgfTtcbn07XG5cbi8vIC0tLS0tICAtLS0tLSAvL1xuXG5yZXR1cm4gVW5pcG9pbnRlcjtcblxufSkpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBLFdBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/unipointer/unipointer.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/Y2QwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL21vZHVsZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanM/Y2VkMiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/module.js\n");

/***/ }),

/***/ "./src/MyAttrChannel.js":
/*!******************************!*\
  !*** ./src/MyAttrChannel.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const MotorCortex = __webpack_require__(/*! @kissmybutton/motorcortex */ \"./node_modules/@kissmybutton/motorcortex/dist/main.js\");\n\nclass MyAttrChannel extends MotorCortex.AttributeChannel {\n  constructor(props) {\n    super(props);\n    this.s = {};\n    this.compoAttributes = {\n      finalG: [\"nodes\", \"edges\"]\n    };\n  }\n\n}\n\nmodule.exports = MyAttrChannel;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvTXlBdHRyQ2hhbm5lbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9NeUF0dHJDaGFubmVsLmpzPzc1ZmQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgTW90b3JDb3J0ZXggPSByZXF1aXJlKFwiQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleFwiKTtcclxuXHJcbmNsYXNzIE15QXR0ckNoYW5uZWwgZXh0ZW5kcyBNb3RvckNvcnRleC5BdHRyaWJ1dGVDaGFubmVsIHtcclxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgc3VwZXIocHJvcHMpO1xyXG4gICAgdGhpcy5zID0ge307XHJcbiAgICB0aGlzLmNvbXBvQXR0cmlidXRlcyA9IHtcclxuICAgICAgZmluYWxHOltcIm5vZGVzXCIsXCJlZGdlc1wiXVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNeUF0dHJDaGFubmVsOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQVJBO0FBQ0E7QUFTQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/MyAttrChannel.js\n");

/***/ }),

/***/ "./src/SigmaAnimPlugin.js":
/*!********************************!*\
  !*** ./src/SigmaAnimPlugin.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const MC = __webpack_require__(/*! @kissmybutton/motorcortex/ */ \"./node_modules/@kissmybutton/motorcortex/dist/main.js\");\n\nwindow.sigma = __webpack_require__(/*! sigma */ \"./node_modules/sigma/build/sigma.require.js\");\n\nconst SigmaAnimation = __webpack_require__(/*! ../lib/SigmaAnimationPlugin.js */ \"./lib/SigmaAnimationPlugin.js\");\n\nclass SigmaAnimPlugin extends MC.TimedIncident {\n  onGetContext() {\n    this.finalG = this.attrs.animatedAttrs.finalG;\n    this.SigmaAnimation = new SigmaAnimation(this.id, this.getInitialValue(\"finalG\"), this.finalG, this.context.s, {\n      x: \"xFinal\",\n      y: \"yFinal\",\n      size: \"sizeFinal\",\n      color: \"colorFinal\"\n    });\n    this.attrs.attrs.master.children.push(this);\n  }\n\n  refreshInstance() {\n    this.SigmaAnimation = new SigmaAnimation(this.id, this.getInitialValue(\"finalG\"), this.finalG, this.context.s, {\n      x: \"xFinal\",\n      y: \"yFinal\",\n      size: \"sizeFinal\",\n      color: \"colorFinal\"\n    });\n    return this;\n  }\n\n  getScratchValue(mcid, attr) {\n    const g = this.context.g;\n    return g;\n  }\n  /**\r\n   * perfomres animations on said graph using an external\r\n   * plugin according to the value of progress when this \r\n   * is called.\r\n   */\n\n\n  onProgress(progress, millisecond) {\n    this.SigmaAnimation.changeFrame(progress);\n  }\n\n}\n\nmodule.exports = SigmaAnimPlugin;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvU2lnbWFBbmltUGx1Z2luLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL1NpZ21hQW5pbVBsdWdpbi5qcz80NjM0Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IE1DID0gcmVxdWlyZShcIkBraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvXCIpO1xyXG53aW5kb3cuc2lnbWEgPSByZXF1aXJlKFwic2lnbWFcIik7XHJcbmNvbnN0IFNpZ21hQW5pbWF0aW9uID0gcmVxdWlyZShcIi4uL2xpYi9TaWdtYUFuaW1hdGlvblBsdWdpbi5qc1wiKVxyXG5cclxuY2xhc3MgU2lnbWFBbmltUGx1Z2luIGV4dGVuZHMgTUMuVGltZWRJbmNpZGVudCB7XHJcblxyXG4gICAgb25HZXRDb250ZXh0KCkge1xyXG4gICAgICAgIHRoaXMuZmluYWxHID0gdGhpcy5hdHRycy5hbmltYXRlZEF0dHJzLmZpbmFsRztcclxuICAgICAgICAgICAgdGhpcy5TaWdtYUFuaW1hdGlvbiA9IG5ldyBTaWdtYUFuaW1hdGlvbihcclxuICAgICAgICAgICAgdGhpcy5pZCxcclxuICAgICAgICAgICAgdGhpcy5nZXRJbml0aWFsVmFsdWUoXCJmaW5hbEdcIiksXHJcbiAgICAgICAgICAgIHRoaXMuZmluYWxHLFxyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQucyxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgeDogXCJ4RmluYWxcIixcclxuICAgICAgICAgICAgICAgIHk6IFwieUZpbmFsXCIsXHJcbiAgICAgICAgICAgICAgICBzaXplOiBcInNpemVGaW5hbFwiLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6IFwiY29sb3JGaW5hbFwiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMuYXR0cnMuYXR0cnMubWFzdGVyLmNoaWxkcmVuLnB1c2godGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVmcmVzaEluc3RhbmNlKCkge1xyXG4gICAgICAgIHRoaXMuU2lnbWFBbmltYXRpb24gPSBuZXcgU2lnbWFBbmltYXRpb24oXHJcbiAgICAgICAgICAgIHRoaXMuaWQsXHJcbiAgICAgICAgICAgIHRoaXMuZ2V0SW5pdGlhbFZhbHVlKFwiZmluYWxHXCIpLFxyXG4gICAgICAgICAgICB0aGlzLmZpbmFsRyxcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnMsXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHg6IFwieEZpbmFsXCIsXHJcbiAgICAgICAgICAgICAgICB5OiBcInlGaW5hbFwiLFxyXG4gICAgICAgICAgICAgICAgc2l6ZTogXCJzaXplRmluYWxcIixcclxuICAgICAgICAgICAgICAgIGNvbG9yOiBcImNvbG9yRmluYWxcIlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBnZXRTY3JhdGNoVmFsdWUobWNpZCwgYXR0cikge1xyXG4gICAgICAgIGNvbnN0IGcgPSB0aGlzLmNvbnRleHQuZztcclxuICAgICAgICByZXR1cm4gZztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHBlcmZvbXJlcyBhbmltYXRpb25zIG9uIHNhaWQgZ3JhcGggdXNpbmcgYW4gZXh0ZXJuYWxcclxuICAgICAqIHBsdWdpbiBhY2NvcmRpbmcgdG8gdGhlIHZhbHVlIG9mIHByb2dyZXNzIHdoZW4gdGhpcyBcclxuICAgICAqIGlzIGNhbGxlZC5cclxuICAgICAqL1xyXG4gICAgb25Qcm9ncmVzcyhwcm9ncmVzcywgbWlsbGlzZWNvbmQpIHtcclxuICAgICAgICB0aGlzLlNpZ21hQW5pbWF0aW9uLmNoYW5nZUZyYW1lKHByb2dyZXNzKTtcclxuICAgIH07XHJcbn1cclxuXHJcbiAgXHJcbm1vZHVsZS5leHBvcnRzID0gU2lnbWFBbmltUGx1Z2luOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFoREE7QUFDQTtBQWtEQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/SigmaAnimPlugin.js\n");

/***/ }),

/***/ "./src/SigmaBasePlugin.js":
/*!********************************!*\
  !*** ./src/SigmaBasePlugin.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const MC = __webpack_require__(/*! @kissmybutton/motorcortex/ */ \"./node_modules/@kissmybutton/motorcortex/dist/main.js\");\n\nconst WebComponentContextHandler = __webpack_require__(/*! @kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/WebComponentContextHandler */ \"./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/WebComponentContextHandler.js\");\n\nconst sigma = __webpack_require__(/*! sigma */ \"./node_modules/sigma/build/sigma.require.js\");\n\nclass SigmaBasePlugin extends MC.ExtendableClip {\n  constructor(attrs, props) {\n    //conditional imports for performance\n    super(attrs, props);\n    this.plugins = {};\n    this.children = [];\n    var ContextHanlder = null;\n    ContextHanlder = WebComponentContextHandler;\n    var contextHanlder = new ContextHanlder(props);\n    this.ownContext = contextHanlder.context;\n    this.isTheClip = true;\n    this.rootElement = this.context.rootElement;\n    var initializeOneTimePlugIn = false;\n    this.init();\n  }\n  /**\r\n   * initializes the instance of sigma with\r\n   * graph (N/E) parameters, generates the said\r\n   * graph and passes it in sigma.js constructor\r\n   * along with its container\r\n   */\n\n\n  init(newGraph) {\n    // import all necessary plugins in this.plugins\n    this.plugins.drag_nodes = __webpack_require__(/*! sigma/plugins/sigma.plugins.dragNodes/sigma.plugins.dragNodes */ \"./node_modules/sigma/plugins/sigma.plugins.dragNodes/sigma.plugins.dragNodes.js\");\n    this.plugins.animate = __webpack_require__(/*! sigma/plugins/sigma.plugins.animate/sigma.plugins.animate */ \"./node_modules/sigma/plugins/sigma.plugins.animate/sigma.plugins.animate.js\");\n    this.plugins.noOverlap = __webpack_require__(/*! sigma/plugins/sigma.layout.noverlap/sigma.layout.noverlap */ \"./node_modules/sigma/plugins/sigma.layout.noverlap/sigma.layout.noverlap.js\"); // initialize all variables necessary for instanciating sigma with a graph\n\n    this.props.container = this.rootElement;\n    this.context.N = this.attrs.attrs.N;\n    this.context.E = this.attrs.attrs.E;\n    this.context.C = this.attrs.attrs.C;\n    this.context.cs = [];\n    this.context.o;\n    this.context.settings = this.attrs.attrs.settings;\n    this.context.options = this.attrs.attrs.options;\n\n    if (!this.attrs.attrs.rendererType) {\n      this.context.defaultRenderType = 'canvas';\n    } else {\n      this.context.defaultRenderType = this.attrs.attrs.rendererType;\n    } // establish which graph to create and call the appropriate function\n\n\n    if (!newGraph) {\n      this.context.g = {\n        nodes: [],\n        edges: [],\n        name: \"empty\"\n      };\n\n      if (!this.attrs.attrs.customGraph) {\n        this.generateRandomGraph(this.context.g);\n      } else {\n        this.context.customNodes = this.attrs.attrs.customGraph.nodes;\n        this.context.customEdges = this.attrs.attrs.customGraph.edges;\n        this.generateCustomGraph(this.context.g);\n      }\n\n      this.cmd = this.attrs.attrs.commands;\n      this.context.s = new sigma({\n        graph: this.context.g,\n        renderer: {\n          container: this.props.container,\n          type: this.context.defaultRenderType\n        },\n        settings: this.context.settings\n      });\n    } else {\n      this.cmd = this.attrs.attrs.commands;\n      this.context.g = newGraph;\n      this.context.s = new sigma({\n        graph: this.context.g,\n        renderer: {\n          container: this.props.container,\n          type: this.context.defaultRenderType\n        },\n        settings: this.context.settings\n      });\n    }\n\n    this.initializePlugins();\n    this.methodUpdate(this.cmd);\n  }\n  /**\r\n   * Initializes all plugins\r\n   */\n\n\n  initializePlugins() {\n    // drag_nodes plugin initialization MUST BE ONGOING\n    if (this.attrs.attrs.options.drag_nodes) {\n      var dragListener = sigma.plugins.dragNodes(this.context.s, this.context.s.renderers[0]);\n      dragListener.bind('startdrag', event => {});\n      dragListener.bind('drag', event => {});\n      dragListener.bind('drop', event => {});\n      dragListener.bind('dragend', event => {\n        this.data = event.data.node;\n\n        const updateNode = node => {\n          var index = parseInt(node.id.substring(1));\n          var newx = node.x;\n          var newy = node.y;\n          this.context.g.nodes[index].x = newx;\n          this.context.g.nodes[index].y = newy;\n          this.context.s.kill();\n          this.init(this.context.g);\n\n          for (var child in this.children) {\n            this.children[child] = this.children[child].refreshInstance();\n          }\n        };\n\n        updateNode(event.data.node);\n      });\n    }\n  }\n  /**\r\n   * Creates a graph imported by the user with appropriate edges\r\n   * and nodes.\r\n   */\n\n\n  generateCustomGraph(g) {\n    for (var i = 0; i < this.context.N; i++) {\n      g.nodes.push(this.context.customNodes[i]);\n    }\n\n    for (var i = 0; i < this.context.E; i++) {\n      g.edges.push(this.context.customEdges[i]);\n    }\n\n    g.name = this.attrs.attrs.customGraph.name;\n  }\n  /**\r\n   * Create the graph with Edges and Nodes\r\n   */\n\n\n  generateRandomGraph(g) {\n    //Generate graph with no clusters\n    if (!this.context.C) {\n      //insert nodes into graph\n      for (var i = 0; i < this.context.N; i++) {\n        g.nodes.push({\n          id: 'n' + i,\n          label: 'Node ' + i,\n          x: Math.random(),\n          y: Math.random(),\n          size: Math.random(),\n          color: `rgb(${parseInt(Math.random() * 255)},${parseInt(Math.random() * 255)},${parseInt(Math.random() * 255)})`\n        });\n      } //insert edges into graph\n\n\n      for (var i = 0; i < this.context.E; i++) {\n        g.edges.push({\n          id: 'e' + i,\n          source: 'n' + (Math.random() * this.context.N | 0),\n          target: 'n' + (Math.random() * this.context.N | 0),\n          size: Math.random(),\n          color: 'rgb(155,155,155)'\n        });\n      }\n    } //Generate graph with clusters C\n    else {\n        for (i = 0; i < this.context.C; i++) {\n          this.context.cs.push({\n            id: i,\n            nodes: [],\n            color: '#' + (Math.floor(Math.random() * 16777215).toString(16) + '000000').substr(0, 6)\n          });\n        }\n\n        for (i = 0; i < this.context.N; i++) {\n          this.context.o = this.context.cs[Math.random() * this.context.C | 0];\n          g.nodes.push({\n            id: 'n' + i,\n            label: 'Node' + i,\n            x: Math.random(),\n            y: Math.random(),\n            size: Math.random(),\n            color: this.context.o.color\n          });\n          this.context.o.nodes.push('n' + i);\n        }\n\n        for (i = 0; i < this.context.E; i++) {\n          if (Math.random() < 1 - 0.5) g.edges.push({\n            id: 'e' + i,\n            source: 'n' + (Math.random() * this.context.N | 0),\n            target: 'n' + (Math.random() * this.context.N | 0)\n          });else {\n            this.context.o = this.context.cs[Math.random() * this.context.C | 0];\n            g.edges.push({\n              id: 'e' + i,\n              source: this.context.o.nodes[Math.random() * this.context.o.nodes.length | 0],\n              target: this.context.o.nodes[Math.random() * this.context.o.nodes.length | 0]\n            });\n          }\n        }\n      }\n  }\n  /**\r\n   * resets content of the passed containers\r\n   */\n\n\n  changePrep(containers) {\n    for (var cont in containers) {\n      containers[cont].innerHTML = \"\";\n    }\n  }\n  /**\r\n   * Calls the methods passed to cmd\r\n   */\n\n\n  methodUpdate(cmd) {\n    for (var key in cmd) {\n      if (key == \"cameraCMD\") {\n        this.context.s.cameras.cmd[key][0];\n      }\n\n      for (var subKey in cmd[key]) {\n        this.context.s[key](...cmd[key][subKey]);\n      }\n    }\n\n    this.context.s.refresh();\n  }\n\n}\n\nmodule.exports = SigmaBasePlugin;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvU2lnbWFCYXNlUGx1Z2luLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL1NpZ21hQmFzZVBsdWdpbi5qcz85NzA4Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IE1DID0gcmVxdWlyZShcIkBraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvXCIpO1xyXG5jb25zdCBXZWJDb21wb25lbnRDb250ZXh0SGFuZGxlciA9IHJlcXVpcmUoXCJAa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2Rpc3QvY29yZVBsdWdpbnMvU2VsZkNvbnRhaW5lZEluY2lkZW50cy9oZWxwZXJzL1dlYkNvbXBvbmVudENvbnRleHRIYW5kbGVyXCIpO1xyXG5jb25zdCBzaWdtYSA9IHJlcXVpcmUoXCJzaWdtYVwiKTtcclxuXHJcblxyXG5cclxuY2xhc3MgU2lnbWFCYXNlUGx1Z2luIGV4dGVuZHMgTUMuRXh0ZW5kYWJsZUNsaXAge1xyXG4gICAgY29uc3RydWN0b3IoYXR0cnMsIHByb3BzKSB7XHJcbiAgICAgICAgLy9jb25kaXRpb25hbCBpbXBvcnRzIGZvciBwZXJmb3JtYW5jZVxyXG4gICAgICAgIHN1cGVyKGF0dHJzLCBwcm9wcyk7XHJcbiAgICAgICAgdGhpcy5wbHVnaW5zID0ge307XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xyXG5cclxuICAgICAgICB2YXIgQ29udGV4dEhhbmxkZXIgPSBudWxsO1xyXG4gICAgICAgIENvbnRleHRIYW5sZGVyID0gV2ViQ29tcG9uZW50Q29udGV4dEhhbmRsZXI7XHJcblxyXG4gICAgICAgIHZhciBjb250ZXh0SGFubGRlciA9IG5ldyBDb250ZXh0SGFubGRlcihwcm9wcyk7XHJcblxyXG4gICAgICAgIHRoaXMub3duQ29udGV4dCA9IGNvbnRleHRIYW5sZGVyLmNvbnRleHQ7XHJcbiAgICAgICAgdGhpcy5pc1RoZUNsaXAgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMucm9vdEVsZW1lbnQgPSB0aGlzLmNvbnRleHQucm9vdEVsZW1lbnQ7XHJcblxyXG4gICAgICAgIHZhciBpbml0aWFsaXplT25lVGltZVBsdWdJbiA9IGZhbHNlO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuaW5pdCgpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIGluaXRpYWxpemVzIHRoZSBpbnN0YW5jZSBvZiBzaWdtYSB3aXRoXHJcbiAgICAgKiBncmFwaCAoTi9FKSBwYXJhbWV0ZXJzLCBnZW5lcmF0ZXMgdGhlIHNhaWRcclxuICAgICAqIGdyYXBoIGFuZCBwYXNzZXMgaXQgaW4gc2lnbWEuanMgY29uc3RydWN0b3JcclxuICAgICAqIGFsb25nIHdpdGggaXRzIGNvbnRhaW5lclxyXG4gICAgICovXHJcbiAgICBpbml0KG5ld0dyYXBoKSB7XHJcbiAgICAgICAgLy8gaW1wb3J0IGFsbCBuZWNlc3NhcnkgcGx1Z2lucyBpbiB0aGlzLnBsdWdpbnNcclxuICAgICAgICB0aGlzLnBsdWdpbnMuZHJhZ19ub2RlcyA9IHJlcXVpcmUoXCJzaWdtYS9wbHVnaW5zL3NpZ21hLnBsdWdpbnMuZHJhZ05vZGVzL3NpZ21hLnBsdWdpbnMuZHJhZ05vZGVzXCIpXHJcbiAgICAgICAgdGhpcy5wbHVnaW5zLmFuaW1hdGUgPSByZXF1aXJlKFwic2lnbWEvcGx1Z2lucy9zaWdtYS5wbHVnaW5zLmFuaW1hdGUvc2lnbWEucGx1Z2lucy5hbmltYXRlXCIpXHJcbiAgICAgICAgdGhpcy5wbHVnaW5zLm5vT3ZlcmxhcCA9IHJlcXVpcmUoXCJzaWdtYS9wbHVnaW5zL3NpZ21hLmxheW91dC5ub3ZlcmxhcC9zaWdtYS5sYXlvdXQubm92ZXJsYXBcIilcclxuXHJcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBhbGwgdmFyaWFibGVzIG5lY2Vzc2FyeSBmb3IgaW5zdGFuY2lhdGluZyBzaWdtYSB3aXRoIGEgZ3JhcGhcclxuICAgICAgICB0aGlzLnByb3BzLmNvbnRhaW5lciA9IHRoaXMucm9vdEVsZW1lbnQ7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0Lk4gPSB0aGlzLmF0dHJzLmF0dHJzLk47XHJcbiAgICAgICAgdGhpcy5jb250ZXh0LkUgPSB0aGlzLmF0dHJzLmF0dHJzLkU7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0LkMgPSB0aGlzLmF0dHJzLmF0dHJzLkM7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0LmNzID0gW107XHJcbiAgICAgICAgdGhpcy5jb250ZXh0Lm87XHJcbiAgICAgICAgdGhpcy5jb250ZXh0LnNldHRpbmdzID0gdGhpcy5hdHRycy5hdHRycy5zZXR0aW5ncztcclxuICAgICAgICB0aGlzLmNvbnRleHQub3B0aW9ucyA9IHRoaXMuYXR0cnMuYXR0cnMub3B0aW9ucztcclxuICAgICAgICBpZiAoIXRoaXMuYXR0cnMuYXR0cnMucmVuZGVyZXJUeXBlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5kZWZhdWx0UmVuZGVyVHlwZSA9ICdjYW52YXMnO1xyXG4gICAgICAgIH0gXHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5kZWZhdWx0UmVuZGVyVHlwZSA9IHRoaXMuYXR0cnMuYXR0cnMucmVuZGVyZXJUeXBlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gZXN0YWJsaXNoIHdoaWNoIGdyYXBoIHRvIGNyZWF0ZSBhbmQgY2FsbCB0aGUgYXBwcm9wcmlhdGUgZnVuY3Rpb25cclxuICAgICAgICBpZiAoIW5ld0dyYXBoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5nID0ge1xyXG4gICAgICAgICAgICAgICAgbm9kZXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgZWRnZXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgbmFtZTpcImVtcHR5XCJcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmF0dHJzLmF0dHJzLmN1c3RvbUdyYXBoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlUmFuZG9tR3JhcGgodGhpcy5jb250ZXh0LmcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmN1c3RvbU5vZGVzID0gdGhpcy5hdHRycy5hdHRycy5jdXN0b21HcmFwaC5ub2RlcztcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5jdXN0b21FZGdlcyA9IHRoaXMuYXR0cnMuYXR0cnMuY3VzdG9tR3JhcGguZWRnZXM7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUN1c3RvbUdyYXBoKHRoaXMuY29udGV4dC5nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNtZCA9IHRoaXMuYXR0cnMuYXR0cnMuY29tbWFuZHM7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5zID0gbmV3IHNpZ21hKHtcclxuICAgICAgICAgICAgICAgIGdyYXBoOiB0aGlzLmNvbnRleHQuZyxcclxuICAgICAgICAgICAgICAgIHJlbmRlcmVyOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiB0aGlzLnByb3BzLmNvbnRhaW5lcixcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLmNvbnRleHQuZGVmYXVsdFJlbmRlclR5cGVcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzZXR0aW5nczogdGhpcy5jb250ZXh0LnNldHRpbmdzXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5jbWQgPSB0aGlzLmF0dHJzLmF0dHJzLmNvbW1hbmRzO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZyA9IG5ld0dyYXBoXHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5zID0gbmV3IHNpZ21hKHtcclxuICAgICAgICAgICAgICAgIGdyYXBoOiB0aGlzLmNvbnRleHQuZyxcclxuICAgICAgICAgICAgICAgIHJlbmRlcmVyOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiB0aGlzLnByb3BzLmNvbnRhaW5lcixcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLmNvbnRleHQuZGVmYXVsdFJlbmRlclR5cGVcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzZXR0aW5nczogdGhpcy5jb250ZXh0LnNldHRpbmdzXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5pbml0aWFsaXplUGx1Z2lucygpO1xyXG4gICAgICAgIHRoaXMubWV0aG9kVXBkYXRlKHRoaXMuY21kKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemVzIGFsbCBwbHVnaW5zXHJcbiAgICAgKi9cclxuICAgIGluaXRpYWxpemVQbHVnaW5zKCkge1xyXG4gICAgICAgIC8vIGRyYWdfbm9kZXMgcGx1Z2luIGluaXRpYWxpemF0aW9uIE1VU1QgQkUgT05HT0lOR1xyXG4gICAgICAgIGlmICh0aGlzLmF0dHJzLmF0dHJzLm9wdGlvbnMuZHJhZ19ub2Rlcykge1xyXG4gICAgICAgICAgICB2YXIgZHJhZ0xpc3RlbmVyID0gc2lnbWEucGx1Z2lucy5kcmFnTm9kZXModGhpcy5jb250ZXh0LnMsIHRoaXMuY29udGV4dC5zLnJlbmRlcmVyc1swXSk7XHJcblxyXG4gICAgICAgICAgICBkcmFnTGlzdGVuZXIuYmluZCgnc3RhcnRkcmFnJywgZXZlbnQgPT4ge30pO1xyXG4gICAgICAgICAgICBkcmFnTGlzdGVuZXIuYmluZCgnZHJhZycsIGV2ZW50ID0+IHt9KTtcclxuICAgICAgICAgICAgZHJhZ0xpc3RlbmVyLmJpbmQoJ2Ryb3AnLCBldmVudCA9PiB7fSk7XHJcbiAgICAgICAgICAgIGRyYWdMaXN0ZW5lci5iaW5kKCdkcmFnZW5kJywgZXZlbnQgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gZXZlbnQuZGF0YS5ub2RlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlTm9kZSA9IG5vZGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlSW50KG5vZGUuaWQuc3Vic3RyaW5nKDEpKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3eCA9IG5vZGUueDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3eSA9IG5vZGUueTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuZy5ub2Rlc1tpbmRleF0ueCA9IG5ld3g7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0Lmcubm9kZXNbaW5kZXhdLnkgPSBuZXd5O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5zLmtpbGwoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXQodGhpcy5jb250ZXh0LmcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGNoaWxkIGluIHRoaXMuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltjaGlsZF0gPSB0aGlzLmNoaWxkcmVuW2NoaWxkXS5yZWZyZXNoSW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICAgICAgdXBkYXRlTm9kZShldmVudC5kYXRhLm5vZGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGdyYXBoIGltcG9ydGVkIGJ5IHRoZSB1c2VyIHdpdGggYXBwcm9wcmlhdGUgZWRnZXNcclxuICAgICAqIGFuZCBub2Rlcy5cclxuICAgICAqL1xyXG4gICAgZ2VuZXJhdGVDdXN0b21HcmFwaChnKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbnRleHQuTjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGcubm9kZXMucHVzaChcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5jdXN0b21Ob2Rlc1tpXVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbnRleHQuRTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGcuZWRnZXMucHVzaChcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5jdXN0b21FZGdlc1tpXVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGcubmFtZSA9IHRoaXMuYXR0cnMuYXR0cnMuY3VzdG9tR3JhcGgubmFtZTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgdGhlIGdyYXBoIHdpdGggRWRnZXMgYW5kIE5vZGVzXHJcbiAgICAgKi9cclxuICAgIGdlbmVyYXRlUmFuZG9tR3JhcGgoZykge1xyXG4gICAgICAgIC8vR2VuZXJhdGUgZ3JhcGggd2l0aCBubyBjbHVzdGVyc1xyXG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0LkMpIHtcclxuICAgICAgICAgICAgLy9pbnNlcnQgbm9kZXMgaW50byBncmFwaFxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29udGV4dC5OOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGcubm9kZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICduJyArIGksXHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdOb2RlICcgKyBpLFxyXG4gICAgICAgICAgICAgICAgICAgIHg6IE1hdGgucmFuZG9tKCksXHJcbiAgICAgICAgICAgICAgICAgICAgeTogTWF0aC5yYW5kb20oKSxcclxuICAgICAgICAgICAgICAgICAgICBzaXplOiBNYXRoLnJhbmRvbSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBgcmdiKCR7cGFyc2VJbnQoTWF0aC5yYW5kb20oKSAqIDI1NSl9LCR7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KE1hdGgucmFuZG9tKCkgKiAyNTUpfSwke1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUludChNYXRoLnJhbmRvbSgpICogMjU1KX0pYFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9pbnNlcnQgZWRnZXMgaW50byBncmFwaFxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29udGV4dC5FOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGcuZWRnZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdlJyArIGksXHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiAnbicgKyAoTWF0aC5yYW5kb20oKSAqIHRoaXMuY29udGV4dC5OIHwgMCksXHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiAnbicgKyAoTWF0aC5yYW5kb20oKSAqIHRoaXMuY29udGV4dC5OIHwgMCksXHJcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogTWF0aC5yYW5kb20oKSxcclxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ3JnYigxNTUsMTU1LDE1NSknXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvL0dlbmVyYXRlIGdyYXBoIHdpdGggY2x1c3RlcnMgQ1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5jb250ZXh0LkM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmNzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIGlkOiBpLFxyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogJyMnICsgKFxyXG4gICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDE2Nzc3MjE1KS50b1N0cmluZygxNikgKyAnMDAwMDAwJ1xyXG4gICAgICAgICAgICAgICAgICAgICkuc3Vic3RyKDAsIDYpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuY29udGV4dC5OOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5vID0gdGhpcy5jb250ZXh0LmNzWyhNYXRoLnJhbmRvbSgpICogdGhpcy5jb250ZXh0LkMpIHwgMF07XHJcbiAgICAgICAgICAgICAgICBnLm5vZGVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIGlkOiAnbicgKyBpLFxyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiAnTm9kZScgKyBpLFxyXG4gICAgICAgICAgICAgICAgICAgIHg6IE1hdGgucmFuZG9tKCksXHJcbiAgICAgICAgICAgICAgICAgICAgeTogTWF0aC5yYW5kb20oKSxcclxuICAgICAgICAgICAgICAgICAgICBzaXplOiBNYXRoLnJhbmRvbSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiB0aGlzLmNvbnRleHQuby5jb2xvclxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuby5ub2Rlcy5wdXNoKCduJyArIGkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5jb250ZXh0LkU7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPCAxIC0gMC41KVxyXG4gICAgICAgICAgICAgICAgICAgIGcuZWRnZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnZScgKyBpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6ICduJyArICgoTWF0aC5yYW5kb20oKSAqIHRoaXMuY29udGV4dC5OKSB8IDApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6ICduJyArICgoTWF0aC5yYW5kb20oKSAqIHRoaXMuY29udGV4dC5OKSB8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQubyA9IHRoaXMuY29udGV4dC5jc1soTWF0aC5yYW5kb20oKSAqIHRoaXMuY29udGV4dC5DKSB8IDBdXHJcbiAgICAgICAgICAgICAgICAgICAgZy5lZGdlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdlJyArIGksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcy5jb250ZXh0Lm8ubm9kZXNbKE1hdGgucmFuZG9tKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICogdGhpcy5jb250ZXh0Lm8ubm9kZXMubGVuZ3RoKSB8IDBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMuY29udGV4dC5vLm5vZGVzWyhNYXRoLnJhbmRvbSgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHRoaXMuY29udGV4dC5vLm5vZGVzLmxlbmd0aCkgfCAwXVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmVzZXRzIGNvbnRlbnQgb2YgdGhlIHBhc3NlZCBjb250YWluZXJzXHJcbiAgICAgKi9cclxuICAgIGNoYW5nZVByZXAoY29udGFpbmVycykge1xyXG4gICAgICAgIGZvciAodmFyIGNvbnQgaW4gY29udGFpbmVycykge1xyXG4gICAgICAgICAgICBjb250YWluZXJzW2NvbnRdLmlubmVySFRNTCA9IFwiXCI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxzIHRoZSBtZXRob2RzIHBhc3NlZCB0byBjbWRcclxuICAgICAqL1xyXG4gICAgbWV0aG9kVXBkYXRlKGNtZCkge1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBjbWQpIHtcclxuICAgICAgICAgICAgaWYgKGtleSA9PSBcImNhbWVyYUNNRFwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQucy5jYW1lcmFzLmNtZFtrZXldWzBdXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIHN1YktleSBpbiBjbWRba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnNba2V5XSguLi5jbWRba2V5XVtzdWJLZXldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbnRleHQucy5yZWZyZXNoKCk7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG4gIFxyXG5tb2R1bGUuZXhwb3J0cyA9IFNpZ21hQmFzZVBsdWdpbjsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQU5BO0FBUUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFVQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQXhCQTtBQTJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBcFBBO0FBQ0E7QUF1UEEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/SigmaBasePlugin.js\n");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const clip = __webpack_require__(/*! ./SigmaBasePlugin.js */ \"./src/SigmaBasePlugin.js\");\n\nconst SigmaAnimPlugin = __webpack_require__(/*! ./SigmaAnimPlugin.js */ \"./src/SigmaAnimPlugin.js\");\n\nconst MyAttrChannel = __webpack_require__(/*! ./MyAttrChannel.js */ \"./src/MyAttrChannel.js\");\n\nconst MC = __webpack_require__(/*! @kissmybutton/motorcortex */ \"./node_modules/@kissmybutton/motorcortex/dist/main.js\");\n\nmodule.exports = {\n  npm_name: \"kissmybutton/motorcortex-bill-sigma\",\n  incidents: [{\n    exportable: SigmaAnimPlugin,\n    name: \"SigmaAnimPlugin\"\n  }],\n  channel: MyAttrChannel,\n  clip\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbWFpbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9tYWluLmpzPzU2ZDciXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY2xpcCA9IHJlcXVpcmUoXCIuL1NpZ21hQmFzZVBsdWdpbi5qc1wiKTtcclxuY29uc3QgU2lnbWFBbmltUGx1Z2luID0gcmVxdWlyZShcIi4vU2lnbWFBbmltUGx1Z2luLmpzXCIpO1xyXG5jb25zdCBNeUF0dHJDaGFubmVsID0gcmVxdWlyZShcIi4vTXlBdHRyQ2hhbm5lbC5qc1wiKTtcclxuY29uc3QgTUMgPSByZXF1aXJlKFwiQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleFwiKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgbnBtX25hbWU6IFwia2lzc215YnV0dG9uL21vdG9yY29ydGV4LWJpbGwtc2lnbWFcIixcclxuICAgIGluY2lkZW50czogW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZXhwb3J0YWJsZTogU2lnbWFBbmltUGx1Z2luLFxyXG4gICAgICAgICAgICBuYW1lOiBcIlNpZ21hQW5pbVBsdWdpblwiXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIGNoYW5uZWw6IE15QXR0ckNoYW5uZWwsXHJcbiAgICBjbGlwXHJcbn07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQVRBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/main.js\n");

/***/ })

/******/ });